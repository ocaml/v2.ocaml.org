<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Random.html">
<link rel="next" href="Set.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Arg" rel="Chapter" href="Arg.html">
<link title="Arg_helper" rel="Chapter" href="Arg_helper.html">
<link title="Array" rel="Chapter" href="Array.html">
<link title="ArrayLabels" rel="Chapter" href="ArrayLabels.html">
<link title="Ast_helper" rel="Chapter" href="Ast_helper.html">
<link title="Ast_invariants" rel="Chapter" href="Ast_invariants.html">
<link title="Ast_iterator" rel="Chapter" href="Ast_iterator.html">
<link title="Ast_mapper" rel="Chapter" href="Ast_mapper.html">
<link title="Asttypes" rel="Chapter" href="Asttypes.html">
<link title="Attr_helper" rel="Chapter" href="Attr_helper.html">
<link title="Bigarray" rel="Chapter" href="Bigarray.html">
<link title="Buffer" rel="Chapter" href="Buffer.html">
<link title="Builtin_attributes" rel="Chapter" href="Builtin_attributes.html">
<link title="Bytes" rel="Chapter" href="Bytes.html">
<link title="BytesLabels" rel="Chapter" href="BytesLabels.html">
<link title="Callback" rel="Chapter" href="Callback.html">
<link title="CamlinternalFormat" rel="Chapter" href="CamlinternalFormat.html">
<link title="CamlinternalFormatBasics" rel="Chapter" href="CamlinternalFormatBasics.html">
<link title="CamlinternalLazy" rel="Chapter" href="CamlinternalLazy.html">
<link title="CamlinternalMod" rel="Chapter" href="CamlinternalMod.html">
<link title="CamlinternalOO" rel="Chapter" href="CamlinternalOO.html">
<link title="Ccomp" rel="Chapter" href="Ccomp.html">
<link title="Char" rel="Chapter" href="Char.html">
<link title="Clflags" rel="Chapter" href="Clflags.html">
<link title="Complex" rel="Chapter" href="Complex.html">
<link title="Condition" rel="Chapter" href="Condition.html">
<link title="Config" rel="Chapter" href="Config.html">
<link title="Consistbl" rel="Chapter" href="Consistbl.html">
<link title="Depend" rel="Chapter" href="Depend.html">
<link title="Digest" rel="Chapter" href="Digest.html">
<link title="Docstrings" rel="Chapter" href="Docstrings.html">
<link title="Dynlink" rel="Chapter" href="Dynlink.html">
<link title="Ephemeron" rel="Chapter" href="Ephemeron.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Filename" rel="Chapter" href="Filename.html">
<link title="Format" rel="Chapter" href="Format.html">
<link title="Gc" rel="Chapter" href="Gc.html">
<link title="Genlex" rel="Chapter" href="Genlex.html">
<link title="Graphics" rel="Chapter" href="Graphics.html">
<link title="GraphicsX11" rel="Chapter" href="GraphicsX11.html">
<link title="Hashtbl" rel="Chapter" href="Hashtbl.html">
<link title="Identifiable" rel="Chapter" href="Identifiable.html">
<link title="Int32" rel="Chapter" href="Int32.html">
<link title="Int64" rel="Chapter" href="Int64.html">
<link title="Lazy" rel="Chapter" href="Lazy.html">
<link title="Lexer" rel="Chapter" href="Lexer.html">
<link title="Lexing" rel="Chapter" href="Lexing.html">
<link title="List" rel="Chapter" href="List.html">
<link title="ListLabels" rel="Chapter" href="ListLabels.html">
<link title="Location" rel="Chapter" href="Location.html">
<link title="Longident" rel="Chapter" href="Longident.html">
<link title="Map" rel="Chapter" href="Map.html">
<link title="Marshal" rel="Chapter" href="Marshal.html">
<link title="Misc" rel="Chapter" href="Misc.html">
<link title="MoreLabels" rel="Chapter" href="MoreLabels.html">
<link title="Mutex" rel="Chapter" href="Mutex.html">
<link title="Nativeint" rel="Chapter" href="Nativeint.html">
<link title="Numbers" rel="Chapter" href="Numbers.html">
<link title="Obj" rel="Chapter" href="Obj.html">
<link title="Oo" rel="Chapter" href="Oo.html">
<link title="Parse" rel="Chapter" href="Parse.html">
<link title="Parser" rel="Chapter" href="Parser.html">
<link title="Parsetree" rel="Chapter" href="Parsetree.html">
<link title="Parsing" rel="Chapter" href="Parsing.html">
<link title="Pervasives" rel="Chapter" href="Pervasives.html">
<link title="Pparse" rel="Chapter" href="Pparse.html">
<link title="Pprintast" rel="Chapter" href="Pprintast.html">
<link title="Printast" rel="Chapter" href="Printast.html">
<link title="Printexc" rel="Chapter" href="Printexc.html">
<link title="Printf" rel="Chapter" href="Printf.html">
<link title="Profile" rel="Chapter" href="Profile.html">
<link title="Queue" rel="Chapter" href="Queue.html">
<link title="Random" rel="Chapter" href="Random.html">
<link title="Scanf" rel="Chapter" href="Scanf.html">
<link title="Set" rel="Chapter" href="Set.html">
<link title="Simplif" rel="Chapter" href="Simplif.html">
<link title="Sort" rel="Chapter" href="Sort.html">
<link title="Spacetime" rel="Chapter" href="Spacetime.html">
<link title="Stack" rel="Chapter" href="Stack.html">
<link title="StdLabels" rel="Chapter" href="StdLabels.html">
<link title="Str" rel="Chapter" href="Str.html">
<link title="Stream" rel="Chapter" href="Stream.html">
<link title="String" rel="Chapter" href="String.html">
<link title="StringLabels" rel="Chapter" href="StringLabels.html">
<link title="Strongly_connected_components" rel="Chapter" href="Strongly_connected_components.html">
<link title="Syntaxerr" rel="Chapter" href="Syntaxerr.html">
<link title="Sys" rel="Chapter" href="Sys.html">
<link title="Targetint" rel="Chapter" href="Targetint.html">
<link title="Tbl" rel="Chapter" href="Tbl.html">
<link title="Terminfo" rel="Chapter" href="Terminfo.html">
<link title="Thread" rel="Chapter" href="Thread.html">
<link title="ThreadUnix" rel="Chapter" href="ThreadUnix.html">
<link title="Typemod" rel="Chapter" href="Typemod.html">
<link title="Uchar" rel="Chapter" href="Uchar.html">
<link title="Unix" rel="Chapter" href="Unix.html">
<link title="UnixLabels" rel="Chapter" href="UnixLabels.html">
<link title="Warnings" rel="Chapter" href="Warnings.html">
<link title="Weak" rel="Chapter" href="Weak.html"><link title="Introduction" rel="Section" href="#1_Introduction">
<link title="Formatted input channel" rel="Section" href="#1_Formattedinputchannel">
<link title="Type of formatted input functions" rel="Section" href="#1_Typeofformattedinputfunctions">
<link title="The general formatted input function" rel="Section" href="#1_Thegeneralformattedinputfunction">
<link title="Format string description" rel="Section" href="#1_Formatstringdescription">
<link title="Specialised formatted input functions" rel="Section" href="#1_Specialisedformattedinputfunctions">
<link title="Reading format strings from input" rel="Section" href="#1_Readingformatstringsfrominput">
<link title="Deprecated" rel="Section" href="#1_Deprecated">
<link title="Functional input with format strings" rel="Subsection" href="#2_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#2_Asimpleexample">
<link title="Formatted input as a functional feature" rel="Subsection" href="#2_Formattedinputasafunctionalfeature">
<link title="The space character in format strings" rel="Subsection" href="#space">
<link title="Conversion specifications in format strings" rel="Subsection" href="#conversion">
<link title="Scanning indications in format strings" rel="Subsection" href="#indication">
<link title="Exceptions during scanning" rel="Subsection" href="#2_Exceptionsduringscanning">
<title>Scanf</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Random.html" title="Random">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Set.html" title="Set">Next</a>
</div>
<h1>Module <a href="type_Scanf.html">Scanf</a></h1>

<pre><span id="MODULEScanf"><span class="keyword">module</span> Scanf</span>: <code class="code"><span class="keyword">sig</span></code> <a href="Scanf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<div class="info-desc">
<p>Formatted input functions.</p>
</div>
</div>
<hr width="100%">
<h2 id="1_Introduction">Introduction</h2><h3 id="2_Functionalinputwithformatstrings">Functional input with format strings</h3><p>The module <a href="Scanf.html"><code class="code"><span class="constructor">Scanf</span></code></a> provides formatted input functions or <em>scanners</em>.</p>

<p>The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.</p>

<p>Generally speaking, the formatted input functions have 3 arguments:</p>
<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>
<p>Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code"><span class="constructor">Scanf</span>.bscanf</code></a> is
    <code class="code">bscanf&nbsp;ic&nbsp;fmt&nbsp;f</code>, where:</p>

<ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code"><span class="constructor">Printf</span></code></a> or <a href="Format.html"><code class="code"><span class="constructor">Format</span></code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input according to <code class="code">fmt</code>.</li>
</ul>
<h3 id="2_Asimpleexample">A simple example</h3><p>As suggested above, the expression <code class="code">bscanf&nbsp;ic&nbsp;<span class="string">"%d"</span>&nbsp;f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f&nbsp;n</code>.</p>

<p>For instance,</p>

<ul>
<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.stdin</code></a> is
    the predefined formatted input channel that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code"><span class="keyword">let</span>&nbsp;f&nbsp;x&nbsp;=&nbsp;x&nbsp;+&nbsp;1</code>,</li>
</ul>
<p>then <code class="code">bscanf&nbsp;<span class="constructor">Scanning</span>.stdin&nbsp;<span class="string">"%d"</span>&nbsp;f</code> reads an integer <code class="code">n</code> from the
    standard input and returns <code class="code">f&nbsp;n</code> (that is <code class="code">n&nbsp;+&nbsp;1</code>). Thus, if we
    evaluate <code class="code">bscanf&nbsp;stdin&nbsp;<span class="string">"%d"</span>&nbsp;f</code>, and then enter <code class="code">41</code> at the
    keyboard, the result we get is <code class="code">42</code>.</p>
<h3 id="2_Formattedinputasafunctionalfeature">Formatted input as a functional feature</h3><p>The OCaml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful:
    the formatted input functions are higher-order functionals and the
    parameter passing mechanism is just the regular function application not
    the variable assignment based mechanism which is typical for formatted
    input in imperative languages; the OCaml format strings also feature
    useful additions to easily define complex tokens; as expected within a
    functional programming language, the formatted input functions also
    support polymorphism, in particular arbitrary interaction with
    polymorphic user-defined scanners. Furthermore, the OCaml formatted input
    facility is fully type-checked at compile time.</p>
<h2 id="1_Formattedinputchannel">Formatted input channel</h2>
<pre><span id="MODULEScanning"><span class="keyword">module</span> <a href="Scanf.Scanning.html">Scanning</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Scanf.Scanning.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><h2 id="1_Typeofformattedinputfunctions">Type of formatted input functions</h2>
<pre><span id="TYPEscanner"><span class="keyword">type</span> <code class="type">('a, 'b, 'c, 'd)</code> scanner</span> = <code class="type">('a, <a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a>, 'b, 'c, 'a -> 'd, 'd) <a href="Pervasives.html#TYPEformat6">format6</a> -><br>       'c</code> </pre>
<div class="info ">
<div class="info-desc">
<p>The type of formatted input scanners: <code class="code">(<span class="keywordsign">'</span>a,&nbsp;<span class="keywordsign">'</span>b,&nbsp;<span class="keywordsign">'</span>c,&nbsp;<span class="keywordsign">'</span>d)&nbsp;scanner</code>
    is the type of a formatted input function that reads from some
    formatted input channel according to some format string; more
    precisely, if <code class="code">scan</code> is some formatted input function, then <code class="code">scan<br>
&nbsp;&nbsp;&nbsp;&nbsp;ic&nbsp;fmt&nbsp;f</code> applies <code class="code">f</code> to all the arguments specified by format
    string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments from the
    <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a> formatted input channel <code class="code">ic</code>.</p>

<p>For instance, the <a href="Scanf.html#VALscanf"><code class="code"><span class="constructor">Scanf</span>.scanf</code></a> function below has type
    <code class="code">(<span class="keywordsign">'</span>a,&nbsp;<span class="keywordsign">'</span>b,&nbsp;<span class="keywordsign">'</span>c,&nbsp;<span class="keywordsign">'</span>d)&nbsp;scanner</code>, since it is a formatted input function that
    reads from <a href="Scanf.Scanning.html#VALstdin"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.stdin</code></a>: <code class="code">scanf&nbsp;fmt&nbsp;f</code> applies <code class="code">f</code> to the arguments
    specified by <code class="code">fmt</code>, reading those arguments from <a href="Pervasives.html#VALstdin"><code class="code">stdin</code></a> as
    expected.</p>

<p>If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding
    formatted input functions must be provided <em>before</em> receiver function
    <code class="code">f</code>. For instance, if <code class="code">read_elem</code> is an input function for values of type
    <code class="code">t</code>, then <code class="code">bscanf&nbsp;ic&nbsp;<span class="string">"%r;"</span>&nbsp;read_elem&nbsp;f</code> reads a value <code class="code">v</code> of type <code class="code">t</code>
    followed by a <code class="code"><span class="string">';'</span></code> character, and returns <code class="code">f&nbsp;v</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 3.10.0</li>
</ul>
</div>


<pre><span id="EXCEPTIONScan_failure"><span class="keyword">exception</span> Scan_failure</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
<div class="info-desc">
<p>When the input can not be read according to the format string
    specification, formatted input functions typically raise exception
    <code class="code"><span class="constructor">Scan_failure</span></code>.</p>
</div>
</div>
<h2 id="1_Thegeneralformattedinputfunction">The general formatted input function</h2>
<pre><span id="VALbscanf"><span class="keyword">val</span> bscanf</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><p><code class="code">bscanf&nbsp;ic&nbsp;fmt&nbsp;r1&nbsp;...&nbsp;rN&nbsp;f</code> reads characters from the
    <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a> formatted input channel <code class="code">ic</code> and converts them to
    values according to format string <code class="code">fmt</code>.
    As a final step, receiver function <code class="code">f</code> is applied to the values read and
    gives the result of the <code class="code">bscanf</code> call.</p>

<p>For instance, if <code class="code">f</code> is the function <code class="code"><span class="keyword">fun</span>&nbsp;s&nbsp;i&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;i&nbsp;+&nbsp;1</code>, then
    <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;<span class="string">"x=&nbsp;1"</span>&nbsp;<span class="string">"%s&nbsp;=&nbsp;%i"</span>&nbsp;f</code> returns <code class="code">2</code>.</p>

<p>Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the
    argument corresponding to the <code class="code">%r</code> conversions specified in the format
    string.</p>
<h2 id="1_Formatstringdescription">Format string description</h2><p>The format string is a character string which contains three types of
    objects:</p>
<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<h3 id="space">The space character in format strings</h3><p>As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code"><span class="string">'&nbsp;'</span></code> or ASCII code
    32) and the line feed character (<code class="code"><span class="string">'\n'</span></code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    'whitespace' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.</p>

<p>Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf&nbsp;ib<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"Price&nbsp;=&nbsp;%d&nbsp;$"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span>&nbsp;=&nbsp;1&nbsp;$</code>,
    <code class="code"><span class="constructor">Price</span>&nbsp;&nbsp;=&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;$</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.</p>
<h3 id="conversion">Conversion specifications in format strings</h3><p>Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters.</p>

<p>The conversion characters and their meanings are:</p>

<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer (<code class="code">0-9</code>+).</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0<span class="constructor">X</span>[0-9<span class="constructor">A</span>-<span class="constructor">F</span>]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-<span class="constructor">F</span>]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code"><span class="constructor">Invalid_argument</span></code>, if the field width
      specification is greater than 1.</li>
<li><code class="code"><span class="constructor">C</span></code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code"><span class="constructor">E</span></code>, <code class="code">g</code>, <code class="code"><span class="constructor">G</span></code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e/<span class="constructor">E</span>+-dd</code>.</li>
<li><code class="code">h</code>, <code class="code"><span class="constructor">H</span></code>: reads an optionally signed floating-point number
      in hexadecimal notation.</li>
<li><code class="code"><span class="constructor">F</span></code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code"><span class="constructor">B</span></code>: reads a boolean argument (<code class="code"><span class="keyword">true</span></code> or <code class="code"><span class="keyword">false</span></code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code"><span class="constructor">Ld</span></code>, <code class="code"><span class="constructor">Li</span></code>, <code class="code"><span class="constructor">Lu</span></code>, <code class="code"><span class="constructor">Lx</span></code>, <code class="code"><span class="constructor">LX</span></code>, <code class="code"><span class="constructor">Lo</span></code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[&nbsp;range&nbsp;]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code"><span class="constructor">Scanning</span>.in_channel&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keywordsign">'</span>a</code> and the argument read has type <code class="code"><span class="keywordsign">'</span>a</code>.</li>
<li><code class="code">{&nbsp;fmt&nbsp;%}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code"><span class="string">"%{&nbsp;%i&nbsp;%}"</span></code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code"><span class="string">"fmt:\"number&nbsp;is&nbsp;%u\""</span></code>, then <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;s&nbsp;<span class="string">"fmt:&nbsp;%{%i%}"</span></code>
      succeeds and returns the format string <code class="code"><span class="string">"number&nbsp;is&nbsp;%u"</span></code>.</li>
<li><code class="code">(&nbsp;fmt&nbsp;%)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code"><span class="string">"%(&nbsp;%i&nbsp;%)"</span></code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code"><span class="string">"\"%4d\"1234.00"</span></code>, then
      <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;s&nbsp;<span class="string">"%(%i%)"</span>&nbsp;(<span class="keyword">fun</span>&nbsp;fmt&nbsp;i&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;fmt,&nbsp;i)</code> evaluates to
      <code class="code">(<span class="string">"%4d"</span>,&nbsp;1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_(&nbsp;fmt&nbsp;%)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code"><span class="string">"\"%4d\"1234.00"</span></code>, then <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;s&nbsp;<span class="string">"%_(%i%)"</span></code> is
      simply equivalent to <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;<span class="string">"1234.00"</span>&nbsp;<span class="string">"%4d"</span></code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code"><span class="constructor">N</span></code> or <code class="code"><span class="constructor">L</span></code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>
<p>Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code"><span class="keyword">fun</span>&nbsp;i&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;i&nbsp;+&nbsp;1</code>, and <code class="code">s</code> is the
    string <code class="code"><span class="string">"x&nbsp;=&nbsp;1"</span></code>, then <code class="code"><span class="constructor">Scanf</span>.sscanf&nbsp;s&nbsp;<span class="string">"%_s&nbsp;=&nbsp;%i"</span>&nbsp;f</code> returns <code class="code">2</code>.</p>

<p>The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).</p>

<p>Notes:</p>

<ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code"><span class="string">""</span></code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code"><span class="string">'_'</span></code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <a href="Str.html"><code class="code"><span class="constructor">Str</span></code></a>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<h3 id="indication">Scanning indications in format strings</h3><p>Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[&nbsp;range&nbsp;]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    plain character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code"><span class="string">"%s@\t"</span></code> reads a string up to the next
    tab character or to the end of input. If a <code class="code">@</code> character appears
    anywhere else in the format string, it is treated as a plain character.</p>

<p>Note:</p>

<ul>
<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped
    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications
    and scanning indications.
    For instance, format <code class="code"><span class="string">"%s@%%"</span></code> reads a string up to the next <code class="code">%</code>
    character, and format <code class="code"><span class="string">"%s@%@"</span></code> reads a string up to the next <code class="code">@</code>.</li>
<li>The scanning indications introduce slight differences in the syntax of
    <a href="Scanf.html"><code class="code"><span class="constructor">Scanf</span></code></a> format strings, compared to those used for the <a href="Printf.html"><code class="code"><span class="constructor">Printf</span></code></a>
    module. However, the scanning indications are similar to those used in
    the <a href="Format.html"><code class="code"><span class="constructor">Format</span></code></a> module; hence, when producing formatted text to be scanned
    by <a href="Scanf.html#VALbscanf"><code class="code"><span class="constructor">Scanf</span>.bscanf</code></a>, it is wise to use printing functions from the
    <a href="Format.html"><code class="code"><span class="constructor">Format</span></code></a> module (or, if you need to use functions from <a href="Printf.html"><code class="code"><span class="constructor">Printf</span></code></a>, banish
    or carefully double check the format strings that contain <code class="code"><span class="string">'@'</span></code>
    characters).</li>
</ul>
<h3 id="2_Exceptionsduringscanning">Exceptions during scanning</h3><p>Scanners may raise the following exceptions when the input cannot be read
    according to the format string:</p>

<ul>
<li>Raise <a href="Scanf.html#EXCEPTIONScan_failure"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scan_failure</span></code></a> if the input does not match the format.</li>
</ul>
<ul>
<li>Raise <code class="code"><span class="constructor">Failure</span></code> if a conversion to a number is not possible.</li>
</ul>
<ul>
<li>Raise <code class="code"><span class="constructor">End_of_file</span></code> if the end of input is encountered while some more
      characters are needed to read the current conversion specification.</li>
</ul>
<ul>
<li>Raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the format string is invalid.</li>
</ul>
<p>Note:</p>

<ul>
<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception
    <code class="code"><span class="constructor">End_of_file</span></code>: if the end of input is reached the conversion succeeds and
    simply returns the characters read so far, or <code class="code"><span class="string">""</span></code> if none were ever read.</li>
</ul>
<h2 id="1_Specialisedformattedinputfunctions">Specialised formatted input functions</h2>
<pre><span id="VALsscanf"><span class="keyword">val</span> sscanf</span> : <code class="type">string -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code"><span class="constructor">Scanf</span>.bscanf</code></a>, but reads from the given string.</p>
</div>
</div>

<pre><span id="VALscanf"><span class="keyword">val</span> scanf</span> : <code class="type">('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code"><span class="constructor">Scanf</span>.bscanf</code></a>, but reads from the predefined formatted input
    channel <a href="Scanf.Scanning.html#VALstdin"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.stdin</code></a> that is connected to <a href="Pervasives.html#VALstdin"><code class="code">stdin</code></a>.</p>
</div>
</div>

<pre><span id="VALkscanf"><span class="keyword">val</span> kscanf</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -><br>       (<a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -> exn -> 'd) -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code"><span class="constructor">Scanf</span>.bscanf</code></a>, but takes an additional function argument
    <code class="code">ef</code> that is called in case of error: if the scanning process or
    some conversion fails, the scanning function aborts and calls the
    error handling function <code class="code">ef</code> with the formatted input channel and the
    exception that aborted the scanning process as arguments.</p>
</div>
</div>

<pre><span id="VALksscanf"><span class="keyword">val</span> ksscanf</span> : <code class="type">string -><br>       (<a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -> exn -> 'd) -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALkscanf"><code class="code"><span class="constructor">Scanf</span>.kscanf</code></a> but reads from the given string.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 4.02.0</li>
</ul>
</div>
<h2 id="1_Readingformatstringsfrominput">Reading format strings from input</h2>
<pre><span id="VALbscanf_format"><span class="keyword">val</span> bscanf_format</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -><br>       ('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a> -><br>       (('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a> -> 'g) -> 'g</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">bscanf_format&nbsp;ic&nbsp;fmt&nbsp;f</code> reads a format string token from the formatted
    input channel <code class="code">ic</code>, according to the given format string <code class="code">fmt</code>, and
    applies <code class="code">f</code> to the resulting format string value.
    Raise <a href="Scanf.html#EXCEPTIONScan_failure"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scan_failure</span></code></a> if the format string value read does not have the
    same type as <code class="code">fmt</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 3.09.0</li>
</ul>
</div>

<pre><span id="VALsscanf_format"><span class="keyword">val</span> sscanf_format</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a> -><br>       (('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a> -> 'g) -> 'g</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf_format"><code class="code"><span class="constructor">Scanf</span>.bscanf_format</code></a>, but reads from the given string.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 3.09.0</li>
</ul>
</div>

<pre><span id="VALformat_from_string"><span class="keyword">val</span> format_from_string</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a> -><br>       ('a, 'b, 'c, 'd, 'e, 'f) <a href="Pervasives.html#TYPEformat6">format6</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">format_from_string&nbsp;s&nbsp;fmt</code> converts a string argument to a format string,
    according to the given format string <code class="code">fmt</code>.
    Raise <a href="Scanf.html#EXCEPTIONScan_failure"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scan_failure</span></code></a> if <code class="code">s</code>, considered as a format string, does not
    have the same type as <code class="code">fmt</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 3.10.0</li>
</ul>
</div>

<pre><span id="VALunescaped"><span class="keyword">val</span> unescaped</span> : <code class="type">string -> string</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">unescaped&nbsp;s</code> return a copy of <code class="code">s</code> with escape sequences (according to
    the lexical conventions of OCaml) replaced by their corresponding special
    characters.
    More precisely, <code class="code"><span class="constructor">Scanf</span>.unescaped</code> has the following property:
    for all string <code class="code">s</code>, <code class="code"><span class="constructor">Scanf</span>.unescaped&nbsp;(<span class="constructor">String</span>.escaped&nbsp;s)&nbsp;=&nbsp;s</code>.</p>

<p>Always return a copy of the argument, even if there is no escape sequence
    in the argument.
    Raise <a href="Scanf.html#EXCEPTIONScan_failure"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scan_failure</span></code></a> if <code class="code">s</code> is not properly escaped (i.e. <code class="code">s</code> has invalid
    escape sequences or special characters that are not properly escaped).
    For instance, <code class="code"><span class="constructor">String</span>.unescaped&nbsp;<span class="string">"\""</span></code> will fail.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 4.00.0</li>
</ul>
</div>
<h2 id="1_Deprecated">Deprecated</h2>
<pre><span id="VALfscanf"><span class="keyword">val</span> fscanf</span> : <code class="type"><a href="Pervasives.html#TYPEin_channel">in_channel</a> -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span><code class="code"><span class="constructor">Scanf</span>.fscanf</code> is error prone and deprecated since 4.03.0.

    This function violates the following invariant of the <a href="Scanf.html"><code class="code"><span class="constructor">Scanf</span></code></a> module:
    To preserve scanning semantics, all scanning functions defined in <a href="Scanf.html"><code class="code"><span class="constructor">Scanf</span></code></a>
    must read from a user defined <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a> formatted input
    channel.

    If you need to read from a <a href="Pervasives.html#TYPEin_channel"><code class="code">in_channel</code></a> input channel
    <code class="code">ic</code>, simply define a <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.in_channel</code></a> formatted input channel as in
    <code class="code"><span class="keyword">let</span>&nbsp;ib&nbsp;=&nbsp;<span class="constructor">Scanning</span>.from_channel&nbsp;ic</code>,
    then use <code class="code"><span class="constructor">Scanf</span>.bscanf&nbsp;ib</code> as usual.</div>
</div>

<pre><span id="VALkfscanf"><span class="keyword">val</span> kfscanf</span> : <code class="type"><a href="Pervasives.html#TYPEin_channel">in_channel</a> -><br>       (<a href="Scanf.Scanning.html#TYPEin_channel">Scanning.in_channel</a> -> exn -> 'd) -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span><code class="code"><span class="constructor">Scanf</span>.kfscanf</code> is error prone and deprecated since 4.03.0.</div>
</div>
</body></html>
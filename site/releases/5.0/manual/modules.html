<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.36">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - The OCaml language</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>The OCaml language</nav><ul id="part-menu"><li class="active"><a href="language.html">The OCaml language</a></li><li><a href="extn.html">Language extensions</a></li></ul>




<h1 class="chapter" id="sec111"><span class="chapter-number">Chapter 11</span> The OCaml language</h1><header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.0</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">The OCaml language</a></li>
<li><a href="lex.html#start-section"><span class="number">1</span> Lexical conventions</a>
</li><li><a href="values.html#start-section"><span class="number">2</span> Values</a>
</li><li><a href="names.html#start-section"><span class="number">3</span> Names</a>
</li><li><a href="types.html#start-section"><span class="number">4</span> Type expressions</a>
</li><li><a href="const.html#start-section"><span class="number">5</span> Constants</a>
</li><li><a href="patterns.html#start-section"><span class="number">6</span> Patterns</a>
</li><li><a href="expr.html#start-section"><span class="number">7</span> Expressions</a>
</li><li><a href="typedecl.html#start-section"><span class="number">8</span> Type and exception definitions</a>
</li><li><a href="classes.html#start-section"><span class="number">9</span> Classes</a>
</li><li><a href="modtypes.html#start-section"><span class="number">10</span> Module types (module specifications)</a>
</li><li><a href="modules.html#start-section"><span class="number">11</span> Module expressions (module implementations)</a>
</li><li><a href="compunit.html#start-section"><span class="number">12</span> Compilation units</a>
</li></ul></nav></header><a id="start-section"></a><section id="section">




<h2 class="section" id="s:module-expr"><a class="section-anchor" href="#s:module-expr" aria-hidden="true"></a><span class="number">11</span> Module expressions (module implementations)</h2>
<ul>
<li><a href="modules.html#ss%3Amexpr-simple"><span class="number">11.1</span> Simple module expressions</a>
</li><li><a href="modules.html#ss%3Amexpr-structures"><span class="number">11.2</span> Structures</a>
</li><li><a href="modules.html#ss%3Amexpr-functors"><span class="number">11.3</span> Functors</a>
</li></ul>
<p>Module expressions are the module-level equivalent of value
expressions: they evaluate to modules, thus providing implementations
for the specifications expressed in module types.</p><p><a id="hevea_manual.kwd179"></a>
<a id="hevea_manual.kwd180"></a>
<a id="hevea_manual.kwd181"></a>
<a id="hevea_manual.kwd182"></a>
<a id="hevea_manual.kwd183"></a>
<a id="hevea_manual.kwd184"></a>
<a id="hevea_manual.kwd185"></a>
<a id="hevea_manual.kwd186"></a>
<a id="hevea_manual.kwd187"></a>
<a id="hevea_manual.kwd188"></a>
<a id="hevea_manual.kwd189"></a>
<a id="hevea_manual.kwd190"></a></p><div class="syntax"><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><a class="syntax" id="module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">struct</span> [ <a class="syntax" href="#module-items"><span class="nonterminal">module-items</span></a> ] <span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">functor</span> <span class="syntax-token">(</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="module-items"><span class="nonterminal">module-items</span></a></td><td class="c005">::=</td><td class="c007">
{ <span class="syntax-token">;;</span> } ( <a class="syntax" href="#definition"><span class="nonterminal">definition</span></a> ∣ <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> ) { { <span class="syntax-token">;;</span> } ( <a class="syntax" href="#definition"><span class="nonterminal">definition</span></a> ∣ <span class="syntax-token">;;</span> <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a>) } { <span class="syntax-token">;;</span> }
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <a class="syntax" href="expr.html#let-binding"><span class="nonterminal">let-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="expr.html#let-binding"><span class="nonterminal">let-binding</span></a> }
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">external</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="intfc.html#external-declaration"><span class="nonterminal">external-declaration</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="typedecl.html#type-definition"><span class="nonterminal">type-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="typedecl.html#exception-definition"><span class="nonterminal">exception-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="classes.html#class-definition"><span class="nonterminal">class-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="classes.html#classtype-definition"><span class="nonterminal">classtype-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> { <span class="syntax-token">(</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> }
[ <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> ]  <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="names.html#modtype-name"><span class="nonterminal">modtype-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">open</span> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">include</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div><p>
See also the following language extensions:
<a href="recursivemodules.html#s%3Arecursive-modules">recursive modules</a>,
<a href="firstclassmodules.html#s%3Afirst-class-modules">first-class modules</a>,
<a href="overridingopen.html#s%3Aexplicit-overriding-open">overriding in open statements</a>,
<a href="attributes.html#s%3Aattributes">attributes</a>,
<a href="extensionnodes.html#s%3Aextension-nodes">extension nodes</a> and
<a href="generativefunctors.html#s%3Agenerative-functors">generative functors</a>.</p>
<h3 class="subsection" id="ss:mexpr-simple"><a class="section-anchor" href="#ss:mexpr-simple" aria-hidden="true">﻿</a><span class="number">11.1</span> Simple module expressions</h3>
<p>The expression <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> evaluates to the module bound to the name
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">)</span> evaluates to the same module as
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> checks that the
type of <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> is a subtype of <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>, that is, that all
components specified in <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> are implemented in
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, and their implementation meets the requirements given
in <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>. In other terms, it checks that the implementation
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> meets the type specification <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>. The whole
expression evaluates to the same module as <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, except that
all components not specified in <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> are hidden and can no
longer be accessed.</p>
<h3 class="subsection" id="ss:mexpr-structures"><a class="section-anchor" href="#ss:mexpr-structures" aria-hidden="true">﻿</a><span class="number">11.2</span> Structures</h3>
<p><a id="hevea_manual.kwd191"></a>
<a id="hevea_manual.kwd192"></a></p><p>Structures <span class="syntax-token">struct</span> … <span class="syntax-token">end</span> are collections of definitions for
value names, type names, exceptions, module names and module type
names. The definitions are evaluated in the order in which they appear
in the structure. The scopes of the bindings performed by the
definitions extend to the end of the structure. As a consequence, a
definition may refer to names bound by earlier definitions in the same
structure.</p><p>For compatibility with toplevel phrases (chapter&nbsp;<a href="toplevel.html#c%3Acamllight">14</a>),
optional <span class="syntax-token">;;</span> are allowed after and before each definition in a structure. These
<span class="syntax-token">;;</span> have no semantic meanings. Similarly, an <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> preceded by <span class="machine"><span class="font-tt">;;</span></span> is allowed as
a component of a structure. It is equivalent to <span class="syntax-token">let</span> <span class="syntax-token">_</span> <span class="syntax-token">=</span> <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a>, i.e. <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> is
evaluated for its side-effects but is not bound to any identifier. If <a class="syntax" href="expr.html#expr"><span class="nonterminal">expr</span></a> is
the first component of a structure, the preceding <span class="machine"><span class="font-tt">;;</span></span> can be omitted.</p><h4 class="subsubsection" id="sss:mexpr-value-defs"><a class="section-anchor" href="#sss:mexpr-value-defs" aria-hidden="true">﻿</a>Value definitions</h4>
<p><a id="hevea_manual.kwd193"></a></p><p>A value definition <span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <a class="syntax" href="expr.html#let-binding"><span class="nonterminal">let-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="expr.html#let-binding"><span class="nonterminal">let-binding</span></a> }
bind value names in the same way as a <span class="syntax-token">let</span> … <span class="syntax-token">in</span> … expression
(see section&nbsp;<a href="expr.html#sss%3Aexpr-localdef">11.7.2</a>). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values
in the right-hand sides.</p><p><a id="hevea_manual.kwd194"></a></p><p>A value definition <span class="syntax-token">external</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="intfc.html#external-declaration"><span class="nonterminal">external-declaration</span></a>
implements <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> as the external function specified in
<a class="syntax" href="intfc.html#external-declaration"><span class="nonterminal">external-declaration</span></a> (see chapter&nbsp;<a href="intfc.html#c%3Aintf-c">22</a>).</p><h4 class="subsubsection" id="sss:mexpr-type-defs"><a class="section-anchor" href="#sss:mexpr-type-defs" aria-hidden="true">﻿</a>Type definitions</h4>
<p><a id="hevea_manual.kwd195"></a></p><p>A definition of one or several type components is written
<span class="syntax-token">type</span> <a class="syntax" href="typedecl.html#typedef"><span class="nonterminal">typedef</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="typedecl.html#typedef"><span class="nonterminal">typedef</span></a> } and consists of a sequence
of mutually recursive definitions of type names.</p><h4 class="subsubsection" id="sss:mexpr-exn-defs"><a class="section-anchor" href="#sss:mexpr-exn-defs" aria-hidden="true">﻿</a>Exception definitions</h4>
<p><a id="hevea_manual.kwd196"></a></p><p>Exceptions are defined with the syntax <span class="syntax-token">exception</span> <a class="syntax" href="typedecl.html#constr-decl"><span class="nonterminal">constr-decl</span></a>
or <span class="syntax-token">exception</span> <a class="syntax" href="names.html#constr-name"><span class="nonterminal">constr-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a>.</p><h4 class="subsubsection" id="sss:mexpr-class-defs"><a class="section-anchor" href="#sss:mexpr-class-defs" aria-hidden="true">﻿</a>Class definitions</h4>
<p><a id="hevea_manual.kwd197"></a></p><p>A definition of one or several classes is written <span class="syntax-token">class</span>
<a class="syntax" href="classes.html#class-binding"><span class="nonterminal">class-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="classes.html#class-binding"><span class="nonterminal">class-binding</span></a> } and consists of a sequence of
mutually recursive definitions of class names. Class definitions are
described more precisely in section&nbsp;<a href="classes.html#ss%3Aclass-def">11.9.3</a>.</p><h4 class="subsubsection" id="sss:mexpr-classtype-defs"><a class="section-anchor" href="#sss:mexpr-classtype-defs" aria-hidden="true">﻿</a>Class type definitions</h4>
<p><a id="hevea_manual.kwd198"></a>
<a id="hevea_manual.kwd199"></a></p><p>A definition of one or several classes is written
<span class="syntax-token">class</span> <span class="syntax-token">type</span> <a class="syntax" href="classes.html#classtype-def"><span class="nonterminal">classtype-def</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="classes.html#classtype-def"><span class="nonterminal">classtype-def</span></a> } and consists of
a sequence of mutually recursive definitions of class type names.
Class type definitions are described more precisely in
section&nbsp;<a href="classes.html#ss%3Aclasstype">11.9.5</a>.</p><h4 class="subsubsection" id="sss:mexpr-module-defs"><a class="section-anchor" href="#sss:mexpr-module-defs" aria-hidden="true">﻿</a>Module definitions</h4>
<p><a id="hevea_manual.kwd200"></a></p><p>The basic form for defining a module component is
<span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, which evaluates <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> and binds
the result to the name <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a>.</p><p>One can write
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
instead of
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span>.
</div><p>
Another derived form is
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> …
<span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
which is equivalent to
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> …
<span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><h4 class="subsubsection" id="sss:mexpr-modtype-defs"><a class="section-anchor" href="#sss:mexpr-modtype-defs" aria-hidden="true">﻿</a>Module type definitions</h4>
<p><a id="hevea_manual.kwd201"></a>
<a id="hevea_manual.kwd202"></a></p><p>A definition for a module type is written
<span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="names.html#modtype-name"><span class="nonterminal">modtype-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>.
It binds the name <a class="syntax" href="names.html#modtype-name"><span class="nonterminal">modtype-name</span></a> to the module type denoted by the
expression <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>.</p><h4 class="subsubsection" id="sss:mexpr-open"><a class="section-anchor" href="#sss:mexpr-open" aria-hidden="true">﻿</a>Opening a module path</h4>
<p><a id="hevea_manual.kwd203"></a></p><p>The expression <span class="syntax-token">open</span> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> in a structure does not define any
components nor perform any bindings. It simply affects the parsing of
the following items of the structure, allowing components of the
module denoted by <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> to be referred to by their simple names
<span class="nonterminal">name</span> instead of path accesses <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <span class="nonterminal">name</span>. The scope of
the <span class="syntax-token">open</span> stops at the end of the structure expression.</p><h4 class="subsubsection" id="sss:mexpr-include"><a class="section-anchor" href="#sss:mexpr-include" aria-hidden="true">﻿</a>Including the components of another structure</h4>
<p><a id="hevea_manual.kwd204"></a></p><p>The expression <span class="syntax-token">include</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> in a structure re-exports in
the current structure all definitions of the structure denoted by
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>. For instance, if you define a module <span class="machine"><span class="font-tt">S</span></span> as below

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> S = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = int  <span class="ocamlkeyword">let</span> x = 2 <span class="ocamlkeyword">end</span></div></div>

</div><p>

defining the module <span class="machine"><span class="font-tt">B</span></span> as

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> B = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">include</span> S  <span class="ocamlkeyword">let</span> y = (x + 1 : t) <span class="ocamlkeyword">end</span></div></div>

</div><p>

is equivalent to defining it as

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> B = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = S.t  <span class="ocamlkeyword">let</span> x = S.x  <span class="ocamlkeyword">let</span> y = (x + 1 : t) <span class="ocamlkeyword">end</span></div></div>

</div><p>

The difference between <span class="syntax-token">open</span> and <span class="syntax-token">include</span> is that <span class="syntax-token">open</span>
simply provides short names for the components of the opened
structure, without defining any components of the current structure,
while <span class="syntax-token">include</span> also adds definitions for the components of the
included structure.</p>
<h3 class="subsection" id="ss:mexpr-functors"><a class="section-anchor" href="#ss:mexpr-functors" aria-hidden="true">﻿</a><span class="number">11.3</span> Functors</h3>
<h4 class="subsubsection" id="sss:mexpr-functor-defs"><a class="section-anchor" href="#sss:mexpr-functor-defs" aria-hidden="true">﻿</a>Functor definition</h4>
<p><a id="hevea_manual.kwd205"></a></p><p>The expression <span class="syntax-token">functor</span> <span class="syntax-token">(</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span>
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> evaluates to a functor that takes as argument modules of
the type <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub>, binds <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> to these modules,
evaluates <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> in the extended environment, and returns the
resulting modules as results. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (“higher-order” functor).</p><p>When the result module expression is itself a functor,
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> … <span class="syntax-token">-&gt;</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
one may use the abbreviated form
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> …
<span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><h4 class="subsubsection" id="sss:mexpr-functor-app"><a class="section-anchor" href="#sss:mexpr-functor-app" aria-hidden="true">﻿</a>Functor application</h4>
<p>The expression <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> <span class="syntax-token">)</span> evaluates
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub> to a functor and <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> to a module, and
applies the former to the latter. The type of <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> must
match the type expected for the arguments of the functor <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub>.</p>

<div class="bottom-navigation"><a class="previous" href="modtypes.html">« Module types (module specifications)</a><a class="next" href="compunit.html">Compilation units »</a></div>




</section><div class="copyright">Copyright © 2022 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>
<!DOCTYPE html>
<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.36">
<style type="text/css">
.c000{border-spacing:0;width:80%}
.c001{border-spacing:6px;border-collapse:separate;}
.c002{font-size:150%}
.c003{font-size:large}
.c004{text-align:center;border:solid 1px;white-space:nowrap}
.c005{text-align:center;white-space:nowrap}
.c006{text-align:left;border:solid 1px;white-space:nowrap}
.c007{text-align:left;white-space:nowrap}
.c008{text-align:right;white-space:nowrap}
.c009{vertical-align:middle}
.c010{vertical-align:top;text-align:left;}
.c011{vertical-align:top;text-align:left;border:solid 1px;}
.c012{vertical-align:top;text-align:left;border:solid 1px;white-space:nowrap}
.c013{vertical-align:top;text-align:left;white-space:nowrap}
.c014{vertical-align:top;text-align:right;white-space:nowrap}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{background-color: black; border: none; height: 1px; margin: 1em auto 1em 0px; width: 40%}
.center{text-align:center;margin-left:auto;margin-right:auto;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.quote{margin-left:3em;margin-right:3em;text-align:inherit;text-indent:0pt}
.horizontal-rule{border:none;background-color:black;}
.hrule{border:none;height:2px;width:100%;background-color:black;}
.display{border-collapse:separate;border-spacing:2px;line-height:1.1;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
a.section-anchor::after{content:"ğŸ”—";
font-size:smaller;
margin-left:-1.5em;
padding-right:0.5em;
}
a.section-anchor{visibility:hidden;
color:grey !important;
text-decoration:none !important;
}
*:hover>a.section-anchor{visibility:visible;
}
a:link{color:#4286f4;text-decoration:underline;}
a:visited{color:#0d46a3;text-decoration:underline;}
a:hover{color:black;text-decoration:underline;}
@media all{@font-face {
/* fira-sans-regular - latin */
font-family: 'Fira Sans';
font-style: normal;
font-weight: 400;
src: url('fonts/fira-sans-v8-latin-regular.eot'); /* IE9 Compat Modes */
src: local('Fira Sans Regular'), local('FiraSans-Regular'),
url('fonts/fira-sans-v8-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
url('fonts/fira-sans-v8-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
url('fonts/fira-sans-v8-latin-regular.woff') format('woff'), /* Modern Browsers */
url('fonts/fira-sans-v8-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
url('fonts/fira-sans-v8-latin-regular.svg#FiraSans') format('svg'); /* Legacy iOS */
}
}
body{max-width:750px;
width: 85%;
margin: auto;
background: #f7f7f7;
margin-top: 80px;
font-size: 1rem;
}
.maintitle{font-family: "Fira Sans", sans-serif;
text-align: center;
}
h1, h2, h3{font-family: "Fira Sans", sans-serif;
font-weight: normal;
border-bottom: 1px solid black;
}
div.ocaml{margin:2ex 0px;
font-size: 1rem;
background: beige;
border: 1px solid grey;
padding: 10px;
overflow-y:auto;
display:flex;
flex-direction: column;
flex-wrap: nowrap;
}
div.ocaml .pre{white-space: pre;
font-family: monospace;
}
.ocamlkeyword{font-weight:bold;
}
.ocamlhighlight{font-weight:bold;
text-decoration:underline;
}
.ocamlerror{font-weight:bold;
color:red;
}
.ocamlwarning{font-weight:bold;
color:purple;
}
.ocamlcomment{color:grey;
}
.ocamlstring{opacity:0.75;
}
#cc_license_logo{float:left;
margin-right: 1em;
}
p,ul{line-height:1.3em}
.cellpadding1 tr td{padding:1px 4px}
div.caml-output{color:maroon;}
div.caml-example.toplevel div.caml-input{color:#006000;}
.ocamlprompt{color:black;}
.osvariant{font-family:sans-serif}
.tableau, .syntax, .syntaxleft{/* same width as body */
max-width: 750px;
overflow-y: auto;
}
.th{font-size:small;}
.li-links{margin:0ex 0ex;}
.font-tt{font-family:monospace;}
.font-it{font-style:italic;}
.font-bold{font-weight:bold;}
.font-sl{font-style:oblique;}
.syntax-token{color:blue;font-family:monospace}
a.syntax:link{color:maroon;text-decoration:underline}
a.syntax:visited{color:maroon;text-decoration:underline}
a.syntax:hover{color:black;text-decoration:none;background-color:#FF6060}
.nonterminal{color:maroon;font-style:oblique}
</style>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<title>The OCaml system, release 5.0
</title>
</head>
<body>
<!--HEVEA command line is: hevea -fix -exec xxdate.exe -O -I .. -I ../cmds -I ../library -I ../refman -I ../refman/extensions -I ../tutorials -I ../../styles -I ../texstuff manual.hva -e macros.tex ../manual.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><div class="maintitle">
Â <span style="font-size:xx-large"><span class="c002">The OCaml system <br>
 release 5.0<br>
<span style="font-size:x-large">Documentation and userâ€™s manual <br>
<span class="c003">Xavier Leroy, <br>
 Damien Doligez, Alain Frisch, Jacques Garrigue, <br>
 Didier RÃ©my, KC Sivaramakrishnan and JÃ©rÃ´me Vouillon <br>
 20</span></span></span></span><sup><span class="c002"><span class="c003">th</span></span></sup><span class="c002"><span class="c003">December
,Â 2022<br>
 Â 
<span style="font-size:medium">Copyright Â© 2022 Institut National de
Recherche en Informatique et en Automatique
</span></span></span></div><div class="maintitle">
<br>

This manual is also available in
<a href="https://ocaml.org/releases/5.0/ocaml-5.0-refman.pdf">PDF</a>,
<a href="https://ocaml.org/releases/5.0/ocaml-5.0-refman.txt">plain text</a>,
as a
<a href="https://ocaml.org/releases/5.0/ocaml-5.0-refman-html.tar.gz">bundle of HTML files</a>,
and as a
<a href="https://ocaml.org/releases/5.0/ocaml-5.0-refman.info.tar.gz">bundle of Emacs Info files</a>.
</div><!--TOC chapter id="sec1" Contents-->
<h1 class="chapter" id="sec1">Contents</h1><!--SEC END --><ul class="toc"><li class="li-toc"><a href="#sec6">PartÂ Iâ€ƒAn introduction to OCaml</a>
<ul class="toc"><li class="li-toc"><a href="#sec7">ChapterÂ 1â€ƒThe core language</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Abasics">1.1â€ƒBasics</a>
</li><li class="li-toc"><a href="#s%3Adatatypes">1.2â€ƒData types</a>
</li><li class="li-toc"><a href="#s%3Afunctions-as-values">1.3â€ƒFunctions as values</a>
</li><li class="li-toc"><a href="#s%3Atut-recvariants">1.4â€ƒRecords and variants</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Arecord-and-variant-disambiguation">1.4.1â€ƒRecord and variant disambiguation</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aimperative-features">1.5â€ƒImperative features</a>
</li><li class="li-toc"><a href="#s%3Aexceptions">1.6â€ƒExceptions</a>
</li><li class="li-toc"><a href="#s%3Alazy-expr">1.7â€ƒLazy expressions</a>
</li><li class="li-toc"><a href="#s%3Asymb-expr">1.8â€ƒSymbolic processing of expressions</a>
</li><li class="li-toc"><a href="#s%3Apretty-printing">1.9â€ƒPretty-printing</a>
</li><li class="li-toc"><a href="#s%3Aprintf">1.10â€ƒPrintf formats</a>
</li><li class="li-toc"><a href="#s%3Astandalone-programs">1.11â€ƒStandalone OCaml programs</a>
</li></ul>
</li><li class="li-toc"><a href="#sec20">ChapterÂ 2â€ƒThe module system</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Amodule%3Astructures">2.1â€ƒStructures</a>
</li><li class="li-toc"><a href="#s%3Asignature">2.2â€ƒSignatures</a>
</li><li class="li-toc"><a href="#s%3Afunctors">2.3â€ƒFunctors</a>
</li><li class="li-toc"><a href="#s%3Afunctors-and-abstraction">2.4â€ƒFunctors and type abstraction</a>
</li><li class="li-toc"><a href="#s%3Aseparate-compilation">2.5â€ƒModules and separate compilation</a>
</li></ul>
</li><li class="li-toc"><a href="#sec26">ChapterÂ 3â€ƒObjects in OCaml</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aclasses-and-objects">3.1â€ƒClasses and objects</a>
</li><li class="li-toc"><a href="#s%3Aimmediate-objects">3.2â€ƒImmediate objects</a>
</li><li class="li-toc"><a href="#s%3Areference-to-self">3.3â€ƒReference to self</a>
</li><li class="li-toc"><a href="#s%3Ainitializers">3.4â€ƒInitializers</a>
</li><li class="li-toc"><a href="#s%3Avirtual-methods">3.5â€ƒVirtual methods</a>
</li><li class="li-toc"><a href="#s%3Aprivate-methods">3.6â€ƒPrivate methods</a>
</li><li class="li-toc"><a href="#s%3Aclass-interfaces">3.7â€ƒClass interfaces</a>
</li><li class="li-toc"><a href="#s%3Ainheritance">3.8â€ƒInheritance</a>
</li><li class="li-toc"><a href="#s%3Amultiple-inheritance">3.9â€ƒMultiple inheritance</a>
</li><li class="li-toc"><a href="#s%3Aparameterized-classes">3.10â€ƒParameterized classes</a>
</li><li class="li-toc"><a href="#s%3Apolymorphic-methods">3.11â€ƒPolymorphic methods</a>
</li><li class="li-toc"><a href="#s%3Ausing-coercions">3.12â€ƒUsing coercions</a>
</li><li class="li-toc"><a href="#s%3Afunctional-objects">3.13â€ƒFunctional objects</a>
</li><li class="li-toc"><a href="#s%3Acloning-objects">3.14â€ƒCloning objects</a>
</li><li class="li-toc"><a href="#s%3Arecursive-classes">3.15â€ƒRecursive classes</a>
</li><li class="li-toc"><a href="#s%3Abinary-methods">3.16â€ƒBinary methods</a>
</li><li class="li-toc"><a href="#s%3Afriends">3.17â€ƒFriends</a>
</li></ul>
</li><li class="li-toc"><a href="#sec44">ChapterÂ 4â€ƒLabeled arguments</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aoptional-arguments">4.1â€ƒOptional arguments</a>
</li><li class="li-toc"><a href="#s%3Alabel-inference">4.2â€ƒLabels and type inference</a>
</li><li class="li-toc"><a href="#s%3Alabel-suggestions">4.3â€ƒSuggestions for labeling</a>
</li></ul>
</li><li class="li-toc"><a href="#sec48">ChapterÂ 5â€ƒPolymorphic variants</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apolyvariant%3Abasic-use">5.1â€ƒBasic use</a>
</li><li class="li-toc"><a href="#s%3Apolyvariant-advanced">5.2â€ƒAdvanced use</a>
</li><li class="li-toc"><a href="#s%3Apolyvariant-weaknesses">5.3â€ƒWeaknesses of polymorphic variants</a>
</li></ul>
</li><li class="li-toc"><a href="#sec52">ChapterÂ 6â€ƒPolymorphism and its limitations</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aweak-polymorphism">6.1â€ƒWeak polymorphism and mutation</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aweak-types">6.1.1â€ƒWeakly polymorphic types</a>
</li><li class="li-toc"><a href="#ss%3Avaluerestriction">6.1.2â€ƒThe value restriction</a>
</li><li class="li-toc"><a href="#ss%3Arelaxed-value-restriction">6.1.3â€ƒThe relaxed value restriction</a>
</li><li class="li-toc"><a href="#ss%3Avariance-and-value-restriction">6.1.4â€ƒVariance and value restriction</a>
</li><li class="li-toc"><a href="#ss%3Avariance%3Aabstract-data-types">6.1.5â€ƒAbstract data types</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Apolymorphic-recursion">6.2â€ƒPolymorphic recursion</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aexplicit-polymorphism">6.2.1â€ƒExplicitly polymorphic annotations</a>
</li><li class="li-toc"><a href="#ss%3Arecursive-poly-examples">6.2.2â€ƒMore examples</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ahigher-rank-poly">6.3â€ƒHigher-rank polymorphic functions</a>
</li></ul>
</li><li class="li-toc"><a href="#sec63">ChapterÂ 7â€ƒGeneralized algebraic datatypes</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Agadts-recfun">7.1â€ƒRecursive functions</a>
</li><li class="li-toc"><a href="#s%3Agadts-type-inference">7.2â€ƒType inference</a>
</li><li class="li-toc"><a href="#s%3Agadt-refutation-cases">7.3â€ƒRefutation cases</a>
</li><li class="li-toc"><a href="#s%3Agadts-advexamples">7.4â€ƒAdvanced examples</a>
</li><li class="li-toc"><a href="#s%3Aexistential-names">7.5â€ƒExistential type names in error messages</a>
</li><li class="li-toc"><a href="#s%3Aexplicit-existential-name">7.6â€ƒExplicit naming of existentials</a>
</li><li class="li-toc"><a href="#s%3Agadt-equation-nonlocal-abstract">7.7â€ƒEquations on non-local abstract types</a>
</li></ul>
</li><li class="li-toc"><a href="#sec71">ChapterÂ 8â€ƒAdvanced examples with classes and modules</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aextended-bank-accounts">8.1â€ƒExtended example: bank accounts</a>
</li><li class="li-toc"><a href="#s%3Amodules-as-classes">8.2â€ƒSimple modules as classes</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Astring-as-class">8.2.1â€ƒStrings</a>
</li><li class="li-toc"><a href="#ss%3Ahashtbl-as-class">8.2.2â€ƒHashtbl</a>
</li><li class="li-toc"><a href="#ss%3Aset-as-class">8.2.3â€ƒSets</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Asubject-observer">8.3â€ƒThe subject/observer pattern</a>
</li></ul>
</li><li class="li-toc"><a href="#sec79">ChapterÂ 9â€ƒParallel programming</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apar_domains">9.1â€ƒDomains</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apar_join">9.1.1â€ƒJoining domains</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Apar_parfib">9.2â€ƒDomainslib: A library for nested-parallel programming</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apar_parfib_domainslib">9.2.1â€ƒParallelising Fibonacci using domainslib</a>
</li><li class="li-toc"><a href="#s%3Apar_iterators">9.2.2â€ƒParallel iteration constructs</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Apar_gc">9.3â€ƒParallel garbage collection</a>
</li><li class="li-toc"><a href="#s%3Apar_mm_easy">9.4â€ƒMemory model: The easy bits</a>
</li><li class="li-toc"><a href="#s%3Apar_sync">9.5â€ƒBlocking synchronisation</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apar_systhread_interaction">9.5.1â€ƒInteraction with systhreads</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Apar_c_bindings">9.6â€ƒInteraction with C bindings</a>
</li><li class="li-toc"><a href="#s%3Apar_atomics">9.7â€ƒAtomics</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Apar_lockfree_stack">9.7.1â€ƒLock-free stack</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec92">ChapterÂ 10â€ƒMemory model: The hard bits</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Awhy_relaxed_memory">10.1â€ƒWhy weakly consistent memory?</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Amm_comp_opt">10.1.1â€ƒCompiler optimisations</a>
</li><li class="li-toc"><a href="#ss%3Amm_hw_opt">10.1.2â€ƒHardware optimisations</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Adrf_sc">10.2â€ƒData race freedom implies sequential consistency</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aatomics">10.2.1â€ƒMemory locations</a>
</li><li class="li-toc"><a href="#s%3Ahappens_before">10.2.2â€ƒHappens-before relation</a>
</li><li class="li-toc"><a href="#s%3Adatarace">10.2.3â€ƒData race</a>
</li><li class="li-toc"><a href="#ss%3Adrf_sc">10.2.4â€ƒDRF-SC</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Adrf_reasoning">10.3â€ƒReasoning with DRF-SC</a>
</li><li class="li-toc"><a href="#s%3Alocal_drf">10.4â€ƒLocal data race freedom</a>
</li><li class="li-toc"><a href="#s%3Amm_semantics">10.5â€ƒAn operational view of the memory model</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Amm_non_atomic">10.5.1â€ƒNon-atomic locations</a>
</li><li class="li-toc"><a href="#ss%3Amm_domains">10.5.2â€ƒDomains</a>
</li><li class="li-toc"><a href="#ss%3Amm_na_access">10.5.3â€ƒNon-atomic accesses</a>
</li><li class="li-toc"><a href="#ss%3Amm_at_access">10.5.4â€ƒAtomic accesses</a>
</li><li class="li-toc"><a href="#s%3Amm_semantics_reasoning">10.5.5â€ƒReasoning with the semantics</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Amm_tearing">10.6â€ƒNon-compliant operations</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec111">PartÂ IIâ€ƒThe OCaml language</a>
<ul class="toc"><li class="li-toc"><a href="#sec112">ChapterÂ 11â€ƒThe OCaml language</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Alexical-conventions">11.1â€ƒLexical conventions</a>
</li><li class="li-toc"><a href="#s%3Avalues">11.2â€ƒValues</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Avalues%3Abase">11.2.1â€ƒBase values</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Atuple">11.2.2â€ƒTuples</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Arecords">11.2.3â€ƒRecords</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Aarray">11.2.4â€ƒArrays</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Avariant">11.2.5â€ƒVariant values</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Apolyvars">11.2.6â€ƒPolymorphic variants</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Afun">11.2.7â€ƒFunctions</a>
</li><li class="li-toc"><a href="#ss%3Avalues%3Aobj">11.2.8â€ƒObjects</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Anames">11.3â€ƒNames</a>
</li><li class="li-toc"><a href="#s%3Atypexpr">11.4â€ƒType expressions</a>
</li><li class="li-toc"><a href="#s%3Aconst">11.5â€ƒConstants</a>
</li><li class="li-toc"><a href="#s%3Apatterns">11.6â€ƒPatterns</a>
</li><li class="li-toc"><a href="#s%3Avalue-expr">11.7â€ƒExpressions</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aprecedence-and-associativity">11.7.1â€ƒPrecedence and associativity</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-basic">11.7.2â€ƒBasic expressions</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-control">11.7.3â€ƒControl structures</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-ops-on-data">11.7.4â€ƒOperations on data structures</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-operators">11.7.5â€ƒOperators</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-obj">11.7.6â€ƒObjects</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-coercions">11.7.7â€ƒCoercions</a>
</li><li class="li-toc"><a href="#ss%3Aexpr-other">11.7.8â€ƒOther</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Atydef">11.8â€ƒType and exception definitions</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Atypedefs">11.8.1â€ƒType definitions</a>
</li><li class="li-toc"><a href="#ss%3Aexndef">11.8.2â€ƒException definitions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aclasses">11.9â€ƒClasses</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aclasses%3Aclass-types">11.9.1â€ƒClass types</a>
</li><li class="li-toc"><a href="#ss%3Aclass-expr">11.9.2â€ƒClass expressions</a>
</li><li class="li-toc"><a href="#ss%3Aclass-def">11.9.3â€ƒClass definitions</a>
</li><li class="li-toc"><a href="#ss%3Aclass-spec">11.9.4â€ƒClass specifications</a>
</li><li class="li-toc"><a href="#ss%3Aclasstype">11.9.5â€ƒClass type definitions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Amodtypes">11.10â€ƒModule types (module specifications)</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Amty-simple">11.10.1â€ƒSimple module types</a>
</li><li class="li-toc"><a href="#ss%3Amty-signatures">11.10.2â€ƒSignatures</a>
</li><li class="li-toc"><a href="#ss%3Amty-functors">11.10.3â€ƒFunctor types</a>
</li><li class="li-toc"><a href="#ss%3Amty-with">11.10.4â€ƒThe <span class="machine"><span class="font-tt">with</span></span> operator</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Amodule-expr">11.11â€ƒModule expressions (module implementations)</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Amexpr-simple">11.11.1â€ƒSimple module expressions</a>
</li><li class="li-toc"><a href="#ss%3Amexpr-structures">11.11.2â€ƒStructures</a>
</li><li class="li-toc"><a href="#ss%3Amexpr-functors">11.11.3â€ƒFunctors</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Acompilation-units">11.12â€ƒCompilation units</a>
</li></ul>
</li><li class="li-toc"><a href="#sec278">ChapterÂ 12â€ƒLanguage extensions</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aletrecvalues">12.1â€ƒRecursive definitions of values</a>
</li><li class="li-toc"><a href="#s%3Arecursive-modules">12.2â€ƒRecursive modules</a>
</li><li class="li-toc"><a href="#s%3Aprivate-types">12.3â€ƒPrivate types</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aprivate-types-variant">12.3.1â€ƒPrivate variant and record types</a>
</li><li class="li-toc"><a href="#ss%3Aprivate-types-abbrev">12.3.2â€ƒPrivate type abbreviations</a>
</li><li class="li-toc"><a href="#ss%3Aprivate-rows">12.3.3â€ƒPrivate row types</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Alocally-abstract">12.4â€ƒLocally abstract types</a>
</li><li class="li-toc"><a href="#s%3Afirst-class-modules">12.5â€ƒFirst-class modules</a>
</li><li class="li-toc"><a href="#s%3Amodule-type-of">12.6â€ƒRecovering the type of a module</a>
</li><li class="li-toc"><a href="#s%3Asignature-substitution">12.7â€ƒSubstituting inside a signature</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Adestructive-substitution">12.7.1â€ƒDestructive substitutions</a>
</li><li class="li-toc"><a href="#ss%3Alocal-substitution">12.7.2â€ƒLocal substitution declarations</a>
</li><li class="li-toc"><a href="#ss%3Amodule-type-substitution">12.7.3â€ƒModule type substitutions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Amodule-alias">12.8â€ƒType-level module aliases</a>
</li><li class="li-toc"><a href="#s%3Aexplicit-overriding-open">12.9â€ƒOverriding in open statements</a>
</li><li class="li-toc"><a href="#s%3Agadts">12.10â€ƒGeneralized algebraic datatypes</a>
</li><li class="li-toc"><a href="#s%3Abigarray-access">12.11â€ƒSyntax for Bigarray access</a>
</li><li class="li-toc"><a href="#s%3Aattributes">12.12â€ƒAttributes</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Abuiltin-attributes">12.12.1â€ƒBuilt-in attributes</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aextension-nodes">12.13â€ƒExtension nodes</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Abuiltin-extension-nodes">12.13.1â€ƒBuilt-in extension nodes</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aextensible-variants">12.14â€ƒExtensible variant types</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aprivate-extensible">12.14.1â€ƒPrivate extensible variant types</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Agenerative-functors">12.15â€ƒGenerative functors</a>
</li><li class="li-toc"><a href="#s%3Aextension-syntax">12.16â€ƒExtension-only syntax</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aextension-operators">12.16.1â€ƒExtension operators</a>
</li><li class="li-toc"><a href="#ss%3Aextension-literals">12.16.2â€ƒExtension literals</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ainline-records">12.17â€ƒInline records</a>
</li><li class="li-toc"><a href="#s%3Adoc-comments">12.18â€ƒDocumentation comments</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Afloating-comments">12.18.1â€ƒFloating comments</a>
</li><li class="li-toc"><a href="#ss%3Aitem-comments">12.18.2â€ƒItem comments</a>
</li><li class="li-toc"><a href="#ss%3Alabel-comments">12.18.3â€ƒLabel comments</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aindex-operators">12.19â€ƒExtended indexing operators </a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Amultiindexing">12.19.1â€ƒMulti-index notation</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aempty-variants">12.20â€ƒEmpty variant types</a>
</li><li class="li-toc"><a href="#s%3Aalerts">12.21â€ƒAlerts</a>
</li><li class="li-toc"><a href="#s%3Ageneralized-open">12.22â€ƒGeneralized open statements</a>
</li><li class="li-toc"><a href="#s%3Abinding-operators">12.23â€ƒBinding operators</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aletops-punning">12.23.1â€ƒShort notation for variable bindings (let-punning)</a>
</li><li class="li-toc"><a href="#ss%3Aletops-rationale">12.23.2â€ƒRationale</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aeffect-handlers">12.24â€ƒEffect handlers</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aeffects-basics">12.24.1â€ƒBasics</a>
</li><li class="li-toc"><a href="#s%3Aeffects-concurrency">12.24.2â€ƒConcurrency</a>
</li><li class="li-toc"><a href="#s%3Aeffects-user-threads">12.24.3â€ƒUser-level threads</a>
</li><li class="li-toc"><a href="#s%3Aeffects-sequence">12.24.4â€ƒControl inversion</a>
</li><li class="li-toc"><a href="#s%3Aeffects-semantics">12.24.5â€ƒSemantics</a>
</li><li class="li-toc"><a href="#s%3Aeffects-shallow">12.24.6â€ƒShallow handlers</a>
</li></ul>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec335">PartÂ IIIâ€ƒThe OCaml tools</a>
<ul class="toc"><li class="li-toc"><a href="#sec336">ChapterÂ 13â€ƒBatch compilation (ocamlc)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Acomp-overview">13.1â€ƒOverview of the compiler</a>
</li><li class="li-toc"><a href="#s%3Acomp-options">13.2â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Amodules-file-system">13.3â€ƒModules and the file system</a>
</li><li class="li-toc"><a href="#s%3Acomp-errors">13.4â€ƒCommon errors</a>
</li><li class="li-toc"><a href="#s%3Acomp-warnings">13.5â€ƒWarning reference</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Awarn6">13.5.1â€ƒWarning 6: Label omitted in function application</a>
</li><li class="li-toc"><a href="#ss%3Awarn9">13.5.2â€ƒWarning 9: missing fields in a record pattern</a>
</li><li class="li-toc"><a href="#ss%3Awarn52">13.5.3â€ƒWarning 52: fragile constant pattern</a>
</li><li class="li-toc"><a href="#ss%3Awarn57">13.5.4â€ƒWarning 57: Ambiguous or-pattern variables under guard</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec347">ChapterÂ 14â€ƒThe toplevel system or REPL (ocaml)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Atoplevel-options">14.1â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Atoplevel-directives">14.2â€ƒToplevel directives</a>
</li><li class="li-toc"><a href="#s%3Atoplevel-modules">14.3â€ƒThe toplevel and the module system</a>
</li><li class="li-toc"><a href="#s%3Atoplevel-common-errors">14.4â€ƒCommon errors</a>
</li><li class="li-toc"><a href="#s%3Acustom-toplevel">14.5â€ƒBuilding custom toplevel systems: <span class="font-tt">ocamlmktop</span></a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamlmktop-options">14.5.1â€ƒOptions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamlnat">14.6â€ƒThe native toplevel: <span class="font-tt">ocamlnat</span> (experimental)</a>
</li></ul>
</li><li class="li-toc"><a href="#sec355">ChapterÂ 15â€ƒThe runtime system (ocamlrun)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aocamlrun-overview">15.1â€ƒOverview</a>
</li><li class="li-toc"><a href="#s%3Aocamlrun-options">15.2â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Aocamlrun-dllpath">15.3â€ƒDynamic loading of shared libraries</a>
</li><li class="li-toc"><a href="#s%3Aocamlrun-common-errors">15.4â€ƒCommon errors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec360">ChapterÂ 16â€ƒNative-code compilation (ocamlopt)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Anative-overview">16.1â€ƒOverview of the compiler</a>
</li><li class="li-toc"><a href="#s%3Anative-options">16.2â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Anative-common-errors">16.3â€ƒCommon errors</a>
</li><li class="li-toc"><a href="#s%3Anative%3Arunning-executable">16.4â€ƒRunning executables produced by ocamlopt</a>
</li><li class="li-toc"><a href="#s%3Acompat-native-bytecode">16.5â€ƒCompatibility with the bytecode compiler</a>
</li></ul>
</li><li class="li-toc"><a href="#sec370">ChapterÂ 17â€ƒLexer and parser generators (ocamllex, ocamlyacc)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aocamllex-overview">17.1â€ƒOverview of <span class="font-tt">ocamllex</span></a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamllex-options">17.1.1â€ƒOptions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamllex-syntax">17.2â€ƒSyntax of lexer definitions</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamllex-header-trailer">17.2.1â€ƒHeader and trailer</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-named-regexp">17.2.2â€ƒNaming regular expressions</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-entry-points">17.2.3â€ƒEntry points</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-regexp">17.2.4â€ƒRegular expressions</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-actions">17.2.5â€ƒActions</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-variables">17.2.6â€ƒVariables in regular expressions</a>
</li><li class="li-toc"><a href="#ss%3Arefill-handlers">17.2.7â€ƒRefill handlers</a>
</li><li class="li-toc"><a href="#ss%3Aocamllex-reserved-ident">17.2.8â€ƒReserved identifiers</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamlyacc-overview">17.3â€ƒOverview of <span class="font-tt">ocamlyacc</span></a>
</li><li class="li-toc"><a href="#s%3Aocamlyacc-syntax">17.4â€ƒSyntax of grammar definitions</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamlyacc-header-trailer">17.4.1â€ƒHeader and trailer</a>
</li><li class="li-toc"><a href="#ss%3Aocamlyacc-declarations">17.4.2â€ƒDeclarations</a>
</li><li class="li-toc"><a href="#ss%3Aocamlyacc-rules">17.4.3â€ƒRules</a>
</li><li class="li-toc"><a href="#ss%3Aocamlyacc-error-handling">17.4.4â€ƒError handling</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamlyacc-options">17.5â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Alexyacc-example">17.6â€ƒA complete example</a>
</li><li class="li-toc"><a href="#s%3Alexyacc-common-errors">17.7â€ƒCommon errors</a>
</li></ul>
</li><li class="li-toc"><a href="#sec391">ChapterÂ 18â€ƒDependency generator (ocamldep)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aocamldep-options">18.1â€ƒOptions</a>
</li><li class="li-toc"><a href="#s%3Aocamldep-makefile">18.2â€ƒA typical Makefile</a>
</li></ul>
</li><li class="li-toc"><a href="#sec394">ChapterÂ 19â€ƒThe documentation generator (ocamldoc)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aocamldoc-usage">19.1â€ƒUsage</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamldoc-invocation">19.1.1â€ƒInvocation</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-merge">19.1.2â€ƒMerging of module information</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-rules">19.1.3â€ƒCoding rules</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamldoc-comments">19.2â€ƒSyntax of documentation comments</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamldoc-placement">19.2.1â€ƒPlacement of documentation comments</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-stop">19.2.2â€ƒThe Stop special comment</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-syntax">19.2.3â€ƒSyntax of documentation comments</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-formatting">19.2.4â€ƒText formatting</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-tags">19.2.5â€ƒDocumentation tags (@-tags)</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamldoc-custom-generators">19.3â€ƒCustom generators</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamldoc-generators">19.3.1â€ƒThe generator modules</a>
</li><li class="li-toc"><a href="#ss%3Aocamldoc-handling-custom-tags">19.3.2â€ƒHandling custom tags</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aocamldoc-adding-flags">19.4â€ƒAdding command line options</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aocamldoc-compilation-and-usage">19.4.1â€ƒCompilation and usage</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec431">ChapterÂ 20â€ƒThe debugger (ocamldebug)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Adebugger-compilation">20.1â€ƒCompiling for debugging</a>
</li><li class="li-toc"><a href="#s%3Adebugger-invocation">20.2â€ƒInvocation</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Adebugger-start">20.2.1â€ƒStarting the debugger</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-init-file">20.2.2â€ƒInitialization file</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-exut">20.2.3â€ƒExiting the debugger</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Adebugger-commands">20.3â€ƒCommands</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Adebugger-help">20.3.1â€ƒGetting help</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-state">20.3.2â€ƒAccessing the debugger state</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Adebugger-execution">20.4â€ƒExecuting a program</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Adebugger-events">20.4.1â€ƒEvents</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-starting-program">20.4.2â€ƒStarting the debugged program</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-running">20.4.3â€ƒRunning the program</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-time-travel">20.4.4â€ƒTime travel</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-kill">20.4.5â€ƒKilling the program</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Abreakpoints">20.5â€ƒBreakpoints</a>
</li><li class="li-toc"><a href="#s%3Adebugger-callstack">20.6â€ƒThe call stack</a>
</li><li class="li-toc"><a href="#s%3Adebugger-examining-values">20.7â€ƒExamining variable values</a>
</li><li class="li-toc"><a href="#s%3Adebugger-control">20.8â€ƒControlling the debugger</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Adebugger-name-and-arguments">20.8.1â€ƒSetting the program name and arguments</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-loading">20.8.2â€ƒHow programs are loaded</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-search-path">20.8.3â€ƒSearch path for files</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-working-dir">20.8.4â€ƒWorking directory</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-reverse-execution">20.8.5â€ƒTurning reverse execution on and off</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-fork">20.8.6â€ƒBehavior of the debugger with respect to <span class="machine"><span class="font-tt">fork</span></span></a>
</li><li class="li-toc"><a href="#ss%3Adebugger-stop-at-new-load">20.8.7â€ƒStopping execution when new code is loaded</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-communication">20.8.8â€ƒCommunication between the debugger and the program</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-fine-tuning">20.8.9â€ƒFine-tuning the debugger</a>
</li><li class="li-toc"><a href="#ss%3Adebugger-printers">20.8.10â€ƒUser-defined printers</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Adebugger-misc-cmds">20.9â€ƒMiscellaneous commands</a>
</li><li class="li-toc"><a href="#s%3Ainf-debugger">20.10â€ƒRunning the debugger under Emacs</a>
</li></ul>
</li><li class="li-toc"><a href="#sec462">ChapterÂ 21â€ƒProfiling (ocamlprof)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aocamlprof-compiling">21.1â€ƒCompiling for profiling</a>
</li><li class="li-toc"><a href="#s%3Aocamlprof-profiling">21.2â€ƒProfiling an execution</a>
</li><li class="li-toc"><a href="#s%3Aocamlprof-printing">21.3â€ƒPrinting profiling information</a>
</li><li class="li-toc"><a href="#s%3Aocamlprof-time-profiling">21.4â€ƒTime profiling</a>
</li></ul>
</li><li class="li-toc"><a href="#c%3Aintf-c">ChapterÂ 22â€ƒInterfacing C with OCaml</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Ac-overview">22.1â€ƒOverview and compilation information</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-prim-decl">22.1.1â€ƒDeclaring primitives</a>
</li><li class="li-toc"><a href="#ss%3Ac-prim-impl">22.1.2â€ƒImplementing primitives</a>
</li><li class="li-toc"><a href="#ss%3Astaticlink-c-code">22.1.3â€ƒStatically linking C code with OCaml code</a>
</li><li class="li-toc"><a href="#ss%3Adynlink-c-code">22.1.4â€ƒDynamically linking C code with OCaml code</a>
</li><li class="li-toc"><a href="#ss%3Ac-static-vs-dynamic">22.1.5â€ƒChoosing between static linking and dynamic linking</a>
</li><li class="li-toc"><a href="#ss%3Acustom-runtime">22.1.6â€ƒBuilding standalone custom runtime systems</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-value">22.2â€ƒThe <span class="font-tt">value</span> type</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-int">22.2.1â€ƒInteger values</a>
</li><li class="li-toc"><a href="#ss%3Ac-blocks">22.2.2â€ƒBlocks</a>
</li><li class="li-toc"><a href="#ss%3Ac-outside-head">22.2.3â€ƒPointers outside the heap</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-ocaml-datatype-repr">22.3â€ƒRepresentation of OCaml data types</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-atomic">22.3.1â€ƒAtomic types</a>
</li><li class="li-toc"><a href="#ss%3Ac-tuples-and-records">22.3.2â€ƒTuples and records</a>
</li><li class="li-toc"><a href="#ss%3Ac-arrays">22.3.3â€ƒArrays</a>
</li><li class="li-toc"><a href="#ss%3Ac-concrete-datatypes">22.3.4â€ƒConcrete data types</a>
</li><li class="li-toc"><a href="#ss%3Ac-objects">22.3.5â€ƒObjects</a>
</li><li class="li-toc"><a href="#ss%3Ac-polyvar">22.3.6â€ƒPolymorphic variants</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-ops-on-values">22.4â€ƒOperations on values</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-kind-tests">22.4.1â€ƒKind tests</a>
</li><li class="li-toc"><a href="#ss%3Ac-int-ops">22.4.2â€ƒOperations on integers</a>
</li><li class="li-toc"><a href="#ss%3Ac-block-access">22.4.3â€ƒAccessing blocks</a>
</li><li class="li-toc"><a href="#ss%3Ac-block-allocation">22.4.4â€ƒAllocating blocks</a>
</li><li class="li-toc"><a href="#ss%3Ac-exceptions">22.4.5â€ƒRaising exceptions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-gc-harmony">22.5â€ƒLiving in harmony with the garbage collector</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-simple-gc-harmony">22.5.1â€ƒSimple interface</a>
</li><li class="li-toc"><a href="#ss%3Ac-low-level-gc-harmony">22.5.2â€ƒLow-level interface</a>
</li><li class="li-toc"><a href="#ss%3Ac-process-pending-actions">22.5.3â€ƒPending actions and asynchronous exceptions</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-intf-example">22.6â€ƒA complete example</a>
</li><li class="li-toc"><a href="#s%3Ac-callback">22.7â€ƒAdvanced topic: callbacks from C to OCaml</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-callbacks">22.7.1â€ƒApplying OCaml closures from C</a>
</li><li class="li-toc"><a href="#ss%3Ac-closures">22.7.2â€ƒObtaining or registering OCaml closures for use in C functions</a>
</li><li class="li-toc"><a href="#ss%3Ac-register-exn">22.7.3â€ƒRegistering OCaml exceptions for use in C functions</a>
</li><li class="li-toc"><a href="#ss%3Amain-c">22.7.4â€ƒMain program in C</a>
</li><li class="li-toc"><a href="#ss%3Ac-embedded-code">22.7.5â€ƒEmbedding the OCaml code in the C code</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ac-advexample">22.8â€ƒAdvanced example with callbacks</a>
</li><li class="li-toc"><a href="#s%3Ac-custom">22.9â€ƒAdvanced topic: custom blocks</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-custom-ops">22.9.1â€ƒThe <span class="machine"><span class="font-tt">struct custom_operations</span></span></a>
</li><li class="li-toc"><a href="#ss%3Ac-custom-alloc">22.9.2â€ƒAllocating custom blocks</a>
</li><li class="li-toc"><a href="#ss%3Ac-custom-access">22.9.3â€ƒAccessing custom blocks</a>
</li><li class="li-toc"><a href="#ss%3Ac-custom-serialization">22.9.4â€ƒWriting custom serialization and deserialization functions</a>
</li><li class="li-toc"><a href="#ss%3Ac-custom-idents">22.9.5â€ƒChoosing identifiers</a>
</li><li class="li-toc"><a href="#ss%3Ac-finalized">22.9.6â€ƒFinalized blocks</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3AC-Bigarrays">22.10â€ƒAdvanced topic: Bigarrays and the OCaml-C interface</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3AC-Bigarrays-include">22.10.1â€ƒInclude file</a>
</li><li class="li-toc"><a href="#ss%3AC-Bigarrays-access">22.10.2â€ƒAccessing an OCaml bigarray from C or Fortran</a>
</li><li class="li-toc"><a href="#ss%3AC-Bigarrays-wrap">22.10.3â€ƒWrapping a C or Fortran array as an OCaml Bigarray</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3AC-cheaper-call">22.11â€ƒAdvanced topic: cheaper C call</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-unboxed">22.11.1â€ƒPassing unboxed values</a>
</li><li class="li-toc"><a href="#ss%3Ac-direct-call">22.11.2â€ƒDirect C call</a>
</li><li class="li-toc"><a href="#ss%3Ac-direct-call-example">22.11.3â€ƒExample: calling C library functions without indirection</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3AC-multithreading">22.12â€ƒAdvanced topic: multithreading</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-thread-register">22.12.1â€ƒRegistering threads created from C</a>
</li><li class="li-toc"><a href="#ss%3Aparallel-execution-long-running-c-code">22.12.2â€ƒParallel execution of long-running C code with systhreads</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Ainterfacing-windows-unicode-apis">22.13â€ƒAdvanced topic: interfacing with Windows Unicode APIs</a>
</li><li class="li-toc"><a href="#s%3Aocamlmklib">22.14â€ƒBuilding mixed C/OCaml libraries: <span class="font-tt">ocamlmklib</span></a>
</li><li class="li-toc"><a href="#s%3Ac-internal-guidelines">22.15â€ƒCautionary words: the internal runtime API</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Ac-internals">22.15.1â€ƒInternal variables and CAML_INTERNALS</a>
</li><li class="li-toc"><a href="#ss%3Ac-internal-macros">22.15.2â€ƒOCaml version macros</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec546">ChapterÂ 23â€ƒOptimisation with Flambda</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aflambda-overview">23.1â€ƒOverview</a>
</li><li class="li-toc"><a href="#s%3Aflambda-cli">23.2â€ƒCommand-line flags</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-rounds">23.2.1â€ƒSpecification of optimisation parameters by round</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-inlining">23.3â€ƒInlining</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-classic">23.3.1â€ƒClassic inlining heuristic</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-inlining-overview">23.3.2â€ƒOverview of â€œFlambdaâ€ inlining heuristics</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-by-constructs">23.3.3â€ƒHandling of specific language constructs</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-inlining-reports">23.3.4â€ƒInlining reports</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-assessment-inlining">23.3.5â€ƒAssessment of inlining benefit</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-speculation">23.3.6â€ƒControl of speculation</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-specialisation">23.4â€ƒSpecialisation</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-assessment-specialisation">23.4.1â€ƒAssessment of specialisation benefit</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-defaults">23.5â€ƒDefault settings of parameters</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-o2">23.5.1â€ƒSettings at -O2 optimisation level</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-o3">23.5.2â€ƒSettings at -O3 optimisation level</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-manual-control">23.6â€ƒManual control of inlining and specialisation</a>
</li><li class="li-toc"><a href="#s%3Aflambda-simplification">23.7â€ƒSimplification</a>
</li><li class="li-toc"><a href="#s%3Aflambda-other-transfs">23.8â€ƒOther code motion transformations</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-lift-const">23.8.1â€ƒLifting of constants</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-lift-toplevel-let">23.8.2â€ƒLifting of toplevel let bindings</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-unboxing">23.9â€ƒUnboxing transformations</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-unbox-fvs">23.9.1â€ƒUnboxing of closure variables</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-unbox-spec-args">23.9.2â€ƒUnboxing of specialised arguments</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-unbox-closures">23.9.3â€ƒUnboxing of closures</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-remove-unused">23.10â€ƒRemoval of unused code and values</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-redundant-let">23.10.1â€ƒRemoval of redundant let expressions</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-redundant">23.10.2â€ƒRemoval of redundant program constructs</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-remove-unused-args">23.10.3â€ƒRemoval of unused arguments</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-removal-closure-vars">23.10.4â€ƒRemoval of unused closure variables</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-other">23.11â€ƒOther code transformations</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aflambda-non-escaping-refs">23.11.1â€ƒTransformation of non-escaping references into mutable variables</a>
</li><li class="li-toc"><a href="#ss%3Aflambda-subst-closure-vars">23.11.2â€ƒSubstitution of closure variables for specialised arguments</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aflambda-effects">23.12â€ƒTreatment of effects</a>
</li><li class="li-toc"><a href="#s%3Aflambda-static-modules">23.13â€ƒCompilation of statically-allocated modules</a>
</li><li class="li-toc"><a href="#s%3Aflambda-inhibition">23.14â€ƒInhibition of optimisation</a>
</li><li class="li-toc"><a href="#s%3Aflambda-unsafe">23.15â€ƒUse of unsafe operations</a>
</li><li class="li-toc"><a href="#s%3Aflambda-glossary">23.16â€ƒGlossary</a>
</li></ul>
</li><li class="li-toc"><a href="#sec597">ChapterÂ 24â€ƒFuzzing with afl-fuzz</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aafl-overview">24.1â€ƒOverview</a>
</li><li class="li-toc"><a href="#s%3Aafl-generate">24.2â€ƒGenerating instrumentation</a>
<ul class="toc"><li class="li-toc"><a href="#ss%3Aafl-advanced">24.2.1â€ƒAdvanced options</a>
</li></ul>
</li><li class="li-toc"><a href="#s%3Aafl-example">24.3â€ƒExample</a>
</li></ul>
</li><li class="li-toc"><a href="#sec602">ChapterÂ 25â€ƒRuntime tracing with runtime events</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aruntime-tracing-overview">25.1â€ƒOverview</a>
</li><li class="li-toc"><a href="#s%3Aruntime-tracing-architecture">25.2â€ƒArchitecture</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Aruntime-tracing-probes">25.2.1â€ƒProbes</a>
</li><li class="li-toc"><a href="#s%3Aruntime-tracing-ingestion">25.2.2â€ƒEvents transport</a>
</li></ul>
</li><li class="li-toc"><a href="#s-runtime-tracing-usage">25.3â€ƒUsage</a>
<ul class="toc"><li class="li-toc"><a href="#s-runtime-tracing-ocaml-apis">25.3.1â€ƒWith OCaml APIs</a>
</li><li class="li-toc"><a href="#s-runtime-tracing-tooling">25.3.2â€ƒWith tooling</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec615">ChapterÂ 26â€ƒThe â€œTail Modulo Constructorâ€ program transformation</a>
<ul class="toc"><li class="li-toc"><a href="#sec%3Adisambiguation">26.1â€ƒDisambiguation</a>
</li><li class="li-toc"><a href="#sec%3Aout-of-tmc">26.2â€ƒDanger: getting out of tail-mod-cons</a>
</li><li class="li-toc"><a href="#sec%3Adetails">26.3â€ƒDetails on the transformation</a>
</li><li class="li-toc"><a href="#sec%3Alimitations">26.4â€ƒCurrent limitations</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec627">PartÂ IVâ€ƒThe OCaml library</a>
<ul class="toc"><li class="li-toc"><a href="#sec628">ChapterÂ 27â€ƒThe core library</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Acore-builtins">27.1â€ƒBuilt-in types and predefined exceptions</a>
</li><li class="li-toc"><a href="#s%3Astdlib-module">27.2â€ƒModule <span class="font-tt">Stdlib</span>: the initially opened module</a>
</li></ul>
</li><li class="li-toc"><a href="#sec633">ChapterÂ 28â€ƒThe standard library</a>
</li><li class="li-toc"><a href="#sec634">ChapterÂ 29â€ƒThe compiler front-end</a>
</li><li class="li-toc"><a href="#sec635">ChapterÂ 30â€ƒThe unix library: Unix system calls</a>
</li><li class="li-toc"><a href="#sec636">ChapterÂ 31â€ƒThe str library: regular expressions and string processing</a>
</li><li class="li-toc"><a href="#sec637">ChapterÂ 32â€ƒThe runtime_events library</a>
</li><li class="li-toc"><a href="#sec638">ChapterÂ 33â€ƒThe threads library</a>
</li><li class="li-toc"><a href="#sec639">ChapterÂ 34â€ƒThe dynlink library: dynamic loading and linking of object files</a>
</li><li class="li-toc"><a href="#sec640">ChapterÂ 35â€ƒRecently removed or moved libraries (Graphics, Bigarray, Num, LablTk)</a>
<ul class="toc"><li class="li-toc"><a href="#s%3Agraphics-removed">35.1â€ƒThe Graphics Library</a>
</li><li class="li-toc"><a href="#s%3Abigarray-moved">35.2â€ƒThe Bigarray Library</a>
</li><li class="li-toc"><a href="#sec643">35.3â€ƒThe Num Library</a>
</li><li class="li-toc"><a href="#s%3Alabltk-removed">35.4â€ƒThe Labltk Library and OCamlBrowser</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec645">PartÂ Vâ€ƒIndexes</a>
</li></ul><!--TOC chapter id="sec2" Foreword-->
<h1 class="chapter" id="sec2">Foreword</h1><!--SEC END --><!--NAME foreword.html-->
<p>This manual documents the release 5.0 of the OCaml
system. It is organized as follows.
</p><ul class="itemize"><li class="li-itemize">PartÂ <a href="#p%3Atutorials">I</a>, â€œAn introduction to OCamlâ€,
gives an overview of the language.
</li><li class="li-itemize">PartÂ <a href="#p%3Arefman">II</a>, â€œThe OCaml languageâ€, is the
reference description of the language.
</li><li class="li-itemize">PartÂ <a href="#p%3Acommands">III</a>, â€œThe OCaml toolsâ€, documents
the compilers, toplevel system, and programming utilities.
</li><li class="li-itemize">PartÂ <a href="#p%3Alibrary">IV</a>, â€œThe OCaml libraryâ€, describes the
modules provided in the standard library.

</li></ul><!--TOC section id="conventions" Conventions-->
<h2 class="section" id="conventions"><a class="section-anchor" href="#conventions" aria-hidden="true">ï»¿</a>Conventions</h2><!--SEC END --><p>OCaml runs on several operating systems. The parts of
this manual that are specific to one operating system are presented as
shown below:</p><blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ This is material specific to the Unix family of operating
systems, including Linux and macOS.
</blockquote><blockquote class="quote"><span class="osvariant">Windows:</span>â€ƒ This is material specific to Microsoft Windows
(Vista, 7, 8, 10).
</blockquote><!--TOC section id="license" License-->
<h2 class="section" id="license"><a class="section-anchor" href="#license" aria-hidden="true">ï»¿</a>License</h2><!--SEC END --><p>The OCaml system is copyright Â© 1996â€“2022
Institut National de Recherche en Informatique et en
Automatique (INRIA).
INRIA holds all ownership rights to the OCaml system.</p><p>The OCaml system is open source and can be freely
redistributed. See the file <span class="machine"><span class="font-tt">LICENSE</span></span> in the distribution for
licensing information.</p><p>The OCaml documentation and userâ€™s manual is
copyright Â© 2022
Institut National de Recherche en Informatique et en
Automatique (INRIA).</p><p>
<a id="cc_license_logo" rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
The OCaml documentation and user's manual is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

</p><!--TOC section id="availability" Availability-->
<h2 class="section" id="availability"><a class="section-anchor" href="#availability" aria-hidden="true">ï»¿</a>Availability</h2><!--SEC END --><p>
The complete OCaml distribution can be accessed via the
<a href="https://ocaml.org/">ocaml.org website</a>.
This site contains a lot of additional information on OCaml.

</p>
<!--TOC part id="sec6" PartÂ Iâ€ƒAn introduction to OCaml-->
<table class="center"><tr><td><h1 class="part" id="sec6">PartÂ I<br>
An introduction to OCaml</h1></td></tr>
</table><!--SEC END --><p>
<a id="p:tutorials"></a>
</p>
<!--TOC chapter id="sec7" ChapterÂ 1â€ƒThe core language-->
<h1 class="chapter" id="sec7">ChapterÂ 1â€ƒThe core language</h1><!--SEC END --><p> <a id="c:core-xamples"></a>
</p><!--NAME coreexamples.html-->
<p>This part of the manual is a tutorial introduction to the OCaml language. A
good familiarity with programming in a conventional languages (say, C or Java)
is assumed, but no prior exposure to functional languages is required. The
present chapter introduces the core language. ChapterÂ <a href="#c%3Amoduleexamples">2</a>
deals with the module system, chapterÂ <a href="#c%3Aobjectexamples">3</a> with the
object-oriented features, chapterÂ <a href="#c%3Alabl-examples">4</a> with labeled
arguments, chapterÂ <a href="#c%3Apoly-variant">5</a> with polymorphic variants,
chapterÂ <a href="#c%3Apolymorphism">6</a> with the limitations of polymorphism, and
chapterÂ <a href="#c%3Aadvexamples">8</a> gives some advanced examples.</p>
<!--TOC section id="s:basics" 1.1â€ƒBasics-->
<h2 class="section" id="s:basics"><a class="section-anchor" href="#s:basics" aria-hidden="true">ï»¿</a>1.1â€ƒBasics</h2><!--SEC END --><p>For this overview of OCaml, we use the interactive system, which is started by
running <span class="machine"><span class="font-tt">ocaml</span></span> from the Unix shell or Windows command prompt. This tutorial is
presented as the transcript of a session with the interactive system: lines
starting with <span class="machine"><span class="font-tt">#</span></span> represent user input; the system responses are printed below,
without a leading <span class="machine"><span class="font-tt">#</span></span>.</p><p>Under the interactive system, the user types OCaml phrases terminated
by <span class="machine"><span class="font-tt">;;</span></span> in response to the <span class="machine"><span class="font-tt">#</span></span> prompt, and the system compiles them
on the fly, executes them, and prints the outcome of evaluation.
Phrases are either simple expressions, or <span class="machine"><span class="font-tt">let</span></span> definitions of
identifiers (either values or functions).

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> 1 + 2 * 3;;</div>



<div class="pre caml-output ok">- : int = 7</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pi = 4.0 *. atan 1.0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pi : float = 3.14159265358979312</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> square x = x *. x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> square : float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> square (sin pi) +. square (cos pi);;</div>



<div class="pre caml-output ok">- : float = 1.</div></div>

</div><p>

The OCaml system computes both the value and the type for
each phrase. Even function parameters need no explicit type declaration:
the system infers their types from their usage in the
function. Notice also that integers and floating-point numbers are
distinct types, with distinct operators: <span class="machine"><span class="font-tt">+</span></span> and <span class="machine"><span class="font-tt">*</span></span> operate on
integers, but <span class="machine"><span class="font-tt">+.</span></span> and <span class="machine"><span class="font-tt">*.</span></span> operate on floats.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">1.0</span> * 2;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type float but an expression was expected of type
         int</div></div>

</div><p>Recursive functions are defined with the <span class="machine"><span class="font-tt">let rec</span></span> binding:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n =
    <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> n <span class="ocamlkeyword">else</span> fib (n - 1) + fib (n - 2);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fib : int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> fib 10;;</div>



<div class="pre caml-output ok">- : int = 55</div></div>

</div>
<!--TOC section id="s:datatypes" 1.2â€ƒData types-->
<h2 class="section" id="s:datatypes"><a class="section-anchor" href="#s:datatypes" aria-hidden="true">ï»¿</a>1.2â€ƒData types</h2><!--SEC END --><p>In addition to integers and floating-point numbers, OCaml offers the
usual basic data types:
</p><ul class="itemize"><li class="li-itemize">booleans

<div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (1 &lt; 2) = <span class="ocamlkeyword">false</span>;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">false</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> one = <span class="ocamlkeyword">if</span> <span class="ocamlkeyword">true</span> <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> one : int = 1</div></div>

</div>

</li><li class="li-itemize">characters

<div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>  'a';;</div>



<div class="pre caml-output ok">- : char = 'a'</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>  int_of_char '\n';;</div>



<div class="pre caml-output ok">- : int = 10</div></div>

</div>

</li><li class="li-itemize">immutable character strings

<div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlstring">"Hello"</span> ^ <span class="ocamlstring">" "</span> ^ <span class="ocamlstring">"world"</span>;;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"Hello world"</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlstring">{|This is a quoted string, here, neither \ nor " are special characters|}</span>;;</div>



<div class="pre caml-output ok">- : string =
<span class="ocamlstring">"This is a quoted string, here, neither \\ nor \" are special characters"</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlstring">{|"\\"|}</span>=<span class="ocamlstring">"\"\\\\\""</span>;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlstring">{delimiter|the end of this|}quoted string is here|delimiter}</span>
  =           <span class="ocamlstring">"the end of this|}quoted string is here"</span>;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div>

</li></ul><p>Predefined data structures include tuples, arrays, and lists. There are also
general mechanisms for defining your own data structures, such as records and
variants, which will be covered in more detail later; for now, we concentrate
on lists. Lists are either given in extension as a bracketed list of
semicolon-separated elements, or built from the empty list <span class="machine"><span class="font-tt">[]</span></span>
(pronounce â€œnilâ€) by adding elements in front using the <span class="machine"><span class="font-tt">::</span></span>
(â€œconsâ€) operator.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> l = [<span class="ocamlstring">"is"</span>; <span class="ocamlstring">"a"</span>; <span class="ocamlstring">"tale"</span>; <span class="ocamlstring">"told"</span>; <span class="ocamlstring">"etc."</span>];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : string list = [<span class="ocamlstring">"is"</span>; <span class="ocamlstring">"a"</span>; <span class="ocamlstring">"tale"</span>; <span class="ocamlstring">"told"</span>; <span class="ocamlstring">"etc."</span>]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlstring">"Life"</span> :: l;;</div>



<div class="pre caml-output ok">- : string list = [<span class="ocamlstring">"Life"</span>; <span class="ocamlstring">"is"</span>; <span class="ocamlstring">"a"</span>; <span class="ocamlstring">"tale"</span>; <span class="ocamlstring">"told"</span>; <span class="ocamlstring">"etc."</span>]</div></div>

</div><p>

As with all other OCaml data structures, lists do not need to be
explicitly allocated and deallocated from memory: all memory
management is entirely automatic in OCaml. Similarly, there is no
explicit handling of pointers: the OCaml compiler silently introduces
pointers where necessary.</p><p>As with most OCaml data structures, inspecting and destructuring lists
is performed by pattern-matching. List patterns have exactly the same
form as list expressions, with identifiers representing unspecified
parts of the list. As an example, here is insertion sort on a list:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> sort lst =
    <span class="ocamlkeyword">match</span> lst <span class="ocamlkeyword">with</span>
      [] -&gt; []
    | head :: tail -&gt; insert head (sort tail)
  <span class="ocamlkeyword">and</span> insert elt lst =
    <span class="ocamlkeyword">match</span> lst <span class="ocamlkeyword">with</span>
      [] -&gt; [elt]
    | head :: tail -&gt; <span class="ocamlkeyword">if</span> elt &lt;= head <span class="ocamlkeyword">then</span> elt :: lst <span class="ocamlkeyword">else</span> head :: insert elt tail
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sort : 'a list -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> insert : 'a -&gt; 'a list -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> sort l;;</div>



<div class="pre caml-output ok">- : string list = [<span class="ocamlstring">"a"</span>; <span class="ocamlstring">"etc."</span>; <span class="ocamlstring">"is"</span>; <span class="ocamlstring">"tale"</span>; <span class="ocamlstring">"told"</span>]</div></div>

</div><p>The type inferred for <span class="machine"><span class="font-tt">sort</span></span>, <span class="machine"><span class="font-tt">'a list -&gt; 'a list</span></span>, means that <span class="machine"><span class="font-tt">sort</span></span>
can actually apply to lists of any type, and returns a list of the
same type. The type <span class="machine"><span class="font-tt">'a</span></span> is a <em>type variable</em>, and stands for any
given type. The reason why <span class="machine"><span class="font-tt">sort</span></span> can apply to lists of any type is
that the comparisons (<span class="machine"><span class="font-tt">=</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, etc.) are <em>polymorphic</em> in OCaml:
they operate between any two values of the same type. This makes
<span class="machine"><span class="font-tt">sort</span></span> itself polymorphic over all list types.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> sort [6; 2; 5; 3];;</div>



<div class="pre caml-output ok">- : int list = [2; 3; 5; 6]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> sort [3.14; 2.718];;</div>



<div class="pre caml-output ok">- : float list = [2.718; 3.14]</div></div>

</div><p>The <span class="machine"><span class="font-tt">sort</span></span> function above does not modify its input list: it builds
and returns a new list containing the same elements as the input list,
in ascending order. There is actually no way in OCaml to modify
a list in-place once it is built: we say that lists are <em>immutable</em>
data structures. Most OCaml data structures are immutable, but a few
(most notably arrays) are <em>mutable</em>, meaning that they can be
modified in-place at any time.</p><p>The OCaml notation for the type of a function with multiple arguments is <br>
<span class="machine"><span class="font-tt">arg1_type -&gt; arg2_type -&gt; ... -&gt; return_type</span></span>. For example,
the type inferred for <span class="machine"><span class="font-tt">insert</span></span>, <span class="machine"><span class="font-tt">'a -&gt; 'a list -&gt; 'a list</span></span>, means that <span class="machine"><span class="font-tt">insert</span></span>
takes two arguments, an element of any type <span class="machine"><span class="font-tt">'a</span></span> and a list with elements of
the same type <span class="machine"><span class="font-tt">'a</span></span> and returns a list of the same type.
</p>
<!--TOC section id="s:functions-as-values" 1.3â€ƒFunctions as values-->
<h2 class="section" id="s:functions-as-values"><a class="section-anchor" href="#s:functions-as-values" aria-hidden="true">ï»¿</a>1.3â€ƒFunctions as values</h2><!--SEC END --><p>OCaml is a functional language: functions in the full mathematical
sense are supported and can be passed around freely just as any other
piece of data. For instance, here is a <span class="machine"><span class="font-tt">deriv</span></span> function that takes any
float function as argument and returns an approximation of its
derivative function:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> deriv f dx = <span class="ocamlkeyword">fun</span> x -&gt; (f (x +. dx) -. f x) /. dx;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> deriv : (float -&gt; float) -&gt; float -&gt; float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sin' = deriv sin 1e-6;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sin' : float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> sin' pi;;</div>



<div class="pre caml-output ok">- : float = -1.00000000013961143</div></div>

</div><p>

Even function composition is definable:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> compose f g = <span class="ocamlkeyword">fun</span> x -&gt; f (g x);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> cos2 = compose square cos;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> cos2 : float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Functions that take other functions as arguments are called
â€œfunctionalsâ€, or â€œhigher-order functionsâ€. Functionals are
especially useful to provide iterators or similar generic operations
over a data structure. For instance, the standard OCaml library
provides a <span class="machine"><span class="font-tt">List.map</span></span> functional that applies a given function to each
element of a list, and returns the list of the results:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.map (<span class="ocamlkeyword">fun</span> n -&gt; n * 2 + 1) [0;1;2;3;4];;</div>



<div class="pre caml-output ok">- : int list = [1; 3; 5; 7; 9]</div></div>

</div><p>

This functional, along with a number of other list and array
functionals, is predefined because it is often useful, but there is
nothing magic with it: it can easily be defined as follows.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map f l =
    <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      [] -&gt; []
    | hd :: tl -&gt; f hd :: map f tl;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:tut-recvariants" 1.4â€ƒRecords and variants-->
<h2 class="section" id="s:tut-recvariants"><a class="section-anchor" href="#s:tut-recvariants" aria-hidden="true">ï»¿</a>1.4â€ƒRecords and variants</h2><!--SEC END --><p>User-defined data structures include records and variants. Both are
defined with the <span class="machine"><span class="font-tt">type</span></span> declaration. Here, we declare a record type to
represent rational numbers.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> ratio = {num: int; denom: int};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> ratio = { num : int; denom : int; }</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> add_ratio r1 r2 =
    {num = r1.num * r2.denom + r2.num * r1.denom;
     denom = r1.denom * r2.denom};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> add_ratio : ratio -&gt; ratio -&gt; ratio = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> add_ratio {num=1; denom=3} {num=2; denom=5};;</div>



<div class="pre caml-output ok">- : ratio = {num = 11; denom = 15}</div></div>

</div><p>

Record fields can also be accessed through pattern-matching:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> integer_part r =
    <span class="ocamlkeyword">match</span> r <span class="ocamlkeyword">with</span>
      {num=num; denom=denom} -&gt; num / denom;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> integer_part : ratio -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Since there is only one case in this pattern matching, it
is safe to expand directly the argument <span class="machine"><span class="font-tt">r</span></span> in a record pattern:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> integer_part {num=num; denom=denom} = num / denom;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> integer_part : ratio -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Unneeded fields can be omitted:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> get_denom {denom=denom} = denom;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> get_denom : ratio -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Optionally, missing fields can be made explicit by ending the list of
fields with a trailing wildcard <span class="machine"><span class="font-tt">_</span></span>::

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> get_num {num=num; _ } = num;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> get_num : ratio -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

When both sides of the <span class="machine"><span class="font-tt">=</span></span> sign are the same, it is possible to avoid
repeating the field name by eliding the <span class="machine"><span class="font-tt">=field</span></span> part:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> integer_part {num; denom} = num / denom;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> integer_part : ratio -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

This short notation for fields also works when constructing records:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ratio num denom = {num; denom};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ratio : int -&gt; int -&gt; ratio = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

At last, it is possible to update few fields of a record at once:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> integer_product integer ratio = { ratio <span class="ocamlkeyword">with</span> num = integer * ratio.num };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> integer_product : int -&gt; ratio -&gt; ratio = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

With this functional update notation, the record on the left-hand side
of <span class="machine"><span class="font-tt">with</span></span> is copied except for the fields on the right-hand side which
are updated.</p><p>The declaration of a variant type lists all possible forms for values
of that type. Each case is identified by a name, called a constructor,
which serves both for constructing values of the variant type and
inspecting them by pattern-matching. Constructor names are capitalized
to distinguish them from variable names (which must start with a
lowercase letter). For instance, here is a variant
type for doing mixed arithmetic (integers and floats):

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> number = Int <span class="ocamlkeyword">of</span> int | Float <span class="ocamlkeyword">of</span> float | Error;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> number = Int <span class="ocamlkeyword">of</span> int | Float <span class="ocamlkeyword">of</span> float | Error</div></div>

</div><p>

This declaration expresses that a value of type <span class="machine"><span class="font-tt">number</span></span> is either an
integer, a floating-point number, or the constant <span class="machine"><span class="font-tt">Error</span></span> representing
the result of an invalid operation (e.g. a division by zero).</p><p>Enumerated types are a special case of variant types, where all
alternatives are constants:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> sign = Positive | Negative;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> sign = Positive | Negative</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sign_int n = <span class="ocamlkeyword">if</span> n &gt;= 0 <span class="ocamlkeyword">then</span> Positive <span class="ocamlkeyword">else</span> Negative;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sign_int : int -&gt; sign = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>To define arithmetic operations for the <span class="machine"><span class="font-tt">number</span></span> type, we use
pattern-matching on the two numbers involved:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> add_num n1 n2 =
    <span class="ocamlkeyword">match</span> (n1, n2) <span class="ocamlkeyword">with</span>
      (Int i1, Int i2) -&gt;
        <span class="ocamlcomment">(* Check for overflow of integer addition *)</span>
        <span class="ocamlkeyword">if</span> sign_int i1 = sign_int i2 &amp;&amp; sign_int (i1 + i2) &lt;&gt; sign_int i1
        <span class="ocamlkeyword">then</span> Float(float i1 +. float i2)
        <span class="ocamlkeyword">else</span> Int(i1 + i2)
    | (Int i1, Float f2) -&gt; Float(float i1 +. f2)
    | (Float f1, Int i2) -&gt; Float(f1 +. float i2)
    | (Float f1, Float f2) -&gt; Float(f1 +. f2)
    | (Error, _) -&gt; Error
    | (_, Error) -&gt; Error;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> add_num : number -&gt; number -&gt; number = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> add_num (Int 123) (Float 3.14159);;</div>



<div class="pre caml-output ok">- : number = Float 126.14159</div></div>

</div><p>Another interesting example of variant type is the built-in
<span class="machine"><span class="font-tt">'a option</span></span> type which represents either a value of type <span class="machine"><span class="font-tt">'a</span></span> or an
absence of value:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a option = Some <span class="ocamlkeyword">of</span> 'a | None;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a option = Some <span class="ocamlkeyword">of</span> 'a | None</div></div>

</div><p>

This type is particularly useful when defining function that can
fail in common situations, for instance

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> safe_square_root x = <span class="ocamlkeyword">if</span> x &gt; 0. <span class="ocamlkeyword">then</span> Some(sqrt x) <span class="ocamlkeyword">else</span> None;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> safe_square_root : float -&gt; float option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The most common usage of variant types is to describe recursive data
structures. Consider for example the type of binary trees:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a btree = Empty | Node <span class="ocamlkeyword">of</span> 'a * 'a btree * 'a btree;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a btree = Empty | Node <span class="ocamlkeyword">of</span> 'a * 'a btree * 'a btree</div></div>

</div><p>

This definition reads as follows: a binary tree containing values of
type <span class="machine"><span class="font-tt">'a</span></span> (an arbitrary type) is either empty, or is a node containing
one value of type <span class="machine"><span class="font-tt">'a</span></span> and two subtrees also containing values of type
<span class="machine"><span class="font-tt">'a</span></span>, that is, two <span class="machine"><span class="font-tt">'a btree</span></span>.</p><p>Operations on binary trees are naturally expressed as recursive functions
following the same structure as the type definition itself. For
instance, here are functions performing lookup and insertion in
ordered binary trees (elements increase from left to right):

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> member x btree =
    <span class="ocamlkeyword">match</span> btree <span class="ocamlkeyword">with</span>
      Empty -&gt; <span class="ocamlkeyword">false</span>
    | Node(y, left, right) -&gt;
        <span class="ocamlkeyword">if</span> x = y <span class="ocamlkeyword">then</span> <span class="ocamlkeyword">true</span> <span class="ocamlkeyword">else</span>
        <span class="ocamlkeyword">if</span> x &lt; y <span class="ocamlkeyword">then</span> member x left <span class="ocamlkeyword">else</span> member x right;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> member : 'a -&gt; 'a btree -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> insert x btree =
    <span class="ocamlkeyword">match</span> btree <span class="ocamlkeyword">with</span>
      Empty -&gt; Node(x, Empty, Empty)
    | Node(y, left, right) -&gt;
        <span class="ocamlkeyword">if</span> x &lt;= y <span class="ocamlkeyword">then</span> Node(y, insert x left, right)
                  <span class="ocamlkeyword">else</span> Node(y, left, insert x right);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> insert : 'a -&gt; 'a btree -&gt; 'a btree = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC subsection id="ss:record-and-variant-disambiguation" 1.4.1â€ƒRecord and variant disambiguation-->
<h3 class="subsection" id="ss:record-and-variant-disambiguation"><a class="section-anchor" href="#ss:record-and-variant-disambiguation" aria-hidden="true">ï»¿</a>1.4.1â€ƒRecord and variant disambiguation</h3><!--SEC END --><p>
( This subsection can be skipped on the first reading )</p><p>Astute readers may have wondered what happens when two or more record
fields or constructors share the same name</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> first_record  = { x:int; y:int; z:int }
  <span class="ocamlkeyword">type</span> middle_record = { x:int; z:int }
  <span class="ocamlkeyword">type</span> last_record   = { x:int };;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> first_variant = A | B | C
  <span class="ocamlkeyword">type</span> last_variant  = A;;</div></div>

</div><p>The answer is that when confronted with multiple options, OCaml tries to
use locally available information to disambiguate between the various fields
and constructors. First, if the type of the record or variant is known,
OCaml can pick unambiguously the corresponding field or constructor.
For instance:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> look_at_x_then_z (r:first_record) =
    <span class="ocamlkeyword">let</span> x = r.x <span class="ocamlkeyword">in</span>
    x + r.z;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> look_at_x_then_z : first_record -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> permute (x:first_variant) = <span class="ocamlkeyword">match</span> x <span class="ocamlkeyword">with</span>
    | A -&gt; (B:first_variant)
    | B -&gt; A
    | C -&gt; C;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> permute : first_variant -&gt; first_variant = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> wrapped = First <span class="ocamlkeyword">of</span> first_record
  <span class="ocamlkeyword">let</span> f (First r) = r, r.x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> wrapped = First <span class="ocamlkeyword">of</span> first_record
<span class="ocamlkeyword">val</span> f : wrapped -&gt; first_record * int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>In the first example, <span class="machine"><span class="font-tt">(r:first_record)</span></span> is an explicit annotation
telling OCaml that the type of <span class="machine"><span class="font-tt">r</span></span> is <span class="machine"><span class="font-tt">first_record</span></span>. With this
annotation, Ocaml knows that <span class="machine"><span class="font-tt">r.x</span></span> refers to the <span class="machine"><span class="font-tt">x</span></span> field of the first
record type. Similarly, the type annotation in the second example makes
it clear to OCaml that the constructors <span class="machine"><span class="font-tt">A</span></span>, <span class="machine"><span class="font-tt">B</span></span> and <span class="machine"><span class="font-tt">C</span></span> come from the
first variant type. Contrarily, in the last example, OCaml has inferred
by itself that the type of <span class="machine"><span class="font-tt">r</span></span> can only be <span class="machine"><span class="font-tt">first_record</span></span> and there are
no needs for explicit type annotations.</p><p>Those explicit type annotations can in fact be used anywhere.
Most of the time they are unnecessary, but they are useful to guide
disambiguation, to debug unexpected type errors, or combined with some
of the more advanced features of OCaml described in later chapters.</p><p>Secondly, for records, OCaml can also deduce the right record type by
looking at the whole set of fields used in a expression or pattern:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> project_and_rotate {x; y; _} = { x= - y; y = x; z = 0} ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> project_and_rotate : first_record -&gt; first_record = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Since the fields <span class="machine"><span class="font-tt">x</span></span> and <span class="machine"><span class="font-tt">y</span></span> can only appear simultaneously in the first
record type, OCaml infers that the type of <span class="machine"><span class="font-tt">project_and_rotate</span></span> is
<span class="machine"><span class="font-tt">first_record -&gt; first_record</span></span>.</p><p>In last resort, if there is not enough information to disambiguate between
different fields or constructors, Ocaml picks the last defined type
amongst all locally valid choices:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> look_at_xz {x; z} = x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> look_at_xz : middle_record -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Here, OCaml has inferred that the possible choices for the type of
<span class="machine"><span class="font-tt">{x;z}</span></span> are <span class="machine"><span class="font-tt">first_record</span></span> and <span class="machine"><span class="font-tt">middle_record</span></span>, since the type
<span class="machine"><span class="font-tt">last_record</span></span> has no field <span class="machine"><span class="font-tt">z</span></span>. Ocaml then picks the type <span class="machine"><span class="font-tt">middle_record</span></span>
as the last defined type between the two possibilities.</p><p>Beware that this last resort disambiguation is local: once Ocaml has
chosen a disambiguation, it sticks to this choice, even if it leads to
an ulterior type error:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> look_at_x_then_y r =
    <span class="ocamlkeyword">let</span> x = r.x <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* Ocaml deduces [r: last_record] *)</span>
    x + r.<span class="ocamlhighlight">y</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type last_record
       There is no field y within type last_record</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> is_a_or_b x = <span class="ocamlkeyword">match</span> x <span class="ocamlkeyword">with</span>
    | A -&gt; <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* OCaml infers [x: last_variant] *)</span>
    | <span class="ocamlhighlight">B</span> -&gt; <span class="ocamlkeyword">true</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This variant pattern is expected to have type last_variant
       There is no constructor B within type last_variant</div></div>

</div><p>Moreover, being the last defined type is a quite unstable position that
may change surreptitiously after adding or moving around a type
definition, or after opening a module (see chapter <a href="#c%3Amoduleexamples">2</a>).
Consequently, adding explicit type annotations to guide disambiguation is
more robust than relying on the last defined type disambiguation.</p>
<!--TOC section id="s:imperative-features" 1.5â€ƒImperative features-->
<h2 class="section" id="s:imperative-features"><a class="section-anchor" href="#s:imperative-features" aria-hidden="true">ï»¿</a>1.5â€ƒImperative features</h2><!--SEC END --><p>Though all examples so far were written in purely applicative style,
OCaml is also equipped with full imperative features. This includes the
usual <span class="machine"><span class="font-tt">while</span></span> and <span class="machine"><span class="font-tt">for</span></span> loops, as well as mutable data structures such
as arrays. Arrays are either created by listing semicolon-separated element
values between <span class="machine"><span class="font-tt">[|</span></span> and <span class="machine"><span class="font-tt">|]</span></span> brackets, or allocated and initialized with the
<span class="machine"><span class="font-tt">Array.make</span></span> function, then filled up later by assignments. For instance, the
function below sums two vectors (represented as float arrays) componentwise.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> add_vect v1 v2 =
    <span class="ocamlkeyword">let</span> len = min (Array.length v1) (Array.length v2) <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> res = Array.make len 0.0 <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">for</span> i = 0 <span class="ocamlkeyword">to</span> len - 1 <span class="ocamlkeyword">do</span>
      res.(i) &lt;- v1.(i) +. v2.(i)
    <span class="ocamlkeyword">done</span>;
    res;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> add_vect : float array -&gt; float array -&gt; float array = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> add_vect [| 1.0; 2.0 |] [| 3.0; 4.0 |];;</div>



<div class="pre caml-output ok">- : float array = [|4.; 6.|]</div></div>

</div><p>Record fields can also be modified by assignment, provided they are
declared <span class="machine"><span class="font-tt">mutable</span></span> in the definition of the record type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> mutable_point = { <span class="ocamlkeyword">mutable</span> x: float; <span class="ocamlkeyword">mutable</span> y: float };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> mutable_point = { <span class="ocamlkeyword">mutable</span> x : float; <span class="ocamlkeyword">mutable</span> y : float; }</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> translate p dx dy =
    p.x &lt;- p.x +. dx; p.y &lt;- p.y +. dy;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> translate : mutable_point -&gt; float -&gt; float -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> mypoint = { x = 0.0; y = 0.0 };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> mypoint : mutable_point = {x = 0.; y = 0.}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> translate mypoint 1.0 2.0;;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> mypoint;;</div>



<div class="pre caml-output ok">- : mutable_point = {x = 1.; y = 2.}</div></div>

</div><p>OCaml has no built-in notion of variable â€“ identifiers whose current
value can be changed by assignment. (The <span class="machine"><span class="font-tt">let</span></span> binding is not an
assignment, it introduces a new identifier with a new scope.)
However, the standard library provides references, which are mutable
indirection cells, with operators <span class="machine"><span class="font-tt">!</span></span> to fetch
the current contents of the reference and <span class="machine"><span class="font-tt">:=</span></span> to assign the contents.
Variables can then be emulated by <span class="machine"><span class="font-tt">let</span></span>-binding a reference. For
instance, here is an in-place insertion sort over arrays:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> insertion_sort a =
    <span class="ocamlkeyword">for</span> i = 1 <span class="ocamlkeyword">to</span> Array.length a - 1 <span class="ocamlkeyword">do</span>
      <span class="ocamlkeyword">let</span> val_i = a.(i) <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">let</span> j = <span class="ocamlkeyword">ref</span> i <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">while</span> !j &gt; 0 &amp;&amp; val_i &lt; a.(!j - 1) <span class="ocamlkeyword">do</span>
        a.(!j) &lt;- a.(!j - 1);
        j := !j - 1
      <span class="ocamlkeyword">done</span>;
      a.(!j) &lt;- val_i
    <span class="ocamlkeyword">done</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> insertion_sort : 'a array -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>References are also useful to write functions that maintain a current
state between two calls to the function. For instance, the following
pseudo-random number generator keeps the last returned number in a
reference:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> current_rand = <span class="ocamlkeyword">ref</span> 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> current_rand : int <span class="ocamlkeyword">ref</span> = {contents = 0}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> random () =
    current_rand := !current_rand * 25713 + 1345;
    !current_rand;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> random : unit -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Again, there is nothing magical with references: they are implemented as
a single-field mutable record, as follows.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a <span class="ocamlkeyword">ref</span> = { <span class="ocamlkeyword">mutable</span> contents: 'a };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a <span class="ocamlkeyword">ref</span> = { <span class="ocamlkeyword">mutable</span> contents : 'a; }</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ( ! ) r = r.contents;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ( ! ) : 'a <span class="ocamlkeyword">ref</span> -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ( := ) r newval = r.contents &lt;- newval;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ( := ) : 'a <span class="ocamlkeyword">ref</span> -&gt; 'a -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>In some special cases, you may need to store a polymorphic function in
a data structure, keeping its polymorphism. Doing this requires
user-provided type annotations, since polymorphism is only introduced
automatically for global definitions. However, you can explicitly give
polymorphic types to record fields.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> idref = { <span class="ocamlkeyword">mutable</span> id: 'a. 'a -&gt; 'a };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> idref = { <span class="ocamlkeyword">mutable</span> id : 'a. 'a -&gt; 'a; }</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> r = {id = <span class="ocamlkeyword">fun</span> x -&gt; x};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> r : idref = {id = &lt;<span class="ocamlkeyword">fun</span>&gt;}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> g s = (s.id 1, s.id <span class="ocamlkeyword">true</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> g : idref -&gt; int * bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> r.id &lt;- (<span class="ocamlkeyword">fun</span> x -&gt; print_string <span class="ocamlstring">"called id\n"</span>; x);;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> g r;;</div>



<div class="pre caml-output ok">called id
called id
- : int * bool = (1, <span class="ocamlkeyword">true</span>)</div></div>

</div>
<!--TOC section id="s:exceptions" 1.6â€ƒExceptions-->
<h2 class="section" id="s:exceptions"><a class="section-anchor" href="#s:exceptions" aria-hidden="true">ï»¿</a>1.6â€ƒExceptions</h2><!--SEC END --><p>OCaml provides exceptions for signalling and handling exceptional
conditions. Exceptions can also be used as a general-purpose non-local
control structure, although this should not be overused since it can
make the code harder to understand. Exceptions are declared with the
<span class="machine"><span class="font-tt">exception</span></span> construct, and signalled with the <span class="machine"><span class="font-tt">raise</span></span> operator. For instance,
the function below for taking the head of a list uses an exception to
signal the case where an empty list is given.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">exception</span> Empty_list;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">exception</span> Empty_list</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> head l =
    <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      [] -&gt; raise Empty_list
    | hd :: tl -&gt; hd;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> head : 'a list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> head [1; 2];;</div>



<div class="pre caml-output ok">- : int = 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> head [];;</div>



<div class="pre caml-output ok">Exception: Empty_list.</div></div>

</div><p>Exceptions are used throughout the standard library to signal cases
where the library functions cannot complete normally. For instance,
the <span class="machine"><span class="font-tt">List.assoc</span></span> function, which returns the data associated with a
given key in a list of (key, data) pairs, raises the predefined
exception <span class="machine"><span class="font-tt">Not_found</span></span> when the key does not appear in the list:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.assoc 1 [(0, <span class="ocamlstring">"zero"</span>); (1, <span class="ocamlstring">"one"</span>)];;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"one"</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.assoc 2 [(0, <span class="ocamlstring">"zero"</span>); (1, <span class="ocamlstring">"one"</span>)];;</div>



<div class="pre caml-output ok">Exception: Not_found.</div></div>

</div><p>Exceptions can be trapped with the <span class="machine"><span class="font-tt">try</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span> construct:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> name_of_binary_digit digit =
    <span class="ocamlkeyword">try</span>
      List.assoc digit [0, <span class="ocamlstring">"zero"</span>; 1, <span class="ocamlstring">"one"</span>]
    <span class="ocamlkeyword">with</span> Not_found -&gt;
      <span class="ocamlstring">"not a binary digit"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> name_of_binary_digit : int -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> name_of_binary_digit 0;;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"zero"</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> name_of_binary_digit (-1);;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"not a binary digit"</span></div></div>

</div><p>The <span class="machine"><span class="font-tt">with</span></span> part does pattern matching on the
exception value with the same syntax and behavior as <span class="machine"><span class="font-tt">match</span></span>. Thus,
several exceptions can be caught by one
<span class="machine"><span class="font-tt">try</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span> construct:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> first_named_value values names =
    <span class="ocamlkeyword">try</span>
      List.assoc (head values) names
    <span class="ocamlkeyword">with</span>
    | Empty_list -&gt; <span class="ocamlstring">"no named value"</span>
    | Not_found -&gt; first_named_value (List.tl values) names;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> first_named_value : 'a list -&gt; ('a * string) list -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> first_named_value [0; 10] [1, <span class="ocamlstring">"one"</span>; 10, <span class="ocamlstring">"ten"</span>];;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"ten"</span></div></div>

</div><p>Also, finalization can be performed by
trapping all exceptions, performing the finalization, then re-raising
the exception:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> temporarily_set_reference <span class="ocamlkeyword">ref</span> newval funct =
    <span class="ocamlkeyword">let</span> oldval = !<span class="ocamlkeyword">ref</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">try</span>
      <span class="ocamlkeyword">ref</span> := newval;
      <span class="ocamlkeyword">let</span> res = funct () <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">ref</span> := oldval;
      res
    <span class="ocamlkeyword">with</span> x -&gt;
      <span class="ocamlkeyword">ref</span> := oldval;
      raise x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> temporarily_set_reference : 'a <span class="ocamlkeyword">ref</span> -&gt; 'a -&gt; (unit -&gt; 'b) -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>An alternative to <span class="machine"><span class="font-tt">try</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span> is to catch the exception while
pattern matching:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> assoc_may_map f x l =
    <span class="ocamlkeyword">match</span> List.assoc x l <span class="ocamlkeyword">with</span>
    | <span class="ocamlkeyword">exception</span> Not_found -&gt; None
    | y -&gt; f y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> assoc_may_map : ('a -&gt; 'b option) -&gt; 'c -&gt; ('c * 'a) list -&gt; 'b option =
  &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Note that this construction is only useful if the exception is raised
between <span class="machine"><span class="font-tt">match</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span>. Exception patterns can be combined
with ordinary patterns at the toplevel,

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> flat_assoc_opt x l =
    <span class="ocamlkeyword">match</span> List.assoc x l <span class="ocamlkeyword">with</span>
    | None | <span class="ocamlkeyword">exception</span> Not_found -&gt; None
    | Some _ <span class="ocamlkeyword">as</span> v -&gt; v;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> flat_assoc_opt : 'a -&gt; ('a * 'b option) list -&gt; 'b option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

but they cannot be nested inside other patterns. For instance,
the pattern <span class="machine"><span class="font-tt">Some (exception A)</span></span> is invalid.</p><p>When exceptions are used as a control structure, it can be useful to make
them as local as possible by using a locally defined exception.
For instance, with

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fixpoint f x =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">exception</span> Done <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> x = <span class="ocamlkeyword">ref</span> x <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">try</span> <span class="ocamlkeyword">while</span> <span class="ocamlkeyword">true</span> <span class="ocamlkeyword">do</span>
        <span class="ocamlkeyword">let</span> y = f !x <span class="ocamlkeyword">in</span>
        <span class="ocamlkeyword">if</span> !x = y <span class="ocamlkeyword">then</span> raise Done <span class="ocamlkeyword">else</span> x := y
      <span class="ocamlkeyword">done</span>; <span class="ocamlkeyword">assert</span> <span class="ocamlkeyword">false</span>
    <span class="ocamlkeyword">with</span> Done -&gt; !x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fixpoint : ('a -&gt; 'a) -&gt; 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

the function <span class="machine"><span class="font-tt">f</span></span> cannot raise a <span class="machine"><span class="font-tt">Done</span></span> exception, which removes an
entire class of misbehaving functions.</p>
<!--TOC section id="s:lazy-expr" 1.7â€ƒLazy expressions-->
<h2 class="section" id="s:lazy-expr"><a class="section-anchor" href="#s:lazy-expr" aria-hidden="true">ï»¿</a>1.7â€ƒLazy expressions</h2><!--SEC END --><p>OCaml allows us to defer some computation until later when we need the result of
that computation. </p><p>We use <span class="machine"><span class="font-tt">lazy (expr)</span></span> to delay the evaluation of some expression <span class="machine"><span class="font-tt">expr</span></span>. For 
example, we can defer the computation of <span class="machine"><span class="font-tt">1+1</span></span> until we need the result of that
expression, <span class="machine"><span class="font-tt">2</span></span>. Let us see how we initialize a lazy expression. </p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> lazy_two = <span class="ocamlkeyword">lazy</span> (print_endline <span class="ocamlstring">"lazy_two evaluation"</span>; 1 + 1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lazy_two : int lazy_t = &lt;<span class="ocamlkeyword">lazy</span>&gt;</div></div>

</div><p>We added <span class="machine"><span class="font-tt">print_endline "lazy_two evaluation"</span></span> to see when the lazy
expression is being evaluated.</p><p>The value of <span class="machine"><span class="font-tt">lazy_two</span></span> is displayed as <span class="machine"><span class="font-tt">&lt;lazy&gt;</span></span>, which means the expression 
has not been evaluated yet, and its final value is unknown.</p><p>Note that <span class="machine"><span class="font-tt">lazy_two</span></span> has type <span class="machine"><span class="font-tt">int lazy_t</span></span>. However, the type <span class="machine"><span class="font-tt">'a lazy_t</span></span> is an 
internal type name, so the type <span class="machine"><span class="font-tt">'a Lazy.t</span></span> should be preferred when possible.</p><p>When we finally need the result of a lazy expression, we can call <span class="machine"><span class="font-tt">Lazy.force</span></span> 
on that expression to force its evaluation. The function <span class="machine"><span class="font-tt">force</span></span> comes from 
standard-library module <a href="libref/Lazy.html"><span class="font-tt">Lazy</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Lazy.force lazy_two;;</div>



<div class="pre caml-output ok">lazy_two evaluation
- : int = 2</div></div>

</div><p>Notice that our function call above prints â€œlazy_two evaluationâ€ and then 
returns the plain value of the computation. </p><p>Now if we look at the value of <span class="machine"><span class="font-tt">lazy_two</span></span>, we see that it is not displayed as 
<span class="machine"><span class="font-tt">&lt;lazy&gt;</span></span> anymore but as <span class="machine"><span class="font-tt">lazy 2</span></span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> lazy_two;;</div>



<div class="pre caml-output ok">- : int lazy_t = <span class="ocamlkeyword">lazy</span> 2</div></div>

</div><p>This is because <span class="machine"><span class="font-tt">Lazy.force</span></span> memoizes the result of the forced expression. In other 
words, every subsequent call of <span class="machine"><span class="font-tt">Lazy.force</span></span> on that expression returns the 
result of the first computation without recomputing the lazy expression. Let us 
force <span class="machine"><span class="font-tt">lazy_two</span></span> once again. </p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Lazy.force lazy_two;;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div><p>The expression is not evaluated this time; notice that â€œlazy_two evaluationâ€ is
not printed. The result of the initial computation is simply returned. </p><p>Lazy patterns provide another way to force a lazy expression. </p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> lazy_l = <span class="ocamlkeyword">lazy</span> ([1; 2] @ [3; 4]);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lazy_l : int list lazy_t = &lt;<span class="ocamlkeyword">lazy</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">lazy</span> l = lazy_l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : int list = [1; 2; 3; 4]</div></div>

</div><p>We can also use lazy patterns in pattern matching.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> maybe_eval lazy_guard lazy_expr =
    <span class="ocamlkeyword">match</span> lazy_guard, lazy_expr <span class="ocamlkeyword">with</span>
    | <span class="ocamlkeyword">lazy</span> <span class="ocamlkeyword">false</span>, _ -&gt; <span class="ocamlstring">"matches if (Lazy.force lazy_guard = false); lazy_expr not forced"</span>
    | <span class="ocamlkeyword">lazy</span> <span class="ocamlkeyword">true</span>, <span class="ocamlkeyword">lazy</span> _ -&gt; <span class="ocamlstring">"matches if (Lazy.force lazy_guard = true); lazy_expr forced"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> maybe_eval : bool lazy_t -&gt; 'a lazy_t -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The lazy expression <span class="machine"><span class="font-tt">lazy_expr</span></span> is forced only if the <span class="machine"><span class="font-tt">lazy_guard</span></span> value yields 
<span class="machine"><span class="font-tt">true</span></span> once computed. Indeed, a simple wildcard pattern (not lazy) never forces 
the lazy expressionâ€™s evaluation. However, a pattern with keyword <span class="machine"><span class="font-tt">lazy</span></span>, even 
if it is wildcard, always forces the evaluation of the deferred computation.</p>
<!--TOC section id="s:symb-expr" 1.8â€ƒSymbolic processing of expressions-->
<h2 class="section" id="s:symb-expr"><a class="section-anchor" href="#s:symb-expr" aria-hidden="true">ï»¿</a>1.8â€ƒSymbolic processing of expressions</h2><!--SEC END --><p>We finish this introduction with a more complete example
representative of the use of OCaml for symbolic processing: formal
manipulations of arithmetic expressions containing variables. The
following variant type describes the expressions we shall manipulate:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> expression =
      Const <span class="ocamlkeyword">of</span> float
    | Var <span class="ocamlkeyword">of</span> string
    | Sum <span class="ocamlkeyword">of</span> expression * expression    <span class="ocamlcomment">(* e1 + e2 *)</span>
    | Diff <span class="ocamlkeyword">of</span> expression * expression   <span class="ocamlcomment">(* e1 - e2 *)</span>
    | Prod <span class="ocamlkeyword">of</span> expression * expression   <span class="ocamlcomment">(* e1 * e2 *)</span>
    | Quot <span class="ocamlkeyword">of</span> expression * expression   <span class="ocamlcomment">(* e1 / e2 *)</span>
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> expression =
    Const <span class="ocamlkeyword">of</span> float
  | Var <span class="ocamlkeyword">of</span> string
  | Sum <span class="ocamlkeyword">of</span> expression * expression
  | Diff <span class="ocamlkeyword">of</span> expression * expression
  | Prod <span class="ocamlkeyword">of</span> expression * expression
  | Quot <span class="ocamlkeyword">of</span> expression * expression</div></div>

</div><p>We first define a function to evaluate an expression given an
environment that maps variable names to their values. For simplicity,
the environment is represented as an association list.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">exception</span> Unbound_variable <span class="ocamlkeyword">of</span> string;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">exception</span> Unbound_variable <span class="ocamlkeyword">of</span> string</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eval env exp =
    <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
      Const c -&gt; c
    | Var v -&gt;
        (<span class="ocamlkeyword">try</span> List.assoc v env <span class="ocamlkeyword">with</span> Not_found -&gt; raise (Unbound_variable v))
    | Sum(f, g) -&gt; eval env f +. eval env g
    | Diff(f, g) -&gt; eval env f -. eval env g
    | Prod(f, g) -&gt; eval env f *. eval env g
    | Quot(f, g) -&gt; eval env f /. eval env g;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> eval : (string * float) list -&gt; expression -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> eval [(<span class="ocamlstring">"x"</span>, 1.0); (<span class="ocamlstring">"y"</span>, 3.14)] (Prod(Sum(Var <span class="ocamlstring">"x"</span>, Const 2.0), Var <span class="ocamlstring">"y"</span>));;</div>



<div class="pre caml-output ok">- : float = 9.42</div></div>

</div><p>Now for a real symbolic processing, we define the derivative of an
expression with respect to a variable <span class="machine"><span class="font-tt">dv</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> deriv exp dv =
    <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
      Const c -&gt; Const 0.0
    | Var v -&gt; <span class="ocamlkeyword">if</span> v = dv <span class="ocamlkeyword">then</span> Const 1.0 <span class="ocamlkeyword">else</span> Const 0.0
    | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)
    | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)
    | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
    | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                         Prod(g, g))
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> deriv : expression -&gt; string -&gt; expression = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> deriv (Quot(Const 1.0, Var <span class="ocamlstring">"x"</span>)) <span class="ocamlstring">"x"</span>;;</div>



<div class="pre caml-output ok">- : expression =
Quot (Diff (Prod (Const 0., Var <span class="ocamlstring">"x"</span>), Prod (Const 1., Const 1.)),
 Prod (Var <span class="ocamlstring">"x"</span>, Var <span class="ocamlstring">"x"</span>))</div></div>

</div>
<!--TOC section id="s:pretty-printing" 1.9â€ƒPretty-printing-->
<h2 class="section" id="s:pretty-printing"><a class="section-anchor" href="#s:pretty-printing" aria-hidden="true">ï»¿</a>1.9â€ƒPretty-printing</h2><!--SEC END --><p>As shown in the examples above, the internal representation (also
called <em>abstract syntax</em>) of expressions quickly becomes hard to
read and write as the expressions get larger. We need a printer and a
parser to go back and forth between the abstract syntax and the <em>concrete syntax</em>, which in the case of expressions is the familiar
algebraic notation (e.g. <span class="machine"><span class="font-tt">2*x+1</span></span>).</p><p>For the printing function, we take into account the usual precedence
rules (i.e. <span class="machine"><span class="font-tt">*</span></span> binds tighter than <span class="machine"><span class="font-tt">+</span></span>) to avoid printing unnecessary
parentheses. To this end, we maintain the current operator precedence
and print parentheses around an operator only if its precedence is
less than the current precedence.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> print_expr exp =
    <span class="ocamlcomment">(* Local function definitions *)</span>
    <span class="ocamlkeyword">let</span> open_paren prec op_prec =
      <span class="ocamlkeyword">if</span> prec &gt; op_prec <span class="ocamlkeyword">then</span> print_string <span class="ocamlstring">"("</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> close_paren prec op_prec =
      <span class="ocamlkeyword">if</span> prec &gt; op_prec <span class="ocamlkeyword">then</span> print_string <span class="ocamlstring">")"</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> print prec exp =     <span class="ocamlcomment">(* prec is the current precedence *)</span>
      <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
        Const c -&gt; print_float c
      | Var v -&gt; print_string v
      | Sum(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string <span class="ocamlstring">" + "</span>; print 0 g;
          close_paren prec 0
      | Diff(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string <span class="ocamlstring">" - "</span>; print 1 g;
          close_paren prec 0
      | Prod(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string <span class="ocamlstring">" * "</span>; print 2 g;
          close_paren prec 2
      | Quot(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string <span class="ocamlstring">" / "</span>; print 3 g;
          close_paren prec 2
    <span class="ocamlkeyword">in</span> print 0 exp;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> print_expr : expression -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> e = Sum(Prod(Const 2.0, Var <span class="ocamlstring">"x"</span>), Const 1.0);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> e : expression = Sum (Prod (Const 2., Var <span class="ocamlstring">"x"</span>), Const 1.)</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> print_expr e; print_newline ();;</div>



<div class="pre caml-output ok">2. * x + 1.
- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> print_expr (deriv e <span class="ocamlstring">"x"</span>); print_newline ();;</div>



<div class="pre caml-output ok">2. * 1. + 0. * x + 0.
- : unit = ()</div></div>

</div>
<!--TOC section id="s:printf" 1.10â€ƒPrintf formats-->
<h2 class="section" id="s:printf"><a class="section-anchor" href="#s:printf" aria-hidden="true">ï»¿</a>1.10â€ƒPrintf formats</h2><!--SEC END --><p>There is a <span class="machine"><span class="font-tt">printf</span></span> function in the <a href="libref/Printf.html"><span class="font-tt">Printf</span></a> module
(see chapterÂ <a href="#c%3Amoduleexamples">2</a>) that allows you to make formatted
output more concisely.
It follows the behavior of the <span class="machine"><span class="font-tt">printf</span></span> function from the C standard library.
The <span class="machine"><span class="font-tt">printf</span></span> function takes a format string that describes the desired output
as a text interspersed with specifiers (for instance <span class="machine"><span class="font-tt">%d</span></span>, <span class="machine"><span class="font-tt">%f</span></span>).
Next, the specifiers are substituted by the following arguments in their order
of apparition in the format string:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Printf.printf <span class="ocamlstring">"%i + %i is an integer value, %F * %F is a float, %S\n"</span>
  3 2 4.5 1. <span class="ocamlstring">"this is a string"</span>;;</div>



<div class="pre caml-output ok">3 + 2 is an integer value, 4.5 * 1. is a float, <span class="ocamlstring">"this is a string"</span>
- : unit = ()</div></div>

</div><p>

The OCaml type system checks that the type of the arguments and the specifiers are
compatible. If you pass it an argument of a type that does not correspond to
the format specifier, the compiler will display an error message:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Printf.printf <span class="ocamlstring">"Float value: %F"</span> <span class="ocamlhighlight">42</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type int but an expression was expected of type
         float
  Hint: Did you mean `42.'?</div></div>

</div><p>

The <span class="machine"><span class="font-tt">fprintf</span></span> function is like <span class="machine"><span class="font-tt">printf</span></span> except that it takes an output channel as
the first argument. The <span class="machine"><span class="font-tt">%a</span></span> specifier can be useful to define custom printers
(for custom types). For instance, we can create a printing template that converts
an integer argument to signed decimal:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pp_int ppf n = Printf.fprintf ppf <span class="ocamlstring">"%d"</span> n;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pp_int : out_channel -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Printf.printf <span class="ocamlstring">"Outputting an integer using a custom printer: %a "</span> pp_int 42;;</div>



<div class="pre caml-output ok">Outputting an integer using a custom printer: 42 - : unit = ()</div></div>

</div><p>

The advantage of those printers based on the <span class="machine"><span class="font-tt">%a</span></span> specifier is that they can be
composed together to create more complex printers step by step.
We can define a combinator that can turn a printer for <span class="machine"><span class="font-tt">'a</span></span> type into a printer
for <span class="machine"><span class="font-tt">'a optional</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pp_option printer ppf = <span class="ocamlkeyword">function</span>
    | None -&gt; Printf.fprintf ppf <span class="ocamlstring">"None"</span>
    | Some v -&gt; Printf.fprintf ppf <span class="ocamlstring">"Some(%a)"</span> printer v;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pp_option :
  (out_channel -&gt; 'a -&gt; unit) -&gt; out_channel -&gt; 'a option -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Printf.fprintf stdout
    <span class="ocamlstring">"The current setting is %a. \nThere is only %a\n"</span>
    (pp_option pp_int) (Some 3)
    (pp_option pp_int) None
  ;;</div>



<div class="pre caml-output ok">The current setting is Some(3).
There is only None
- : unit = ()</div></div>

</div><p>

If the value of its argument its <span class="machine"><span class="font-tt">None</span></span>, the printer returned by pp_option
printer prints <span class="machine"><span class="font-tt">None</span></span> otherwise it uses the provided printer to print <span class="machine"><span class="font-tt">Some </span></span>.</p><p>Here is how to rewrite the pretty-printer using <span class="machine"><span class="font-tt">fprintf</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pp_expr ppf expr =
    <span class="ocamlkeyword">let</span> open_paren prec op_prec output =
      <span class="ocamlkeyword">if</span> prec &gt; op_prec <span class="ocamlkeyword">then</span> Printf.fprintf output <span class="ocamlstring">"%s"</span> <span class="ocamlstring">"("</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> close_paren prec op_prec output =
      <span class="ocamlkeyword">if</span> prec &gt; op_prec <span class="ocamlkeyword">then</span> Printf.fprintf output <span class="ocamlstring">"%s"</span> <span class="ocamlstring">")"</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> print prec ppf expr =
        <span class="ocamlkeyword">match</span> expr <span class="ocamlkeyword">with</span>
        | Const c -&gt; Printf.fprintf ppf <span class="ocamlstring">"%F"</span> c
        | Var v -&gt; Printf.fprintf ppf <span class="ocamlstring">"%s"</span> v
        | Sum(f, g) -&gt;
            open_paren prec 0 ppf;
            Printf.fprintf ppf <span class="ocamlstring">"%a + %a"</span> (print 0) f (print 0) g;
            close_paren prec 0 ppf
        | Diff(f, g) -&gt;
            open_paren prec 0 ppf;
            Printf.fprintf ppf <span class="ocamlstring">"%a - %a"</span> (print 0) f (print 1) g;
            close_paren prec 0 ppf
        | Prod(f, g) -&gt;
            open_paren prec 2 ppf;
            Printf.fprintf ppf <span class="ocamlstring">"%a * %a"</span> (print 2) f (print 2) g;
            close_paren prec 2 ppf
        | Quot(f, g) -&gt;
            open_paren prec 2 ppf;
            Printf.fprintf ppf <span class="ocamlstring">"%a / %a"</span> (print 2) f (print 3) g;
            close_paren prec 2 ppf
    <span class="ocamlkeyword">in</span> print 0 ppf expr;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pp_expr : out_channel -&gt; expression -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> pp_expr stdout e; print_newline ();;</div>



<div class="pre caml-output ok">2. * x + 1.
- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> pp_expr stdout (deriv e <span class="ocamlstring">"x"</span>); print_newline ();;</div>



<div class="pre caml-output ok">2. * 1. + 0. * x + 0.
- : unit = ()</div></div>

</div><p>Due to the way that format strings are built, storing a format string requires
an explicit type annotation:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> str : _ format =
      <span class="ocamlstring">"%i is an integer value, %F is a float, %S\n"</span>;;</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Printf.printf str 3 4.5 <span class="ocamlstring">"string value"</span>;;</div>



<div class="pre caml-output ok">3 is an integer value, 4.5 is a float, <span class="ocamlstring">"string value"</span>
- : unit = ()</div></div>

</div>
<!--TOC section id="s:standalone-programs" 1.11â€ƒStandalone OCaml programs-->
<h2 class="section" id="s:standalone-programs"><a class="section-anchor" href="#s:standalone-programs" aria-hidden="true">ï»¿</a>1.11â€ƒStandalone OCaml programs</h2><!--SEC END --><p>All examples given so far were executed under the interactive system.
OCaml code can also be compiled separately and executed
non-interactively using the batch compilers <span class="machine"><span class="font-tt">ocamlc</span></span> and <span class="machine"><span class="font-tt">ocamlopt</span></span>.
The source code must be put in a file with extension <span class="machine"><span class="font-tt">.ml</span></span>. It
consists of a sequence of phrases, which will be evaluated at runtime
in their order of appearance in the source file. Unlike in interactive
mode, types and values are not printed automatically; the program must
call printing functions explicitly to produce some output. The <span class="machine"><span class="font-tt">;;</span></span> used
in the interactive examples is not required in
source files created for use with OCaml compilers, but can be helpful
to mark the end of a top-level expression unambiguously even when
there are syntax errors.
Here is a
sample standalone program to print the greatest common divisor
(gcd) of two numbers:
</p><pre>(* File gcd.ml *)
let rec gcd a b =
  if b = 0 then a
  else gcd b (a mod b);;

let main () =
  let a = int_of_string Sys.argv.(1) in
  let b = int_of_string Sys.argv.(2) in
  Printf.printf "%d\n" (gcd a b);
  exit 0;;
main ();;
</pre><p><span class="machine"><span class="font-tt">Sys.argv</span></span> is an array of strings containing the command-line
parameters. <span class="machine"><span class="font-tt">Sys.argv.(1)</span></span> is thus the first command-line parameter.
The program above is compiled and executed with the following shell
commands:
</p><pre>$ ocamlc -o gcd gcd.ml
$ ./gcd 6 9
3
$ ./gcd 7 11
1
</pre><p>
More complex standalone OCaml programs are typically composed of
multiple source files, and can link with precompiled libraries.
ChaptersÂ <a href="#c%3Acamlc">13</a> andÂ <a href="#c%3Anativecomp">16</a> explain how to use the
batch compilers <span class="machine"><span class="font-tt">ocamlc</span></span> and <span class="machine"><span class="font-tt">ocamlopt</span></span>. Recompilation of
multi-file OCaml projects can be automated using third-party
build systems, such as <a href="https://github.com/ocaml/dune">dune</a>.

</p>
<!--TOC chapter id="sec20" ChapterÂ 2â€ƒThe module system-->
<h1 class="chapter" id="sec20">ChapterÂ 2â€ƒThe module system</h1><!--SEC END --><p> <a id="c:moduleexamples"></a>
</p><!--NAME moduleexamples.html-->
<p>This chapter introduces the module system of OCaml.</p>
<!--TOC section id="s:module:structures" 2.1â€ƒStructures-->
<h2 class="section" id="s:module:structures"><a class="section-anchor" href="#s:module:structures" aria-hidden="true">ï»¿</a>2.1â€ƒStructures</h2><!--SEC END --><p>A primary motivation for modules is to package together related
definitions (such as the definitions of a data type and associated
operations over that type) and enforce a consistent naming scheme for
these definitions. This avoids running out of names or accidentally
confusing names. Such a package is called a <em>structure</em> and
is introduced by the <span class="machine"><span class="font-tt">struct</span></span>â€¦<span class="machine"><span class="font-tt">end</span></span> construct, which contains an
arbitrary sequence of definitions. The structure is usually given a
name with the <span class="machine"><span class="font-tt">module</span></span> binding. For instance, here is a structure
packaging together a type of priority queues and their operations:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> PrioQueue =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> priority = int
      <span class="ocamlkeyword">type</span> 'a queue = Empty | Node <span class="ocamlkeyword">of</span> priority * 'a * 'a queue * 'a queue
      <span class="ocamlkeyword">let</span> empty = Empty
      <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> insert queue prio elt =
        <span class="ocamlkeyword">match</span> queue <span class="ocamlkeyword">with</span>
          Empty -&gt; Node(prio, elt, Empty, Empty)
        | Node(p, e, left, right) -&gt;
            <span class="ocamlkeyword">if</span> prio &lt;= p
            <span class="ocamlkeyword">then</span> Node(prio, elt, insert right p e, left)
            <span class="ocamlkeyword">else</span> Node(p, e, insert right prio elt, left)
      <span class="ocamlkeyword">exception</span> Queue_is_empty
      <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> remove_top = <span class="ocamlkeyword">function</span>
          Empty -&gt; raise Queue_is_empty
        | Node(prio, elt, left, Empty) -&gt; left
        | Node(prio, elt, Empty, right) -&gt; right
        | Node(prio, elt, (Node(lprio, lelt, _, _) <span class="ocamlkeyword">as</span> left),
                          (Node(rprio, relt, _, _) <span class="ocamlkeyword">as</span> right)) -&gt;
            <span class="ocamlkeyword">if</span> lprio &lt;= rprio
            <span class="ocamlkeyword">then</span> Node(lprio, lelt, remove_top left, right)
            <span class="ocamlkeyword">else</span> Node(rprio, relt, left, remove_top right)
      <span class="ocamlkeyword">let</span> extract = <span class="ocamlkeyword">function</span>
          Empty -&gt; raise Queue_is_empty
        | Node(prio, elt, _, _) <span class="ocamlkeyword">as</span> queue -&gt; (prio, elt, remove_top queue)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> PrioQueue :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> priority = int
    <span class="ocamlkeyword">type</span> 'a queue = Empty | Node <span class="ocamlkeyword">of</span> priority * 'a * 'a queue * 'a queue
    <span class="ocamlkeyword">val</span> empty : 'a queue
    <span class="ocamlkeyword">val</span> insert : 'a queue -&gt; priority -&gt; 'a -&gt; 'a queue
    <span class="ocamlkeyword">exception</span> Queue_is_empty
    <span class="ocamlkeyword">val</span> remove_top : 'a queue -&gt; 'a queue
    <span class="ocamlkeyword">val</span> extract : 'a queue -&gt; priority * 'a * 'a queue
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Outside the structure, its components can be referred to using the
â€œdot notationâ€, that is, identifiers qualified by a structure name.
For instance, <span class="machine"><span class="font-tt">PrioQueue.insert</span></span> is the function <span class="machine"><span class="font-tt">insert</span></span> defined
inside the structure <span class="machine"><span class="font-tt">PrioQueue</span></span> and <span class="machine"><span class="font-tt">PrioQueue.queue</span></span> is the type
<span class="machine"><span class="font-tt">queue</span></span> defined in <span class="machine"><span class="font-tt">PrioQueue</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.insert PrioQueue.empty 1 <span class="ocamlstring">"hello"</span>;;</div>



<div class="pre caml-output ok">- : string PrioQueue.queue =
PrioQueue.Node (1, <span class="ocamlstring">"hello"</span>, PrioQueue.Empty, PrioQueue.Empty)</div></div>

</div><p>Another possibility is to open the module, which brings all
identifiers defined inside the module in the scope of the current
structure.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">open</span> PrioQueue;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> insert empty 1 <span class="ocamlstring">"hello"</span>;;</div>



<div class="pre caml-output ok">- : string PrioQueue.queue = Node (1, <span class="ocamlstring">"hello"</span>, Empty, Empty)</div></div>

</div><p>Opening a module enables lighter access to its components, at the
cost of making it harder to identify in which module an identifier
has been defined. In particular, opened modules can shadow
identifiers present in the current scope, potentially leading
to confusing errors:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> empty = []
  <span class="ocamlkeyword">open</span> PrioQueue;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> empty : 'a list = []</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> x = 1 :: <span class="ocamlhighlight">empty</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type 'a PrioQueue.queue
       but an expression was expected of type int list</div></div>

</div><p>A partial solution to this conundrum is to open modules locally,
making the components of the module available only in the
concerned expression. This can also make the code both easier to read
(since the open statement is closer to where it is used) and easier to refactor
(since the code fragment is more self-contained).
Two constructions are available for this purpose:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> PrioQueue <span class="ocamlkeyword">in</span>
  insert empty 1 <span class="ocamlstring">"hello"</span>;;</div>



<div class="pre caml-output ok">- : string PrioQueue.queue = Node (1, <span class="ocamlstring">"hello"</span>, Empty, Empty)</div></div>

</div><p>

and

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.(insert empty 1 <span class="ocamlstring">"hello"</span>);;</div>



<div class="pre caml-output ok">- : string PrioQueue.queue = Node (1, <span class="ocamlstring">"hello"</span>, Empty, Empty)</div></div>

</div><p>

In the second form, when the body of a local open is itself delimited
by parentheses, braces or bracket, the parentheses of the local open
can be omitted. For instance,

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.[empty] = PrioQueue.([empty]);;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.[|empty|] = PrioQueue.([|empty|]);;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.{ contents = empty } = PrioQueue.({ contents = empty });;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div><p>

becomes

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> PrioQueue.[insert empty 1 <span class="ocamlstring">"hello"</span>];;</div>



<div class="pre caml-output ok">- : string PrioQueue.queue list = [Node (1, <span class="ocamlstring">"hello"</span>, Empty, Empty)]</div></div>

</div><p>

This second form also works for patterns:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> at_most_one_element x = <span class="ocamlkeyword">match</span> x <span class="ocamlkeyword">with</span>
  | PrioQueue.( Empty| Node (_,_, Empty,Empty) ) -&gt; <span class="ocamlkeyword">true</span>
  | _ -&gt; <span class="ocamlkeyword">false</span> ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> at_most_one_element : 'a PrioQueue.queue -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>It is also possible to copy the components of a module inside
another module by using an <span class="machine"><span class="font-tt">include</span></span> statement. This can be
particularly useful to extend existing modules. As an illustration,
we could add functions that return an optional value rather than
an exception when the priority queue is empty.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> PrioQueueOpt =
  <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">include</span> PrioQueue

    <span class="ocamlkeyword">let</span> remove_top_opt x =
      <span class="ocamlkeyword">try</span> Some(remove_top x) <span class="ocamlkeyword">with</span> Queue_is_empty -&gt; None

    <span class="ocamlkeyword">let</span> extract_opt x =
      <span class="ocamlkeyword">try</span> Some(extract x) <span class="ocamlkeyword">with</span> Queue_is_empty -&gt; None
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> PrioQueueOpt :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> priority = int
    <span class="ocamlkeyword">type</span> 'a queue =
      'a PrioQueue.queue =
        Empty
      | Node <span class="ocamlkeyword">of</span> priority * 'a * 'a queue * 'a queue
    <span class="ocamlkeyword">val</span> empty : 'a queue
    <span class="ocamlkeyword">val</span> insert : 'a queue -&gt; priority -&gt; 'a -&gt; 'a queue
    <span class="ocamlkeyword">exception</span> Queue_is_empty
    <span class="ocamlkeyword">val</span> remove_top : 'a queue -&gt; 'a queue
    <span class="ocamlkeyword">val</span> extract : 'a queue -&gt; priority * 'a * 'a queue
    <span class="ocamlkeyword">val</span> remove_top_opt : 'a queue -&gt; 'a queue option
    <span class="ocamlkeyword">val</span> extract_opt : 'a queue -&gt; (priority * 'a * 'a queue) option
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:signature" 2.2â€ƒSignatures-->
<h2 class="section" id="s:signature"><a class="section-anchor" href="#s:signature" aria-hidden="true">ï»¿</a>2.2â€ƒSignatures</h2><!--SEC END --><p>Signatures are interfaces for structures. A signature specifies
which components of a structure are accessible from the outside, and
with which type. It can be used to hide some components of a structure
(e.g. local function definitions) or export some components with a
restricted type. For instance, the signature below specifies the three
priority queue operations <span class="machine"><span class="font-tt">empty</span></span>, <span class="machine"><span class="font-tt">insert</span></span> and <span class="machine"><span class="font-tt">extract</span></span>, but not the
auxiliary function <span class="machine"><span class="font-tt">remove_top</span></span>. Similarly, it makes the <span class="machine"><span class="font-tt">queue</span></span> type
abstract (by not providing its actual representation as a concrete type).

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> PRIOQUEUE =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> priority = int         <span class="ocamlcomment">(* still concrete *)</span>
      <span class="ocamlkeyword">type</span> 'a queue               <span class="ocamlcomment">(* now abstract *)</span>
      <span class="ocamlkeyword">val</span> empty : 'a queue
      <span class="ocamlkeyword">val</span> insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue
      <span class="ocamlkeyword">val</span> extract : 'a queue -&gt; int * 'a * 'a queue
      <span class="ocamlkeyword">exception</span> Queue_is_empty
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> PRIOQUEUE =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> priority = int
    <span class="ocamlkeyword">type</span> 'a queue
    <span class="ocamlkeyword">val</span> empty : 'a queue
    <span class="ocamlkeyword">val</span> insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue
    <span class="ocamlkeyword">val</span> extract : 'a queue -&gt; int * 'a * 'a queue
    <span class="ocamlkeyword">exception</span> Queue_is_empty
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Restricting the <span class="machine"><span class="font-tt">PrioQueue</span></span> structure by this signature results in
another view of the <span class="machine"><span class="font-tt">PrioQueue</span></span> structure where the <span class="machine"><span class="font-tt">remove_top</span></span>
function is not accessible and the actual representation of priority
queues is hidden:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> AbstractPrioQueue : PRIOQUEUE</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">AbstractPrioQueue.remove_top</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Unbound value AbstractPrioQueue.remove_top</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> AbstractPrioQueue.insert AbstractPrioQueue.empty 1 <span class="ocamlstring">"hello"</span>;;</div>



<div class="pre caml-output ok">- : string AbstractPrioQueue.queue = &lt;abstr&gt;</div></div>

</div><p>

The restriction can also be performed during the definition of the
structure, as in
</p><pre>module PrioQueue = (struct ... end : PRIOQUEUE);;
</pre><p>An alternate syntax is provided for the above:
</p><pre>module PrioQueue : PRIOQUEUE = struct ... end;;
</pre><p>
Like for modules, it is possible to include a signature to copy
its components inside the current signature. For instance, we
can extend the PRIOQUEUE signature with the <span class="machine"><span class="font-tt">extract_opt</span></span>
function:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> PRIOQUEUE_WITH_OPT =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">include</span> PRIOQUEUE
      <span class="ocamlkeyword">val</span> extract_opt : 'a queue -&gt; (int * 'a * 'a queue) option
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> PRIOQUEUE_WITH_OPT =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> priority = int
    <span class="ocamlkeyword">type</span> 'a queue
    <span class="ocamlkeyword">val</span> empty : 'a queue
    <span class="ocamlkeyword">val</span> insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue
    <span class="ocamlkeyword">val</span> extract : 'a queue -&gt; int * 'a * 'a queue
    <span class="ocamlkeyword">exception</span> Queue_is_empty
    <span class="ocamlkeyword">val</span> extract_opt : 'a queue -&gt; (int * 'a * 'a queue) option
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:functors" 2.3â€ƒFunctors-->
<h2 class="section" id="s:functors"><a class="section-anchor" href="#s:functors" aria-hidden="true">ï»¿</a>2.3â€ƒFunctors</h2><!--SEC END --><p>Functors are â€œfunctionsâ€ from modules to modules. Functors let you create
parameterized modules and then provide other modules as parameter(s) to get
a specific implementation. For instance, a <span class="machine"><span class="font-tt">Set</span></span> module implementing sets
as sorted lists could be parameterized to work with any module that provides
an element type and a comparison function <span class="machine"><span class="font-tt">compare</span></span> (such as <span class="machine"><span class="font-tt">OrderedString</span></span>):</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> comparison = Less | Equal | Greater;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> comparison = Less | Equal | Greater</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ORDERED_TYPE =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> t
      <span class="ocamlkeyword">val</span> compare: t -&gt; t -&gt; comparison
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ORDERED_TYPE = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">val</span> compare : t -&gt; t -&gt; comparison <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Set =
    <span class="ocamlkeyword">functor</span> (Elt: ORDERED_TYPE) -&gt;
      <span class="ocamlkeyword">struct</span>
        <span class="ocamlkeyword">type</span> element = Elt.t
        <span class="ocamlkeyword">type</span> set = element list
        <span class="ocamlkeyword">let</span> empty = []
        <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> add x s =
          <span class="ocamlkeyword">match</span> s <span class="ocamlkeyword">with</span>
            [] -&gt; [x]
          | hd::tl -&gt;
             <span class="ocamlkeyword">match</span> Elt.compare x hd <span class="ocamlkeyword">with</span>
               Equal   -&gt; s         <span class="ocamlcomment">(* x is already in s *)</span>
             | Less    -&gt; x :: s    <span class="ocamlcomment">(* x is smaller than all elements of s *)</span>
             | Greater -&gt; hd :: add x tl
        <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> member x s =
          <span class="ocamlkeyword">match</span> s <span class="ocamlkeyword">with</span>
            [] -&gt; <span class="ocamlkeyword">false</span>
          | hd::tl -&gt;
              <span class="ocamlkeyword">match</span> Elt.compare x hd <span class="ocamlkeyword">with</span>
                Equal   -&gt; <span class="ocamlkeyword">true</span>     <span class="ocamlcomment">(* x belongs to s *)</span>
              | Less    -&gt; <span class="ocamlkeyword">false</span>    <span class="ocamlcomment">(* x is smaller than all elements of s *)</span>
              | Greater -&gt; member x tl
      <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> Set :
  <span class="ocamlkeyword">functor</span> (Elt : ORDERED_TYPE) -&gt;
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> element = Elt.t
      <span class="ocamlkeyword">type</span> set = element list
      <span class="ocamlkeyword">val</span> empty : 'a list
      <span class="ocamlkeyword">val</span> add : Elt.t -&gt; Elt.t list -&gt; Elt.t list
      <span class="ocamlkeyword">val</span> member : Elt.t -&gt; Elt.t list -&gt; bool
    <span class="ocamlkeyword">end</span></div></div>

</div><p>

By applying the <span class="machine"><span class="font-tt">Set</span></span> functor to a structure implementing an ordered
type, we obtain set operations for this type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> OrderedString =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> t = string
      <span class="ocamlkeyword">let</span> compare x y = <span class="ocamlkeyword">if</span> x = y <span class="ocamlkeyword">then</span> Equal <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">if</span> x &lt; y <span class="ocamlkeyword">then</span> Less <span class="ocamlkeyword">else</span> Greater
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> OrderedString :
  <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t = string <span class="ocamlkeyword">val</span> compare : 'a -&gt; 'a -&gt; comparison <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> StringSet = Set(OrderedString);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> StringSet :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> element = OrderedString.t
    <span class="ocamlkeyword">type</span> set = element list
    <span class="ocamlkeyword">val</span> empty : 'a list
    <span class="ocamlkeyword">val</span> add : OrderedString.t -&gt; OrderedString.t list -&gt; OrderedString.t list
    <span class="ocamlkeyword">val</span> member : OrderedString.t -&gt; OrderedString.t list -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> StringSet.member <span class="ocamlstring">"bar"</span> (StringSet.add <span class="ocamlstring">"foo"</span> StringSet.empty);;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">false</span></div></div>

</div>
<!--TOC section id="s:functors-and-abstraction" 2.4â€ƒFunctors and type abstraction-->
<h2 class="section" id="s:functors-and-abstraction"><a class="section-anchor" href="#s:functors-and-abstraction" aria-hidden="true">ï»¿</a>2.4â€ƒFunctors and type abstraction</h2><!--SEC END --><p>As in the <span class="machine"><span class="font-tt">PrioQueue</span></span> example, it would be good style to hide the
actual implementation of the type <span class="machine"><span class="font-tt">set</span></span>, so that users of the
structure will not rely on sets being lists, and we can switch later
to another, more efficient representation of sets without breaking
their code. This can be achieved by restricting <span class="machine"><span class="font-tt">Set</span></span> by a suitable
functor signature:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> SETFUNCTOR =
    <span class="ocamlkeyword">functor</span> (Elt: ORDERED_TYPE) -&gt;
      <span class="ocamlkeyword">sig</span>
        <span class="ocamlkeyword">type</span> element = Elt.t      <span class="ocamlcomment">(* concrete *)</span>
        <span class="ocamlkeyword">type</span> set                  <span class="ocamlcomment">(* abstract *)</span>
        <span class="ocamlkeyword">val</span> empty : set
        <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
        <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
      <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> SETFUNCTOR =
  <span class="ocamlkeyword">functor</span> (Elt : ORDERED_TYPE) -&gt;
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> element = Elt.t
      <span class="ocamlkeyword">type</span> set
      <span class="ocamlkeyword">val</span> empty : set
      <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
      <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
    <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> AbstractSet = (Set : SETFUNCTOR);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> AbstractSet : SETFUNCTOR</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> AbstractStringSet = AbstractSet(OrderedString);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> AbstractStringSet :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> element = OrderedString.t
    <span class="ocamlkeyword">type</span> set = AbstractSet(OrderedString).set
    <span class="ocamlkeyword">val</span> empty : set
    <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
    <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> AbstractStringSet.add <span class="ocamlstring">"gee"</span> AbstractStringSet.empty;;</div>



<div class="pre caml-output ok">- : AbstractStringSet.set = &lt;abstr&gt;</div></div>

</div><p>In an attempt to write the type constraint above more elegantly,
one may wish to name the signature of the structure
returned by the functor, then use that signature in the constraint:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> SET =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> element
      <span class="ocamlkeyword">type</span> set
      <span class="ocamlkeyword">val</span> empty : set
      <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
      <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> SET =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> element
    <span class="ocamlkeyword">type</span> set
    <span class="ocamlkeyword">val</span> empty : set
    <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
    <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> WrongSet = (Set : <span class="ocamlkeyword">functor</span>(Elt: ORDERED_TYPE) -&gt; SET);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> WrongSet : <span class="ocamlkeyword">functor</span> (Elt : ORDERED_TYPE) -&gt; SET</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> WrongStringSet = WrongSet(OrderedString);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> WrongStringSet :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> element = WrongSet(OrderedString).element
    <span class="ocamlkeyword">type</span> set = WrongSet(OrderedString).set
    <span class="ocamlkeyword">val</span> empty : set
    <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
    <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> WrongStringSet.add <span class="ocamlhighlight">"gee"</span> WrongStringSet.empty ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type string but an expression was expected of type
         WrongStringSet.element = WrongSet(OrderedString).element</div></div>

</div><p>

The problem here is that <span class="machine"><span class="font-tt">SET</span></span> specifies the type <span class="machine"><span class="font-tt">element</span></span>
abstractly, so that the type equality between <span class="machine"><span class="font-tt">element</span></span> in the result
of the functor and <span class="machine"><span class="font-tt">t</span></span> in its argument is forgotten. Consequently,
<span class="machine"><span class="font-tt">WrongStringSet.element</span></span> is not the same type as <span class="machine"><span class="font-tt">string</span></span>, and the
operations of <span class="machine"><span class="font-tt">WrongStringSet</span></span> cannot be applied to strings.
As demonstrated above, it is important that the type <span class="machine"><span class="font-tt">element</span></span> in the
signature <span class="machine"><span class="font-tt">SET</span></span> be declared equal to <span class="machine"><span class="font-tt">Elt.t</span></span>; unfortunately, this is
impossible above since <span class="machine"><span class="font-tt">SET</span></span> is defined in a context where <span class="machine"><span class="font-tt">Elt</span></span> does
not exist. To overcome this difficulty, OCaml provides a
<span class="machine"><span class="font-tt">with type</span></span> construct over signatures that allows enriching a signature
with extra type equalities:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> AbstractSet2 =
    (Set : <span class="ocamlkeyword">functor</span>(Elt: ORDERED_TYPE) -&gt; (SET <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> element = Elt.t));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> AbstractSet2 :
  <span class="ocamlkeyword">functor</span> (Elt : ORDERED_TYPE) -&gt;
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> element = Elt.t
      <span class="ocamlkeyword">type</span> set
      <span class="ocamlkeyword">val</span> empty : set
      <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
      <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
    <span class="ocamlkeyword">end</span></div></div>

</div><p>As in the case of simple structures, an alternate syntax is provided
for defining functors and restricting their result:
</p><pre>module AbstractSet2(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
</pre><p>
Abstracting a type component in a functor result is a powerful
technique that provides a high degree of type safety, as we now
illustrate. Consider an ordering over character strings that is
different from the standard ordering implemented in the
<span class="machine"><span class="font-tt">OrderedString</span></span> structure. For instance, we compare strings without
distinguishing upper and lower case.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> NoCaseString =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> t = string
      <span class="ocamlkeyword">let</span> compare s1 s2 =
        OrderedString.compare (String.lowercase_ascii s1) (String.lowercase_ascii s2)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> NoCaseString :
  <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t = string <span class="ocamlkeyword">val</span> compare : string -&gt; string -&gt; comparison <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> NoCaseStringSet = AbstractSet(NoCaseString);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> NoCaseStringSet :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> element = NoCaseString.t
    <span class="ocamlkeyword">type</span> set = AbstractSet(NoCaseString).set
    <span class="ocamlkeyword">val</span> empty : set
    <span class="ocamlkeyword">val</span> add : element -&gt; set -&gt; set
    <span class="ocamlkeyword">val</span> member : element -&gt; set -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> NoCaseStringSet.add <span class="ocamlstring">"FOO"</span> <span class="ocamlhighlight">AbstractStringSet.empty</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type
         AbstractStringSet.set = AbstractSet(OrderedString).set
       but an expression was expected of type
         NoCaseStringSet.set = AbstractSet(NoCaseString).set</div></div>

</div><p>

Note that the two types <span class="machine"><span class="font-tt">AbstractStringSet.set</span></span> and
<span class="machine"><span class="font-tt">NoCaseStringSet.set</span></span> are not compatible, and values of these
two types do not match. This is the correct behavior: even though both
set types contain elements of the same type (strings), they are built
upon different orderings of that type, and different invariants need
to be maintained by the operations (being strictly increasing for the
standard ordering and for the case-insensitive ordering). Applying
operations from <span class="machine"><span class="font-tt">AbstractStringSet</span></span> to values of type
<span class="machine"><span class="font-tt">NoCaseStringSet.set</span></span> could give incorrect results, or build
lists that violate the invariants of <span class="machine"><span class="font-tt">NoCaseStringSet</span></span>.</p>
<!--TOC section id="s:separate-compilation" 2.5â€ƒModules and separate compilation-->
<h2 class="section" id="s:separate-compilation"><a class="section-anchor" href="#s:separate-compilation" aria-hidden="true">ï»¿</a>2.5â€ƒModules and separate compilation</h2><!--SEC END --><p>All examples of modules so far have been given in the context of the
interactive system. However, modules are most useful for large,
batch-compiled programs. For these programs, it is a practical
necessity to split the source into several files, called compilation
units, that can be compiled separately, thus minimizing recompilation
after changes.</p><p>In OCaml, compilation units are special cases of structures
and signatures, and the relationship between the units can be
explained easily in terms of the module system. A compilation unit <span class="font-it">A</span>
comprises two files:
</p><ul class="itemize"><li class="li-itemize">the implementation file <span class="font-it">A</span><span class="machine"><span class="font-tt">.ml</span></span>, which contains a sequence
of definitions, analogous to the inside of a <span class="machine"><span class="font-tt">struct</span></span>â€¦<span class="machine"><span class="font-tt">end</span></span>
construct;
</li><li class="li-itemize">the interface file <span class="font-it">A</span><span class="machine"><span class="font-tt">.mli</span></span>, which contains a sequence of
specifications, analogous to the inside of a <span class="machine"><span class="font-tt">sig</span></span>â€¦<span class="machine"><span class="font-tt">end</span></span>
construct.
</li></ul><p>
These two files together define a structure named <span class="font-it">A</span> as if
the following definition was entered at top-level:
</p><pre>
module <span class="font-it">A</span>: sig (* contents of file <span class="font-it">A</span>.mli *) end
        = struct (* contents of file <span class="font-it">A</span>.ml *) end;;
</pre><p>
The files that define the compilation units can be compiled separately
using the <span class="machine"><span class="font-tt">ocamlc -c</span></span> command (the <span class="machine"><span class="font-tt">-c</span></span> option means â€œcompile only, do
not try to linkâ€); this produces compiled interface files (with
extension <span class="machine"><span class="font-tt">.cmi</span></span>) and compiled object code files (with extension
<span class="machine"><span class="font-tt">.cmo</span></span>). When all units have been compiled, their <span class="machine"><span class="font-tt">.cmo</span></span> files are
linked together using the <span class="machine"><span class="font-tt">ocamlc</span></span> command. For instance, the following
commands compile and link a program composed of two compilation units
<span class="machine"><span class="font-tt">Aux</span></span> and <span class="machine"><span class="font-tt">Main</span></span>:
</p><pre>$ ocamlc -c Aux.mli                     # produces aux.cmi
$ ocamlc -c Aux.ml                      # produces aux.cmo
$ ocamlc -c Main.mli                    # produces main.cmi
$ ocamlc -c Main.ml                     # produces main.cmo
$ ocamlc -o theprogram Aux.cmo Main.cmo
</pre><p>The program behaves exactly as if the following phrases were entered
at top-level:
</p><pre>
module Aux: sig (* contents of Aux.mli *) end
          = struct (* contents of Aux.ml *) end;;
module Main: sig (* contents of Main.mli *) end
           = struct (* contents of Main.ml *) end;;
</pre><p>
In particular, <span class="machine"><span class="font-tt">Main</span></span> can refer to <span class="machine"><span class="font-tt">Aux</span></span>: the definitions and
declarations contained in <span class="machine"><span class="font-tt">Main.ml</span></span> and <span class="machine"><span class="font-tt">Main.mli</span></span> can refer to
definition in <span class="machine"><span class="font-tt">Aux.ml</span></span>, using the <span class="machine"><span class="font-tt">Aux.</span></span><span class="font-it">ident</span> notation, provided
these definitions are exported in <span class="machine"><span class="font-tt">Aux.mli</span></span>.</p><p>The order in which the <span class="machine"><span class="font-tt">.cmo</span></span> files are given to <span class="machine"><span class="font-tt">ocamlc</span></span> during the
linking phase determines the order in which the module definitions
occur. Hence, in the example above, <span class="machine"><span class="font-tt">Aux</span></span> appears first and <span class="machine"><span class="font-tt">Main</span></span> can
refer to it, but <span class="machine"><span class="font-tt">Aux</span></span> cannot refer to <span class="machine"><span class="font-tt">Main</span></span>.</p><p>Note that only top-level structures can be mapped to
separately-compiled files, but neither functors nor module types.
However, all module-class objects can appear as components of a
structure, so the solution is to put the functor or module type
inside a structure, which can then be mapped to a file.

</p>
<!--TOC chapter id="sec26" ChapterÂ 3â€ƒObjects in OCaml-->
<h1 class="chapter" id="sec26">ChapterÂ 3â€ƒObjects in OCaml</h1><!--SEC END --><p>
<a id="c:objectexamples"></a>
</p><!--NAME objectexamples.html-->
<p>
<span class="font-it">(Chapter written by JÃ©rÃ´me Vouillon, Didier RÃ©my and Jacques Garrigue)</span></p><p><br>
<br>
</p><p>This chapter gives an overview of the object-oriented features of
OCaml.</p><p>Note that the relationship between object, class and type in OCaml is
different than in mainstream object-oriented languages such as Java and
C++, so you shouldnâ€™t assume that similar keywords mean the same thing.
Object-oriented features are used much less frequently in OCaml than
in those languages. OCaml has alternatives that are often more appropriate,
such as modules and functors. Indeed, many OCaml programs do not use objects
at all.</p>
<!--TOC section id="s:classes-and-objects" 3.1â€ƒClasses and objects-->
<h2 class="section" id="s:classes-and-objects"><a class="section-anchor" href="#s:classes-and-objects" aria-hidden="true">ï»¿</a>3.1â€ƒClasses and objects</h2><!--SEC END --><p>The class <span class="machine"><span class="font-tt">point</span></span> below defines one instance variable <span class="machine"><span class="font-tt">x</span></span> and two methods
<span class="machine"><span class="font-tt">get_x</span></span> and <span class="machine"><span class="font-tt">move</span></span>. The initial value of the instance variable is <span class="machine"><span class="font-tt">0</span></span>.
The variable <span class="machine"><span class="font-tt">x</span></span> is declared mutable, so the method <span class="machine"><span class="font-tt">move</span></span> can change
its value.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = 0
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">method</span> move : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>

</div><p>We now create a new point <span class="machine"><span class="font-tt">p</span></span>, instance of the <span class="machine"><span class="font-tt">point</span></span> class.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> point;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : point = &lt;obj&gt;</div></div>

</div><p>

Note that the type of <span class="machine"><span class="font-tt">p</span></span> is <span class="machine"><span class="font-tt">point</span></span>. This is an abbreviation
automatically defined by the class definition above. It stands for the
object type <span class="machine"><span class="font-tt">&lt;get_x : int; move : int -&gt; unit&gt;</span></span>, listing the methods
of class <span class="machine"><span class="font-tt">point</span></span> along with their types.</p><p>We now invoke some methods of <span class="machine"><span class="font-tt">p</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 0</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#move 3;;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 3</div></div>

</div><p>The evaluation of the body of a class only takes place at object
creation time. Therefore, in the following example, the instance
variable <span class="machine"><span class="font-tt">x</span></span> is initialized to different values for two different
objects.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> x0 = <span class="ocamlkeyword">ref</span> 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x0 : int <span class="ocamlkeyword">ref</span> = {contents = 0}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = incr x0; !x0
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">method</span> move : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">new</span> point#get_x;;</div>



<div class="pre caml-output ok">- : int = 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">new</span> point#get_x;;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div><p>The class <span class="machine"><span class="font-tt">point</span></span> can also be abstracted over the initial values of
the <span class="machine"><span class="font-tt">x</span></span> coordinate.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point = <span class="ocamlkeyword">fun</span> x_init -&gt;
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  int -&gt;
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">method</span> move : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>

</div><p>

Like in function definitions, the definition above can be
abbreviated as:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  int -&gt;
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">method</span> move : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>

</div><p>

An instance of the class <span class="machine"><span class="font-tt">point</span></span> is now a function that expects an
initial parameter to create a point object:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">new</span> point;;</div>



<div class="pre caml-output ok">- : int -&gt; point = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> point 7;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : point = &lt;obj&gt;</div></div>

</div><p>

The parameter <span class="machine"><span class="font-tt">x_init</span></span> is, of course, visible in the whole body of the
definition, including methods. For instance, the method <span class="machine"><span class="font-tt">get_offset</span></span>
in the class below returns the position of the object relative to its
initial position.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> get_offset = x - x_init
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Expressions can be evaluated and bound before defining the object body
of the class. This is useful to enforce invariants. For instance,
points can be automatically adjusted to the nearest point on a grid,
as follows:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> adjusted_point x_init =
    <span class="ocamlkeyword">let</span> origin = (x_init / 10) * 10 <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = origin
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> get_offset = x - origin
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> adjusted_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

(One could also raise an exception if the <span class="machine"><span class="font-tt">x_init</span></span> coordinate is not
on the grid.) In fact, the same effect could be obtained here by
calling the definition of class <span class="machine"><span class="font-tt">point</span></span> with the value of the
<span class="machine"><span class="font-tt">origin</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> adjusted_point x_init =  point ((x_init / 10) * 10);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> adjusted_point : int -&gt; point</div></div>

</div><p>

An alternate solution would have been to define the adjustment in
a special allocation function:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> new_adjusted_point x_init = <span class="ocamlkeyword">new</span> point ((x_init / 10) * 10);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> new_adjusted_point : int -&gt; point = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

However, the former pattern is generally more appropriate, since
the code for adjustment is part of the definition of the class and will be
inherited.</p><p>This ability provides class constructors as can be found in other
languages. Several constructors can be defined this way to build objects of
the same class but with different initialization patterns; an
alternative is to use initializers, as described below in
sectionÂ <a href="#s%3Ainitializers">3.4</a>.</p>
<!--TOC section id="s:immediate-objects" 3.2â€ƒImmediate objects-->
<h2 class="section" id="s:immediate-objects"><a class="section-anchor" href="#s:immediate-objects" aria-hidden="true">ï»¿</a>3.2â€ƒImmediate objects</h2><!--SEC END --><p>There is another, more direct way to create an object: create it
without going through a class.</p><p>The syntax is exactly the same as for class expressions, but the
result is a single object rather than a class. All the constructs
described in the rest of this section also apply to immediate objects.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = 0
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : &lt; get_x : int; move : int -&gt; unit &gt; = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 0</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#move 3;;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 3</div></div>

</div><p>Unlike classes, which cannot be defined inside an expression,
immediate objects can appear anywhere, using variables from their
environment.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> minmax x y =
    <span class="ocamlkeyword">if</span> x &lt; y <span class="ocamlkeyword">then</span> <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> min = x <span class="ocamlkeyword">method</span> max = y <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> min = y <span class="ocamlkeyword">method</span> max = x <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> minmax : 'a -&gt; 'a -&gt; &lt; max : 'a; min : 'a &gt; = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Immediate objects have two weaknesses compared to classes: their types
are not abbreviated, and you cannot inherit from them. But these two
weaknesses can be advantages in some situations, as we will see
in sectionsÂ <a href="#s%3Areference-to-self">3.3</a> andÂ <a href="#s%3Aparameterized-classes">3.10</a>.</p>
<!--TOC section id="s:reference-to-self" 3.3â€ƒReference to self-->
<h2 class="section" id="s:reference-to-self"><a class="section-anchor" href="#s:reference-to-self" aria-hidden="true">ï»¿</a>3.3â€ƒReference to self</h2><!--SEC END --><p>A method or an initializer can invoke methods on self (that is,
the current object). For that, self must be explicitly bound, here to
the variable <span class="machine"><span class="font-tt">s</span></span> (<span class="machine"><span class="font-tt">s</span></span> could be any identifier, even though we will
often choose the name <span class="machine"><span class="font-tt">self</span></span>.)

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> printable_point x_init =
    <span class="ocamlkeyword">object</span> (s)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
      <span class="ocamlkeyword">method</span> print = print_int s#get_x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> printable_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> print : unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> printable_point 7;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : printable_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#print;;</div>



<div class="pre caml-output ok">7- : unit = ()</div></div>

</div><p>

Dynamically, the variable <span class="machine"><span class="font-tt">s</span></span> is bound at the invocation of a method. In
particular, when the class <span class="machine"><span class="font-tt">printable_point</span></span> is inherited, the variable
<span class="machine"><span class="font-tt">s</span></span> will be correctly bound to the object of the subclass.</p><p>A common problem with self is that, as its type may be extended in
subclasses, you cannot fix it in advance. Here is a simple example.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ints = <span class="ocamlkeyword">ref</span> [];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ints : '_weak1 list <span class="ocamlkeyword">ref</span> = {contents = []}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> my_int =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">method</span> n = 1
      <span class="ocamlkeyword">method</span> register = ints := <span class="ocamlhighlight">self</span> :: !ints
    <span class="ocamlkeyword">end</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type &lt; n : int; register : 'a; .. &gt;
       but an expression was expected of type 'weak1
       Self type cannot escape its class</div></div>

</div><p>

You can ignore the first two lines of the error message. What matters
is the last one: putting self into an external reference would make it
impossible to extend it through inheritance.
We will see in sectionÂ <a href="#s%3Ausing-coercions">3.12</a> a workaround to this
problem.
Note however that, since immediate objects are not extensible, the
problem does not occur with them.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> my_int =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">method</span> n = 1
      <span class="ocamlkeyword">method</span> register = ints := self :: !ints
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> my_int : &lt; n : int; register : unit &gt; = &lt;obj&gt;</div></div>

</div>
<!--TOC section id="s:initializers" 3.4â€ƒInitializers-->
<h2 class="section" id="s:initializers"><a class="section-anchor" href="#s:initializers" aria-hidden="true">ï»¿</a>3.4â€ƒInitializers</h2><!--SEC END --><p>Let-bindings within class definitions are evaluated before the object
is constructed. It is also possible to evaluate an expression
immediately after the object has been built. Such code is written as
an anonymous hidden method called an initializer. Therefore, it can
access self and the instance variables.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> printable_point x_init =
    <span class="ocamlkeyword">let</span> origin = (x_init / 10) * 10 <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = origin
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
      <span class="ocamlkeyword">method</span> print = print_int self#get_x
      <span class="ocamlkeyword">initializer</span> print_string <span class="ocamlstring">"new point at "</span>; self#print; print_newline ()
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> printable_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> print : unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> printable_point 17;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">new</span> point at 10
<span class="ocamlkeyword">val</span> p : printable_point = &lt;obj&gt;</div></div>

</div><p>

Initializers cannot be overridden. On the contrary, all initializers are
evaluated sequentially.
Initializers are particularly useful to enforce invariants.
Another example can be seen in sectionÂ <a href="#s%3Aextended-bank-accounts">8.1</a>.</p>
<!--TOC section id="s:virtual-methods" 3.5â€ƒVirtual methods-->
<h2 class="section" id="s:virtual-methods"><a class="section-anchor" href="#s:virtual-methods" aria-hidden="true">ï»¿</a>3.5â€ƒVirtual methods</h2><!--SEC END --><p>It is possible to declare a method without actually defining it, using
the keyword <span class="machine"><span class="font-tt">virtual</span></span>. This method will be provided later in
subclasses. A class containing virtual methods must be flagged
<span class="machine"><span class="font-tt">virtual</span></span>, and cannot be instantiated (that is, no object of this class
can be created). It still defines type abbreviations (treating virtual methods
as other methods.)

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> abstract_point x_init =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> get_x : int
      <span class="ocamlkeyword">method</span> get_offset = self#get_x - x_init
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> move : int -&gt; unit
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> abstract_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> get_x : int
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> abstract_point x_init
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>Instance variables can also be declared as virtual, with the same effect
as with methods.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> abstract_point2 =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> <span class="ocamlkeyword">virtual</span> x : int
      <span class="ocamlkeyword">method</span> move d = x &lt;- x + d
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> abstract_point2 :
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> <span class="ocamlkeyword">virtual</span> x : int <span class="ocamlkeyword">method</span> move : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point2 x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> abstract_point2
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_offset = x - x_init
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point2 :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:private-methods" 3.6â€ƒPrivate methods-->
<h2 class="section" id="s:private-methods"><a class="section-anchor" href="#s:private-methods" aria-hidden="true">ï»¿</a>3.6â€ƒPrivate methods</h2><!--SEC END --><p>Private methods are methods that do not appear in object interfaces.
They can only be invoked from other methods of the same object.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> restricted_point x_init =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> move d = x &lt;- x + d
      <span class="ocamlkeyword">method</span> bump = self#move 1
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> restricted_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> bump : unit
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> restricted_point 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : restricted_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">p</span>#move 10 ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type restricted_point
       It has no method move</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#bump;;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>

</div><p>

Note that this is not the same thing as private and protected methods
in Java or C++, which can be called from other objects of the same
class. This is a direct consequence of the independence between types
and classes in OCaml: two unrelated classes may produce
objects of the same type, and there is no way at the type level to
ensure that an object comes from a specific class. However a possible
encoding of friend methods is given in sectionÂ <a href="#s%3Afriends">3.17</a>.</p><p>Private methods are inherited (they are by default visible in subclasses),
unless they are hidden by signature matching, as described below.</p><p>Private methods can be made public in a subclass.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point_again x =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> restricted_point x
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> move : _
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point_again :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> bump : unit
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

The annotation <span class="machine"><span class="font-tt">virtual</span></span> here is only used to mention a method without
providing its definition. Since we didnâ€™t add the <span class="machine"><span class="font-tt">private</span></span>
annotation, this makes the method public, keeping the original
definition.</p><p>An alternative definition is

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point_again x =
    <span class="ocamlkeyword">object</span> (self : &lt; move : _; ..&gt; )
      <span class="ocamlkeyword">inherit</span> restricted_point x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point_again :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> bump : unit
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

The constraint on selfâ€™s type is requiring a public <span class="machine"><span class="font-tt">move</span></span> method, and
this is sufficient to override <span class="machine"><span class="font-tt">private</span></span>.</p><p>One could think that a private method should remain private in a subclass.
However, since the method is visible in a subclass, it is always possible
to pick its code and define a method of the same name that runs that
code, so yet another (heavier) solution would be:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> point_again x =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> restricted_point x <span class="ocamlkeyword">as</span> super
      <span class="ocamlkeyword">method</span> move = super#move
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> point_again :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> bump : unit
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>Of course, private methods can also be virtual. Then, the keywords must
appear in this order: <span class="machine"><span class="font-tt">method private virtual</span></span>.</p>
<!--TOC section id="s:class-interfaces" 3.7â€ƒClass interfaces-->
<h2 class="section" id="s:class-interfaces"><a class="section-anchor" href="#s:class-interfaces" aria-hidden="true">ï»¿</a>3.7â€ƒClass interfaces</h2><!--SEC END --><p>Class interfaces are inferred from class definitions. They may also
be defined directly and used to restrict the type of a class. Like class
declarations, they also define a new type abbreviation.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> restricted_point_type =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> get_x : int
      <span class="ocamlkeyword">method</span> bump : unit
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> restricted_point_type =
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> bump : unit <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">fun</span> (x : restricted_point_type) -&gt; x;;</div>



<div class="pre caml-output ok">- : restricted_point_type -&gt; restricted_point_type = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

In addition to program documentation, class interfaces can be used to
constrain the type of a class. Both concrete instance variables and concrete
private methods can be hidden by a class type constraint. Public
methods and virtual members, however, cannot.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> restricted_point' x = (restricted_point x : restricted_point_type);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> restricted_point' : int -&gt; restricted_point_type</div></div>

</div><p>

Or, equivalently:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> restricted_point' = (restricted_point : int -&gt; restricted_point_type);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> restricted_point' : int -&gt; restricted_point_type</div></div>

</div><p>

The interface of a class can also be specified in a module
signature, and used to restrict the inferred signature of a module.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> POINT = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">class</span> restricted_point' : int -&gt;
      <span class="ocamlkeyword">object</span>
        <span class="ocamlkeyword">method</span> get_x : int
        <span class="ocamlkeyword">method</span> bump : unit
      <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> POINT =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">class</span> restricted_point' :
      int -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> bump : unit <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Point : POINT = <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">class</span> restricted_point' = restricted_point
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> Point : POINT</div></div>

</div>
<!--TOC section id="s:inheritance" 3.8â€ƒInheritance-->
<h2 class="section" id="s:inheritance"><a class="section-anchor" href="#s:inheritance" aria-hidden="true">ï»¿</a>3.8â€ƒInheritance</h2><!--SEC END --><p>We illustrate inheritance by defining a class of colored points that
inherits from the class of points. This class has all instance
variables and all methods of class <span class="machine"><span class="font-tt">point</span></span>, plus a new instance
variable <span class="machine"><span class="font-tt">c</span></span> and a new method <span class="machine"><span class="font-tt">color</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> colored_point x (c : string) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> point x
      <span class="ocamlkeyword">val</span> c = c
      <span class="ocamlkeyword">method</span> color = c
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> colored_point :
  int -&gt;
  string -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> c : string
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> color : string
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p' = <span class="ocamlkeyword">new</span> colored_point 5 <span class="ocamlstring">"red"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p' : colored_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p'#get_x, p'#color;;</div>



<div class="pre caml-output ok">- : int * string = (5, <span class="ocamlstring">"red"</span>)</div></div>

</div><p>

A point and a colored point have incompatible types, since a point has
no method <span class="machine"><span class="font-tt">color</span></span>. However, the function <span class="machine"><span class="font-tt">get_x</span></span> below is a generic
function applying method <span class="machine"><span class="font-tt">get_x</span></span> to any object <span class="machine"><span class="font-tt">p</span></span> that has this
method (and possibly some others, which are represented by an ellipsis
in the type). Thus, it applies to both points and colored points.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> get_succ_x p = p#get_x + 1;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> get_succ_x : &lt; get_x : int; .. &gt; -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> get_succ_x p + get_succ_x p';;</div>



<div class="pre caml-output ok">- : int = 8</div></div>

</div><p>

Methods need not be declared previously, as shown by the example:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> set_x p = p#set_x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> set_x : &lt; set_x : 'a; .. &gt; -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> incr p = set_x p (get_succ_x p);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> incr : &lt; get_x : int; set_x : int -&gt; 'a; .. &gt; -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:multiple-inheritance" 3.9â€ƒMultiple inheritance-->
<h2 class="section" id="s:multiple-inheritance"><a class="section-anchor" href="#s:multiple-inheritance" aria-hidden="true">ï»¿</a>3.9â€ƒMultiple inheritance</h2><!--SEC END --><p>Multiple inheritance is allowed. Only the last definition of a method
is kept: the redefinition in a subclass of a method that was visible in
the parent class overrides the definition in the parent class.
Previous definitions of a method can be reused by binding the related
ancestor. Below, <span class="machine"><span class="font-tt">super</span></span> is bound to the ancestor <span class="machine"><span class="font-tt">printable_point</span></span>.
The name <span class="machine"><span class="font-tt">super</span></span> is a pseudo value identifier that can only be used to
invoke a super-class method, as in <span class="machine"><span class="font-tt">super#print</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> printable_colored_point y c =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">val</span> c = c
      <span class="ocamlkeyword">method</span> color = c
      <span class="ocamlkeyword">inherit</span> printable_point y <span class="ocamlkeyword">as</span> super
      <span class="ocamlkeyword">method</span>! print =
        print_string <span class="ocamlstring">"("</span>;
        super#print;
        print_string <span class="ocamlstring">", "</span>;
        print_string (self#color);
        print_string <span class="ocamlstring">")"</span>
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> printable_colored_point :
  int -&gt;
  string -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> c : string
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> color : string
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> print : unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p' = <span class="ocamlkeyword">new</span> printable_colored_point 17 <span class="ocamlstring">"red"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">new</span> point at (10, red)
<span class="ocamlkeyword">val</span> p' : printable_colored_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p'#print;;</div>



<div class="pre caml-output ok">(10, red)- : unit = ()</div></div>

</div><p>

A private method that has been hidden in the parent class is no longer
visible, and is thus not overridden. Since initializers are treated as
private methods, all initializers along the class hierarchy are evaluated,
in the order they are introduced.</p><p>Note that for clarityâ€™s sake, the method <span class="machine"><span class="font-tt">print</span></span> is explicitly marked as
overriding another definition by annotating the <span class="machine"><span class="font-tt">method</span></span> keyword with
an exclamation mark <span class="machine"><span class="font-tt">!</span></span>. If the method <span class="machine"><span class="font-tt">print</span></span> were not overriding the
<span class="machine"><span class="font-tt">print</span></span> method of <span class="machine"><span class="font-tt">printable_point</span></span>, the compiler would raise an error:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">object</span>
      <span class="ocamlhighlight">method! m = ()</span>
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: The method `m' has no previous definition</div></div>

</div><p>This explicit overriding annotation also works
for <span class="machine"><span class="font-tt">val</span></span> and <span class="machine"><span class="font-tt">inherit</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> another_printable_colored_point y c c' =
    <span class="ocamlkeyword">object</span> (self)
    <span class="ocamlkeyword">inherit</span> printable_point y
    <span class="ocamlkeyword">inherit</span>! printable_colored_point y c
    <span class="ocamlkeyword">val</span>! c = c'
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> another_printable_colored_point :
  int -&gt;
  string -&gt;
  string -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> c : string
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> color : string
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> print : unit
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:parameterized-classes" 3.10â€ƒParameterized classes-->
<h2 class="section" id="s:parameterized-classes"><a class="section-anchor" href="#s:parameterized-classes" aria-hidden="true">ï»¿</a>3.10â€ƒParameterized classes</h2><!--SEC END --><p>Reference cells can be implemented as objects.
The naive definition fails to typecheck:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">class oref x_init =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Some type variables are unbound in this type:
         class oref :
           'a -&gt;
           object
             val mutable x : 'a
             method get : 'a
             method set : 'a -&gt; unit
           end
       The method get has type 'a where 'a is unbound</div></div>

</div><p>

The reason is that at least one of the methods has a polymorphic type
(here, the type of the value stored in the reference cell), thus
either the class should be parametric, or the method type should be
constrained to a monomorphic type. A monomorphic instance of the class could
be defined by:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> oref (x_init:int) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get = x
      <span class="ocamlkeyword">method</span> set y = x &lt;- y
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> oref :
  int -&gt;
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int <span class="ocamlkeyword">method</span> get : int <span class="ocamlkeyword">method</span> set : int -&gt; unit <span class="ocamlkeyword">end</span></div></div>

</div><p>

Note that since immediate objects do not define a class type, they have
no such restriction.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> new_oref x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init
      <span class="ocamlkeyword">method</span> get = x
      <span class="ocamlkeyword">method</span> set y = x &lt;- y
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> new_oref : 'a -&gt; &lt; get : 'a; set : 'a -&gt; unit &gt; = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

On the other hand, a class for polymorphic references must explicitly
list the type parameters in its declaration. Class type parameters are
listed between <span class="machine"><span class="font-tt">[</span></span> and <span class="machine"><span class="font-tt">]</span></span>. The type parameters must also be
bound somewhere in the class body by a type constraint.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] oref x_init =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = (x_init : 'a)
      <span class="ocamlkeyword">method</span> get = x
      <span class="ocamlkeyword">method</span> set y = x &lt;- y
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] oref :
  'a -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : 'a <span class="ocamlkeyword">method</span> get : 'a <span class="ocamlkeyword">method</span> set : 'a -&gt; unit <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">new</span> oref 1 <span class="ocamlkeyword">in</span> r#set 2; (r#get);;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div><p>

The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the <span class="machine"><span class="font-tt">constraint</span></span> clause.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] oref_succ (x_init:'a) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x = x_init + 1
      <span class="ocamlkeyword">method</span> get = x
      <span class="ocamlkeyword">method</span> set y = x &lt;- y
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] oref_succ :
  'a -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = int
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> get : int
    <span class="ocamlkeyword">method</span> set : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Let us consider a more complex example: define a circle, whose center
may be any kind of point. We put an additional type
constraint in method <span class="machine"><span class="font-tt">move</span></span>, since no free variables must remain
unaccounted for by the class type parameters.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] circle (c : 'a) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> center = c
      <span class="ocamlkeyword">method</span> center = center
      <span class="ocamlkeyword">method</span> set_center c = center &lt;- c
      <span class="ocamlkeyword">method</span> move = (center#move : int -&gt; unit)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] circle :
  'a -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = &lt; move : int -&gt; unit; .. &gt;
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> center : 'a
    <span class="ocamlkeyword">method</span> center : 'a
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> set_center : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

An alternate definition of <span class="machine"><span class="font-tt">circle</span></span>, using a <span class="machine"><span class="font-tt">constraint</span></span> clause in
the class definition, is shown below. The type <span class="machine"><span class="font-tt">#point</span></span> used below in
the <span class="machine"><span class="font-tt">constraint</span></span> clause is an abbreviation produced by the definition
of class <span class="machine"><span class="font-tt">point</span></span>. This abbreviation unifies with the type of any
object belonging to a subclass of class <span class="machine"><span class="font-tt">point</span></span>. It actually expands to
<span class="machine"><span class="font-tt">&lt; get_x : int; move : int -&gt; unit; .. &gt;</span></span>. This leads to the following
alternate definition of <span class="machine"><span class="font-tt">circle</span></span>, which has slightly stronger
constraints on its argument, as we now expect <span class="machine"><span class="font-tt">center</span></span> to have a
method <span class="machine"><span class="font-tt">get_x</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] circle (c : 'a) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">constraint</span> 'a = #point
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> center = c
      <span class="ocamlkeyword">method</span> center = center
      <span class="ocamlkeyword">method</span> set_center c = center &lt;- c
      <span class="ocamlkeyword">method</span> move = center#move
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] circle :
  'a -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = #point
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> center : 'a
    <span class="ocamlkeyword">method</span> center : 'a
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> set_center : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

The class <span class="machine"><span class="font-tt">colored_circle</span></span> is a specialized version of class
<span class="machine"><span class="font-tt">circle</span></span> that requires the type of the center to unify with
<span class="machine"><span class="font-tt">#colored_point</span></span>, and adds a method <span class="machine"><span class="font-tt">color</span></span>. Note that when specializing a
parameterized class, the instance of type parameter must always be
explicitly given. It is again written between <span class="machine"><span class="font-tt">[</span></span> and <span class="machine"><span class="font-tt">]</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] colored_circle c =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">constraint</span> 'a = #colored_point
      <span class="ocamlkeyword">inherit</span> ['a] circle c
      <span class="ocamlkeyword">method</span> color = center#color
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] colored_circle :
  'a -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = #colored_point
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> center : 'a
    <span class="ocamlkeyword">method</span> center : 'a
    <span class="ocamlkeyword">method</span> color : string
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> set_center : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:polymorphic-methods" 3.11â€ƒPolymorphic methods-->
<h2 class="section" id="s:polymorphic-methods"><a class="section-anchor" href="#s:polymorphic-methods" aria-hidden="true">ï»¿</a>3.11â€ƒPolymorphic methods</h2><!--SEC END --><p>While parameterized classes may be polymorphic in their contents, they
are not enough to allow polymorphism of method use.</p><p>A classical example is defining an iterator.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.fold_left;;</div>



<div class="pre caml-output ok">- : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] intlist (l : int list) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> empty = (l = [])
      <span class="ocamlkeyword">method</span> fold f (accu : 'a) = List.fold_left f accu l
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] intlist :
  int list -&gt;
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> empty : bool <span class="ocamlkeyword">method</span> fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a <span class="ocamlkeyword">end</span></div></div>

</div><p>

At first look, we seem to have a polymorphic iterator, however this
does not work in practice.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">new</span> intlist [1; 2; 3];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : '_weak2 intlist = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> l#fold (<span class="ocamlkeyword">fun</span> x y -&gt; x+y) 0;;</div>



<div class="pre caml-output ok">- : int = 6</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> l;;</div>



<div class="pre caml-output ok">- : int intlist = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> l#fold (<span class="ocamlkeyword">fun</span> s x -&gt; <span class="ocamlhighlight">s</span> ^ Int.to_string x ^ <span class="ocamlstring">" "</span>) <span class="ocamlstring">""</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type int but an expression was expected of type
         string</div></div>

</div><p>

Our iterator works, as shows its first use for summation. However,
since objects themselves are not polymorphic (only their constructors
are), using the <span class="machine"><span class="font-tt">fold</span></span> method fixes its type for this individual object.
Our next attempt to use it as a string iterator fails.</p><p>The problem here is that quantification was wrongly located: it is
not the class we want to be polymorphic, but the <span class="machine"><span class="font-tt">fold</span></span> method.
This can be achieved by giving an explicitly polymorphic type in the
method definition.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> intlist (l : int list) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> empty = (l = [])
      <span class="ocamlkeyword">method</span> fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a =
        <span class="ocamlkeyword">fun</span> f accu -&gt; List.fold_left f accu l
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> intlist :
  int list -&gt;
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> empty : bool <span class="ocamlkeyword">method</span> fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">new</span> intlist [1; 2; 3];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : intlist = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> l#fold (<span class="ocamlkeyword">fun</span> x y -&gt; x+y) 0;;</div>



<div class="pre caml-output ok">- : int = 6</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> l#fold (<span class="ocamlkeyword">fun</span> s x -&gt; s ^ Int.to_string x ^ <span class="ocamlstring">" "</span>) <span class="ocamlstring">""</span>;;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"1 2 3 "</span></div></div>

</div><p>

As you can see in the class type shown by the compiler, while
polymorphic method types must be fully explicit in class definitions
(appearing immediately after the method name), quantified type
variables can be left implicit in class descriptions. Why require types
to be explicit? The problem is that <span class="machine"><span class="font-tt">(int -&gt; int -&gt; int) -&gt; int -&gt; int</span></span> would also be a valid type for <span class="machine"><span class="font-tt">fold</span></span>, and it happens to be
incompatible with the polymorphic type we gave (automatic
instantiation only works for toplevel types variables, not for inner
quantifiers, where it becomes an undecidable problem.) So the compiler
cannot choose between those two types, and must be helped.</p><p>However, the type can be completely omitted in the class definition if
it is already known, through inheritance or type constraints on self.
Here is an example of method overriding.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> intlist_rev l =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> intlist l
      <span class="ocamlkeyword">method</span>! fold f accu = List.fold_left f accu (List.rev l)
    <span class="ocamlkeyword">end</span>;;</div></div>

</div><p>

The following idiom separates description and definition.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> ['a] iterator =
    <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b <span class="ocamlkeyword">end</span>;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> intlist' l =
    <span class="ocamlkeyword">object</span> (self : int #iterator)
      <span class="ocamlkeyword">method</span> empty = (l = [])
      <span class="ocamlkeyword">method</span> fold f accu = List.fold_left f accu l
    <span class="ocamlkeyword">end</span>;;</div></div>

</div><p>

Note here the <span class="machine"><span class="font-tt">(self : int #iterator)</span></span> idiom, which ensures that this
object implements the interface <span class="machine"><span class="font-tt">iterator</span></span>.</p><p>Polymorphic methods are called in exactly the same way as normal
methods, but you should be aware of some limitations of type
inference. Namely, a polymorphic method can only be called if its
type is known at the call site. Otherwise, the method will be assumed
to be monomorphic, and given an incompatible type.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sum lst = lst#fold (<span class="ocamlkeyword">fun</span> x y -&gt; x+y) 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'a; .. &gt; -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> sum <span class="ocamlhighlight">l</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type intlist
       but an expression was expected of type
         &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'a; .. &gt;
       Types for method fold are incompatible</div></div>

</div><p>

The workaround is easy: you should put a type constraint on the
parameter.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sum (lst : _ #iterator) = lst#fold (<span class="ocamlkeyword">fun</span> x y -&gt; x+y) 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : int #iterator -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Of course the constraint may also be an explicit method type.
Only occurrences of quantified variables are required.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sum lst =
    (lst : &lt; fold : 'a. ('a -&gt; _ -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt;)#fold (+) 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : &lt; fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt; -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Another use of polymorphic methods is to allow some form of implicit
subtyping in method arguments. We have already seen in
sectionÂ <a href="#s%3Ainheritance">3.8</a> how some functions may be polymorphic in the
class of their argument. This can be extended to methods.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> point0 = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> point0 = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> get_x : int <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> distance_point x =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> point x
      <span class="ocamlkeyword">method</span> distance : 'a. (#point0 <span class="ocamlkeyword">as</span> 'a) -&gt; int =
        <span class="ocamlkeyword">fun</span> other -&gt; abs (other#get_x - x)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> distance_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlkeyword">method</span> distance : #point0 -&gt; int
    <span class="ocamlkeyword">method</span> get_offset : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> distance_point 3 <span class="ocamlkeyword">in</span>
  (p#distance (<span class="ocamlkeyword">new</span> point 8), p#distance (<span class="ocamlkeyword">new</span> colored_point 1 <span class="ocamlstring">"blue"</span>));;</div>



<div class="pre caml-output ok">- : int * int = (5, 2)</div></div>

</div><p>

Note here the special syntax <span class="machine"><span class="font-tt">(#point0 as 'a)</span></span> we have to use to
quantify the extensible part of <span class="machine"><span class="font-tt">#point0</span></span>. As for the variable binder,
it can be omitted in class specifications. If you want polymorphism
inside object field it must be quantified independently.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> multi_poly =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> m1 : 'a. (&lt; n1 : 'b. 'b -&gt; 'b; .. &gt; <span class="ocamlkeyword">as</span> 'a) -&gt; _ =
        <span class="ocamlkeyword">fun</span> o -&gt; o#n1 <span class="ocamlkeyword">true</span>, o#n1 <span class="ocamlstring">"hello"</span>
      <span class="ocamlkeyword">method</span> m2 : 'a 'b. (&lt; n2 : 'b -&gt; bool; .. &gt; <span class="ocamlkeyword">as</span> 'a) -&gt; 'b -&gt; _ =
        <span class="ocamlkeyword">fun</span> o x -&gt; o#n2 x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> multi_poly :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">method</span> m1 : &lt; n1 : 'b. 'b -&gt; 'b; .. &gt; -&gt; bool * string
    <span class="ocamlkeyword">method</span> m2 : &lt; n2 : 'b -&gt; bool; .. &gt; -&gt; 'b -&gt; bool
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

In method <span class="machine"><span class="font-tt">m1</span></span>, <span class="machine"><span class="font-tt">o</span></span> must be an object with at least a method <span class="machine"><span class="font-tt">n1</span></span>,
itself polymorphic. In method <span class="machine"><span class="font-tt">m2</span></span>, the argument of <span class="machine"><span class="font-tt">n2</span></span> and <span class="machine"><span class="font-tt">x</span></span> must
have the same type, which is quantified at the same level as <span class="machine"><span class="font-tt">'a</span></span>.</p>
<!--TOC section id="s:using-coercions" 3.12â€ƒUsing coercions-->
<h2 class="section" id="s:using-coercions"><a class="section-anchor" href="#s:using-coercions" aria-hidden="true">ï»¿</a>3.12â€ƒUsing coercions</h2><!--SEC END --><p>Subtyping is never implicit. There are, however, two ways to perform
subtyping. The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.</p><p>We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its <span class="machine"><span class="font-tt">color</span></span> method:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> colored_point_to_point cp = (cp : colored_point :&gt; point);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> colored_point_to_point : colored_point -&gt; point = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> point 3 <span class="ocamlkeyword">and</span> q = <span class="ocamlkeyword">new</span> colored_point 4 <span class="ocamlstring">"blue"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : point = &lt;obj&gt;
<span class="ocamlkeyword">val</span> q : colored_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> l = [p; (colored_point_to_point q)];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : point list = [&lt;obj&gt;; &lt;obj&gt;]</div></div>

</div><p>

An object of type <span class="machine"><span class="font-tt">t</span></span> can be seen as an object of type <span class="machine"><span class="font-tt">t'</span></span>
only if <span class="machine"><span class="font-tt">t</span></span> is a subtype of <span class="machine"><span class="font-tt">t'</span></span>. For instance, a point cannot be
seen as a colored point.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">(p : point :&gt; colored_point)</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Type point = &lt; get_offset : int; get_x : int; move : int -&gt; unit &gt;
       is not a subtype of
         colored_point =
           &lt; color : string; get_offset : int; get_x : int;
             move : int -&gt; unit &gt;
       The first object type has no method color</div></div>

</div><p>

Indeed, narrowing coercions without runtime checks would be unsafe.
Runtime type checks might raise exceptions, and they would require
the presence of type information at runtime, which is not the case in
the OCaml system.
For these reasons, there is no such operation available in the language.</p><p>Be aware that subtyping and inheritance are not related. Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types. For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
</p><p>The domain of a coercion can often be omitted. For instance, one can
define:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> to_point cp = (cp :&gt; point);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> to_point : #point -&gt; point = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

In this case, the function <span class="machine"><span class="font-tt">colored_point_to_point</span></span> is an instance of the
function <span class="machine"><span class="font-tt">to_point</span></span>. This is not always true, however. The fully
explicit coercion is more precise and is sometimes unavoidable.
Consider, for example, the following class:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c0 = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m = {&lt; &gt;} <span class="ocamlkeyword">method</span> n = 0 <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> c0 : <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> m : 'a <span class="ocamlkeyword">method</span> n : int <span class="ocamlkeyword">end</span></div></div>

</div><p>

The object type <span class="machine"><span class="font-tt">c0</span></span> is an abbreviation for <span class="machine"><span class="font-tt">&lt;m : 'a; n : int&gt; as 'a</span></span>.
Consider now the type declaration:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c1 =  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : c1 <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c1 = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : c1 <span class="ocamlkeyword">end</span></div></div>

</div><p>

The object type <span class="machine"><span class="font-tt">c1</span></span> is an abbreviation for the type <span class="machine"><span class="font-tt">&lt;m : 'a&gt; as 'a</span></span>.
The coercion from an object of type <span class="machine"><span class="font-tt">c0</span></span> to an object of type <span class="machine"><span class="font-tt">c1</span></span> is
correct:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">fun</span> (x:c0) -&gt; (x : c0 :&gt; c1);;</div>



<div class="pre caml-output ok">- : c0 -&gt; c1 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

However, the domain of the coercion cannot always be omitted.
In that case, the solution is to use the explicit form.
Sometimes, a change in the class-type definition can also solve the problem

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c2 = <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> m : 'a <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c2 = <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> m : 'a <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">fun</span> (x:c0) -&gt; (x :&gt; c2);;</div>



<div class="pre caml-output ok">- : c0 -&gt; c2 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

While class types <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> are different, both object types
<span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> expand to the same object type (same method names and types).
Yet, when the domain of a coercion is left implicit and its co-domain
is an abbreviation of a known class type, then the class type, rather
than the object type, is used to derive the coercion function. This
allows leaving the domain implicit in most cases when coercing from a
subclass to its superclass.
The type of a coercion can always be seen as below:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> to_c1 x = (x :&gt; c1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> to_c1 : &lt; m : #c1; .. &gt; -&gt; c1 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> to_c2 x = (x :&gt; c2);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> to_c2 : #c2 -&gt; c2 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Note the difference between these two coercions: in the case of <span class="machine"><span class="font-tt">to_c2</span></span>,
the type
<span class="machine"><span class="font-tt">#c2 = &lt; m : 'a; .. &gt; as 'a</span></span> is polymorphically recursive (according
to the explicit recursion in the class type of <span class="machine"><span class="font-tt">c2</span></span>); hence the
success of applying this coercion to an object of class <span class="machine"><span class="font-tt">c0</span></span>.
On the other hand, in the first case, <span class="machine"><span class="font-tt">c1</span></span> was only expanded and
unrolled twice to obtain <span class="machine"><span class="font-tt">&lt; m : &lt; m : c1; .. &gt;; .. &gt;</span></span> (remember <span class="machine"><span class="font-tt">#c1 = &lt; m : c1; .. &gt;</span></span>), without introducing recursion.
You may also note that the type of <span class="machine"><span class="font-tt">to_c2</span></span> is <span class="machine"><span class="font-tt">#c2 -&gt; c2</span></span> while
the type of <span class="machine"><span class="font-tt">to_c1</span></span> is more general than <span class="machine"><span class="font-tt">#c1 -&gt; c1</span></span>. This is not always true,
since there are class types for which some instances of <span class="machine"><span class="font-tt">#c</span></span> are not subtypes
of <span class="machine"><span class="font-tt">c</span></span>, as explained in sectionÂ <a href="#s%3Abinary-methods">3.16</a>. Yet, for
parameterless classes the coercion <span class="machine"><span class="font-tt">(_ :&gt; c)</span></span> is always more general than
<span class="machine"><span class="font-tt">(_ : #c :&gt; c)</span></span>.
</p><p>A common problem may occur when one tries to define a coercion to a
class <span class="machine"><span class="font-tt">c</span></span> while defining class <span class="machine"><span class="font-tt">c</span></span>. The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known. Then, a coercion <span class="machine"><span class="font-tt">(_ :&gt; c)</span></span> or <span class="machine"><span class="font-tt">(_ : #c :&gt; c)</span></span> is taken to be
the identity function, as in

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">fun</span> x -&gt; (x :&gt; 'a);;</div>



<div class="pre caml-output ok">- : 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

As a consequence, if the coercion is applied to <span class="machine"><span class="font-tt">self</span></span>, as in the
following example, the type of <span class="machine"><span class="font-tt">self</span></span> is unified with the closed type
<span class="machine"><span class="font-tt">c</span></span> (a closed object type is an object type without ellipsis). This
would constrain the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m = 1 <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">and</span> d = <span class="ocamlkeyword">object</span> (self)
    <span class="ocamlkeyword">inherit</span> c
    <span class="ocamlkeyword">method</span> n = 2
    <span class="ocamlkeyword">method</span> as_c = (<span class="ocamlhighlight">self</span> :&gt; c)
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression cannot be coerced to type c = &lt; m : int &gt;; it has type
         &lt; as_c : c; m : int; n : int; .. &gt;
       but is here used with type c
       Self type cannot escape its class</div></div>

</div><p>

However, the most common instance of this problem, coercing self to
its current class, is detected as a special case by the type checker,
and properly typed.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c = <span class="ocamlkeyword">object</span> (self) <span class="ocamlkeyword">method</span> m = (self :&gt; c) <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> c : <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : c <span class="ocamlkeyword">end</span></div></div>

</div><p>

This allows the following idiom, keeping a list of all objects
belonging to a class or its subclasses:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> all_c = <span class="ocamlkeyword">ref</span> [];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> all_c : '_weak3 list <span class="ocamlkeyword">ref</span> = {contents = []}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c (m : int) =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">method</span> m = m
      <span class="ocamlkeyword">initializer</span> all_c := (self :&gt; c) :: !all_c
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> c : int -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : int <span class="ocamlkeyword">end</span></div></div>

</div><p>

This idiom can in turn be used to retrieve an object whose type has
been weakened:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> lookup_obj obj = <span class="ocamlkeyword">function</span> [] -&gt; raise Not_found
    | obj' :: l -&gt;
       <span class="ocamlkeyword">if</span> (obj :&gt; &lt; &gt;) = (obj' :&gt; &lt; &gt;) <span class="ocamlkeyword">then</span> obj' <span class="ocamlkeyword">else</span> lookup_obj obj l ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lookup_obj : &lt; .. &gt; -&gt; (&lt; .. &gt; <span class="ocamlkeyword">as</span> 'a) list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> lookup_c obj = lookup_obj obj !all_c;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lookup_c : &lt; .. &gt; -&gt; &lt; m : int &gt; = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

The type <span class="machine"><span class="font-tt">&lt; m : int &gt;</span></span> we see here is just the expansion of <span class="machine"><span class="font-tt">c</span></span>, due
to the use of a reference; we have succeeded in getting back an object
of type <span class="machine"><span class="font-tt">c</span></span>.</p><p><br>
The previous coercion problem can often be avoided by first
defining the abbreviation, using a class type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c' = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : int <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> c' = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : int <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c : c' = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m = 1 <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">and</span> d = <span class="ocamlkeyword">object</span> (self)
    <span class="ocamlkeyword">inherit</span> c
    <span class="ocamlkeyword">method</span> n = 2
    <span class="ocamlkeyword">method</span> as_c = (self :&gt; c')
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> c : c'
<span class="ocamlkeyword">and</span> d : <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> as_c : c' <span class="ocamlkeyword">method</span> m : int <span class="ocamlkeyword">method</span> n : int <span class="ocamlkeyword">end</span></div></div>

</div><p>

It is also possible to use a virtual class. Inheriting from this class
simultaneously forces all methods of <span class="machine"><span class="font-tt">c</span></span> to have the same
type as the methods of <span class="machine"><span class="font-tt">c'</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> c' = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> m : int <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> c' : <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> m : int <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> c = <span class="ocamlkeyword">object</span> (self) <span class="ocamlkeyword">inherit</span> c' <span class="ocamlkeyword">method</span> m = 1 <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> c : <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> m : int <span class="ocamlkeyword">end</span></div></div>

</div><p>

One could think of defining the type abbreviation directly:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> c' = &lt;m : int&gt;;;</div></div>

</div><p>

However, the abbreviation <span class="machine"><span class="font-tt">#c'</span></span> cannot be defined directly in a similar way.
It can only be defined by a class or a class-type definition.
This is because a <span class="machine"><span class="font-tt">#</span></span>-abbreviation carries an implicit anonymous
variable <span class="machine"><span class="font-tt">..</span></span> that cannot be explicitly named.
The closer you get to it is:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a c'_class = 'a <span class="ocamlkeyword">constraint</span> 'a = &lt; m : int; .. &gt;;;</div></div>

</div><p>

with an extra type variable capturing the open object type.</p>
<!--TOC section id="s:functional-objects" 3.13â€ƒFunctional objects-->
<h2 class="section" id="s:functional-objects"><a class="section-anchor" href="#s:functional-objects" aria-hidden="true">ï»¿</a>3.13â€ƒFunctional objects</h2><!--SEC END --><p>It is possible to write a version of class <span class="machine"><span class="font-tt">point</span></span> without assignments
on the instance variables. The override construct <span class="machine"><span class="font-tt">{&lt; ... &gt;}</span></span> returns a copy of
â€œselfâ€ (that is, the current object), possibly changing the value of
some instance variables.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> functional_point y =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> x = y
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = {&lt; x = x + d &gt;}
      <span class="ocamlkeyword">method</span> move_to x = {&lt; x &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> functional_point :
  int -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> x : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; 'a
    <span class="ocamlkeyword">method</span> move_to : int -&gt; 'a
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> functional_point 7;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : functional_point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 7</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (p#move 3)#get_x;;</div>



<div class="pre caml-output ok">- : int = 10</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (p#move_to 15)#get_x;;</div>



<div class="pre caml-output ok">- : int = 15</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p#get_x;;</div>



<div class="pre caml-output ok">- : int = 7</div></div>

</div><p>

As with records, the form <span class="machine"><span class="font-tt">{&lt; x &gt;}</span></span> is an elided version of
<span class="machine"><span class="font-tt">{&lt; x = x &gt;}</span></span> which avoids the repetition of the instance variable name.
Note that the type abbreviation <span class="machine"><span class="font-tt">functional_point</span></span> is recursive, which can
be seen in the class type of <span class="machine"><span class="font-tt">functional_point</span></span>: the type of self is <span class="machine"><span class="font-tt">'a</span></span>
and <span class="machine"><span class="font-tt">'a</span></span> appears inside the type of the method <span class="machine"><span class="font-tt">move</span></span>.</p><p>The above definition of <span class="machine"><span class="font-tt">functional_point</span></span> is not equivalent
to the following:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> bad_functional_point y =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> x = y
      <span class="ocamlkeyword">method</span> get_x = x
      <span class="ocamlkeyword">method</span> move d = <span class="ocamlkeyword">new</span> bad_functional_point (x+d)
      <span class="ocamlkeyword">method</span> move_to x = <span class="ocamlkeyword">new</span> bad_functional_point x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> bad_functional_point :
  int -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> x : int
    <span class="ocamlkeyword">method</span> get_x : int
    <span class="ocamlkeyword">method</span> move : int -&gt; bad_functional_point
    <span class="ocamlkeyword">method</span> move_to : int -&gt; bad_functional_point
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of <span class="machine"><span class="font-tt">bad_functional_point</span></span>,
the method <span class="machine"><span class="font-tt">move</span></span> will
keep returning an object of the parent class. On the contrary, in a
subclass of <span class="machine"><span class="font-tt">functional_point</span></span>, the method <span class="machine"><span class="font-tt">move</span></span> will return an
object of the subclass.</p><p>Functional update is often used in conjunction with binary methods
as illustrated in sectionÂ <a href="#ss%3Astring-as-class">8.2.1</a>.</p>
<!--TOC section id="s:cloning-objects" 3.14â€ƒCloning objects-->
<h2 class="section" id="s:cloning-objects"><a class="section-anchor" href="#s:cloning-objects" aria-hidden="true">ï»¿</a>3.14â€ƒCloning objects</h2><!--SEC END --><p>Objects can also be cloned, whether they are functional or imperative.
The library function <span class="machine"><span class="font-tt">Oo.copy</span></span> makes a shallow copy of an object. That is,
it returns a new object that has the same methods and instance
variables as its argument. The
instance variables are copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely.
A deeper assignment (for example if the instance variable is a reference cell)
will of course affect both the original and the copy.</p><p>The type of <span class="machine"><span class="font-tt">Oo.copy</span></span> is the following:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Oo.copy;;</div>



<div class="pre caml-output ok">- : (&lt; .. &gt; <span class="ocamlkeyword">as</span> 'a) -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

The keyword <span class="machine"><span class="font-tt">as</span></span> in that type binds the type variable <span class="machine"><span class="font-tt">'a</span></span> to
the object type <span class="machine"><span class="font-tt">&lt; .. &gt;</span></span>. Therefore, <span class="machine"><span class="font-tt">Oo.copy</span></span> takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of <span class="machine"><span class="font-tt">Oo.copy</span></span> is different from type <span class="machine"><span class="font-tt">&lt; .. &gt; -&gt; &lt; .. &gt;</span></span> as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> point 5;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> p : point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> q = Oo.copy p;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> q : point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> q#move 7; (p#get_x, q#get_x);;</div>



<div class="pre caml-output ok">- : int * int = (5, 12)</div></div>

</div><p>

In fact, <span class="machine"><span class="font-tt">Oo.copy p</span></span> will behave as <span class="machine"><span class="font-tt">p#copy</span></span> assuming that a public
method <span class="machine"><span class="font-tt">copy</span></span> with body <span class="machine"><span class="font-tt">{&lt; &gt;}</span></span> has been defined in the class of <span class="machine"><span class="font-tt">p</span></span>.</p><p>Objects can be compared using the generic comparison functions <span class="machine"><span class="font-tt">=</span></span> and <span class="machine"><span class="font-tt">&lt;&gt;</span></span>.
Two objects are equal if and only if they are physically equal. In
particular, an object and its copy are not equal.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> q = Oo.copy p;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> q : point = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> p = q, p = p;;</div>



<div class="pre caml-output ok">- : bool * bool = (<span class="ocamlkeyword">false</span>, <span class="ocamlkeyword">true</span>)</div></div>

</div><p>

Other generic comparisons such as (<span class="machine"><span class="font-tt">&lt;</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, ...) can also be used on
objects. The
relation <span class="machine"><span class="font-tt">&lt;</span></span> defines an unspecified but strict ordering on objects. The
ordering relationship between two objects is fixed permanently once the
two objects have been created, and it is not affected by mutation of fields.</p><p>Cloning and override have a non empty intersection.
They are interchangeable when used within an object and without
overriding any field:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> copy =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> copy = {&lt; &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> copy : <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> copy : 'a <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> copy =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">method</span> copy = Oo.copy self
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> copy : <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> copy : 'a <span class="ocamlkeyword">end</span></div></div>

</div><p>

Only the override can be used to actually override fields, and
only the <span class="machine"><span class="font-tt">Oo.copy</span></span> primitive can be used externally.</p><p>Cloning can also be used to provide facilities for saving and
restoring the state of objects.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> backup =
    <span class="ocamlkeyword">object</span> (self : 'mytype)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy = None
      <span class="ocamlkeyword">method</span> save = copy &lt;- Some {&lt; copy = None &gt;}
      <span class="ocamlkeyword">method</span> restore = <span class="ocamlkeyword">match</span> copy <span class="ocamlkeyword">with</span> Some x -&gt; x | None -&gt; self
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> backup :
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy : 'a option
    <span class="ocamlkeyword">method</span> restore : 'a
    <span class="ocamlkeyword">method</span> save : unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

The above definition will only backup one level.
The backup facility can be added to any class by using multiple inheritance.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] backup_ref x = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">inherit</span> ['a] oref x <span class="ocamlkeyword">inherit</span> backup <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] backup_ref :
  'a -&gt;
  <span class="ocamlkeyword">object</span> ('b)
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy : 'b option
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : 'a
    <span class="ocamlkeyword">method</span> get : 'a
    <span class="ocamlkeyword">method</span> restore : 'b
    <span class="ocamlkeyword">method</span> save : unit
    <span class="ocamlkeyword">method</span> set : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> get p n = <span class="ocamlkeyword">if</span> n = 0 <span class="ocamlkeyword">then</span> p # get <span class="ocamlkeyword">else</span> get (p # restore) (n-1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> get : (&lt; get : 'b; restore : 'a; .. &gt; <span class="ocamlkeyword">as</span> 'a) -&gt; int -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> backup_ref 0  <span class="ocamlkeyword">in</span>
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;</div>



<div class="pre caml-output ok">- : int list = [2; 1; 1; 1; 1]</div></div>

</div><p>

We can define a variant of backup that retains all copies. (We also
add a method <span class="machine"><span class="font-tt">clear</span></span> to manually erase all copies.)

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> backup =
    <span class="ocamlkeyword">object</span> (self : 'mytype)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy = None
      <span class="ocamlkeyword">method</span> save = copy &lt;- Some {&lt; &gt;}
      <span class="ocamlkeyword">method</span> restore = <span class="ocamlkeyword">match</span> copy <span class="ocamlkeyword">with</span> Some x -&gt; x | None -&gt; self
      <span class="ocamlkeyword">method</span> clear = copy &lt;- None
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> backup :
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy : 'a option
    <span class="ocamlkeyword">method</span> clear : unit
    <span class="ocamlkeyword">method</span> restore : 'a
    <span class="ocamlkeyword">method</span> save : unit
  <span class="ocamlkeyword">end</span></div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] backup_ref x = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">inherit</span> ['a] oref x <span class="ocamlkeyword">inherit</span> backup <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] backup_ref :
  'a -&gt;
  <span class="ocamlkeyword">object</span> ('b)
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> copy : 'b option
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : 'a
    <span class="ocamlkeyword">method</span> clear : unit
    <span class="ocamlkeyword">method</span> get : 'a
    <span class="ocamlkeyword">method</span> restore : 'b
    <span class="ocamlkeyword">method</span> save : unit
    <span class="ocamlkeyword">method</span> set : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> p = <span class="ocamlkeyword">new</span> backup_ref 0  <span class="ocamlkeyword">in</span>
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;</div>



<div class="pre caml-output ok">- : int list = [2; 1; 0; 0; 0]</div></div>

</div>
<!--TOC section id="s:recursive-classes" 3.15â€ƒRecursive classes-->
<h2 class="section" id="s:recursive-classes"><a class="section-anchor" href="#s:recursive-classes" aria-hidden="true">ï»¿</a>3.15â€ƒRecursive classes</h2><!--SEC END --><p>Recursive classes can be used to define objects whose types are
mutually recursive.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> window =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> top_widget = (None : widget option)
      <span class="ocamlkeyword">method</span> top_widget = top_widget
    <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">and</span> widget (w : window) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> window = w
      <span class="ocamlkeyword">method</span> window = window
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> window :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> top_widget : widget option
    <span class="ocamlkeyword">method</span> top_widget : widget option
  <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">and</span> widget : window -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> window : window <span class="ocamlkeyword">method</span> window : window <span class="ocamlkeyword">end</span></div></div>

</div><p>

Although their types are mutually recursive, the classes <span class="machine"><span class="font-tt">widget</span></span> and
<span class="machine"><span class="font-tt">window</span></span> are themselves independent.</p>
<!--TOC section id="s:binary-methods" 3.16â€ƒBinary methods-->
<h2 class="section" id="s:binary-methods"><a class="section-anchor" href="#s:binary-methods" aria-hidden="true">ï»¿</a>3.16â€ƒBinary methods</h2><!--SEC END --><p>A binary method is a method which takes an argument of the same type
as self. The class <span class="machine"><span class="font-tt">comparable</span></span> below is a template for classes with a
binary method <span class="machine"><span class="font-tt">leq</span></span> of type <span class="machine"><span class="font-tt">'a -&gt; bool</span></span> where the type variable <span class="machine"><span class="font-tt">'a</span></span>
is bound to the type of self. Therefore, <span class="machine"><span class="font-tt">#comparable</span></span> expands to <span class="machine"><span class="font-tt">&lt; leq : 'a -&gt; bool; .. &gt; as 'a</span></span>. We see here that the binder <span class="machine"><span class="font-tt">as</span></span> also
allows writing recursive types.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> comparable =
    <span class="ocamlkeyword">object</span> (_ : 'a)
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> leq : 'a -&gt; bool
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> comparable : <span class="ocamlkeyword">object</span> ('a) <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> leq : 'a -&gt; bool <span class="ocamlkeyword">end</span></div></div>

</div><p>

We then define a subclass <span class="machine"><span class="font-tt">money</span></span> of <span class="machine"><span class="font-tt">comparable</span></span>. The class <span class="machine"><span class="font-tt">money</span></span>
simply wraps floats as comparable objects.<sup><a id="text1" href="#note1">1</a></sup> We will extend
<span class="machine"><span class="font-tt">money</span></span> below with more operations. We have to use a type constraint on
the class parameter <span class="machine"><span class="font-tt">x</span></span> because the primitive <span class="machine"><span class="font-tt">&lt;=</span></span> is a polymorphic
function in OCaml. The <span class="machine"><span class="font-tt">inherit</span></span> clause ensures that the type of
objects of this class is an instance of <span class="machine"><span class="font-tt">#comparable</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> money (x : float) =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> comparable
      <span class="ocamlkeyword">val</span> repr = x
      <span class="ocamlkeyword">method</span> value = repr
      <span class="ocamlkeyword">method</span> leq p = repr &lt;= p#value
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> money :
  float -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : float
    <span class="ocamlkeyword">method</span> leq : 'a -&gt; bool
    <span class="ocamlkeyword">method</span> value : float
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Note that the type <span class="machine"><span class="font-tt">money</span></span> is not a subtype of type
<span class="machine"><span class="font-tt">comparable</span></span>, as the self type appears in contravariant position
in the type of method <span class="machine"><span class="font-tt">leq</span></span>.
Indeed, an object <span class="machine"><span class="font-tt">m</span></span> of class <span class="machine"><span class="font-tt">money</span></span> has a method <span class="machine"><span class="font-tt">leq</span></span>
that expects an argument of type <span class="machine"><span class="font-tt">money</span></span> since it accesses
its <span class="machine"><span class="font-tt">value</span></span> method. Considering <span class="machine"><span class="font-tt">m</span></span> of type <span class="machine"><span class="font-tt">comparable</span></span> would allow a
call to method <span class="machine"><span class="font-tt">leq</span></span> on <span class="machine"><span class="font-tt">m</span></span> with an argument that does not have a method
<span class="machine"><span class="font-tt">value</span></span>, which would be an error.</p><p>Similarly, the type <span class="machine"><span class="font-tt">money2</span></span> below is not a subtype of type <span class="machine"><span class="font-tt">money</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> money2 x =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> money x
      <span class="ocamlkeyword">method</span> times k = {&lt; repr = k *. repr &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> money2 :
  float -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : float
    <span class="ocamlkeyword">method</span> leq : 'a -&gt; bool
    <span class="ocamlkeyword">method</span> times : float -&gt; 'a
    <span class="ocamlkeyword">method</span> value : float
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

It is however possible to define functions that manipulate objects of
type either <span class="machine"><span class="font-tt">money</span></span> or <span class="machine"><span class="font-tt">money2</span></span>: the function <span class="machine"><span class="font-tt">min</span></span>
will return the minimum of any two objects whose type unifies with
<span class="machine"><span class="font-tt">#comparable</span></span>. The type of <span class="machine"><span class="font-tt">min</span></span> is not the same as <span class="machine"><span class="font-tt">#comparable -&gt; #comparable -&gt; #comparable</span></span>, as the abbreviation <span class="machine"><span class="font-tt">#comparable</span></span> hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> min (x : #comparable) y =
    <span class="ocamlkeyword">if</span> x#leq y <span class="ocamlkeyword">then</span> x <span class="ocamlkeyword">else</span> y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> min : (#comparable <span class="ocamlkeyword">as</span> 'a) -&gt; 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

This function can be applied to objects of type <span class="machine"><span class="font-tt">money</span></span>
or <span class="machine"><span class="font-tt">money2</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (min (<span class="ocamlkeyword">new</span> money  1.3) (<span class="ocamlkeyword">new</span> money 3.1))#value;;</div>



<div class="pre caml-output ok">- : float = 1.3</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (min (<span class="ocamlkeyword">new</span> money2 5.0) (<span class="ocamlkeyword">new</span> money2 3.14))#value;;</div>



<div class="pre caml-output ok">- : float = 3.14</div></div>

</div><p>More examples of binary methods can be found in
sectionsÂ <a href="#ss%3Astring-as-class">8.2.1</a> andÂ <a href="#ss%3Aset-as-class">8.2.3</a>.</p><p>Note the use of override for method <span class="machine"><span class="font-tt">times</span></span>.
Writing <span class="machine"><span class="font-tt">new money2 (k *. repr)</span></span> instead of <span class="machine"><span class="font-tt">{&lt; repr = k *. repr &gt;}</span></span>
would not behave well with inheritance: in a subclass <span class="machine"><span class="font-tt">money3</span></span> of <span class="machine"><span class="font-tt">money2</span></span>
the <span class="machine"><span class="font-tt">times</span></span> method would return an object of class <span class="machine"><span class="font-tt">money2</span></span> but not of class
<span class="machine"><span class="font-tt">money3</span></span> as would be expected.</p><p>The class <span class="machine"><span class="font-tt">money</span></span> could naturally carry another binary method. Here is a
direct definition:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> money x =
    <span class="ocamlkeyword">object</span> (self : 'a)
      <span class="ocamlkeyword">val</span> repr = x
      <span class="ocamlkeyword">method</span> value = repr
      <span class="ocamlkeyword">method</span> print = print_float repr
      <span class="ocamlkeyword">method</span> times k = {&lt; repr = k *. x &gt;}
      <span class="ocamlkeyword">method</span> leq (p : 'a) = repr &lt;= p#value
      <span class="ocamlkeyword">method</span> plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> money :
  float -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : float
    <span class="ocamlkeyword">method</span> leq : 'a -&gt; bool
    <span class="ocamlkeyword">method</span> plus : 'a -&gt; 'a
    <span class="ocamlkeyword">method</span> print : unit
    <span class="ocamlkeyword">method</span> times : float -&gt; 'a
    <span class="ocamlkeyword">method</span> value : float
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:friends" 3.17â€ƒFriends-->
<h2 class="section" id="s:friends"><a class="section-anchor" href="#s:friends" aria-hidden="true">ï»¿</a>3.17â€ƒFriends</h2><!--SEC END --><p>The above class <span class="machine"><span class="font-tt">money</span></span> reveals a problem that often occurs with binary
methods. In order to interact with other objects of the same class, the
representation of <span class="machine"><span class="font-tt">money</span></span> objects must be revealed, using a method such as
<span class="machine"><span class="font-tt">value</span></span>. If we remove all binary methods (here <span class="machine"><span class="font-tt">plus</span></span> and <span class="machine"><span class="font-tt">leq</span></span>),
the representation can easily be hidden inside objects by removing the method
<span class="machine"><span class="font-tt">value</span></span> as well. However, this is not possible as soon as some binary
method requires access to the representation of objects of the same
class (other than self).

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> safe_money x =
    <span class="ocamlkeyword">object</span> (self : 'a)
      <span class="ocamlkeyword">val</span> repr = x
      <span class="ocamlkeyword">method</span> print = print_float repr
      <span class="ocamlkeyword">method</span> times k = {&lt; repr = k *. x &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> safe_money :
  float -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : float
    <span class="ocamlkeyword">method</span> print : unit
    <span class="ocamlkeyword">method</span> times : float -&gt; 'a
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Here, the representation of the object is known only to a particular object.
To make it available to other objects of the same class, we are forced to
make it available to the whole world. However we can easily restrict the
visibility of the representation using the module system.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> MONEY =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> t
      <span class="ocamlkeyword">class</span> c : float -&gt;
        <span class="ocamlkeyword">object</span> ('a)
          <span class="ocamlkeyword">val</span> repr : t
          <span class="ocamlkeyword">method</span> value : t
          <span class="ocamlkeyword">method</span> print : unit
          <span class="ocamlkeyword">method</span> times : float -&gt; 'a
          <span class="ocamlkeyword">method</span> leq : 'a -&gt; bool
          <span class="ocamlkeyword">method</span> plus : 'a -&gt; 'a
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Euro : MONEY =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> t = float
      <span class="ocamlkeyword">class</span> c x =
        <span class="ocamlkeyword">object</span> (self : 'a)
          <span class="ocamlkeyword">val</span> repr = x
          <span class="ocamlkeyword">method</span> value = repr
          <span class="ocamlkeyword">method</span> print = print_float repr
          <span class="ocamlkeyword">method</span> times k = {&lt; repr = k *. x &gt;}
          <span class="ocamlkeyword">method</span> leq (p : 'a) = repr &lt;= p#value
          <span class="ocamlkeyword">method</span> plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>

</div><p>

Another example of friend functions may be found in sectionÂ <a href="#ss%3Aset-as-class">8.2.3</a>.
These examples occur when a group of objects (here
objects of the same class) and functions should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside the module.</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes"><a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">floats are an
approximation of decimal numbers, they are unsuitable for use in most
monetary calculations as they may introduce errors.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec44" ChapterÂ 4â€ƒLabeled arguments-->
<h1 class="chapter" id="sec44">ChapterÂ 4â€ƒLabeled arguments</h1><!--SEC END --><p> <a id="c:labl-examples"></a>
</p><!--NAME lablexamples.html-->
<p>
<span class="font-it">(Chapter written by Jacques Garrigue)</span></p><p>If you have a look at modules ending in <span class="machine"><span class="font-tt">Labels</span></span> in the standard
library, you will see that function types have annotations you did not
have in the functions you defined yourself.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.map;;</div>



<div class="pre caml-output ok">- : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> StringLabels.sub;;</div>



<div class="pre caml-output ok">- : string -&gt; pos:int -&gt; len:int -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Such annotations of the form <span class="machine"><span class="font-tt">name:</span></span> are called <em>labels</em>. They are
meant to document the code, allow more checking, and give more
flexibility to function application.
You can give such names to arguments in your programs, by prefixing them
with a tilde <span class="machine"><span class="font-tt">~</span></span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f ~x ~y = x - y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : x:int -&gt; y:int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> x = 3 <span class="ocamlkeyword">and</span> y = 2 <span class="ocamlkeyword">in</span> f ~x ~y;;</div>



<div class="pre caml-output ok">- : int = 1</div></div>

</div><p>When you want to use distinct names for the variable and the label
appearing in the type, you can use a naming label of the form
<span class="machine"><span class="font-tt">~name:</span></span>. This also applies when the argument is not a variable.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f ~x:x1 ~y:y1 = x1 - y1;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : x:int -&gt; y:int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> f ~x:3 ~y:2;;</div>



<div class="pre caml-output ok">- : int = 1</div></div>

</div><p>Labels obey the same rules as other identifiers in OCaml, that is you
cannot use a reserved keyword (like <span class="machine"><span class="font-tt">in</span></span> or <span class="machine"><span class="font-tt">to</span></span>) as a label.</p><p>Formal parameters and arguments are matched according to their
respective labels, the absence of label
being interpreted as the empty label.
This allows commuting arguments in applications. One can also
partially apply a function on any argument, creating a new function of
the remaining parameters.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f ~x ~y = x - y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : x:int -&gt; y:int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> f ~y:2 ~x:3;;</div>



<div class="pre caml-output ok">- : int = 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.fold_left;;</div>



<div class="pre caml-output ok">- : f:('a -&gt; 'b -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.fold_left [1;2;3] ~init:0 ~f:( + );;</div>



<div class="pre caml-output ok">- : int = 6</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.fold_left ~init:0;;</div>



<div class="pre caml-output ok">- : f:(int -&gt; 'a -&gt; int) -&gt; 'a list -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>If several arguments of a function bear the same label (or no label),
they will not commute among themselves, and order matters. But they
can still commute with other arguments.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> hline ~x:x1 ~x:x2 ~y = (x1, x2, y);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> hline : x:'a -&gt; x:'b -&gt; y:'c -&gt; 'a * 'b * 'c = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> hline ~x:3 ~y:2 ~x:5;;</div>



<div class="pre caml-output ok">- : int * int * int = (3, 5, 2)</div></div>

</div>
<!--TOC section id="s:optional-arguments" 4.1â€ƒOptional arguments-->
<h2 class="section" id="s:optional-arguments"><a class="section-anchor" href="#s:optional-arguments" aria-hidden="true">ï»¿</a>4.1â€ƒOptional arguments</h2><!--SEC END --><p>An interesting feature of labeled arguments is that they can be made
optional. For optional parameters, the question mark <span class="machine"><span class="font-tt">?</span></span> replaces the
tilde <span class="machine"><span class="font-tt">~</span></span> of non-optional ones, and the label is also prefixed by <span class="machine"><span class="font-tt">?</span></span>
in the function type.
Default values may be given for such optional parameters.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bump ?(step = 1) x = x + step;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bump : ?step:int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> bump 2;;</div>



<div class="pre caml-output ok">- : int = 3</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> bump ~step:3 2;;</div>



<div class="pre caml-output ok">- : int = 5</div></div>

</div><p>A function taking some optional arguments must also take at least one
non-optional argument. The criterion for deciding whether an optional
argument has been omitted is the non-labeled application of an
argument appearing after this optional argument in the function type.
Note that if that argument is labeled, you will only be able to
eliminate optional arguments by totally applying the function,
omitting all optional arguments and omitting all labels for all
remaining arguments.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> test ?(x = 0) ?(y = 0) () ?(z = 0) () = (x, y, z);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> test : ?x:int -&gt; ?y:int -&gt; unit -&gt; ?z:int -&gt; unit -&gt; int * int * int =
  &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> test ();;</div>



<div class="pre caml-output ok">- : ?z:int -&gt; unit -&gt; int * int * int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> test ~x:2 () ~z:3 ();;</div>



<div class="pre caml-output ok">- : int * int * int = (2, 0, 3)</div></div>

</div><p>Optional parameters may also commute with non-optional or unlabeled
ones, as long as they are applied simultaneously. By nature, optional
arguments do not commute with unlabeled arguments applied
independently.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> test ~y:2 ~x:3 () ();;</div>



<div class="pre caml-output ok">- : int * int * int = (3, 2, 0)</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> test () () ~z:1 ~y:2 ~x:3;;</div>



<div class="pre caml-output ok">- : int * int * int = (3, 2, 1)</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlhighlight">(test () ())</span> ~z:1 ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type int * int * int
       This is not a function; it cannot be applied.</div></div>

</div><p>

Here <span class="machine"><span class="font-tt">(test () ())</span></span> is already <span class="machine"><span class="font-tt">(0,0,0)</span></span> and cannot be further
applied.</p><p>Optional arguments are actually implemented as option types. If
you do not give a default value, you have access to their internal
representation, <span class="machine"><span class="font-tt">type 'a option = None | Some of 'a</span></span>. You can then
provide different behaviors when an argument is present or not.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bump ?step x =
    <span class="ocamlkeyword">match</span> step <span class="ocamlkeyword">with</span>
    | None -&gt; x * 2
    | Some y -&gt; x + y
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bump : ?step:int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>It may also be useful to relay an optional argument from a function
call to another. This can be done by prefixing the applied argument
with <span class="machine"><span class="font-tt">?</span></span>. This question mark disables the wrapping of optional
argument in an option type.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> test2 ?x ?y () = test ?x ?y () ();;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> test2 : ?x:int -&gt; ?y:int -&gt; unit -&gt; int * int * int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> test2 ?x:None;;</div>



<div class="pre caml-output ok">- : ?y:int -&gt; unit -&gt; int * int * int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:label-inference" 4.2â€ƒLabels and type inference-->
<h2 class="section" id="s:label-inference"><a class="section-anchor" href="#s:label-inference" aria-hidden="true">ï»¿</a>4.2â€ƒLabels and type inference</h2><!--SEC END --><p>While they provide an increased comfort for writing function
applications, labels and optional arguments have the pitfall that they
cannot be inferred as completely as the rest of the language.</p><p>You can see it in the following two examples.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> h' g = g ~y:2 ~x:3;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> h' : (y:int -&gt; x:int -&gt; 'a) -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> h' <span class="ocamlhighlight">f</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type x:int -&gt; y:int -&gt; int
       but an expression was expected of type y:int -&gt; x:int -&gt; 'a</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bump_it bump x =
    bump ~step:2 x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bump_it : (step:int -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> bump_it <span class="ocamlhighlight">bump</span> 1 ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type ?step:int -&gt; int -&gt; int
       but an expression was expected of type step:int -&gt; 'a -&gt; 'b</div></div>

</div><p>

The first case is simple: <span class="machine"><span class="font-tt">g</span></span> is passed <span class="machine"><span class="font-tt">~y</span></span> and then <span class="machine"><span class="font-tt">~x</span></span>, but <span class="machine"><span class="font-tt">f</span></span>
expects <span class="machine"><span class="font-tt">~x</span></span> and then <span class="machine"><span class="font-tt">~y</span></span>. This is correctly handled if we know the
type of <span class="machine"><span class="font-tt">g</span></span> to be <span class="machine"><span class="font-tt">x:int -&gt; y:int -&gt; int</span></span> in advance, but otherwise
this causes the above type clash. The simplest workaround is to apply
formal parameters in a standard order.</p><p>The second example is more subtle: while we intended the argument
<span class="machine"><span class="font-tt">bump</span></span> to be of type <span class="machine"><span class="font-tt">?step:int -&gt; int -&gt; int</span></span>, it is inferred as
<span class="machine"><span class="font-tt">step:int -&gt; int -&gt; 'a</span></span>.
These two types being incompatible (internally normal and optional
arguments are different), a type error occurs when applying <span class="machine"><span class="font-tt">bump_it</span></span>
to the real <span class="machine"><span class="font-tt">bump</span></span>.</p><p>We will not try here to explain in detail how type inference works.
One must just understand that there is not enough information in the
above program to deduce the correct type of <span class="machine"><span class="font-tt">g</span></span> or <span class="machine"><span class="font-tt">bump</span></span>. That is,
there is no way to know whether an argument is optional or not, or
which is the correct order, by looking only at how a function is
applied. The strategy used by the compiler is to assume that there are
no optional arguments, and that applications are done in the right
order.</p><p>The right way to solve this problem for optional parameters is to add
a type annotation to the argument <span class="machine"><span class="font-tt">bump</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bump_it (bump : ?step:int -&gt; int -&gt; int) x =
    bump ~step:2 x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bump_it : (?step:int -&gt; int -&gt; int) -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> bump_it bump 1;;</div>



<div class="pre caml-output ok">- : int = 3</div></div>

</div><p>

In practice, such problems appear mostly when using objects whose
methods have optional arguments, so writing the type of object
arguments is often a good idea.</p><p>Normally the compiler generates a type error if you attempt to pass to
a function a parameter whose type is different from the expected one.
However, in the specific case where the expected type is a non-labeled
function type, and the argument is a function expecting optional
parameters, the compiler will attempt to transform the argument to
have it match the expected type, by passing <span class="machine"><span class="font-tt">None</span></span> for all optional
parameters.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> twice f (x : int) = f(f x);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> twice : (int -&gt; int) -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> twice bump 2;;</div>



<div class="pre caml-output ok">- : int = 8</div></div>

</div><p>This transformation is coherent with the intended semantics,
including side-effects. That is, if the application of optional
parameters shall produce side-effects, these are delayed until the
received function is really applied to an argument.</p>
<!--TOC section id="s:label-suggestions" 4.3â€ƒSuggestions for labeling-->
<h2 class="section" id="s:label-suggestions"><a class="section-anchor" href="#s:label-suggestions" aria-hidden="true">ï»¿</a>4.3â€ƒSuggestions for labeling</h2><!--SEC END --><p>Like for names, choosing labels for functions is not an easy task. A
good labeling is one which</p><ul class="itemize"><li class="li-itemize">makes programs more readable,
</li><li class="li-itemize">is easy to remember,
</li><li class="li-itemize">when possible, allows useful partial applications.
</li></ul><p>We explain here the rules we applied when labeling OCaml
libraries.</p><p>To speak in an â€œobject-orientedâ€ way, one can consider that each
function has a main argument, its <em>object</em>, and other arguments
related with its action, the <em>parameters</em>. To permit the
combination of functions through functionals in commuting label mode, the
object will not be labeled. Its role is clear from the function
itself. The parameters are labeled with names reminding of
their nature or their role. The best labels combine nature and
role. When this is not possible the role is to be preferred, since the
nature will
often be given by the type itself. Obscure abbreviations should be
avoided.
</p><pre>
<span class="machine"><span class="font-tt">ListLabels.map : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</span></span>
UnixLabels.write : file_descr -&gt; buf:bytes -&gt; pos:int -&gt; len:int -&gt; unit
</pre><p>When there are several objects of same nature and role, they are all
left unlabeled.
</p><pre>
<span class="machine"><span class="font-tt">ListLabels.iter2 : f:('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</span></span>
</pre><p>When there is no preferable object, all arguments are labeled.
</p><pre>
BytesLabels.blit :
  src:bytes -&gt; src_pos:int -&gt; dst:bytes -&gt; dst_pos:int -&gt; len:int -&gt; unit
</pre><p>However, when there is only one argument, it is often left unlabeled.
</p><pre>
BytesLabels.create : int -&gt; bytes
</pre><p>
This principle also applies to functions of several arguments whose
return type is a type variable, as long as the role of each argument
is not ambiguous. Labeling such functions may lead to awkward error
messages when one attempts to omit labels in an application, as we
have seen with <span class="machine"><span class="font-tt">ListLabels.fold_left</span></span>.</p><p>Here are some of the label names you will find throughout the
libraries.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Label</span></td><td class="c004"><span class="font-bold">Meaning</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">f:</span></span></td><td class="c006">a function to be applied </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">pos:</span></span></td><td class="c006">a position in a string, array or byte sequence </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">len:</span></span></td><td class="c006">a length </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">buf:</span></span></td><td class="c006">a byte sequence or string used as buffer </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">src:</span></span></td><td class="c006">the source of an operation </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">dst:</span></span></td><td class="c006">the destination of an operation </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">init:</span></span></td><td class="c006">the initial value for an iterator </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">cmp:</span></span></td><td class="c006">a comparison function, <span class="font-it">e.g.</span> <span class="machine"><span class="font-tt">Stdlib.compare</span></span> </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">mode:</span></span></td><td class="c006">an operation mode or a flag list </td></tr>
</table></div></div><p>All these are only suggestions, but keep in mind that the
choice of labels is essential for readability. Bizarre choices will
make the program harder to maintain.</p><p>In the ideal, the right function name with right labels should be
enough to understand the functionâ€™s meaning. Since one can get this
information with OCamlBrowser or the <span class="machine"><span class="font-tt">ocaml</span></span> toplevel, the documentation
is only used when a more detailed specification is needed.</p>
<!--TOC chapter id="sec48" ChapterÂ 5â€ƒPolymorphic variants-->
<h1 class="chapter" id="sec48">ChapterÂ 5â€ƒPolymorphic variants</h1><!--SEC END --><p> <a id="c:poly-variant"></a>
</p><!--NAME polyvariant.html-->
<p>
<span class="font-it">(Chapter written by Jacques Garrigue)</span></p><p>Variants as presented in sectionÂ <a href="#s%3Atut-recvariants">1.4</a> are a
powerful tool to build data structures and algorithms. However they
sometimes lack flexibility when used in modular programming. This is
due to the fact that every constructor is assigned to a unique type
when defined and used. Even if the same name appears in the definition
of multiple types, the constructor itself belongs to only one type.
Therefore, one cannot decide that a given constructor belongs to
multiple types, or consider a value of some type to belong to some
other type with more constructors.</p><p>With polymorphic variants, this original assumption is removed. That
is, a variant tag does not belong to any type in particular, the type
system will just check that it is an admissible value according to its
use. You need not define a type before using a variant tag. A variant
type will be inferred independently for each of its uses.</p>
<!--TOC section id="s:polyvariant:basic-use" 5.1â€ƒBasic use-->
<h2 class="section" id="s:polyvariant:basic-use"><a class="section-anchor" href="#s:polyvariant:basic-use" aria-hidden="true">ï»¿</a>5.1â€ƒBasic use</h2><!--SEC END --><p>In programs, polymorphic variants work like usual ones. You just have
to prefix their names with a backquote character <span class="machine"><span class="font-tt">`</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> [`On; `Off];;</div>



<div class="pre caml-output ok">- : [&gt; `Off | `On ] list = [`On; `Off]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> `Number 1;;</div>



<div class="pre caml-output ok">- : [&gt; `Number <span class="ocamlkeyword">of</span> int ] = `Number 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">function</span> `On -&gt; 1 | `Off -&gt; 0 | `Number n -&gt; n;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : [&lt; `Number <span class="ocamlkeyword">of</span> int | `Off | `On ] -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.map f [`On; `Off];;</div>



<div class="pre caml-output ok">- : int list = [1; 0]</div></div>

</div><p>

<span class="machine"><span class="font-tt">[&gt;`Off|`On] list</span></span> means that to match this list, you should at
least be able to match <span class="machine"><span class="font-tt">`Off</span></span> and <span class="machine"><span class="font-tt">`On</span></span>, without argument.
<span class="machine"><span class="font-tt">[&lt;`On|`Off|`Number of int]</span></span> means that <span class="machine"><span class="font-tt">f</span></span> may be applied to <span class="machine"><span class="font-tt">`Off</span></span>,
<span class="machine"><span class="font-tt">`On</span></span> (both without argument), or <span class="machine"><span class="font-tt">`Number</span></span> <span class="font-it">n</span> where
<span class="font-it">n</span> is an integer.
The <span class="machine"><span class="font-tt">&gt;</span></span> and <span class="machine"><span class="font-tt">&lt;</span></span> inside the variant types show that they may still be
refined, either by defining more tags or by allowing less. As such, they
contain an implicit type variable. Because each of the variant types
appears only once in the whole type, their implicit type variables are
not shown.</p><p>The above variant types were polymorphic, allowing further refinement.
When writing type annotations, one will most often describe fixed
variant types, that is types that cannot be refined. This is
also the case for type abbreviations. Such types do not contain <span class="machine"><span class="font-tt">&lt;</span></span> or
<span class="machine"><span class="font-tt">&gt;</span></span>, but just an enumeration of the tags and their associated types,
just like in a normal datatype definition.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a vlist = [`Nil | `Cons <span class="ocamlkeyword">of</span> 'a * 'a vlist];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a vlist = [ `Cons <span class="ocamlkeyword">of</span> 'a * 'a vlist | `Nil ]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map f : 'a vlist -&gt; 'b vlist = <span class="ocamlkeyword">function</span>
    | `Nil -&gt; `Nil
    | `Cons(a, l) -&gt; `Cons(f a, map f l)
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map : ('a -&gt; 'b) -&gt; 'a vlist -&gt; 'b vlist = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:polyvariant-advanced" 5.2â€ƒAdvanced use-->
<h2 class="section" id="s:polyvariant-advanced"><a class="section-anchor" href="#s:polyvariant-advanced" aria-hidden="true">ï»¿</a>5.2â€ƒAdvanced use</h2><!--SEC END --><p>Type-checking polymorphic variants is a subtle thing, and some
expressions may result in more complex type information.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">function</span> `A -&gt; `C | `B -&gt; `D | x -&gt; x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : ([&gt; `A | `B | `C | `D ] <span class="ocamlkeyword">as</span> 'a) -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> f `E;;</div>



<div class="pre caml-output ok">- : [&gt; `A | `B | `C | `D | `E ] = `E</div></div>

</div><p>

Here we are seeing two phenomena. First, since this matching is open
(the last case catches any tag), we obtain the type <span class="machine"><span class="font-tt">[&gt; `A | `B]</span></span>
rather than <span class="machine"><span class="font-tt">[&lt; `A | `B]</span></span> in a closed matching. Then, since <span class="machine"><span class="font-tt">x</span></span> is
returned as is, input and return types are identical. The notation <span class="machine"><span class="font-tt">as 'a</span></span> denotes such type sharing. If we apply <span class="machine"><span class="font-tt">f</span></span> to yet another tag
<span class="machine"><span class="font-tt">`E</span></span>, it gets added to the list.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f1 = <span class="ocamlkeyword">function</span> `A x -&gt; x = 1 | `B -&gt; <span class="ocamlkeyword">true</span> | `C -&gt; <span class="ocamlkeyword">false</span>
  <span class="ocamlkeyword">let</span> f2 = <span class="ocamlkeyword">function</span> `A x -&gt; x = <span class="ocamlstring">"a"</span> | `B -&gt; <span class="ocamlkeyword">true</span> ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f1 : [&lt; `A <span class="ocamlkeyword">of</span> int | `B | `C ] -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> f2 : [&lt; `A <span class="ocamlkeyword">of</span> string | `B ] -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f x = f1 x &amp;&amp; f2 x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : [&lt; `A <span class="ocamlkeyword">of</span> string &amp; int | `B ] -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Here <span class="machine"><span class="font-tt">f1</span></span> and <span class="machine"><span class="font-tt">f2</span></span> both accept the variant tags <span class="machine"><span class="font-tt">`A</span></span> and <span class="machine"><span class="font-tt">`B</span></span>, but the
argument of <span class="machine"><span class="font-tt">`A</span></span> is <span class="machine"><span class="font-tt">int</span></span> for <span class="machine"><span class="font-tt">f1</span></span> and <span class="machine"><span class="font-tt">string</span></span> for <span class="machine"><span class="font-tt">f2</span></span>. In <span class="machine"><span class="font-tt">f</span></span>â€™s
type <span class="machine"><span class="font-tt">`C</span></span>, only accepted by <span class="machine"><span class="font-tt">f1</span></span>, disappears, but both argument types
appear for <span class="machine"><span class="font-tt">`A</span></span> as <span class="machine"><span class="font-tt">int &amp; string</span></span>. This means that if we
pass the variant tag <span class="machine"><span class="font-tt">`A</span></span> to <span class="machine"><span class="font-tt">f</span></span>, its argument should be <em>both</em>
<span class="machine"><span class="font-tt">int</span></span> and <span class="machine"><span class="font-tt">string</span></span>. Since there is no such value, <span class="machine"><span class="font-tt">f</span></span> cannot be
applied to <span class="machine"><span class="font-tt">`A</span></span>, and <span class="machine"><span class="font-tt">`B</span></span> is the only accepted input.</p><p>Even if a value has a fixed variant type, one can still give it a
larger type through coercions. Coercions are normally written with
both the source type and the destination type, but in simple cases the
source type may be omitted.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a wlist = [`Nil | `Cons <span class="ocamlkeyword">of</span> 'a * 'a wlist | `Snoc <span class="ocamlkeyword">of</span> 'a wlist * 'a];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a wlist = [ `Cons <span class="ocamlkeyword">of</span> 'a * 'a wlist | `Nil | `Snoc <span class="ocamlkeyword">of</span> 'a wlist * 'a ]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> wlist_of_vlist  l = (l : 'a vlist :&gt; 'a wlist);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> wlist_of_vlist : 'a vlist -&gt; 'a wlist = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> open_vlist l = (l : 'a vlist :&gt; [&gt; 'a vlist]);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> open_vlist : 'a vlist -&gt; [&gt; 'a vlist ] = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">fun</span> x -&gt; (x :&gt; [`A|`B|`C]);;</div>



<div class="pre caml-output ok">- : [&lt; `A | `B | `C ] -&gt; [ `A | `B | `C ] = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>You may also selectively coerce values through pattern matching.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> split_cases = <span class="ocamlkeyword">function</span>
    | `Nil | `Cons _ <span class="ocamlkeyword">as</span> x -&gt; `A x
    | `Snoc _ <span class="ocamlkeyword">as</span> x -&gt; `B x
  ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> split_cases :
  [&lt; `Cons <span class="ocamlkeyword">of</span> 'a | `Nil | `Snoc <span class="ocamlkeyword">of</span> 'b ] -&gt;
  [&gt; `A <span class="ocamlkeyword">of</span> [&gt; `Cons <span class="ocamlkeyword">of</span> 'a | `Nil ] | `B <span class="ocamlkeyword">of</span> [&gt; `Snoc <span class="ocamlkeyword">of</span> 'b ] ] = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

When an or-pattern composed of variant tags is wrapped inside an
alias-pattern, the alias is given a type containing only the tags
enumerated in the or-pattern. This allows for many useful idioms, like
incremental definition of functions.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> num x = `Num x
  <span class="ocamlkeyword">let</span> eval1 eval (`Num x) = x
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eval x = eval1 eval x ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> num : 'a -&gt; [&gt; `Num <span class="ocamlkeyword">of</span> 'a ] = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eval1 : 'a -&gt; [&lt; `Num <span class="ocamlkeyword">of</span> 'b ] -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eval : [&lt; `Num <span class="ocamlkeyword">of</span> 'a ] -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> plus x y = `Plus(x,y)
  <span class="ocamlkeyword">let</span> eval2 eval = <span class="ocamlkeyword">function</span>
    | `Plus(x,y) -&gt; eval x + eval y
    | `Num _ <span class="ocamlkeyword">as</span> x -&gt; eval1 eval x
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eval x = eval2 eval x ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> plus : 'a -&gt; 'b -&gt; [&gt; `Plus <span class="ocamlkeyword">of</span> 'a * 'b ] = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eval2 : ('a -&gt; int) -&gt; [&lt; `Num <span class="ocamlkeyword">of</span> int | `Plus <span class="ocamlkeyword">of</span> 'a * 'a ] -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eval : ([&lt; `Num <span class="ocamlkeyword">of</span> int | `Plus <span class="ocamlkeyword">of</span> 'a * 'a ] <span class="ocamlkeyword">as</span> 'a) -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>To make this even more comfortable, you may use type definitions as
abbreviations for or-patterns. That is, if you have defined <span class="machine"><span class="font-tt">type myvariant = [`Tag1 of int | `Tag2 of bool]</span></span>, then the pattern <span class="machine"><span class="font-tt">#myvariant</span></span> is
equivalent to writing <span class="machine"><span class="font-tt">(`Tag1(_ : int) | `Tag2(_ : bool))</span></span>.</p><p>Such abbreviations may be used alone,

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">function</span>
    | #myvariant -&gt; <span class="ocamlstring">"myvariant"</span>
    | `Tag3 -&gt; <span class="ocamlstring">"Tag3"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : [&lt; `Tag1 <span class="ocamlkeyword">of</span> int | `Tag2 <span class="ocamlkeyword">of</span> bool | `Tag3 ] -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

or combined with with aliases.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> g1 = <span class="ocamlkeyword">function</span> `Tag1 _ -&gt; <span class="ocamlstring">"Tag1"</span> | `Tag2 _ -&gt; <span class="ocamlstring">"Tag2"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> g1 : [&lt; `Tag1 <span class="ocamlkeyword">of</span> 'a | `Tag2 <span class="ocamlkeyword">of</span> 'b ] -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> g = <span class="ocamlkeyword">function</span>
    | #myvariant <span class="ocamlkeyword">as</span> x -&gt; g1 x
    | `Tag3 -&gt; <span class="ocamlstring">"Tag3"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> g : [&lt; `Tag1 <span class="ocamlkeyword">of</span> int | `Tag2 <span class="ocamlkeyword">of</span> bool | `Tag3 ] -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:polyvariant-weaknesses" 5.3â€ƒWeaknesses of polymorphic variants-->
<h2 class="section" id="s:polyvariant-weaknesses"><a class="section-anchor" href="#s:polyvariant-weaknesses" aria-hidden="true">ï»¿</a>5.3â€ƒWeaknesses of polymorphic variants</h2><!--SEC END --><p>After seeing the power of polymorphic variants, one may wonder why
they were added to core language variants, rather than replacing them.</p><p>The answer is twofold. The first aspect is that while being pretty
efficient, the lack of static type information allows for less
optimizations, and makes polymorphic variants slightly heavier than
core language ones. However noticeable differences would only
appear on huge data structures.</p><p>More important is the fact that polymorphic variants, while being
type-safe, result in a weaker type discipline. That is, core language
variants do actually much more than ensuring type-safety, they also
check that you use only declared constructors, that all constructors
present in a data-structure are compatible, and they enforce typing
constraints to their parameters.</p><p>For this reason, you must be more careful about making types explicit
when you use polymorphic variants. When you write a library, this is
easy since you can describe exact types in interfaces, but for simple
programs you are probably better off with core language variants.</p><p>Beware also that some idioms make trivial errors very hard to find.
For instance, the following code is probably wrong but the compiler
has no way to see it.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> abc = [`A | `B | `C] ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> abc = [ `A | `B | `C ]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">function</span>
    | `As -&gt; <span class="ocamlstring">"A"</span>
    | #abc -&gt; <span class="ocamlstring">"other"</span> ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : [&lt; `A | `As | `B | `C ] -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f : abc -&gt; string = f ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : abc -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

You can avoid such risks by annotating the definition itself.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f : abc -&gt; string = <span class="ocamlkeyword">function</span>
    | <span class="ocamlhighlight">`As</span> -&gt; <span class="ocamlstring">"A"</span>
    | #abc -&gt; <span class="ocamlstring">"other"</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This pattern matches values of type [? `As ]
       but a pattern was expected which matches values of type abc
       The second variant type does not allow tag(s) `As</div></div>

</div>
<!--TOC chapter id="sec52" ChapterÂ 6â€ƒPolymorphism and its limitations-->
<h1 class="chapter" id="sec52">ChapterÂ 6â€ƒPolymorphism and its limitations</h1><!--SEC END --><p><a id="c:polymorphism"></a>
</p><!--NAME polymorphism.html-->
<p><br>
<br>
</p><p>This chapter covers more advanced questions related to the
limitations of polymorphic functions and types. There are some situations
in OCaml where the type inferred by the type checker may be less generic
than expected. Such non-genericity can stem either from interactions
between side-effects and typing or the difficulties of implicit polymorphic
recursion and higher-rank polymorphism.</p><p>This chapter details each of these situations and, if it is possible,
how to recover genericity.</p>
<!--TOC section id="s:weak-polymorphism" 6.1â€ƒWeak polymorphism and mutation-->
<h2 class="section" id="s:weak-polymorphism"><a class="section-anchor" href="#s:weak-polymorphism" aria-hidden="true">ï»¿</a>6.1â€ƒWeak polymorphism and mutation</h2><!--SEC END -->
<!--TOC subsection id="ss:weak-types" 6.1.1â€ƒWeakly polymorphic types-->
<h3 class="subsection" id="ss:weak-types"><a class="section-anchor" href="#ss:weak-types" aria-hidden="true">ï»¿</a>6.1.1â€ƒWeakly polymorphic types</h3><!--SEC END --><p>
Maybe the most frequent examples of non-genericity derive from the
interactions between polymorphic types and mutation. A simple example
appears when typing the following expression

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> store = <span class="ocamlkeyword">ref</span> None ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> store : '_weak1 option <span class="ocamlkeyword">ref</span> = {contents = None}</div></div>

</div><p>

Since the type of <span class="machine"><span class="font-tt">None</span></span> is <span class="machine"><span class="font-tt">'a option</span></span> and the function <span class="machine"><span class="font-tt">ref</span></span> has type
<span class="machine"><span class="font-tt">'b -&gt; 'b ref</span></span>, a natural deduction for the type of <span class="machine"><span class="font-tt">store</span></span> would be
<span class="machine"><span class="font-tt">'a option ref</span></span>. However, the inferred type, <span class="machine"><span class="font-tt">'_weak1 option ref</span></span>, is
different. Type variables whose names start with a <span class="machine"><span class="font-tt">_weak</span></span> prefix like
<span class="machine"><span class="font-tt">'_weak1</span></span> are weakly polymorphic type variables, sometimes shortened to
â€œweak type variablesâ€.
A weak type variable is a placeholder for a single type that is currently
unknown. Once the specific type <span class="machine"><span class="font-tt">t</span></span> behind the placeholder type <span class="machine"><span class="font-tt">'_weak1</span></span>
is known, all occurrences of <span class="machine"><span class="font-tt">'_weak1</span></span> will be replaced by <span class="machine"><span class="font-tt">t</span></span>. For instance,
we can define another option reference and store an <span class="machine"><span class="font-tt">int</span></span> inside:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> another_store = <span class="ocamlkeyword">ref</span> None ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> another_store : '_weak2 option <span class="ocamlkeyword">ref</span> = {contents = None}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> another_store := Some 0;
  another_store ;;</div>



<div class="pre caml-output ok">- : int option <span class="ocamlkeyword">ref</span> = {contents = Some 0}</div></div>

</div><p>

After storing an <span class="machine"><span class="font-tt">int</span></span> inside <span class="machine"><span class="font-tt">another_store</span></span>, the type of <span class="machine"><span class="font-tt">another_store</span></span> has
been updated from <span class="machine"><span class="font-tt">'_weak2 option ref</span></span> to <span class="machine"><span class="font-tt">int option ref</span></span>.
This distinction between weakly and generic polymorphic type variable protects
OCaml programs from unsoundness and runtime errors. To understand from where
unsoundness might come, consider this simple function which swaps a value <span class="machine"><span class="font-tt">x</span></span>
with the value stored inside a <span class="machine"><span class="font-tt">store</span></span> reference, if there is such value:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> swap store x = <span class="ocamlkeyword">match</span> !store <span class="ocamlkeyword">with</span>
    | None -&gt; store := Some x; x
    | Some y -&gt; store := Some x; y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> swap : 'a option <span class="ocamlkeyword">ref</span> -&gt; 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

We can apply this function to our store

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> one = swap store 1
  <span class="ocamlkeyword">let</span> one_again = swap store 2
  <span class="ocamlkeyword">let</span> two = swap store 3;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> one : int = 1
<span class="ocamlkeyword">val</span> one_again : int = 1
<span class="ocamlkeyword">val</span> two : int = 2</div></div>

</div><p>

After these three swaps the stored value is <span class="machine"><span class="font-tt">3</span></span>. Everything is fine up to
now. We can then try to swap <span class="machine"><span class="font-tt">3</span></span> with a more interesting value, for
instance a function:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> error = swap store <span class="ocamlhighlight">(fun x -&gt; x)</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression should not be a function, the expected type is int</div></div>

</div><p>

At this point, the type checker rightfully complains that it is not
possible to swap an integer and a function, and that an <span class="machine"><span class="font-tt">int</span></span> should always
be traded for another <span class="machine"><span class="font-tt">int</span></span>. Furthermore, the type checker prevents us from
manually changing the type of the value stored by <span class="machine"><span class="font-tt">store</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> store := Some <span class="ocamlhighlight">(fun x -&gt; x)</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression should not be a function, the expected type is int</div></div>

</div><p>

Indeed, looking at the type of store, we see that the weak type <span class="machine"><span class="font-tt">'_weak1</span></span> has
been replaced by the type <span class="machine"><span class="font-tt">int</span></span>

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> store;;</div>



<div class="pre caml-output ok">- : int option <span class="ocamlkeyword">ref</span> = {contents = Some 3}</div></div>

</div><p>

Therefore, after placing an <span class="machine"><span class="font-tt">int</span></span> in <span class="machine"><span class="font-tt">store</span></span>, we cannot use it to store any
value other than an <span class="machine"><span class="font-tt">int</span></span>. More generally, weak types protect the program from
undue mutation of values with a polymorphic type.</p><p>Moreover, weak types cannot appear in the signature of toplevel modules:
types must be known at compilation time. Otherwise, different compilation
units could replace the weak type with different and incompatible types.
For this reason, compiling the following small piece of code
</p><pre>let option_ref = ref None
</pre><p>yields a compilation error
</p><pre>Error: The type of this expression, '_weak1 option ref,
       contains type variables that cannot be generalized
</pre><p>To solve this error, it is enough to add an explicit type annotation to
specify the type at declaration time:
</p><pre>let option_ref: int option ref = ref None
</pre><p>This is in any case a good practice for such global mutable variables.
Otherwise, they will pick out the type of first use. If there is a mistake
at this point, it can result in confusing type errors when later, correct
uses are flagged as errors.</p>
<!--TOC subsection id="ss:valuerestriction" 6.1.2â€ƒThe value restriction-->
<h3 class="subsection" id="ss:valuerestriction"><a class="section-anchor" href="#ss:valuerestriction" aria-hidden="true">ï»¿</a>6.1.2â€ƒThe value restriction</h3><!--SEC END --><p>Identifying the exact context in which polymorphic types should be
replaced by weak types in a modular way is a difficult question. Indeed
the type system must handle the possibility that functions may hide persistent
mutable states. For instance, the following function uses an internal reference
to implement a delayed identity function

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> make_fake_id () =
    <span class="ocamlkeyword">let</span> store = <span class="ocamlkeyword">ref</span> None <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">fun</span> x -&gt; swap store x ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> make_fake_id : unit -&gt; 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fake_id = make_fake_id();;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fake_id : '_weak3 -&gt; '_weak3 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

It would be unsound to apply this <span class="machine"><span class="font-tt">fake_id</span></span> function to values with different
types. The function <span class="machine"><span class="font-tt">fake_id</span></span> is therefore rightfully assigned the type
<span class="machine"><span class="font-tt">'_weak3 -&gt; '_weak3</span></span> rather than <span class="machine"><span class="font-tt">'a -&gt; 'a</span></span>. At the same time, it ought to
be possible to use a local mutable state without impacting the type of a
function.
</p><p>To circumvent these dual difficulties, the type checker considers that any value
returned by a function might rely on persistent mutable states behind the scene
and should be given a weak type. This restriction on the type of mutable
values and the results of function application is called the value restriction.
Note that this value restriction is conservative: there are situations where the
value restriction is too cautious and gives a weak type to a value that could be
safely generalized to a polymorphic type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> not_id = (<span class="ocamlkeyword">fun</span> x -&gt; x) (<span class="ocamlkeyword">fun</span> x -&gt; x);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> not_id : '_weak4 -&gt; '_weak4 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Quite often, this happens when defining functions using higher order functions.
To avoid this problem, a solution is to add an explicit argument to the
function:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> id_again = <span class="ocamlkeyword">fun</span> x -&gt; (<span class="ocamlkeyword">fun</span> x -&gt; x) (<span class="ocamlkeyword">fun</span> x -&gt; x) x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> id_again : 'a -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

With this argument, <span class="machine"><span class="font-tt">id_again</span></span> is seen as a function definition by the type
checker and can therefore be generalized. This kind of manipulation is called
eta-expansion in lambda calculus and is sometimes referred under this name.</p>
<!--TOC subsection id="ss:relaxed-value-restriction" 6.1.3â€ƒThe relaxed value restriction-->
<h3 class="subsection" id="ss:relaxed-value-restriction"><a class="section-anchor" href="#ss:relaxed-value-restriction" aria-hidden="true">ï»¿</a>6.1.3â€ƒThe relaxed value restriction</h3><!--SEC END --><p>There is another partial solution to the problem of unnecessary weak types,
which is implemented directly within the type checker. Briefly, it is possible
to prove that weak types that only appear as type parameters in covariant
positions â€“also called positive positionsâ€“ can be safely generalized to
polymorphic types. For instance, the type <span class="machine"><span class="font-tt">'a list</span></span> is covariant in <span class="machine"><span class="font-tt">'a</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> f () = [];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : unit -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> empty = f ();;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> empty : 'a list = []</div></div>

</div><p>

Note that the type inferred for <span class="machine"><span class="font-tt">empty</span></span> is <span class="machine"><span class="font-tt">'a list</span></span> and not the <span class="machine"><span class="font-tt">'_weak5 list</span></span>
that should have occurred with the value restriction.</p><p>The value restriction combined with this generalization for covariant type
parameters is called the relaxed value restriction.</p>
<!--TOC subsection id="ss:variance-and-value-restriction" 6.1.4â€ƒVariance and value restriction-->
<h3 class="subsection" id="ss:variance-and-value-restriction"><a class="section-anchor" href="#ss:variance-and-value-restriction" aria-hidden="true">ï»¿</a>6.1.4â€ƒVariance and value restriction</h3><!--SEC END --><p>
Variance describes how type constructors behave with respect to subtyping.
Consider for instance a pair of type <span class="machine"><span class="font-tt">x</span></span> and <span class="machine"><span class="font-tt">xy</span></span> with <span class="machine"><span class="font-tt">x</span></span> a subtype of <span class="machine"><span class="font-tt">xy</span></span>,
denoted <span class="machine"><span class="font-tt">x :&gt; xy</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> x = [ `X ];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> x = [ `X ]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> xy = [ `X | `Y ];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> xy = [ `X | `Y ]</div></div>

</div><p>

As <span class="machine"><span class="font-tt">x</span></span> is a subtype of <span class="machine"><span class="font-tt">xy</span></span>, we can convert a value of type <span class="machine"><span class="font-tt">x</span></span>
to a value of type <span class="machine"><span class="font-tt">xy</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> x:x = `X;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x : x = `X</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> x' = ( x :&gt; xy);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x' : xy = `X</div></div>

</div><p>

Similarly, if we have a value of type <span class="machine"><span class="font-tt">x list</span></span>, we can convert it to a value
of type <span class="machine"><span class="font-tt">xy list</span></span>, since we could convert each element one by one:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> l:x list = [`X; `X];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l : x list = [`X; `X]</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> l' = ( l :&gt; xy list);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> l' : xy list = [`X; `X]</div></div>

</div><p>

In other words, <span class="machine"><span class="font-tt">x :&gt; xy</span></span> implies that <span class="machine"><span class="font-tt">x list :&gt; xy list</span></span>, therefore
the type constructor <span class="machine"><span class="font-tt">'a list</span></span> is covariant (it preserves subtyping)
in its parameter <span class="machine"><span class="font-tt">'a</span></span>.</p><p>Contrarily, if we have a function that can handle values of type <span class="machine"><span class="font-tt">xy</span></span>

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> f: xy -&gt; unit = <span class="ocamlkeyword">function</span>
    | `X -&gt; ()
    | `Y -&gt; ();;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : xy -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

it can also handle values of type <span class="machine"><span class="font-tt">x</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> f' = (f :&gt; x -&gt; unit);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f' : x -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Note that we can rewrite the type of <span class="machine"><span class="font-tt">f</span></span> and <span class="machine"><span class="font-tt">f'</span></span> as

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> 'a proc = 'a -&gt; unit
    <span class="ocamlkeyword">let</span> f' = (f: xy proc :&gt; x proc);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a proc = 'a -&gt; unit
<span class="ocamlkeyword">val</span> f' : x proc = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

In this case, we have <span class="machine"><span class="font-tt">x :&gt; xy</span></span> implies <span class="machine"><span class="font-tt">xy proc :&gt; x proc</span></span>. Notice
that the second subtyping relation reverse the order of <span class="machine"><span class="font-tt">x</span></span> and <span class="machine"><span class="font-tt">xy</span></span>:
the type constructor <span class="machine"><span class="font-tt">'a proc</span></span> is contravariant in its parameter <span class="machine"><span class="font-tt">'a</span></span>.
More generally, the function type constructor <span class="machine"><span class="font-tt">'a -&gt; 'b</span></span> is covariant in
its return type <span class="machine"><span class="font-tt">'b</span></span> and contravariant in its argument type <span class="machine"><span class="font-tt">'a</span></span>.</p><p>A type constructor can also be invariant in some of its type parameters,
neither covariant nor contravariant. A typical example is a reference:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> x: x <span class="ocamlkeyword">ref</span> = <span class="ocamlkeyword">ref</span> `X;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x : x <span class="ocamlkeyword">ref</span> = {contents = `X}</div></div>

</div><p>

If we were able to coerce <span class="machine"><span class="font-tt">x</span></span> to the type <span class="machine"><span class="font-tt">xy ref</span></span> as a variable <span class="machine"><span class="font-tt">xy</span></span>,
we could use <span class="machine"><span class="font-tt">xy</span></span> to store the value <span class="machine"><span class="font-tt">`Y</span></span> inside the reference and then use
the <span class="machine"><span class="font-tt">x</span></span> value to read this content as a value of type <span class="machine"><span class="font-tt">x</span></span>,
which would break the type system.</p><p>More generally, as soon as a type variable appears in a position describing
mutable state it becomes invariant. As a corollary, covariant variables will
never denote mutable locations and can be safely generalized.
For a better description, interested readers can consult the original
article by Jacques Garrigue on
<a href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf"><span class="font-tt">http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf</span></a></p><p>Together, the relaxed value restriction and type parameter covariance
help to avoid eta-expansion in many situations.</p>
<!--TOC subsection id="ss:variance:abstract-data-types" 6.1.5â€ƒAbstract data types-->
<h3 class="subsection" id="ss:variance:abstract-data-types"><a class="section-anchor" href="#ss:variance:abstract-data-types" aria-hidden="true">ï»¿</a>6.1.5â€ƒAbstract data types</h3><!--SEC END --><p>
Moreover, when the type definitions are exposed, the type checker
is able to infer variance information on its own and one can benefit from
the relaxed value restriction even unknowingly. However, this is not the case
anymore when defining new abstract types. As an illustration, we can define a
module type collection as:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> COLLECTION = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> 'a t
    <span class="ocamlkeyword">val</span> empty: unit -&gt; 'a t
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">module</span> Implementation = <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">type</span> 'a t = 'a list
    <span class="ocamlkeyword">let</span> empty ()= []
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> COLLECTION = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> 'a t <span class="ocamlkeyword">val</span> empty : unit -&gt; 'a t <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> Implementation :
  <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> 'a t = 'a list <span class="ocamlkeyword">val</span> empty : unit -&gt; 'a list <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> List2: COLLECTION = Implementation;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> List2 : COLLECTION</div></div>

</div><p>In this situation, when coercing the module <span class="machine"><span class="font-tt">List2</span></span> to the module type
<span class="machine"><span class="font-tt">COLLECTION</span></span>, the type checker forgets that <span class="machine"><span class="font-tt">'a List2.t</span></span> was covariant
in <span class="machine"><span class="font-tt">'a</span></span>. Consequently, the relaxed value restriction does not apply anymore:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   List2.empty ();;</div>



<div class="pre caml-output ok">- : '_weak5 List2.t = &lt;abstr&gt;</div></div>

</div><p>To keep the relaxed value restriction, we need to declare the abstract type
<span class="machine"><span class="font-tt">'a COLLECTION.t</span></span> as covariant in <span class="machine"><span class="font-tt">'a</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> COLLECTION = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> +'a t
    <span class="ocamlkeyword">val</span> empty: unit -&gt; 'a t
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">module</span> List2: COLLECTION = Implementation;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> COLLECTION = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> +'a t <span class="ocamlkeyword">val</span> empty : unit -&gt; 'a t <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> List2 : COLLECTION</div></div>

</div><p>We then recover polymorphism:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   List2.empty ();;</div>



<div class="pre caml-output ok">- : 'a List2.t = &lt;abstr&gt;</div></div>

</div>
<!--TOC section id="s:polymorphic-recursion" 6.2â€ƒPolymorphic recursion-->
<h2 class="section" id="s:polymorphic-recursion"><a class="section-anchor" href="#s:polymorphic-recursion" aria-hidden="true">ï»¿</a>6.2â€ƒPolymorphic recursion</h2><!--SEC END --><p>The second major class of non-genericity is directly related to the problem
of type inference for polymorphic functions. In some circumstances, the type
inferred by OCaml might be not general enough to allow the definition of
some recursive functions, in particular for recursive functions acting on
non-regular algebraic data types.</p><p>With a regular polymorphic algebraic data type, the type parameters of
the type constructor are constant within the definition of the type. For
instance, we can look at arbitrarily nested list defined as:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> 'a regular_nested = List <span class="ocamlkeyword">of</span> 'a list | Nested <span class="ocamlkeyword">of</span> 'a regular_nested list
    <span class="ocamlkeyword">let</span> l = Nested[ List [1]; Nested [List[2;3]]; Nested[Nested[]] ];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a regular_nested = List <span class="ocamlkeyword">of</span> 'a list | Nested <span class="ocamlkeyword">of</span> 'a regular_nested list
<span class="ocamlkeyword">val</span> l : int regular_nested =
  Nested [List [1]; Nested [List [2; 3]]; Nested [Nested []]]</div></div>

</div><p>

Note that the type constructor <span class="machine"><span class="font-tt">regular_nested</span></span> always appears as
<span class="machine"><span class="font-tt">'a regular_nested</span></span> in the definition above, with the same parameter
<span class="machine"><span class="font-tt">'a</span></span>. Equipped with this type, one can compute a maximal depth with
a classic recursive function

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> maximal_depth = <span class="ocamlkeyword">function</span>
    | List _ -&gt; 1
    | Nested [] -&gt; 0
    | Nested (a::q) -&gt; 1 + max (maximal_depth a) (maximal_depth (Nested q));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> maximal_depth : 'a regular_nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Non-regular recursive algebraic data types correspond to polymorphic algebraic
data types whose parameter types vary between the left and right side of
the type definition. For instance, it might be interesting to define a datatype
that ensures that all lists are nested at the same depth:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> 'a nested = List <span class="ocamlkeyword">of</span> 'a list | Nested <span class="ocamlkeyword">of</span> 'a list nested;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a nested = List <span class="ocamlkeyword">of</span> 'a list | Nested <span class="ocamlkeyword">of</span> 'a list nested</div></div>

</div><p>

Intuitively, a value of type <span class="machine"><span class="font-tt">'a nested</span></span> is a list of list â€¦of list of
elements <span class="machine"><span class="font-tt">a</span></span> with <span class="machine"><span class="font-tt">k</span></span> nested list. We can then adapt the <span class="machine"><span class="font-tt">maximal_depth</span></span>
function defined on <span class="machine"><span class="font-tt">regular_depth</span></span> into a <span class="machine"><span class="font-tt">depth</span></span> function that computes this
<span class="machine"><span class="font-tt">k</span></span>. As a first try, we may define

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> depth = <span class="ocamlkeyword">function</span>
    | List _ -&gt; 1
    | Nested n -&gt; 1 + depth <span class="ocamlhighlight">n</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type 'a list nested
       but an expression was expected of type 'a nested
       The type variable 'a occurs inside 'a list</div></div>

</div><p>

The type error here comes from the fact that during the definition of <span class="machine"><span class="font-tt">depth</span></span>,
the type checker first assigns to <span class="machine"><span class="font-tt">depth</span></span> the type <span class="machine"><span class="font-tt">'a -&gt; 'b </span></span>.
When typing the pattern matching, <span class="machine"><span class="font-tt">'a -&gt; 'b</span></span> becomes <span class="machine"><span class="font-tt">'a nested -&gt; 'b</span></span>, then
<span class="machine"><span class="font-tt">'a nested -&gt; int</span></span> once the <span class="machine"><span class="font-tt">List</span></span> branch is typed.
However, when typing the application <span class="machine"><span class="font-tt">depth n</span></span> in the <span class="machine"><span class="font-tt">Nested</span></span> branch,
the type checker encounters a problem: <span class="machine"><span class="font-tt">depth n</span></span> is applied to
<span class="machine"><span class="font-tt">'a list nested</span></span>, it must therefore have the type
<span class="machine"><span class="font-tt">'a list nested -&gt; 'b</span></span>. Unifying this constraint with the previous one
leads to the impossible constraint <span class="machine"><span class="font-tt">'a list nested = 'a nested</span></span>.
In other words, within its definition, the recursive function <span class="machine"><span class="font-tt">depth</span></span> is
applied to values of type <span class="machine"><span class="font-tt">'a t</span></span> with different types <span class="machine"><span class="font-tt">'a</span></span> due to the
non-regularity of the type constructor <span class="machine"><span class="font-tt">nested</span></span>. This creates a problem because
the type checker had introduced a new type variable <span class="machine"><span class="font-tt">'a</span></span> only at the
<em>definition</em> of the function <span class="machine"><span class="font-tt">depth</span></span> whereas, here, we need a
different type variable for every <em>application</em> of the function <span class="machine"><span class="font-tt">depth</span></span>.</p>
<!--TOC subsection id="ss:explicit-polymorphism" 6.2.1â€ƒExplicitly polymorphic annotations-->
<h3 class="subsection" id="ss:explicit-polymorphism"><a class="section-anchor" href="#ss:explicit-polymorphism" aria-hidden="true">ï»¿</a>6.2.1â€ƒExplicitly polymorphic annotations</h3><!--SEC END --><p>
The solution of this conundrum is to use an explicitly polymorphic type
annotation for the type <span class="machine"><span class="font-tt">'a</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> depth: 'a. 'a nested -&gt; int = <span class="ocamlkeyword">function</span>
    | List _ -&gt; 1
    | Nested n -&gt; 1 + depth n;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> depth : 'a nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> depth ( Nested(List [ [7]; [8] ]) );;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div><p>

In the type of <span class="machine"><span class="font-tt">depth</span></span>, <span class="machine"><span class="font-tt">'a.'a nested -&gt; int</span></span>, the type variable <span class="machine"><span class="font-tt">'a</span></span>
is universally quantified. In other words, <span class="machine"><span class="font-tt">'a.'a nested -&gt; int</span></span> reads as
â€œfor all type <span class="machine"><span class="font-tt">'a</span></span>, <span class="machine"><span class="font-tt">depth</span></span> maps <span class="machine"><span class="font-tt">'a nested</span></span> values to integersâ€.
Whereas the standard type <span class="machine"><span class="font-tt">'a nested -&gt; int</span></span> can be interpreted
as â€œlet be a type variable <span class="machine"><span class="font-tt">'a</span></span>, then <span class="machine"><span class="font-tt">depth</span></span> maps <span class="machine"><span class="font-tt">'a nested</span></span> values
to integersâ€. There are two major differences with these two type
expressions. First, the explicit polymorphic annotation indicates to the
type checker that it needs to introduce a new type variable every time
the function <span class="machine"><span class="font-tt">depth</span></span> is applied. This solves our problem with the definition
of the function <span class="machine"><span class="font-tt">depth</span></span>.</p><p>Second, it also notifies the type checker that the type of the function should
be polymorphic. Indeed, without explicit polymorphic type annotation, the
following type annotation is perfectly valid

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> sum: 'a -&gt; 'b -&gt; 'c = <span class="ocamlkeyword">fun</span> x y -&gt; x + y;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

since <span class="machine"><span class="font-tt">'a</span></span>,<span class="machine"><span class="font-tt">'b</span></span> and <span class="machine"><span class="font-tt">'c</span></span> denote type variables that may or may not be
polymorphic. Whereas, it is an error to unify an explicitly polymorphic type
with a non-polymorphic type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> sum: 'a 'b 'c. 'a -&gt; 'b -&gt; 'c = <span class="ocamlhighlight">fun x y -&gt; x + y</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This definition has type int -&gt; int -&gt; int which is less general than
         'a 'b 'c. 'a -&gt; 'b -&gt; 'c</div></div>

</div><p>An important remark here is that it is not needed to explicit fully
the type of <span class="machine"><span class="font-tt">depth</span></span>: it is sufficient to add annotations only for the
universally quantified type variables:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> depth: 'a. 'a nested -&gt; _ = <span class="ocamlkeyword">function</span>
    | List _ -&gt; 1
    | Nested n -&gt; 1 + depth n;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> depth : 'a nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> depth ( Nested(List [ [7]; [8] ]) );;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div>
<!--TOC subsection id="ss:recursive-poly-examples" 6.2.2â€ƒMore examples-->
<h3 class="subsection" id="ss:recursive-poly-examples"><a class="section-anchor" href="#ss:recursive-poly-examples" aria-hidden="true">ï»¿</a>6.2.2â€ƒMore examples</h3><!--SEC END --><p>
With explicit polymorphic annotations, it becomes possible to implement
any recursive function that depends only on the structure of the nested
lists and not on the type of the elements. For instance, a more complex
example would be to compute the total number of elements of the nested
lists:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> len nested =
      <span class="ocamlkeyword">let</span> map_and_sum f = List.fold_left (<span class="ocamlkeyword">fun</span> acc x -&gt; acc + f x) 0 <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> len: 'a. ('a list -&gt; int ) -&gt; 'a nested -&gt; int =
      <span class="ocamlkeyword">fun</span> nested_len n -&gt;
        <span class="ocamlkeyword">match</span> n <span class="ocamlkeyword">with</span>
        | List l -&gt; nested_len l
        | Nested n -&gt; len (map_and_sum nested_len) n
      <span class="ocamlkeyword">in</span>
    len List.length nested;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> len : 'a nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> len (Nested(Nested(List [ [ [1;2]; [3] ]; [ []; [4]; [5;6;7]]; [[]] ])));;</div>



<div class="pre caml-output ok">- : int = 7</div></div>

</div><p>Similarly, it may be necessary to use more than one explicitly
polymorphic type variables, like for computing the nested list of
list lengths of the nested list:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> shape n =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> shape: 'a 'b. ('a nested -&gt; int nested) -&gt;
      ('b list list -&gt; 'a list) -&gt; 'b nested -&gt; int nested
      = <span class="ocamlkeyword">fun</span> nest nested_shape -&gt;
        <span class="ocamlkeyword">function</span>
        | List l -&gt; raise
         (Invalid_argument <span class="ocamlstring">"shape requires nested_list of depth greater than 1"</span>)
        | Nested (List l) -&gt; nest @@ List (nested_shape l)
        | Nested n -&gt;
          <span class="ocamlkeyword">let</span> nested_shape = List.map nested_shape <span class="ocamlkeyword">in</span>
          <span class="ocamlkeyword">let</span> nest x = nest (Nested x) <span class="ocamlkeyword">in</span>
          shape nest nested_shape n <span class="ocamlkeyword">in</span>
    shape (<span class="ocamlkeyword">fun</span> n -&gt; n ) (<span class="ocamlkeyword">fun</span> l -&gt; List.map List.length l ) n;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> shape : 'a nested -&gt; int nested = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> shape (Nested(Nested(List [ [ [1;2]; [3] ]; [ []; [4]; [5;6;7]]; [[]] ])));;</div>



<div class="pre caml-output ok">- : int nested = Nested (List [[2; 1]; [0; 1; 3]; [0]])</div></div>

</div>
<!--TOC section id="s:higher-rank-poly" 6.3â€ƒHigher-rank polymorphic functions-->
<h2 class="section" id="s:higher-rank-poly"><a class="section-anchor" href="#s:higher-rank-poly" aria-hidden="true">ï»¿</a>6.3â€ƒHigher-rank polymorphic functions</h2><!--SEC END --><p>Explicit polymorphic annotations are however not sufficient to cover all
the cases where the inferred type of a function is less general than
expected. A similar problem arises when using polymorphic functions as arguments
of higher-order functions. For instance, we may want to compute the average
depth or length of two nested lists:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> average_depth x y = (depth x + depth y) / 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> average_depth : 'a nested -&gt; 'b nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> average_len x y = (len x + len y) / 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> average_len : 'a nested -&gt; 'b nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> one = average_len (List [2]) (List [[]]);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> one : int = 1</div></div>

</div><p>

It would be natural to factorize these two definitions as:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>     <span class="ocamlkeyword">let</span> average f x y = (f x + f y) / 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> average : ('a -&gt; int) -&gt; 'a -&gt; 'a -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

However, the type of <span class="machine"><span class="font-tt">average len</span></span> is less generic than the type of
<span class="machine"><span class="font-tt">average_len</span></span>, since it requires the type of the first and second argument to
be the same:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   average_len (List [2]) (List [[]]);;</div>



<div class="pre caml-output ok">- : int = 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   average len (List [2]) (List [<span class="ocamlhighlight">[]</span>]);;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type 'a list
       but an expression was expected of type int</div></div>

</div><p>As previously with polymorphic recursion, the problem stems from the fact that
type variables are introduced only at the start of the <span class="machine"><span class="font-tt">let</span></span> definitions. When
we compute both <span class="machine"><span class="font-tt">f x</span></span> and <span class="machine"><span class="font-tt">f y</span></span>, the type of <span class="machine"><span class="font-tt">x</span></span> and <span class="machine"><span class="font-tt">y</span></span> are unified together.
To avoid this unification, we need to indicate to the type checker
that f is polymorphic in its first argument. In some sense, we would want
<span class="machine"><span class="font-tt">average</span></span> to have type
</p><pre>val average: ('a. 'a nested -&gt; int) -&gt; 'a nested -&gt; 'b nested -&gt; int
</pre><p>Note that this syntax is not valid within OCaml: <span class="machine"><span class="font-tt">average</span></span> has an universally
quantified type <span class="machine"><span class="font-tt">'a</span></span> inside the type of one of its argument whereas for
polymorphic recursion the universally quantified type was introduced before
the rest of the type. This position of the universally quantified type means
that <span class="machine"><span class="font-tt">average</span></span> is a second-rank polymorphic function. This kind of higher-rank
functions is not directly supported by OCaml: type inference for second-rank
polymorphic function and beyond is undecidable; therefore using this kind of
higher-rank functions requires to handle manually these universally quantified
types.</p><p>In OCaml, there are two ways to introduce this kind of explicit universally
quantified types: universally quantified record fields,

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">type</span> 'a nested_reduction = { f:'elt. 'elt nested -&gt; 'a };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a nested_reduction = { f : 'elt. 'elt nested -&gt; 'a; }</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> boxed_len = { f = len };;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> boxed_len : int nested_reduction = {f = &lt;<span class="ocamlkeyword">fun</span>&gt;}</div></div>

</div><p>

and universally quantified object methods:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> obj_len = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> f:'a. 'a nested -&gt; 'b = len <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> obj_len : &lt; f : 'a. 'a nested -&gt; int &gt; = &lt;obj&gt;</div></div>

</div><p>

To solve our problem, we can therefore use either the record solution:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> average nsm x y = (nsm.f x + nsm.f y) / 2 ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> average : int nested_reduction -&gt; 'a nested -&gt; 'b nested -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

or the object one:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>   <span class="ocamlkeyword">let</span> average (obj:&lt;f:'a. 'a nested -&gt; _ &gt; ) x y = (obj#f x + obj#f y) / 2 ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> average : &lt; f : 'a. 'a nested -&gt; int &gt; -&gt; 'b nested -&gt; 'c nested -&gt; int =
  &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC chapter id="sec63" ChapterÂ 7â€ƒGeneralized algebraic datatypes-->
<h1 class="chapter" id="sec63">ChapterÂ 7â€ƒGeneralized algebraic datatypes</h1><!--SEC END --><p> <a id="c:gadts-tutorial"></a>
</p><!--NAME gadts-tutorial.html-->
<p>Generalized algebraic datatypes, or GADTs, extend usual sum types in
two ways: constraints on type parameters may change depending on the
value constructor, and some type variables may be existentially
quantified.
Adding constraints is done by giving an explicit return type, where type
parameters are instantiated:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ term =
  | Int : int -&gt; int term
  | Add : (int -&gt; int -&gt; int) term
  | App : ('b -&gt; 'a) term * 'b term -&gt; 'a term</div></div>

</div><p>This return type must use the same type constructor as the type being
defined, and have the same number of parameters.
Variables are made existential when they appear inside a constructorâ€™s
argument, but not in its return type.
Since the use of a return type often eliminates the need to name type
parameters in the left-hand side of a type definition, one can replace
them with anonymous types <span class="machine"><span class="font-tt">_</span></span> in that case.</p><p>The constraints associated to each constructor can be recovered
through pattern-matching.
Namely, if the type of the scrutinee of a pattern-matching contains
a locally abstract type, this type can be refined according to the
constructor used.
These extra constraints are only valid inside the corresponding branch
of the pattern-matching.
If a constructor has some existential variables, fresh locally
abstract types are generated, and they must not escape the
scope of this branch.</p>
<!--TOC section id="s:gadts-recfun" 7.1â€ƒRecursive functions-->
<h2 class="section" id="s:gadts-recfun"><a class="section-anchor" href="#s:gadts-recfun" aria-hidden="true">ï»¿</a>7.1â€ƒRecursive functions</h2><!--SEC END --><p>We write an <span class="machine"><span class="font-tt">eval</span></span> function:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eval : <span class="ocamlkeyword">type</span> a. a term -&gt; a = <span class="ocamlkeyword">function</span>
  | Int n    -&gt; n                 <span class="ocamlcomment">(* a = int *)</span>
  | Add      -&gt; (<span class="ocamlkeyword">fun</span> x y -&gt; x+y)  <span class="ocamlcomment">(* a = int -&gt; int -&gt; int *)</span>
  | App(f,x) -&gt; (eval f) (eval x)
          <span class="ocamlcomment">(* eval called at types (b-&gt;a) and b for fresh b *)</span></div></div>

</div><p>And use it:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> two = eval (App (App (Add, Int 1), Int 1))</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> two : int = 2</div></div>

</div><p>

It is important to remark that the function <span class="machine"><span class="font-tt">eval</span></span> is using the
polymorphic syntax for locally abstract types. When defining a recursive
function that manipulates a GADT, explicit polymorphic recursion should
generally be used. For instance, the following definition fails with a
type error:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eval (<span class="ocamlkeyword">type</span> a) : a term -&gt; a = <span class="ocamlkeyword">function</span>
  | Int n    -&gt; n
  | Add      -&gt; (<span class="ocamlkeyword">fun</span> x y -&gt; x+y)
  | App(f,x) -&gt; (eval <span class="ocamlhighlight">f</span>) (eval x)</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type ($App_'b -&gt; a) term
       but an expression was expected of type 'a
       The type constructor $App_'b would escape its scope</div></div>

</div><p>

In absence of an explicit polymorphic annotation, a monomorphic type
is inferred for the recursive function. If a recursive call occurs
inside the function definition at a type that involves an existential
GADT type variable, this variable flows to the type of the recursive
function, and thus escapes its scope. In the above example, this happens
in the branch <span class="machine"><span class="font-tt">App(f,x)</span></span> when <span class="machine"><span class="font-tt">eval</span></span> is called with <span class="machine"><span class="font-tt">f</span></span> as an argument.
In this branch, the type of <span class="machine"><span class="font-tt">f</span></span> is <span class="machine"><span class="font-tt">($App_'b -&gt; a) term</span></span>. The prefix <span class="machine"><span class="font-tt">$</span></span> in
<span class="machine"><span class="font-tt">$App_'b</span></span> denotes an existential type named by the compiler
(seeÂ <a href="#s%3Aexistential-names">7.5</a>). Since the type of <span class="machine"><span class="font-tt">eval</span></span> is
<span class="machine"><span class="font-tt">'a term -&gt; 'a</span></span>, the call <span class="machine"><span class="font-tt">eval f</span></span> makes the existential type <span class="machine"><span class="font-tt">$App_'b</span></span>
flow to the type variable <span class="machine"><span class="font-tt">'a</span></span> and escape its scope. This triggers the
above error.</p>
<!--TOC section id="s:gadts-type-inference" 7.2â€ƒType inference-->
<h2 class="section" id="s:gadts-type-inference"><a class="section-anchor" href="#s:gadts-type-inference" aria-hidden="true">ï»¿</a>7.2â€ƒType inference</h2><!--SEC END --><p>Type inference for GADTs is notoriously hard.
This is due to the fact some types may become ambiguous when escaping
from a branch.
For instance, in the <span class="machine"><span class="font-tt">Int</span></span> case above, <span class="machine"><span class="font-tt">n</span></span> could have either type <span class="machine"><span class="font-tt">int</span></span>
or <span class="machine"><span class="font-tt">a</span></span>, and they are not equivalent outside of that branch.
As a first approximation, type inference will always work if a
pattern-matching is annotated with types containing no free type
variables (both on the scrutinee and the return type).
This is the case in the above example, thanks to the type annotation
containing only locally abstract types.</p><p>In practice, type inference is a bit more clever than that: type
annotations do not need to be immediately on the pattern-matching, and
the types do not have to be always closed.
As a result, it is usually enough to only annotate functions, as in
the example above. Type annotations are
propagated in two ways: for the scrutinee, they follow the flow of
type inference, in a way similar to polymorphic methods; for the
return type, they follow the structure of the program, they are split
on functions, propagated to all branches of a pattern matching,
and go through tuples, records, and sum types.
Moreover, the notion of ambiguity used is stronger: a type is only
seen as ambiguous if it was mixed with incompatible types (equated by
constraints), without type annotations between them.
For instance, the following program types correctly.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> sum : <span class="ocamlkeyword">type</span> a. a term -&gt; _ = <span class="ocamlkeyword">fun</span> x -&gt;
  <span class="ocamlkeyword">let</span> y =
    <span class="ocamlkeyword">match</span> x <span class="ocamlkeyword">with</span>
    | Int n -&gt; n
    | Add   -&gt; 0
    | App(f,x) -&gt; sum f + sum x
  <span class="ocamlkeyword">in</span> y + 1</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : 'a term -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Here the return type <span class="machine"><span class="font-tt">int</span></span> is never mixed with <span class="machine"><span class="font-tt">a</span></span>, so it is seen as
non-ambiguous, and can be inferred.
When using such partial type annotations we strongly suggest
specifying the <span class="machine"><span class="font-tt">-principal</span></span> mode, to check that inference is
principal.</p><p>The exhaustiveness check is aware of GADT constraints, and can
automatically infer that some cases cannot happen.
For instance, the following pattern matching is correctly seen as
exhaustive (the <span class="machine"><span class="font-tt">Add</span></span> case cannot happen).

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> get_int : int term -&gt; int = <span class="ocamlkeyword">function</span>
  | Int n    -&gt; n
  | App(_,_) -&gt; 0</div></div>

</div>
<!--TOC section id="s:gadt-refutation-cases" 7.3â€ƒRefutation cases-->
<h2 class="section" id="s:gadt-refutation-cases"><a class="section-anchor" href="#s:gadt-refutation-cases" aria-hidden="true">ï»¿</a>7.3â€ƒRefutation cases</h2><!--SEC END --><p>Usually, the exhaustiveness check only tries to check whether the
cases omitted from the pattern matching are typable or not.
However, you can force it to try harder by adding <em>refutation cases</em>,
written as a full stop.
In the presence of a refutation case, the exhaustiveness check will first
compute the intersection of the pattern with the complement of the
cases preceding it. It then checks whether the resulting patterns can
really match any concrete values by trying to type-check them.
Wild cards in the generated patterns are handled in a special way: if
their type is a variant type with only GADT constructors, then the
pattern is split into the different constructors, in order to check whether
any of them is possible (this splitting is not done for arguments of these
constructors, to avoid non-termination). We also split tuples and
variant types with only one case, since they may contain GADTs inside.
For instance, the following code is deemed exhaustive:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ t =
  | Int : int t
  | Bool : bool t

<span class="ocamlkeyword">let</span> deep : (char t * int) option -&gt; char = <span class="ocamlkeyword">function</span>
  | None -&gt; 'c'
  | _ -&gt; .</div></div>

</div><p>Namely, the inferred remaining case is <span class="machine"><span class="font-tt">Some _</span></span>, which is split into
<span class="machine"><span class="font-tt">Some (Int, _)</span></span> and <span class="machine"><span class="font-tt">Some (Bool, _)</span></span>, which are both untypable because
<span class="machine"><span class="font-tt">deep</span></span> expects a non-existing <span class="machine"><span class="font-tt">char t</span></span> as the first element of the tuple.
Note that the refutation case could be omitted here, because it is
automatically added when there is only one case in the pattern
matching.</p><p>Another addition is that the redundancy check is now aware of GADTs: a
case will be detected as redundant if it could be replaced by a
refutation case using the same pattern.</p>
<!--TOC section id="s:gadts-advexamples" 7.4â€ƒAdvanced examples-->
<h2 class="section" id="s:gadts-advexamples"><a class="section-anchor" href="#s:gadts-advexamples" aria-hidden="true">ï»¿</a>7.4â€ƒAdvanced examples</h2><!--SEC END --><p>
The <span class="machine"><span class="font-tt">term</span></span> type we have defined above is an <em>indexed</em> type, where
a type parameter reflects a property of the value contents.
Another use of GADTs is <em>singleton</em> types, where a GADT value
represents exactly one type. This value can be used as runtime
representation for this type, and a function receiving it can have a
polytypic behavior.</p><p>Here is an example of a polymorphic function that takes the
runtime representation of some type <span class="machine"><span class="font-tt">t</span></span> and a value of the same type,
then pretty-prints the value as a string:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ typ =
  | Int : int typ
  | String : string typ
  | Pair : 'a typ * 'b typ -&gt; ('a * 'b) typ

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> to_string: <span class="ocamlkeyword">type</span> t. t typ -&gt; t -&gt; string =
  <span class="ocamlkeyword">fun</span> t x -&gt;
  <span class="ocamlkeyword">match</span> t <span class="ocamlkeyword">with</span>
  | Int -&gt; Int.to_string x
  | String -&gt; Printf.sprintf <span class="ocamlstring">"%S"</span> x
  | Pair(t1,t2) -&gt;
      <span class="ocamlkeyword">let</span> (x1, x2) = x <span class="ocamlkeyword">in</span>
      Printf.sprintf <span class="ocamlstring">"(%s,%s)"</span> (to_string t1 x1) (to_string t2 x2)</div></div>

</div><p>Another frequent application of GADTs is equality witnesses.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> (_,_) eq = Eq : ('a,'a) eq

<span class="ocamlkeyword">let</span> cast : <span class="ocamlkeyword">type</span> a b. (a,b) eq -&gt; a -&gt; b = <span class="ocamlkeyword">fun</span> Eq x -&gt; x</div></div>

</div><p>

Here type <span class="machine"><span class="font-tt">eq</span></span> has only one constructor, and by matching on it one
adds a local constraint allowing the conversion between <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span>.
By building such equality witnesses, one can make equal types which
are syntactically different.</p><p>Here is an example using both singleton types and equality witnesses
to implement dynamic types.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> eq_type : <span class="ocamlkeyword">type</span> a b. a typ -&gt; b typ -&gt; (a,b) eq option =
  <span class="ocamlkeyword">fun</span> a b -&gt;
  <span class="ocamlkeyword">match</span> a, b <span class="ocamlkeyword">with</span>
  | Int, Int -&gt; Some Eq
  | String, String -&gt; Some Eq
  | Pair(a1,a2), Pair(b1,b2) -&gt;
      <span class="ocamlkeyword">begin</span> <span class="ocamlkeyword">match</span> eq_type a1 b1, eq_type a2 b2 <span class="ocamlkeyword">with</span>
      | Some Eq, Some Eq -&gt; Some Eq
      | _ -&gt; None
      <span class="ocamlkeyword">end</span>
  | _ -&gt; None

<span class="ocamlkeyword">type</span> dyn = Dyn : 'a typ * 'a -&gt; dyn

<span class="ocamlkeyword">let</span> get_dyn : <span class="ocamlkeyword">type</span> a. a typ -&gt; dyn -&gt; a option =
  <span class="ocamlkeyword">fun</span> a (Dyn(b,x)) -&gt;
  <span class="ocamlkeyword">match</span> eq_type a b <span class="ocamlkeyword">with</span>
  | None -&gt; None
  | Some Eq -&gt; Some x</div></div>

</div>
<!--TOC section id="s:existential-names" 7.5â€ƒExistential type names in error messages-->
<h2 class="section" id="s:existential-names"><a class="section-anchor" href="#s:existential-names" aria-hidden="true">ï»¿</a>7.5â€ƒExistential type names in error messages</h2><!--SEC END --><p>The typing of pattern matching in the presence of GADTs can generate many
existential types. When necessary, error messages refer to these
existential types using compiler-generated names. Currently, the
compiler generates these names according to the following nomenclature:
</p><ul class="itemize"><li class="li-itemize">First, types whose name starts with a <span class="machine"><span class="font-tt">$</span></span> are existentials.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">$Constr_'a</span></span> denotes an existential type introduced for the type
variable <span class="machine"><span class="font-tt">'a</span></span> of the GADT constructor <span class="machine"><span class="font-tt">Constr</span></span>:

<div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> any = Any : 'name -&gt; any
<span class="ocamlkeyword">let</span> escape (Any x) = <span class="ocamlhighlight">x</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type $Any_'name
       but an expression was expected of type 'a
       The type constructor $Any_'name would escape its scope</div></div>

</div>

</li><li class="li-itemize"><span class="machine"><span class="font-tt">$Constr</span></span> denotes an existential type introduced for an anonymous type variable in the GADT constructor <span class="machine"><span class="font-tt">Constr</span></span>:

<div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> any = Any : _ -&gt; any
<span class="ocamlkeyword">let</span> escape (Any x) = <span class="ocamlhighlight">x</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This expression has type $Any but an expression was expected of type
         'a
       The type constructor $Any would escape its scope</div></div>

</div>

</li><li class="li-itemize"><span class="machine"><span class="font-tt">$'a</span></span> if the existential variable was unified with the type variable <span class="machine"><span class="font-tt">'a</span></span> during typing:

<div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> ('arg,'result,'aux) fn =
  | Fun: ('a -&gt;'b) -&gt; ('a,'b,unit) fn
  | Mem1: ('a -&gt;'b) * 'a * 'b -&gt; ('a, 'b, 'a * 'b) fn
 <span class="ocamlkeyword">let</span> apply: ('arg,'result, _ ) fn -&gt; 'arg -&gt; 'result = <span class="ocamlkeyword">fun</span> f x -&gt;
  <span class="ocamlkeyword">match</span> f <span class="ocamlkeyword">with</span>
  | Fun f -&gt; f x
  | <span class="ocamlhighlight">Mem1 (f,y,fy)</span> -&gt; <span class="ocamlkeyword">if</span> x = y <span class="ocamlkeyword">then</span> fy <span class="ocamlkeyword">else</span> f x</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This pattern matches values of type
         ($'arg, 'result, $'arg * 'result) fn
       but a pattern was expected which matches values of type
         ($'arg, 'result, unit) fn
       The type constructor $'arg would escape its scope</div></div>

</div>

</li><li class="li-itemize"><span class="machine"><span class="font-tt">$n</span></span> (n a number) is an internally generated existential which could not be named using one of the previous schemes.
</li></ul><p>As shown by the last item, the current behavior is imperfect
and may be improved in future versions.</p>
<!--TOC section id="s:explicit-existential-name" 7.6â€ƒExplicit naming of existentials-->
<h2 class="section" id="s:explicit-existential-name"><a class="section-anchor" href="#s:explicit-existential-name" aria-hidden="true">ï»¿</a>7.6â€ƒExplicit naming of existentials</h2><!--SEC END --><p>As explained above, pattern-matching on a GADT constructor may introduce
existential types. Syntax has been introduced which allows them to be named
explicitly. For instance, the following code names the type of the argument of
<span class="machine"><span class="font-tt">f</span></span> and uses this name.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ closure = Closure : ('a -&gt; 'b) * 'a -&gt; 'b closure
<span class="ocamlkeyword">let</span> eval = <span class="ocamlkeyword">fun</span> (Closure (<span class="ocamlkeyword">type</span> a) (f, x : (a -&gt; _) * _)) -&gt; f (x : a)</div></div>

</div><p>

All existential type variables of the constructor must by introduced by
the (<span class="machine"><span class="font-tt">type</span></span> ...) construct and bound by a type annotation on the
outside of the constructor argument.</p>
<!--TOC section id="s:gadt-equation-nonlocal-abstract" 7.7â€ƒEquations on non-local abstract types-->
<h2 class="section" id="s:gadt-equation-nonlocal-abstract"><a class="section-anchor" href="#s:gadt-equation-nonlocal-abstract" aria-hidden="true">ï»¿</a>7.7â€ƒEquations on non-local abstract types</h2><!--SEC END --><p>GADT pattern-matching may also add type equations to non-local
abstract types. The behaviour is the same as with local abstract
types. Reusing the above <span class="machine"><span class="font-tt">eq</span></span> type, one can write:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">val</span> x : t <span class="ocamlkeyword">val</span> e : (t,int) eq <span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = int
  <span class="ocamlkeyword">let</span> x = 33
  <span class="ocamlkeyword">let</span> e = Eq
<span class="ocamlkeyword">end</span>

<span class="ocamlkeyword">let</span> x : int = <span class="ocamlkeyword">let</span> Eq = M.e <span class="ocamlkeyword">in</span> M.x</div></div>

</div><p>Of course, not all abstract types can be refined, as this would
contradict the exhaustiveness check. Namely, builtin types (those
defined by the compiler itself, such as <span class="machine"><span class="font-tt">int</span></span> or <span class="machine"><span class="font-tt">array</span></span>), and
abstract types defined by the local module, are non-instantiable, and
as such cause a type error rather than introduce an equation.

</p>
<!--TOC chapter id="sec71" ChapterÂ 8â€ƒAdvanced examples with classes and modules-->
<h1 class="chapter" id="sec71">ChapterÂ 8â€ƒAdvanced examples with classes and modules</h1><!--SEC END --><!--NAME advexamples.html-->
<p>
<a id="c:advexamples"></a></p><p><span class="font-it">(Chapter written by Didier RÃ©my)</span></p><p><br>
<br>
</p><p>In this chapter, we show some larger examples using objects, classes
and modules. We review many of the object features simultaneously on
the example of a bank account. We show how modules taken from the
standard library can be expressed as classes. Lastly, we describe a
programming pattern known as <em>virtual types</em> through the example
of window managers.</p>
<!--TOC section id="s:extended-bank-accounts" 8.1â€ƒExtended example: bank accounts-->
<h2 class="section" id="s:extended-bank-accounts"><a class="section-anchor" href="#s:extended-bank-accounts" aria-hidden="true">ï»¿</a>8.1â€ƒExtended example: bank accounts</h2><!--SEC END --><p>In this section, we illustrate most aspects of Object and inheritance
by refining, debugging, and specializing the following
initial naive definition of a simple bank account. (We reuse the
module <span class="machine"><span class="font-tt">Euro</span></span> defined at the end of chapterÂ <a href="#c%3Aobjectexamples">3</a>.)

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> euro = <span class="ocamlkeyword">new</span> Euro.c;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> euro : float -&gt; Euro.c = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> zero = euro 0.;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> zero : Euro.c = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> neg x = x#times (-1.);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> neg : &lt; times : float -&gt; 'a; .. &gt; -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> account =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance = zero
      <span class="ocamlkeyword">method</span> balance = balance
      <span class="ocamlkeyword">method</span> deposit x = balance &lt;- balance # plus x
      <span class="ocamlkeyword">method</span> withdraw x =
        <span class="ocamlkeyword">if</span> x#leq balance <span class="ocamlkeyword">then</span> (balance &lt;- balance # plus (neg x); x) <span class="ocamlkeyword">else</span> zero
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> account :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">new</span> account <span class="ocamlkeyword">in</span> c # deposit (euro 100.); c # withdraw (euro 50.);;</div>



<div class="pre caml-output ok">- : Euro.c = &lt;obj&gt;</div></div>

</div><p>

We now refine this definition with a method to compute interest.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> account_with_interests =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> account
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> interest = self # deposit (self # balance # times 0.03)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> account_with_interests :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> interest : unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

We make the method <span class="machine"><span class="font-tt">interest</span></span> private, since clearly it should not be
called freely from the outside. Here, it is only made accessible to subclasses
that will manage monthly or yearly updates of the account.</p><p>We should soon fix a bug in the current definition: the deposit method can
be used for withdrawing money by depositing negative amounts. We can
fix this directly:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> safe_account =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> account
      <span class="ocamlkeyword">method</span> deposit x = <span class="ocamlkeyword">if</span> zero#leq x <span class="ocamlkeyword">then</span> balance &lt;- balance#plus x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> safe_account :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

However, the bug might be fixed more safely by the following definition:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> safe_account =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> account <span class="ocamlkeyword">as</span> unsafe
      <span class="ocamlkeyword">method</span> deposit x =
        <span class="ocamlkeyword">if</span> zero#leq x <span class="ocamlkeyword">then</span> unsafe # deposit x
        <span class="ocamlkeyword">else</span> raise (Invalid_argument <span class="ocamlstring">"deposit"</span>)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> safe_account :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

In particular, this does not require the knowledge of the implementation of
the method <span class="machine"><span class="font-tt">deposit</span></span>.</p><p>To keep track of operations, we extend the class with a mutable field
<span class="machine"><span class="font-tt">history</span></span> and a private method <span class="machine"><span class="font-tt">trace</span></span> to add an operation in the
log. Then each method to be traced is redefined.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a operation = Deposit <span class="ocamlkeyword">of</span> 'a | Retrieval <span class="ocamlkeyword">of</span> 'a;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a operation = Deposit <span class="ocamlkeyword">of</span> 'a | Retrieval <span class="ocamlkeyword">of</span> 'a</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> account_with_history =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> safe_account <span class="ocamlkeyword">as</span> super
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> history = []
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> trace x = history &lt;- x :: history
      <span class="ocamlkeyword">method</span> deposit x = self#trace (Deposit x);  super#deposit x
      <span class="ocamlkeyword">method</span> withdraw x = self#trace (Retrieval x); super#withdraw x
      <span class="ocamlkeyword">method</span> history = List.rev history
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> account_with_history :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> trace : Euro.c operation -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

One may wish to open an account and simultaneously deposit some initial
amount. Although the initial implementation did not address this
requirement, it can be achieved by using an initializer.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> account_with_deposit x =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> account_with_history
      <span class="ocamlkeyword">initializer</span> balance &lt;- x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> account_with_deposit :
  Euro.c -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> trace : Euro.c operation -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

A better alternative is:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> account_with_deposit x =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> account_with_history
      <span class="ocamlkeyword">initializer</span> self#deposit x
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> account_with_deposit :
  Euro.c -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance : Euro.c
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> balance : Euro.c
    <span class="ocamlkeyword">method</span> deposit : Euro.c -&gt; unit
    <span class="ocamlkeyword">method</span> history : Euro.c operation list
    <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> trace : Euro.c operation -&gt; unit
    <span class="ocamlkeyword">method</span> withdraw : Euro.c -&gt; Euro.c
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Indeed, the latter is safer since the call to <span class="machine"><span class="font-tt">deposit</span></span> will automatically
benefit from safety checks and from the trace.
Letâ€™s test it:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ccp = <span class="ocamlkeyword">new</span> account_with_deposit (euro 100.) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> _balance = ccp#withdraw (euro 50.) <span class="ocamlkeyword">in</span>
  ccp#history;;</div>



<div class="pre caml-output ok">- : Euro.c operation list = [Deposit &lt;obj&gt;; Retrieval &lt;obj&gt;]</div></div>

</div><p>

Closing an account can be done with the following polymorphic function:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> close c = c#withdraw c#balance;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> close : &lt; balance : 'a; withdraw : 'a -&gt; 'b; .. &gt; -&gt; 'b = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>

Of course, this applies to all sorts of accounts.</p><p>Finally, we gather several versions of the account into a module <span class="machine"><span class="font-tt">Account</span></span>
abstracted over some currency.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> today () = (01,01,2000) <span class="ocamlcomment">(* an approximation *)</span>
  <span class="ocamlkeyword">module</span> Account (M:MONEY) =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> m = M.c
      <span class="ocamlkeyword">let</span> m = <span class="ocamlkeyword">new</span> M.c
      <span class="ocamlkeyword">let</span> zero = m 0.

      <span class="ocamlkeyword">class</span> bank =
        <span class="ocamlkeyword">object</span> (self)
          <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> balance = zero
          <span class="ocamlkeyword">method</span> balance = balance
          <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> history = []
          <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> trace x = history &lt;- x::history
          <span class="ocamlkeyword">method</span> deposit x =
            self#trace (Deposit x);
            <span class="ocamlkeyword">if</span> zero#leq x <span class="ocamlkeyword">then</span> balance &lt;- balance # plus x
            <span class="ocamlkeyword">else</span> raise (Invalid_argument <span class="ocamlstring">"deposit"</span>)
          <span class="ocamlkeyword">method</span> withdraw x =
            <span class="ocamlkeyword">if</span> x#leq balance <span class="ocamlkeyword">then</span>
              (balance &lt;- balance # plus (neg x); self#trace (Retrieval x); x)
            <span class="ocamlkeyword">else</span> zero
          <span class="ocamlkeyword">method</span> history = List.rev history
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> client_view =
        <span class="ocamlkeyword">object</span>
          <span class="ocamlkeyword">method</span> deposit : m -&gt; unit
          <span class="ocamlkeyword">method</span> history : m operation list
          <span class="ocamlkeyword">method</span> withdraw : m -&gt; m
          <span class="ocamlkeyword">method</span> balance : m
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> check_client x =
        <span class="ocamlkeyword">let</span> y = <span class="ocamlkeyword">if</span> (m 100.)#leq x <span class="ocamlkeyword">then</span> x
        <span class="ocamlkeyword">else</span> raise (Failure <span class="ocamlstring">"Insufficient initial deposit"</span>) <span class="ocamlkeyword">in</span>
        <span class="ocamlkeyword">object</span> (self)
          <span class="ocamlkeyword">initializer</span> self#deposit y
          <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> deposit: m -&gt; unit
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">module</span> Client (B : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">class</span> bank : client_view <span class="ocamlkeyword">end</span>) =
        <span class="ocamlkeyword">struct</span>
          <span class="ocamlkeyword">class</span> account x : client_view =
            <span class="ocamlkeyword">object</span>
              <span class="ocamlkeyword">inherit</span> B.bank
              <span class="ocamlkeyword">inherit</span> check_client x
            <span class="ocamlkeyword">end</span>

          <span class="ocamlkeyword">let</span> discount x =
            <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">new</span> account x <span class="ocamlkeyword">in</span>
            <span class="ocamlkeyword">if</span> today() &lt; (1998,10,30) <span class="ocamlkeyword">then</span> c # deposit (m 100.); c
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>

</div><p>

This shows the use of modules to group several class definitions that can in
fact be thought of as a single unit. This unit would be provided by a bank
for both internal and external uses.
This is implemented as a functor that abstracts over the currency so that
the same code can be used to provide accounts in different currencies.</p><p>The class <span class="machine"><span class="font-tt">bank</span></span> is the <em>real</em> implementation of the bank account (it
could have been inlined). This is the one that will be used for further
extensions, refinements, etc. Conversely, the client will only be given the client view.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Euro_account = Account(Euro);;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Client = Euro_account.Client (Euro_account);;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">new</span> Client.account (<span class="ocamlkeyword">new</span> Euro.c 100.);;</div></div>

</div><p>

Hence, the clients do not have direct access to the <span class="machine"><span class="font-tt">balance</span></span>, nor the
<span class="machine"><span class="font-tt">history</span></span> of their own accounts. Their only way to change their balance is
to deposit or withdraw money. It is important to give the clients
a class and not just the ability to create accounts (such as the
promotional <span class="machine"><span class="font-tt">discount</span></span> account), so that they can
personalize their account.
For instance, a client may refine the <span class="machine"><span class="font-tt">deposit</span></span> and <span class="machine"><span class="font-tt">withdraw</span></span> methods
so as to do his own financial bookkeeping, automatically. On the
other hand, the function <span class="machine"><span class="font-tt">discount</span></span> is given as such, with no
possibility for further personalization.</p><p>It is important to provide the clientâ€™s view as a functor
<span class="machine"><span class="font-tt">Client</span></span> so that client accounts can still be built after a possible
specialization of the <span class="machine"><span class="font-tt">bank</span></span>.
The functor <span class="machine"><span class="font-tt">Client</span></span> may remain unchanged and be passed
the new definition to initialize a clientâ€™s view of the extended account.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Investment_account (M : MONEY) =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> m = M.c
      <span class="ocamlkeyword">module</span> A = Account(M)

      <span class="ocamlkeyword">class</span> bank =
        <span class="ocamlkeyword">object</span>
          <span class="ocamlkeyword">inherit</span> A.bank <span class="ocamlkeyword">as</span> super
          <span class="ocamlkeyword">method</span> deposit x =
            <span class="ocamlkeyword">if</span> (<span class="ocamlkeyword">new</span> M.c 1000.)#leq x <span class="ocamlkeyword">then</span>
              print_string <span class="ocamlstring">"Would you like to invest?"</span>;
            super#deposit x
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">module</span> Client = A.Client
    <span class="ocamlkeyword">end</span>;;</div></div>

</div><p>

The functor <span class="machine"><span class="font-tt">Client</span></span> may also be redefined when some new features of the
account can be given to the client.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Internet_account (M : MONEY) =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> m = M.c
      <span class="ocamlkeyword">module</span> A = Account(M)

      <span class="ocamlkeyword">class</span> bank =
        <span class="ocamlkeyword">object</span>
          <span class="ocamlkeyword">inherit</span> A.bank
          <span class="ocamlkeyword">method</span> mail s = print_string s
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> client_view =
        <span class="ocamlkeyword">object</span>
          <span class="ocamlkeyword">method</span> deposit : m -&gt; unit
          <span class="ocamlkeyword">method</span> history : m operation list
          <span class="ocamlkeyword">method</span> withdraw : m -&gt; m
          <span class="ocamlkeyword">method</span> balance : m
          <span class="ocamlkeyword">method</span> mail : string -&gt; unit
        <span class="ocamlkeyword">end</span>

      <span class="ocamlkeyword">module</span> Client (B : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">class</span> bank : client_view <span class="ocamlkeyword">end</span>) =
        <span class="ocamlkeyword">struct</span>
          <span class="ocamlkeyword">class</span> account x : client_view =
            <span class="ocamlkeyword">object</span>
              <span class="ocamlkeyword">inherit</span> B.bank
              <span class="ocamlkeyword">inherit</span> A.check_client x
            <span class="ocamlkeyword">end</span>
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>

</div>
<!--TOC section id="s:modules-as-classes" 8.2â€ƒSimple modules as classes-->
<h2 class="section" id="s:modules-as-classes"><a class="section-anchor" href="#s:modules-as-classes" aria-hidden="true">ï»¿</a>8.2â€ƒSimple modules as classes</h2><!--SEC END --><p>One may wonder whether it is possible to treat primitive types such as
integers and strings as objects. Although this is usually uninteresting
for integers or strings, there may be some situations where
this is desirable. The class <span class="machine"><span class="font-tt">money</span></span> above is such an example.
We show here how to do it for strings.</p>
<!--TOC subsection id="ss:string-as-class" 8.2.1â€ƒStrings-->
<h3 class="subsection" id="ss:string-as-class"><a class="section-anchor" href="#ss:string-as-class" aria-hidden="true">ï»¿</a>8.2.1â€ƒStrings</h3><!--SEC END --><p>A naive definition of strings as objects could be:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ostring s =
    <span class="ocamlkeyword">object</span>
       <span class="ocamlkeyword">method</span> get n = String.get s n
       <span class="ocamlkeyword">method</span> print = print_string s
       <span class="ocamlkeyword">method</span> escaped = <span class="ocamlkeyword">new</span> ostring (String.escaped s)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ostring :
  string -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">method</span> escaped : ostring
    <span class="ocamlkeyword">method</span> get : int -&gt; char
    <span class="ocamlkeyword">method</span> print : unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

However, the method <span class="machine"><span class="font-tt">escaped</span></span> returns an object of the class <span class="machine"><span class="font-tt">ostring</span></span>,
and not an object of the current class. Hence, if the class is further
extended, the method <span class="machine"><span class="font-tt">escaped</span></span> will only return an object of the parent
class.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> sub_string s =
    <span class="ocamlkeyword">object</span>
       <span class="ocamlkeyword">inherit</span> ostring s
       <span class="ocamlkeyword">method</span> sub start len = <span class="ocamlkeyword">new</span> sub_string (String.sub s  start len)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> sub_string :
  string -&gt;
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">method</span> escaped : ostring
    <span class="ocamlkeyword">method</span> get : int -&gt; char
    <span class="ocamlkeyword">method</span> print : unit
    <span class="ocamlkeyword">method</span> sub : int -&gt; int -&gt; sub_string
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

As seen in sectionÂ <a href="#s%3Abinary-methods">3.16</a>, the solution is to use
functional update instead. We need to create an instance variable
containing the representation <span class="machine"><span class="font-tt">s</span></span> of the string.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> better_string s =
    <span class="ocamlkeyword">object</span>
       <span class="ocamlkeyword">val</span> repr = s
       <span class="ocamlkeyword">method</span> get n = String.get repr n
       <span class="ocamlkeyword">method</span> print = print_string repr
       <span class="ocamlkeyword">method</span> escaped = {&lt; repr = String.escaped repr &gt;}
       <span class="ocamlkeyword">method</span> sub start len = {&lt; repr = String.sub s start len &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> better_string :
  string -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : string
    <span class="ocamlkeyword">method</span> escaped : 'a
    <span class="ocamlkeyword">method</span> get : int -&gt; char
    <span class="ocamlkeyword">method</span> print : unit
    <span class="ocamlkeyword">method</span> sub : int -&gt; int -&gt; 'a
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

As shown in the inferred type, the methods <span class="machine"><span class="font-tt">escaped</span></span> and <span class="machine"><span class="font-tt">sub</span></span> now return
objects of the same type as the one of the class.</p><p>Another difficulty is the implementation of the method <span class="machine"><span class="font-tt">concat</span></span>.
In order to concatenate a string with another string of the same class,
one must be able to access the instance variable externally. Thus, a method
<span class="machine"><span class="font-tt">repr</span></span> returning s must be defined. Here is the correct definition of
strings:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ostring s =
    <span class="ocamlkeyword">object</span> (self : 'mytype)
       <span class="ocamlkeyword">val</span> repr = s
       <span class="ocamlkeyword">method</span> repr = repr
       <span class="ocamlkeyword">method</span> get n = String.get repr n
       <span class="ocamlkeyword">method</span> print = print_string repr
       <span class="ocamlkeyword">method</span> escaped = {&lt; repr = String.escaped repr &gt;}
       <span class="ocamlkeyword">method</span> sub start len = {&lt; repr = String.sub s start len &gt;}
       <span class="ocamlkeyword">method</span> concat (t : 'mytype) = {&lt; repr = repr ^ t#repr &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ostring :
  string -&gt;
  <span class="ocamlkeyword">object</span> ('a)
    <span class="ocamlkeyword">val</span> repr : string
    <span class="ocamlkeyword">method</span> concat : 'a -&gt; 'a
    <span class="ocamlkeyword">method</span> escaped : 'a
    <span class="ocamlkeyword">method</span> get : int -&gt; char
    <span class="ocamlkeyword">method</span> print : unit
    <span class="ocamlkeyword">method</span> repr : string
    <span class="ocamlkeyword">method</span> sub : int -&gt; int -&gt; 'a
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

Another constructor of the class string can be defined to return a new
string of a given length:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> cstring n = ostring (String.make n ' ');;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> cstring : int -&gt; ostring</div></div>

</div><p>

Here, exposing the representation of strings is probably harmless. We do
could also hide the representation of strings as we hid the currency in the
class <span class="machine"><span class="font-tt">money</span></span> of sectionÂ <a href="#s%3Afriends">3.17</a>.</p>
<!--TOC subsubsection id="sss:stack-as-class" Stacks-->
<h4 class="subsubsection" id="sss:stack-as-class"><a class="section-anchor" href="#sss:stack-as-class" aria-hidden="true">ï»¿</a>Stacks</h4><!--SEC END --><p>There is sometimes an alternative between using modules or classes for
parametric data types.
Indeed, there are situations when the two approaches are quite similar.
For instance, a stack can be straightforwardly implemented as a class:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">exception</span> Empty;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">exception</span> Empty</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] stack =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = ([] : 'a list)
      <span class="ocamlkeyword">method</span> push x = l &lt;- x::l
      <span class="ocamlkeyword">method</span> pop = <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span> [] -&gt; raise Empty | a::l' -&gt; l &lt;- l'; a
      <span class="ocamlkeyword">method</span> clear = l &lt;- []
      <span class="ocamlkeyword">method</span> length = List.length l
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] stack :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : 'a list
    <span class="ocamlkeyword">method</span> clear : unit
    <span class="ocamlkeyword">method</span> length : int
    <span class="ocamlkeyword">method</span> pop : 'a
    <span class="ocamlkeyword">method</span> push : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

However, writing a method for iterating over a stack is more
problematic. A method <span class="machine"><span class="font-tt">fold</span></span> would have type
<span class="machine"><span class="font-tt">('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</span></span>. Here <span class="machine"><span class="font-tt">'a</span></span> is the parameter of the stack.
The parameter <span class="machine"><span class="font-tt">'b</span></span> is not related to the class <span class="machine"><span class="font-tt">'a stack</span></span> but to the
argument that will be passed to the method <span class="machine"><span class="font-tt">fold</span></span>.
A naive approach is to make <span class="machine"><span class="font-tt">'b</span></span> an extra parameter of class <span class="machine"><span class="font-tt">stack</span></span>:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a, 'b] stack2 =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> ['a] stack
      <span class="ocamlkeyword">method</span> fold f (x : 'b) = List.fold_left f x l
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a, 'b] stack2 :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : 'a list
    <span class="ocamlkeyword">method</span> clear : unit
    <span class="ocamlkeyword">method</span> fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
    <span class="ocamlkeyword">method</span> length : int
    <span class="ocamlkeyword">method</span> pop : 'a
    <span class="ocamlkeyword">method</span> push : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

However, the method <span class="machine"><span class="font-tt">fold</span></span> of a given object can only be
applied to functions that all have the same type:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> s = <span class="ocamlkeyword">new</span> stack2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> s : ('_weak1, '_weak2) stack2 = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> s#fold ( + ) 0;;</div>



<div class="pre caml-output ok">- : int = 0</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> s;;</div>



<div class="pre caml-output ok">- : (int, int) stack2 = &lt;obj&gt;</div></div>

</div><p>

A better solution is to use polymorphic methods, which were
introduced in OCaml version 3.05. Polymorphic methods makes
it possible to treat the type variable <span class="machine"><span class="font-tt">'b</span></span> in the type of <span class="machine"><span class="font-tt">fold</span></span> as
universally quantified, giving <span class="machine"><span class="font-tt">fold</span></span> the polymorphic type
<span class="machine"><span class="font-tt">Forall 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</span></span>.
An explicit type declaration on the method <span class="machine"><span class="font-tt">fold</span></span> is required, since
the type checker cannot infer the polymorphic type by itself.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a] stack3 =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> ['a] stack
      <span class="ocamlkeyword">method</span> fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
                  = <span class="ocamlkeyword">fun</span> f x -&gt; List.fold_left f x l
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] stack3 :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : 'a list
    <span class="ocamlkeyword">method</span> clear : unit
    <span class="ocamlkeyword">method</span> fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
    <span class="ocamlkeyword">method</span> length : int
    <span class="ocamlkeyword">method</span> pop : 'a
    <span class="ocamlkeyword">method</span> push : 'a -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC subsection id="ss:hashtbl-as-class" 8.2.2â€ƒHashtbl-->
<h3 class="subsection" id="ss:hashtbl-as-class"><a class="section-anchor" href="#ss:hashtbl-as-class" aria-hidden="true">ï»¿</a>8.2.2â€ƒHashtbl</h3><!--SEC END --><p>A simplified version of object-oriented hash tables should have the
following class type.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> ['a, 'b] hash_table =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> find : 'a -&gt; 'b
      <span class="ocamlkeyword">method</span> add : 'a -&gt; 'b -&gt; unit
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> ['a, 'b] hash_table =
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> add : 'a -&gt; 'b -&gt; unit <span class="ocamlkeyword">method</span> find : 'a -&gt; 'b <span class="ocamlkeyword">end</span></div></div>

</div><p>

A simple implementation, which is quite reasonable for small hash tables is
to use an association list:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a, 'b] small_hashtbl : ['a, 'b] hash_table =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> table = []
      <span class="ocamlkeyword">method</span> find key = List.assoc key table
      <span class="ocamlkeyword">method</span> add key value = table &lt;- (key, value) :: table
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a, 'b] small_hashtbl : ['a, 'b] hash_table</div></div>

</div><p>

A better implementation, and one that scales up better, is to use a
true hash tableâ€¦ whose elements are small hash tables!

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['a, 'b] hashtbl size : ['a, 'b] hash_table =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">val</span> table = Array.init size (<span class="ocamlkeyword">fun</span> i -&gt; <span class="ocamlkeyword">new</span> small_hashtbl)
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">private</span> hash key =
        (Hashtbl.hash key) <span class="ocamlkeyword">mod</span> (Array.length table)
      <span class="ocamlkeyword">method</span> find key = table.(self#hash key) # find key
      <span class="ocamlkeyword">method</span> add key = table.(self#hash key) # add key
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a, 'b] hashtbl : int -&gt; ['a, 'b] hash_table</div></div>

</div>
<!--TOC subsection id="ss:set-as-class" 8.2.3â€ƒSets-->
<h3 class="subsection" id="ss:set-as-class"><a class="section-anchor" href="#ss:set-as-class" aria-hidden="true">ï»¿</a>8.2.3â€ƒSets</h3><!--SEC END --><p>Implementing sets leads to another difficulty. Indeed, the method
<span class="machine"><span class="font-tt">union</span></span> needs to be able to access the internal representation of
another object of the same class.</p><p>This is another instance of friend functions as seen in
sectionÂ <a href="#s%3Afriends">3.17</a>. Indeed, this is the same mechanism used in the module
<span class="machine"><span class="font-tt">Set</span></span> in the absence of objects.</p><p>In the object-oriented version of sets, we only need to add an additional
method <span class="machine"><span class="font-tt">tag</span></span> to return the representation of a set. Since sets are
parametric in the type of elements, the method <span class="machine"><span class="font-tt">tag</span></span> has a parametric type
<span class="machine"><span class="font-tt">'a tag</span></span>, concrete within
the module definition but abstract in its signature.
From outside, it will then be guaranteed that two objects with a method <span class="machine"><span class="font-tt">tag</span></span>
of the same type will share the same representation.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> SET =
    <span class="ocamlkeyword">sig</span>
      <span class="ocamlkeyword">type</span> 'a tag
      <span class="ocamlkeyword">class</span> ['a] c :
        <span class="ocamlkeyword">object</span> ('b)
          <span class="ocamlkeyword">method</span> is_empty : bool
          <span class="ocamlkeyword">method</span> mem : 'a -&gt; bool
          <span class="ocamlkeyword">method</span> add : 'a -&gt; 'b
          <span class="ocamlkeyword">method</span> union : 'b -&gt; 'b
          <span class="ocamlkeyword">method</span> iter : ('a -&gt; unit) -&gt; unit
          <span class="ocamlkeyword">method</span> tag : 'a tag
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> Set : SET =
    <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> merge l1 l2 =
        <span class="ocamlkeyword">match</span> l1 <span class="ocamlkeyword">with</span>
          [] -&gt; l2
        | h1 :: t1 -&gt;
            <span class="ocamlkeyword">match</span> l2 <span class="ocamlkeyword">with</span>
              [] -&gt; l1
            | h2 :: t2 -&gt;
                <span class="ocamlkeyword">if</span> h1 &lt; h2 <span class="ocamlkeyword">then</span> h1 :: merge t1 l2
                <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">if</span> h1 &gt; h2 <span class="ocamlkeyword">then</span> h2 :: merge l1 t2
                <span class="ocamlkeyword">else</span> merge t1 l2
      <span class="ocamlkeyword">type</span> 'a tag = 'a list
      <span class="ocamlkeyword">class</span> ['a] c =
        <span class="ocamlkeyword">object</span> (_ : 'b)
          <span class="ocamlkeyword">val</span> repr = ([] : 'a list)
          <span class="ocamlkeyword">method</span> is_empty = (repr = [])
          <span class="ocamlkeyword">method</span> mem x = List.exists (( = ) x) repr
          <span class="ocamlkeyword">method</span> add x = {&lt; repr = merge [x] repr &gt;}
          <span class="ocamlkeyword">method</span> union (s : 'b) = {&lt; repr = merge repr s#tag &gt;}
          <span class="ocamlkeyword">method</span> iter (f : 'a -&gt; unit) = List.iter f repr
          <span class="ocamlkeyword">method</span> tag = repr
        <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">end</span>;;</div></div>

</div>
<!--TOC section id="s:subject-observer" 8.3â€ƒThe subject/observer pattern-->
<h2 class="section" id="s:subject-observer"><a class="section-anchor" href="#s:subject-observer" aria-hidden="true">ï»¿</a>8.3â€ƒThe subject/observer pattern</h2><!--SEC END --><p>The following example, known as the subject/observer pattern, is often
presented in the literature as a difficult inheritance problem with
inter-connected classes.
The general pattern amounts to the definition a pair of two
classes that recursively interact with one another.</p><p>The class <span class="machine"><span class="font-tt">observer</span></span> has a distinguished method <span class="machine"><span class="font-tt">notify</span></span> that requires
two arguments, a subject and an event to execute an action.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> ['subject, 'event] observer =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> notify : 'subject -&gt;  'event -&gt; unit
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">virtual</span> ['subject, 'event] observer :
  <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> <span class="ocamlkeyword">virtual</span> notify : 'subject -&gt; 'event -&gt; unit <span class="ocamlkeyword">end</span></div></div>

</div><p>

The class <span class="machine"><span class="font-tt">subject</span></span> remembers a list of observers in an instance variable,
and has a distinguished method <span class="machine"><span class="font-tt">notify_observers</span></span> to broadcast the message
<span class="machine"><span class="font-tt">notify</span></span> to all observers with a particular event <span class="machine"><span class="font-tt">e</span></span>.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['observer, 'event] subject =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> observers = ([]:'observer list)
      <span class="ocamlkeyword">method</span> add_observer obs = observers &lt;- (obs :: observers)
      <span class="ocamlkeyword">method</span> notify_observers (e : 'event) =
          List.iter (<span class="ocamlkeyword">fun</span> x -&gt; x#notify self e) observers
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a, 'event] subject :
  <span class="ocamlkeyword">object</span> ('b)
    <span class="ocamlkeyword">constraint</span> 'a = &lt; notify : 'b -&gt; 'event -&gt; unit; .. &gt;
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> observers : 'a list
    <span class="ocamlkeyword">method</span> add_observer : 'a -&gt; unit
    <span class="ocamlkeyword">method</span> notify_observers : 'event -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

The difficulty usually lies in defining instances of the pattern above
by inheritance. This can be done in a natural and obvious manner in
OCaml, as shown on the following example manipulating windows.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> event = Raise | Resize | Move;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> event = Raise | Resize | Move</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> string_of_event = <span class="ocamlkeyword">function</span>
      Raise -&gt; <span class="ocamlstring">"Raise"</span> | Resize -&gt; <span class="ocamlstring">"Resize"</span> | Move -&gt; <span class="ocamlstring">"Move"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> string_of_event : event -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> count = <span class="ocamlkeyword">ref</span> 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> count : int <span class="ocamlkeyword">ref</span> = {contents = 0}</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['observer] window_subject =
    <span class="ocamlkeyword">let</span> id = count := succ !count; !count <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> ['observer, event] subject
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> position = 0
      <span class="ocamlkeyword">method</span> identity = id
      <span class="ocamlkeyword">method</span> move x = position &lt;- position + x; self#notify_observers Move
      <span class="ocamlkeyword">method</span> draw = Printf.printf <span class="ocamlstring">"{Position = %d}\n"</span>  position;
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] window_subject :
  <span class="ocamlkeyword">object</span> ('b)
    <span class="ocamlkeyword">constraint</span> 'a = &lt; notify : 'b -&gt; event -&gt; unit; .. &gt;
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> observers : 'a list
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> position : int
    <span class="ocamlkeyword">method</span> add_observer : 'a -&gt; unit
    <span class="ocamlkeyword">method</span> draw : unit
    <span class="ocamlkeyword">method</span> identity : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> notify_observers : event -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['subject] window_observer =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> ['subject, event] observer
      <span class="ocamlkeyword">method</span> notify s e = s#draw
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] window_observer :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = &lt; draw : unit; .. &gt;
    <span class="ocamlkeyword">method</span> notify : 'a -&gt; event -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

As can be expected, the type of <span class="machine"><span class="font-tt">window</span></span> is recursive.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> window = <span class="ocamlkeyword">new</span> window_subject;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> window : &lt; notify : 'a -&gt; event -&gt; unit; _.. &gt; window_subject <span class="ocamlkeyword">as</span> 'a =
  &lt;obj&gt;</div></div>

</div><p>

However, the two classes of <span class="machine"><span class="font-tt">window_subject</span></span> and <span class="machine"><span class="font-tt">window_observer</span></span> are not
mutually recursive.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> window_observer = <span class="ocamlkeyword">new</span> window_observer;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> window_observer : &lt; draw : unit; _.. &gt; window_observer = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> window#add_observer window_observer;;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> window#move 1;;</div>



<div class="pre caml-output ok">{Position = 1}
- : unit = ()</div></div>

</div><p>Classes <span class="machine"><span class="font-tt">window_observer</span></span> and <span class="machine"><span class="font-tt">window_subject</span></span> can still be extended by
inheritance. For instance, one may enrich the <span class="machine"><span class="font-tt">subject</span></span> with new
behaviors and refine the behavior of the observer.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['observer] richer_window_subject =
    <span class="ocamlkeyword">object</span> (self)
      <span class="ocamlkeyword">inherit</span> ['observer] window_subject
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> size = 1
      <span class="ocamlkeyword">method</span> resize x = size &lt;- size + x; self#notify_observers Resize
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> top = <span class="ocamlkeyword">false</span>
      <span class="ocamlkeyword">method</span> raise = top &lt;- <span class="ocamlkeyword">true</span>; self#notify_observers Raise
      <span class="ocamlkeyword">method</span> draw = Printf.printf <span class="ocamlstring">"{Position = %d; Size = %d}\n"</span>  position size;
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] richer_window_subject :
  <span class="ocamlkeyword">object</span> ('b)
    <span class="ocamlkeyword">constraint</span> 'a = &lt; notify : 'b -&gt; event -&gt; unit; .. &gt;
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> observers : 'a list
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> position : int
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> size : int
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> top : bool
    <span class="ocamlkeyword">method</span> add_observer : 'a -&gt; unit
    <span class="ocamlkeyword">method</span> draw : unit
    <span class="ocamlkeyword">method</span> identity : int
    <span class="ocamlkeyword">method</span> move : int -&gt; unit
    <span class="ocamlkeyword">method</span> notify_observers : event -&gt; unit
    <span class="ocamlkeyword">method</span> raise : unit
    <span class="ocamlkeyword">method</span> resize : int -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['subject] richer_window_observer =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> ['subject] window_observer <span class="ocamlkeyword">as</span> super
      <span class="ocamlkeyword">method</span> notify s e = <span class="ocamlkeyword">if</span> e &lt;&gt; Raise <span class="ocamlkeyword">then</span> s#raise; super#notify s e
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] richer_window_observer :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = &lt; draw : unit; raise : unit; .. &gt;
    <span class="ocamlkeyword">method</span> notify : 'a -&gt; event -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

We can also create a different kind of observer:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> ['subject] trace_observer =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">inherit</span> ['subject, event] observer
      <span class="ocamlkeyword">method</span> notify s e =
        Printf.printf
          <span class="ocamlstring">"&lt;Window %d &lt;== %s&gt;\n"</span> s#identity (string_of_event e)
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> ['a] trace_observer :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">constraint</span> 'a = &lt; identity : int; .. &gt;
    <span class="ocamlkeyword">method</span> notify : 'a -&gt; event -&gt; unit
  <span class="ocamlkeyword">end</span></div></div>

</div><p>

and attach several observers to the same object:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> window = <span class="ocamlkeyword">new</span> richer_window_subject;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> window :
  &lt; notify : 'a -&gt; event -&gt; unit; _.. &gt; richer_window_subject <span class="ocamlkeyword">as</span> 'a = &lt;obj&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> window#add_observer (<span class="ocamlkeyword">new</span> richer_window_observer);;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> window#add_observer (<span class="ocamlkeyword">new</span> trace_observer);;</div>



<div class="pre caml-output ok">- : unit = ()</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> window#move 1; window#resize 2;;</div>



<div class="pre caml-output ok">&lt;Window 1 &lt;== Move&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 1}
{Position = 1; Size = 1}
&lt;Window 1 &lt;== Resize&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 3}
{Position = 1; Size = 3}
- : unit = ()</div></div>

</div>
<!--TOC chapter id="sec79" ChapterÂ 9â€ƒParallel programming-->
<h1 class="chapter" id="sec79">ChapterÂ 9â€ƒParallel programming</h1><!--SEC END --><!--NAME parallelism.html-->
<p>
<a id="c:parallelism"></a></p><p>In this chapter, we shall look at the parallel programming facilities in OCaml.
The OCaml standard library exposes low-level primitives for parallel
programming. We recommend the users to utilise higher-level parallel
programming libraries such as
<a href="https://github.com/ocaml-multicore/domainslib">domainslib</a>. This
tutorial will first cover the high-level parallel programming using domainslib
followed by low-level primitives exposed by the compiler.</p><p>OCaml distinguishes concurrency and parallelism and provides distinct
mechanisms for expressing them. Concurrency is overlapped execution of tasks
(section <a href="#s%3Aeffects-concurrency">12.24.2</a>) whereas parallelism is simultaneous
execution of tasks. In particular, parallel tasks overlap in time but
concurrent tasks may or may not overlap in time. Tasks may execute concurrently
by yielding control to each other. While concurrency is a program structuring
mechanism, parallelism is a mechanism to make your programs run faster. If you
are interested in the concurrent programming mechanisms in OCaml, please refer
to the section <a href="#s%3Aeffect-handlers">12.24</a> on effect handlers and the chapter
<a href="#c%3Athreads">33</a> on the threads library.</p>
<!--TOC section id="s:par_domains" 9.1â€ƒDomains-->
<h2 class="section" id="s:par_domains"><a class="section-anchor" href="#s:par_domains" aria-hidden="true">ï»¿</a>9.1â€ƒDomains</h2><!--SEC END --><p>Domains are the units of parallelism in OCaml. The module <a href="libref/Domain.html"><span class="font-tt">Domain</span></a>
provides the primitives to create and manage domains. New domains can be
spawned using the <span class="machine"><span class="font-tt">spawn</span></span> function.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; print_endline <span class="ocamlstring">"I ran in parallel"</span>)</div>



<div class="pre caml-output ok">I ran <span class="ocamlkeyword">in</span> parallel
- : unit Domain.t = &lt;abstr&gt;</div></div>

</div><p>The <span class="machine"><span class="font-tt">spawn</span></span> function executes the given computation in parallel with
the calling domain.</p><p>Domains are heavy-weight entities. Each domain maps 1:1 to an operating system
thread. Each domain also has its own runtime state, which includes domain-local
structures for allocating memory. Hence, they are relatively expensive to
create and tear down.</p><p><em><span class="font-bold">It is recommended that the programs do not spawn more domains
than cores available</span></em>.</p><p>In this tutorial, we shall be implementing, running and measuring the
performance of parallel programs. The results observed are dependent on the
number of cores available on the target machine. This tutorial is being written
on a 2.3 GHz Quad-Core Intel Core i7 MacBook Pro with 4 cores and 8 hardware
threads. It is reasonable to expect roughly 4x performance on 4 domains for
parallel programs with little coordination between the domains, and when the
machine is not under load. Beyond 4 domains, the speedup is likely to be less
than linear. We shall also use the command-line benchmarking tool
<a href="https://github.com/sharkdp/hyperfine">hyperfine</a> for benchmarking our
programs.</p>
<!--TOC subsection id="s:par_join" 9.1.1â€ƒJoining domains-->
<h3 class="subsection" id="s:par_join"><a class="section-anchor" href="#s:par_join" aria-hidden="true">ï»¿</a>9.1.1â€ƒJoining domains</h3><!--SEC END --><p>We shall use the program to compute the nth Fibonacci number using recursion as
a running example. The sequential program for computing the nth Fibonacci
number is given below.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n = <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> fib (n - 1) + fib (n - 2)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = fib n <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><p>The program can be compiled and benchmarked as follows.</p><pre>$ ocamlopt -o fib.exe fib.ml
$ ./fib.exe 42
fib(42) = 433494437
$ hyperfine './fib.exe 42' # Benchmarking
Benchmark 1: ./fib.exe 42
  Time (mean Â± sd):     1.193 s Â±  0.006 s    [User: 1.186 s, System: 0.003 s]
  Range (min â€¦ max):    1.181 s â€¦  1.202 s    10 runs
</pre><p>
We see that it takes around 1.2 seconds to compute the 42nd Fibonacci number.</p><p>Spawned domains can be joined using the <span class="machine"><span class="font-tt">join</span></span> function to get their results.
The <span class="machine"><span class="font-tt">join</span></span> function waits for target domain to terminate. The following program
computes the nth Fibonacci number twice in parallel.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib_twice.ml *)</span>
<span class="ocamlkeyword">let</span> n = int_of_string Sys.argv.(1)

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n = <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> fib (n - 1) + fib (n - 2)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> d1 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib n) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> d2 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib n) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = Domain.join d1 <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r1;
  <span class="ocamlkeyword">let</span> r2 = Domain.join d2 <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r2

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><p>The program spawns two domains which compute the nth Fibonacci number. The
<span class="machine"><span class="font-tt">spawn</span></span> function returns a <span class="machine"><span class="font-tt">Domain.t</span></span> value which can be joined to get the
result of the parallel computation. The <span class="machine"><span class="font-tt">join</span></span> function blocks until the
computation runs to completion.</p><pre>$ ocamlopt -o fib_twice.exe fib_twice.ml
$ ./fib_twice.exe 42
fib(42) = 433494437
fib(42) = 433494437
$ hyperfine './fib_twice.exe 42'
Benchmark 1: ./fib_twice.exe 42
  Time (mean Â± sd):     1.249 s Â±  0.025 s    [User: 2.451 s, System: 0.012 s]
  Range (min â€¦ max):    1.221 s â€¦  1.290 s    10 runs
</pre><p>
As one can see that computing the nth Fibonacci number twice almost took the
same time as computing it once thanks to parallelism.</p>
<!--TOC section id="s:par_parfib" 9.2â€ƒDomainslib: A library for nested-parallel programming-->
<h2 class="section" id="s:par_parfib"><a class="section-anchor" href="#s:par_parfib" aria-hidden="true">ï»¿</a>9.2â€ƒDomainslib: A library for nested-parallel programming</h2><!--SEC END --><p>Let us attempt to parallelise the Fibonacci function. The two recursive calls
may be executed in parallel. However, naively parallelising the recursive calls
by spawning domains for each one will not work as it spawns too many domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib_par1.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n =
  <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">begin</span>
    <span class="ocamlkeyword">let</span> d1 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib (n - 1)) <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> d2 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib (n - 2)) <span class="ocamlkeyword">in</span>
    Domain.join d1 + Domain.join d2
  <span class="ocamlkeyword">end</span>

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = fib n <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r

<span class="ocamlkeyword">let</span> _ = main ()</div>



<div class="pre caml-output ok">fib(1) = 1
<span class="ocamlkeyword">val</span> n : int = 1
<span class="ocamlkeyword">val</span> fib : int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> main : unit -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><pre>$ ocamlopt -o fib_par1.exe fib_par1.ml
$ ./fib_par1.exe 42
Fatal error: exception Failure("failed to allocate domain")
</pre><p>
OCaml has a limit of 128 domains that can be active at the same time. An
attempt to spawn more domains will raise an exception. How then can we
parallelise the Fibonacci function?</p>
<!--TOC subsection id="s:par_parfib_domainslib" 9.2.1â€ƒParallelising Fibonacci using domainslib-->
<h3 class="subsection" id="s:par_parfib_domainslib"><a class="section-anchor" href="#s:par_parfib_domainslib" aria-hidden="true">ï»¿</a>9.2.1â€ƒParallelising Fibonacci using domainslib</h3><!--SEC END --><p>The OCaml standard library provides only low-level primitives for concurrent
and parallel programming, leaving high-level programming libraries to be
developed and distributed outside the core compiler distribution.
<a href="https://github.com/ocaml-multicore/domainslib">Domainslib</a> is such a
library for nested-parallel programming, which is epitomised by the parallelism
available in the recursive Fibonacci computation. Let us use domainslib to
parallelise the recursive Fibonacci program. It is recommended that you install
domainslib using the <a href="https://opam.ocaml.org/">opam</a> package manager. This
tutorial uses domainslib version 0.4.2.</p><p>Domainslib provides an async/await mechanism for spawning parallel tasks and
awaiting their results. On top of this mechanism, domainslib provides parallel
iterators. At its core, domainslib has an efficient implementation of
work-stealing queue in order to efficiently share tasks with other domains. A
parallel implementation of the Fibonacci program is given below.</p><pre>(* fib_par2.ml *)
let num_domains = int_of_string Sys.argv.(1)
let n = int_of_string Sys.argv.(2)

let rec fib n = if n &lt; 2 then 1 else fib (n - 1) + fib (n - 2)

module T = Domainslib.Task

let rec fib_par pool n =
  if n &gt; 20 then begin
    let a = T.async pool (fun _ -&gt; fib_par pool (n-1)) in
    let b = T.async pool (fun _ -&gt; fib_par pool (n-2)) in
    T.await pool a + T.await pool b
  end else fib n

let main () =
  let pool = T.setup_pool ~num_additional_domains:(num_domains - 1) () in
  let res = T.run pool (fun _ -&gt; fib_par pool n) in
  T.teardown_pool pool;
  Printf.printf "fib(%d) = %d\n" n res

let _ = main ()
</pre><p>
The program takes the number of domains and the input to the Fibonacci function
as the first and the second command-line arguments respectively.</p><p>Let us start with the main function. First, we set up a pool of domains on which
the nested parallel tasks will run. The domain invoking the <span class="machine"><span class="font-tt">run</span></span> function will
also participate in executing the tasks submitted to the pool. We invoke the
parallel Fibonacci function <span class="machine"><span class="font-tt">fib_par</span></span> in the <span class="machine"><span class="font-tt">run</span></span> function. Finally, we tear
down the pool and print the result.</p><p>For sufficiently large inputs (<span class="machine"><span class="font-tt">n &gt; 20</span></span>), the <span class="machine"><span class="font-tt">fib_par</span></span> function spawns the
left and the right recursive calls asynchronously in the pool using the <span class="machine"><span class="font-tt">async</span></span>
function. The <span class="machine"><span class="font-tt">async</span></span> function returns a promise for the result. The result of
an asynchronous computation is obtained by awaiting the promise using the
<span class="machine"><span class="font-tt">await</span></span> function. The <span class="machine"><span class="font-tt">await</span></span> function call blocks until the promise is
resolved.</p><p>For small inputs, the <span class="machine"><span class="font-tt">fib_par</span></span> function simply calls the sequential Fibonacci
function <span class="machine"><span class="font-tt">fib</span></span>. It is important to switch to sequential mode for small problem
sizes. If not, the cost of parallelisation will outweigh the work available.</p><p>For simplicity, we use <span class="machine"><span class="font-tt">ocamlfind</span></span> to compile this program. It is recommended
that the users use <a href="https://github.com/ocaml/dune">dune</a> to build their
programs that utilise libraries installed through
<a href="https://opam.ocaml.org/">opam</a>.</p><pre>$ ocamlfind ocamlopt -package domainslib -linkpkg -o fib_par2.exe fib_par2.ml
$ ./fib_par2.exe 1 42
fib(42) = 433494437
$ hyperfine './fib.exe 42' './fib_par2.exe 2 42' \
            './fib_par2.exe 4 42' './fib_par2.exe 8 42'
Benchmark 1: ./fib.exe 42
  Time (mean Â± sd):     1.217 s Â±  0.018 s    [User: 1.203 s, System: 0.004 s]
  Range (min â€¦ max):    1.202 s â€¦  1.261 s    10 runs

Benchmark 2: ./fib_par2.exe 2 42
  Time (mean Â± sd):    628.2 ms Â±   2.9 ms    [User: 1243.1 ms, System: 4.9 ms]
  Range (min â€¦ max):   625.7 ms â€¦ 634.5 ms    10 runs

Benchmark 3: ./fib_par2.exe 4 42
  Time (mean Â± sd):    337.6 ms Â±  23.4 ms    [User: 1321.8 ms, System: 8.4 ms]
  Range (min â€¦ max):   318.5 ms â€¦ 377.6 ms    10 runs

Benchmark 4: ./fib_par2.exe 8 42
  Time (mean Â± sd):    250.0 ms Â±   9.4 ms    [User: 1877.1 ms, System: 12.6 ms]
  Range (min â€¦ max):   242.5 ms â€¦ 277.3 ms    11 runs

Summary
  './fib_par2.exe 8 42' ran
    1.35 Â± 0.11 times faster than './fib_par2.exe 4 42'
    2.51 Â± 0.10 times faster than './fib_par2.exe 2 42'
    4.87 Â± 0.20 times faster than './fib.exe 42'
</pre><p>
The results show that, with 8 domains, the parallel Fibonacci program runs 4.87
times faster than the sequential version.</p>
<!--TOC subsection id="s:par_iterators" 9.2.2â€ƒParallel iteration constructs-->
<h3 class="subsection" id="s:par_iterators"><a class="section-anchor" href="#s:par_iterators" aria-hidden="true">ï»¿</a>9.2.2â€ƒParallel iteration constructs</h3><!--SEC END --><p>Many numerical algorithms use for-loops. The parallel-for primitive provides a
straight-forward way to parallelise such code. Let us take the
<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/spectralnorm.html#spectralnorm">spectral-norm</a>
benchmark from the computer language benchmarks game and parallelise it. The
sequential version of the program is given below.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* spectralnorm.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 32

<span class="ocamlkeyword">let</span> eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

<span class="ocamlkeyword">let</span> eval_A_times_u u v =
  <span class="ocamlkeyword">let</span> n = Array.length v - 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i = 0 <span class="ocamlkeyword">to</span>  n <span class="ocamlkeyword">do</span>
    <span class="ocamlkeyword">let</span> vi = <span class="ocamlkeyword">ref</span> 0. <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">for</span> j = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> vi := !vi +. eval_A i j *. u.(j) <span class="ocamlkeyword">done</span>;
    v.(i) &lt;- !vi
  <span class="ocamlkeyword">done</span>

<span class="ocamlkeyword">let</span> eval_At_times_u u v =
  <span class="ocamlkeyword">let</span> n = Array.length v - 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span>
    <span class="ocamlkeyword">let</span> vi = <span class="ocamlkeyword">ref</span> 0. <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">for</span> j = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> vi := !vi +. eval_A j i *. u.(j) <span class="ocamlkeyword">done</span>;
    v.(i) &lt;- !vi
  <span class="ocamlkeyword">done</span>

<span class="ocamlkeyword">let</span> eval_AtA_times_u u v =
  <span class="ocamlkeyword">let</span> w = Array.make (Array.length u) 0.0 <span class="ocamlkeyword">in</span>
  eval_A_times_u u w; eval_At_times_u w v

<span class="ocamlkeyword">let</span> () =
  <span class="ocamlkeyword">let</span> u = Array.make n 1.0  <span class="ocamlkeyword">and</span>  v = Array.make n 0.0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> _i = 0 <span class="ocamlkeyword">to</span> 9 <span class="ocamlkeyword">do</span>
    eval_AtA_times_u u v; eval_AtA_times_u v u
  <span class="ocamlkeyword">done</span>;

  <span class="ocamlkeyword">let</span> vv = <span class="ocamlkeyword">ref</span> 0.0  <span class="ocamlkeyword">and</span>  vBv = <span class="ocamlkeyword">ref</span> 0.0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i=0 <span class="ocamlkeyword">to</span> n-1 <span class="ocamlkeyword">do</span>
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  <span class="ocamlkeyword">done</span>;
  Printf.printf <span class="ocamlstring">"%0.9f\n"</span> (sqrt(!vBv /. !vv))</div></div>

</div><p>Observe that the program has nested loops in <span class="machine"><span class="font-tt">eval_A_times_u</span></span> and
<span class="machine"><span class="font-tt">eval_At_times_u</span></span>. Each iteration of the outer loop body reads from <span class="machine"><span class="font-tt">u</span></span> but
writes to disjoint memory locations in <span class="machine"><span class="font-tt">v</span></span>. Hence, the iterations of the outer
loop are not dependent on each other and can be executed in parallel.</p><p>The parallel version of spectral norm is shown below.</p><pre>(* spectralnorm_par.ml *)
let num_domains = try int_of_string Sys.argv.(1) with _ -&gt; 1
let n = try int_of_string Sys.argv.(2) with _ -&gt; 32

let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

module T = Domainslib.Task

let eval_A_times_u pool u v =
  let n = Array.length v - 1 in
  T.parallel_for pool ~start:0 ~finish:n ~body:(fun i -&gt;
    let vi = ref 0. in
    for j = 0 to n do vi := !vi +. eval_A i j *. u.(j) done;
    v.(i) &lt;- !vi
  )

let eval_At_times_u pool u v =
  let n = Array.length v - 1 in
  T.parallel_for pool ~start:0 ~finish:n ~body:(fun i -&gt;
    let vi = ref 0. in
    for j = 0 to n do vi := !vi +. eval_A j i *. u.(j) done;
    v.(i) &lt;- !vi
  )

let eval_AtA_times_u pool u v =
  let w = Array.make (Array.length u) 0.0 in
  eval_A_times_u pool u w; eval_At_times_u pool w v

let () =
  let pool = T.setup_pool ~num_additional_domains:(num_domains - 1) () in
  let u = Array.make n 1.0  and  v = Array.make n 0.0 in
  T.run pool (fun _ -&gt;
  for _i = 0 to 9 do
    eval_AtA_times_u pool u v; eval_AtA_times_u pool v u
  done);

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  done;
  T.teardown_pool pool;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))
</pre><p>
Observe that the <span class="machine"><span class="font-tt">parallel_for</span></span> function is isomorphic to the for-loop in the
sequential version. No other change is required except for the boiler plate
code to set up and tear down the pools.</p><pre>$ ocamlopt -o spectralnorm.exe spectralnorm.ml
$ ocamlfind ocamlopt -package domainslib -linkpkg -o spectralnorm_par.exe \
  spectralnorm_par.ml
$ hyperfine './spectralnorm.exe 4096' './spectralnorm_par.exe 2 4096' \
            './spectralnorm_par.exe 4 4096' './spectralnorm_par.exe 8 4096'
Benchmark 1: ./spectralnorm.exe 4096
  Time (mean Â± sd):     1.989 s Â±  0.013 s    [User: 1.972 s, System: 0.007 s]
  Range (min â€¦ max):    1.975 s â€¦  2.018 s    10 runs

Benchmark 2: ./spectralnorm_par.exe 2 4096
  Time (mean Â± sd):     1.083 s Â±  0.015 s    [User: 2.140 s, System: 0.009 s]
  Range (min â€¦ max):    1.064 s â€¦  1.102 s    10 runs

Benchmark 3: ./spectralnorm_par.exe 4 4096
  Time (mean Â± sd):    698.7 ms Â±  10.3 ms    [User: 2730.8 ms, System: 18.3 ms]
  Range (min â€¦ max):   680.9 ms â€¦ 721.7 ms    10 runs

Benchmark 4: ./spectralnorm_par.exe 8 4096
  Time (mean Â± sd):    921.8 ms Â±  52.1 ms    [User: 6711.6 ms, System: 51.0 ms]
  Range (min â€¦ max):   838.6 ms â€¦ 989.2 ms    10 runs

Summary
  './spectralnorm_par.exe 4 4096' ran
    1.32 Â± 0.08 times faster than './spectralnorm_par.exe 8 4096'
    1.55 Â± 0.03 times faster than './spectralnorm_par.exe 2 4096'
    2.85 Â± 0.05 times faster than './spectralnorm.exe 4096'
</pre><p>
On the authorâ€™s machine, the program scales reasonably well up to 4 domains but
performs worse with 8 domains. Recall that the machine only has 4 physical
cores. Debugging and fixing this performance issue is beyond the scope of this
tutorial.</p>
<!--TOC section id="s:par_gc" 9.3â€ƒParallel garbage collection-->
<h2 class="section" id="s:par_gc"><a class="section-anchor" href="#s:par_gc" aria-hidden="true">ï»¿</a>9.3â€ƒParallel garbage collection</h2><!--SEC END --><p>An important aspect of the scalability of parallel OCaml programs is the
scalability of the garbage collector (GC). The OCaml GC is designed to have
both low latency and good parallel scalability. OCaml has a generational
garbage collector with a small minor heap and a large major heap. New objects
(upto a certain size) are allocated in the minor heap. Each domain has its own
domain-local minor heap arena into which new objects are allocated without
synchronising with the other domains. When a domain exhausts its minor heap
arena, it calls for a stop-the-world collection of the minor heaps. In the
stop-the-world section, all the domains collect their minor heap arenas in
parallel evacuating the survivors to the major heap.</p><p>For the major heap, each domain maintains domain-local, size-segmented pools of
memory into which large objects and survivors from the minor collection are
allocated. Having domain-local pools avoids synchronisation for most major heap
allocations. The major heap is collected by a concurrent mark-and-sweep
algorithm that involves a few short stop-the-world pauses for each major cycle.</p><p>Overall, the users should expect the garbage collector to scale well with
increasing number of domains, with the latency remaining low. For more
information on the design and evaluation of the garbage collector, please have
a look at the ICFP 2020 paper on
<a href="https://arxiv.org/abs/2004.11663"><span class="machine"><span class="font-tt">Retrofitting Parallelism onto OCaml</span></span></a>.</p>
<!--TOC section id="s:par_mm_easy" 9.4â€ƒMemory model: The easy bits-->
<h2 class="section" id="s:par_mm_easy"><a class="section-anchor" href="#s:par_mm_easy" aria-hidden="true">ï»¿</a>9.4â€ƒMemory model: The easy bits</h2><!--SEC END --><p>Modern processors and compilers aggressively optimise programs. These
optimisations accelerate without otherwise affecting sequential programs, but
cause surprising behaviours to be visible in parallel programs. To benefit from
these optimisations, OCaml adopts a <span class="font-it">relaxed memory model</span> that precisely
specifies which of these <em>relaxed behaviours</em> programs may observe. While
these models are difficult to program against directly, the OCaml memory model
provides recipes that retain the simplicity of sequential reasoning.</p><p>Firstly, immutable values may be freely shared between multiple domains and may
be accessed in parallel. For mutable data structures such as reference cells,
arrays and mutable record fields, programmers should avoid <em>data races</em>.
Reference cells, arrays and mutable record fields are said to be
<em>non-atomic</em> data structures. A data race is said to occur when two
domains concurrently access a non-atomic memory location without
<em>synchronisation</em> and at least one of the accesses is a write. OCaml
provides a number of ways to introduce synchronisation including atomic
variables (section <a href="#s%3Apar_atomics">9.7</a>) and mutexes (section <a href="#s%3Apar_sync">9.5</a>).</p><p>Importantly, <span class="font-bold">for data race free (DRF) programs, OCaml provides
sequentially consistent (SC) semantics</span> â€“ the observed behaviour of such
programs can be explained by the interleaving of operations from different
domains. This property is known as DRF-SC guarantee. Moreover, in OCaml, DRF-SC
guarantee is modular â€“ if a part of a program is data race free, then the
OCaml memory model ensures that those parts have sequential consistency despite
other parts of the program having data races. Even for programs with data
races, OCaml provides strong guarantees. While the user may observe non
sequentially consistent behaviours, there are no crashes.</p><p>For more details on the relaxed behaviours in the presence of data races,
please have a look at the chapter on the hard bits of the memory model
(chapter <a href="#c%3Amemorymodel">10</a>).</p>
<!--TOC section id="s:par_sync" 9.5â€ƒBlocking synchronisation-->
<h2 class="section" id="s:par_sync"><a class="section-anchor" href="#s:par_sync" aria-hidden="true">ï»¿</a>9.5â€ƒBlocking synchronisation</h2><!--SEC END --><p>Domains may perform blocking synchronisation with the help of
<a href="libref/Mutex.html"><span class="font-tt">Mutex</span></a>, <a href="libref/Condition.html"><span class="font-tt">Condition</span></a> and <a href="libref/Semaphore.html"><span class="font-tt">Semaphore</span></a>
modules. These modules are the same as those used to synchronise threads
created by the threads library (chapter <a href="#c%3Athreads">33</a>). For clarity, in the
rest of this chapter, we shall call the threads created by the threads library
as <em>systhreads</em>. The following program implements a concurrent stack using
mutex and condition variables.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Blocking_stack : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> make : unit -&gt; 'a t
  <span class="ocamlkeyword">val</span> push : 'a t -&gt; 'a -&gt; unit
  <span class="ocamlkeyword">val</span> pop  : 'a t -&gt; 'a
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = {
    <span class="ocamlkeyword">mutable</span> contents: 'a list;
    mutex : Mutex.t;
    nonempty : Condition.t
  }

  <span class="ocamlkeyword">let</span> make () = {
    contents = [];
    mutex = Mutex.create ();
    nonempty = Condition.create ()
  }

  <span class="ocamlkeyword">let</span> push r v =
    Mutex.lock r.mutex;
    r.contents &lt;- v::r.contents;
    Condition.signal r.nonempty;
    Mutex.unlock r.mutex

  <span class="ocamlkeyword">let</span> pop r =
    Mutex.lock r.mutex;
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> loop () =
      <span class="ocamlkeyword">match</span> r.contents <span class="ocamlkeyword">with</span>
      | [] -&gt;
          Condition.wait r.nonempty r.mutex;
          loop ()
      | x::xs -&gt; r.contents &lt;- xs; x
    <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> res = loop () <span class="ocamlkeyword">in</span>
    Mutex.unlock r.mutex;
    res
<span class="ocamlkeyword">end</span></div></div>

</div><p>The concurrent stack is implemented using a record with three fields: a mutable
field <span class="machine"><span class="font-tt">contents</span></span> which stores the elements in the stack, a <span class="machine"><span class="font-tt">mutex</span></span> to control
access to the <span class="machine"><span class="font-tt">contents</span></span> field, and a condition variable <span class="machine"><span class="font-tt">nonempty</span></span>, which is
used to signal blocked domains waiting for the stack to become non-empty.</p><p>The <span class="machine"><span class="font-tt">push</span></span> operation locks the mutex, updates the <span class="machine"><span class="font-tt">contents</span></span> field with a new
list whose head is the element being pushed and the tail is the old list. The
condition variable <span class="machine"><span class="font-tt">nonempty</span></span> is signalled while the lock is held in order to
wake up any domains waiting on this condition. If there are waiting domains,
one of the domains is woken up. If there are none, then the <span class="machine"><span class="font-tt">signal</span></span> operation
has no effect.</p><p>The <span class="machine"><span class="font-tt">pop</span></span> operation locks the mutex and checks whether the stack is empty. If
so, the calling domain waits on the condition variable <span class="machine"><span class="font-tt">nonempty</span></span> using the
<span class="machine"><span class="font-tt">wait</span></span> primitive. The <span class="machine"><span class="font-tt">wait</span></span> call atomically suspends the execution of the
current domain and unlocks the <span class="machine"><span class="font-tt">mutex</span></span>. When this domain is woken up again
(when the <span class="machine"><span class="font-tt">wait</span></span> call returns), it holds the lock on <span class="machine"><span class="font-tt">mutex</span></span>. The domain tries
to read the contents of the stack again. If the <span class="machine"><span class="font-tt">pop</span></span> operation sees that the
stack is non-empty, it updates the <span class="machine"><span class="font-tt">contents</span></span> to the tail of the old list, and
returns the head.</p><p>The use of <span class="machine"><span class="font-tt">mutex</span></span> to control access to the shared resource <span class="machine"><span class="font-tt">contents</span></span>
introduces sufficient synchronisation between multiple domains using the stack.
Hence, there are no data races when multiple domains use the stack in parallel.</p>
<!--TOC subsection id="s:par_systhread_interaction" 9.5.1â€ƒInteraction with systhreads-->
<h3 class="subsection" id="s:par_systhread_interaction"><a class="section-anchor" href="#s:par_systhread_interaction" aria-hidden="true">ï»¿</a>9.5.1â€ƒInteraction with systhreads</h3><!--SEC END --><p>How do systhreads interact with domains? The systhreads created on a particular
domain remain pinned to that domain. Only one systhread at a time is allowed to
run OCaml code on a particular domain. However, systhreads belonging to a
particular domain may run C library or system code in parallel. Systhreads
belonging to different domains may execute in parallel.</p><p>When using systhreads, the thread created for executing the computation given
to <span class="machine"><span class="font-tt">Domain.spawn</span></span> is also treated as a systhread. For example, the following
program creates in total two domains (including the initial domain) with two
systhreads each (including the initial systhread for each of the domains).</p><pre>(* dom_thr.ml *)
let m = Mutex.create ()
let r = ref None (* protected by m *)

let task () =
  let my_thr_id = Thread.(id (self ())) in
  let my_dom_id :&gt; int = Domain.self () in
  Mutex.lock m;
  begin match !r with
  | None -&gt;
      Printf.printf "Thread %d running on domain %d saw initial write\n%!"
        my_thr_id my_dom_id
  | Some their_thr_id -&gt;
      Printf.printf "Thread %d running on domain %d saw the write by thread %d\n%!"
        my_thr_id my_dom_id their_thr_id;
  end;
  r := Some my_thr_id;
  Mutex.unlock m

let task' () =
  let t = Thread.create task () in
  task ();
  Thread.join t

let main () =
  let d = Domain.spawn task' in
  task' ();
  Domain.join d

let _ = main ()
</pre><pre>$ ocamlopt -I +threads unix.cmxa threads.cmxa -o dom_thr.exe dom_thr.ml
$ ./dom_thr.exe
Thread 1 running on domain 1 saw initial write
Thread 0 running on domain 0 saw the write by thread 1
Thread 2 running on domain 1 saw the write by thread 0
Thread 3 running on domain 0 saw the write by thread 2
</pre><p>
This program uses a shared reference cell protected by a mutex to communicate
between the different systhreads running on two different domains. The
systhread identifiers uniquely identify systhreads in the program. The initial
domain gets the domain id and the thread id as 0. The newly spawned domain gets
domain id as 1.</p>
<!--TOC section id="s:par_c_bindings" 9.6â€ƒInteraction with C bindings-->
<h2 class="section" id="s:par_c_bindings"><a class="section-anchor" href="#s:par_c_bindings" aria-hidden="true">ï»¿</a>9.6â€ƒInteraction with C bindings</h2><!--SEC END --><p>During parallel execution with multiple domains, C code running on a domain may
run in parallel with any C code running in other domains even if neither of
them has released the â€œdomain lockâ€. Prior to OCaml 5.0, C bindings may have
assumed that if the OCaml runtime lock is not released, then it would be safe
to manipulate global C state (e.g. initialise a function-local static value).
This is no longer true in the presence of parallel execution with multiple
domains.</p>
<!--TOC section id="s:par_atomics" 9.7â€ƒAtomics-->
<h2 class="section" id="s:par_atomics"><a class="section-anchor" href="#s:par_atomics" aria-hidden="true">ï»¿</a>9.7â€ƒAtomics</h2><!--SEC END --><p>Mutex, condition variables and semaphores are used to implement blocking
synchronisation between domains. For non-blocking synchronisation, OCaml
provides <a href="libref/Atomic.html"><span class="font-tt">Atomic</span></a> variables. As the name suggests, non-blocking
synchronisation does not provide mechanisms for suspending and waking up
domains. On the other hand, primitives used in non-blocking synchronisation are
often compiled to atomic read-modify-write primitives that the hardware
provides. As an example, the following program increments a non-atomic counter
and an atomic counter in parallel.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* incr.ml *)</span>
<span class="ocamlkeyword">let</span> twice_in_parallel f =
  <span class="ocamlkeyword">let</span> d1 = Domain.spawn f <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> d2 = Domain.spawn f <span class="ocamlkeyword">in</span>
  Domain.join d1;
  Domain.join d2

<span class="ocamlkeyword">let</span> plain_ref n =
  <span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> f () = <span class="ocamlkeyword">for</span> _i=1 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> incr r <span class="ocamlkeyword">done</span> <span class="ocamlkeyword">in</span>
  twice_in_parallel f;
  Printf.printf <span class="ocamlstring">"Non-atomic ref count: %d\n"</span> !r

<span class="ocamlkeyword">let</span> atomic_ref n =
  <span class="ocamlkeyword">let</span> r = Atomic.make 0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> f () = <span class="ocamlkeyword">for</span> _i=1 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> Atomic.incr r <span class="ocamlkeyword">done</span> <span class="ocamlkeyword">in</span>
  twice_in_parallel f;
  Printf.printf <span class="ocamlstring">"Atomic ref count: %d\n"</span> (Atomic.get r)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1 <span class="ocamlkeyword">in</span>
  plain_ref n;
  atomic_ref n

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><pre>$ ocamlopt -o incr.exe incr.ml
$ ./incr.exe 1_000_000
Non-atomic ref count: 1187193
Atomic ref count: 2000000
</pre><p>
Observe that the result from using the non-atomic counter is lower than what
one would naively expect. This is because the non-atomic <span class="machine"><span class="font-tt">incr</span></span> function is
equivalent to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> incr r =
  <span class="ocamlkeyword">let</span> curr = !r <span class="ocamlkeyword">in</span>
        r := curr + 1</div></div>

</div><p>Observe that the load and the store are two separate operations, and the
increment operation as a whole is not performed atomically. When two domains
execute this code in parallel, both of them may read the same value of the
counter <span class="machine"><span class="font-tt">curr</span></span> and update it to <span class="machine"><span class="font-tt">curr + 1</span></span>. Hence, instead of two increments,
the effect will be that of a single increment. On the other hand, the atomic
counter performs the load and the store atomically with the help of hardware
support for atomicity. The atomic counter returns the expected result.</p><p>The atomic variables can be used for low-level synchronisation between the
domains. The following example uses an atomic variable to exchange a message
between two domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> r = Atomic.make None

<span class="ocamlkeyword">let</span> sender () = Atomic.set r (Some <span class="ocamlstring">"Hello"</span>)

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> receiver () =
  <span class="ocamlkeyword">match</span> Atomic.get r <span class="ocamlkeyword">with</span>
  | None -&gt; Domain.cpu_relax (); receiver ()
  | Some m -&gt; print_endline m

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> s = Domain.spawn sender <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> d = Domain.spawn receiver <span class="ocamlkeyword">in</span>
  Domain.join s;
  Domain.join d

<span class="ocamlkeyword">let</span> _ = main ()</div>



<div class="pre caml-output ok">Hello
<span class="ocamlkeyword">val</span> r : string option Atomic.t = &lt;abstr&gt;
<span class="ocamlkeyword">val</span> sender : unit -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> receiver : unit -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> main : unit -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>While the sender and the receiver compete to access <span class="machine"><span class="font-tt">r</span></span>, this is not a data
race since <span class="machine"><span class="font-tt">r</span></span> is an atomic reference.</p>
<!--TOC subsection id="s:par_lockfree_stack" 9.7.1â€ƒLock-free stack-->
<h3 class="subsection" id="s:par_lockfree_stack"><a class="section-anchor" href="#s:par_lockfree_stack" aria-hidden="true">ï»¿</a>9.7.1â€ƒLock-free stack</h3><!--SEC END --><p>The Atomic module is used to implement non-blocking, lock-free data structures.
The following program implements a lock-free stack.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Lockfree_stack : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> make : unit -&gt; 'a t
  <span class="ocamlkeyword">val</span> push : 'a t -&gt; 'a -&gt; unit
  <span class="ocamlkeyword">val</span> pop  : 'a t -&gt; 'a option
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = 'a list Atomic.t

  <span class="ocamlkeyword">let</span> make () = Atomic.make []

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> push r v =
    <span class="ocamlkeyword">let</span> s = Atomic.get r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">if</span> Atomic.compare_and_set r s (v::s) <span class="ocamlkeyword">then</span> ()
    <span class="ocamlkeyword">else</span> (Domain.cpu_relax (); push r v)

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> pop r =
    <span class="ocamlkeyword">let</span> s = Atomic.get r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">match</span> s <span class="ocamlkeyword">with</span>
    | [] -&gt; None
    | x::xs -&gt;
        <span class="ocamlkeyword">if</span> Atomic.compare_and_set r s xs <span class="ocamlkeyword">then</span> Some x
        <span class="ocamlkeyword">else</span> (Domain.cpu_relax (); pop r)
<span class="ocamlkeyword">end</span></div></div>

</div><p>The atomic stack is represented by an atomic reference that holds a list. The
<span class="machine"><span class="font-tt">push</span></span> and <span class="machine"><span class="font-tt">pop</span></span> operations use the <span class="machine"><span class="font-tt">compare_and_set</span></span> primitive to attempt to
atomically update the atomic reference. The expression <span class="machine"><span class="font-tt">compare_and_set r seen v</span></span> sets the value of <span class="machine"><span class="font-tt">r</span></span> to <span class="machine"><span class="font-tt">v</span></span> if and only if its current value is physically
equal to <span class="machine"><span class="font-tt">seen</span></span>. Importantly, the comparison and the update occur atomically.
The expression evaluates to <span class="machine"><span class="font-tt">true</span></span> if the comparison succeeded (and the update
happened) and <span class="machine"><span class="font-tt">false</span></span> otherwise.</p><p>If the <span class="machine"><span class="font-tt">compare_and_set</span></span> fails, then some other domain is also attempting to
update the atomic reference at the same time. In this case, the <span class="machine"><span class="font-tt">push</span></span> and
<span class="machine"><span class="font-tt">pop</span></span> operations call <span class="machine"><span class="font-tt">Domain.cpu_relax</span></span> to back off for a short duration
allowing competing domains to make progress before retrying the failed
operation. This lock-free stack implementation is also known as Treiber
stack.

</p>
<!--TOC chapter id="sec92" ChapterÂ 10â€ƒMemory model: The hard bits-->
<h1 class="chapter" id="sec92">ChapterÂ 10â€ƒMemory model: The hard bits</h1><!--SEC END --><!--NAME memorymodel.html-->
<p>
<a id="c:memorymodel"></a></p><p>This chapter describes the details of OCaml relaxed memory model. The relaxed
memory model describes what values an OCaml program is allowed to witness when
reading a memory location. If you are interested in high-level parallel
programming in OCaml, please have a look at the parallel programming chapter
<a href="#c%3Aparallelism">9</a>.</p><p>This chapter is aimed at experts who would like to understand the details of
the OCaml memory model from a practitionerâ€™s perspective. For a formal
definition of the OCaml memory model, its guarantees and the compilation to
hardware memory models, please have a look at the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>. The memory model presented in this chapter is an extension of the one
presented in the PLDI 2018 paper. This chapter also covers some pragmatic
aspects of the memory model that are not covered in the paper.</p>
<!--TOC section id="s:why_relaxed_memory" 10.1â€ƒWhy weakly consistent memory?-->
<h2 class="section" id="s:why_relaxed_memory"><a class="section-anchor" href="#s:why_relaxed_memory" aria-hidden="true">ï»¿</a>10.1â€ƒWhy weakly consistent memory?</h2><!--SEC END --><p>The simplest memory model that we could give to our programs is sequential
consistency. Under sequential consistency, the values observed by the program
can be explained through some interleaving of the operations from different
domains in the program. For example, consider the following program with two
domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> executing in parallel:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> b = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 a b <span class="ocamlkeyword">in</span>
    Printf.printf <span class="ocamlstring">"r1 = %d, r2 = %d, r3 = %d\n"</span> r1 r2 r3)
  <span class="ocamlkeyword">in</span>
  d2 b;
  Domain.join h</div></div>

</div><p>The reference cells <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are initially <span class="machine"><span class="font-tt">1</span></span>. The user may observe <span class="machine"><span class="font-tt">r1 = 2, r2 = 0, r3 = 2</span></span> if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurred before the read of <span class="machine"><span class="font-tt">b</span></span>
in <span class="machine"><span class="font-tt">d1</span></span>. Here, the observed behaviour can be explained in terms of interleaving
of the operations from different domains.</p><p>Let us now assume that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases of each other.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> ab = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 ab ab <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 ab;
  Domain.join h</div></div>

</div><p>In the above program, the variables <span class="machine"><span class="font-tt">ab</span></span>, <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> refer to the same
reference cell. One would expect that the assertion in the main function will
never fail. The reasoning is that if <span class="machine"><span class="font-tt">r2</span></span> is <span class="machine"><span class="font-tt">0</span></span>, then the write in <span class="machine"><span class="font-tt">d2</span></span>
occurred before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>. Given that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases,
the second read of <span class="machine"><span class="font-tt">a</span></span> in <span class="machine"><span class="font-tt">d1</span></span> should also return <span class="machine"><span class="font-tt">0</span></span>.</p>
<!--TOC subsection id="ss:mm_comp_opt" 10.1.1â€ƒCompiler optimisations-->
<h3 class="subsection" id="ss:mm_comp_opt"><a class="section-anchor" href="#ss:mm_comp_opt" aria-hidden="true">ï»¿</a>10.1.1â€ƒCompiler optimisations</h3><!--SEC END --><p>Surprisingly, this assertion may fail in OCaml due to compiler optimisations.
The OCaml compiler observes the common sub-expression <span class="machine"><span class="font-tt">!a * 2</span></span> in <span class="machine"><span class="font-tt">d1</span></span> and
optimises the program to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = r1 <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* CSE: !a * 2 ==&gt; r1 *)</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> ab = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 ab ab <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 ab;
  Domain.join h</div></div>

</div><p>This optimisation is known as the common sub-expression elimination (CSE). Such
optimisations are valid and necessary for good performance, and do not change
the sequential meaning of the program. However, CSE breaks sequential
reasoning.</p><p>In the optimized program above, even if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurs between
the first and the second reads in <span class="machine"><span class="font-tt">d1</span></span>, the program will observe the value <span class="machine"><span class="font-tt">2</span></span>
for <span class="machine"><span class="font-tt">r3</span></span>, causing the assertion to fail. The observed behaviour cannot be
explained by interleaving of operations from different domains in the source
program. Thus, CSE optimization is said to be invalid under sequential
consistency.</p><p>One way to explain the observed behaviour is as if the operations performed on
a domain were reordered. For example, if the second and the third reads from
<span class="machine"><span class="font-tt">d2</span></span> were reordered,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>then we can explain the observed behaviour <span class="machine"><span class="font-tt">(2,0,2)</span></span> returned by
<span class="machine"><span class="font-tt">d1</span></span>.</p>
<!--TOC subsection id="ss:mm_hw_opt" 10.1.2â€ƒHardware optimisations-->
<h3 class="subsection" id="ss:mm_hw_opt"><a class="section-anchor" href="#ss:mm_hw_opt" aria-hidden="true">ï»¿</a>10.1.2â€ƒHardware optimisations</h3><!--SEC END --><p>The other source of reordering is by the hardware. Modern hardware
architectures have complex cache hierarchies with multiple levels of cache.
While cache coherence ensures that reads and writes to a single memory
location respect sequential consistency, the guarantees on programs that
operate on different memory locations are much weaker. Consider the following
program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>Under sequential consistency, we would never expect the assertion to fail.
However, even on x86, which offers much stronger guarantees than ARM, the
writes performed at a CPU core are not immediately published to all of the
other cores. Since <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are different memory locations, the reads of <span class="machine"><span class="font-tt">a</span></span>
and <span class="machine"><span class="font-tt">b</span></span> may both witness the initial values, leading to the assertion failure.</p><p>This behaviour can be explained if a load is allowed to be reordered before a
preceding store to a different memory location. This reordering can happen due
to the presence of in-core store-buffers on modern processors. Each core
effectively has a FIFO buffer of pending writes to avoid the need to block
while a write completes. The writes to <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> may be in the store-buffers
of cores <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> running the domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span>, respectively. The
reads of <span class="machine"><span class="font-tt">b</span></span> and <span class="machine"><span class="font-tt">a</span></span> running on the cores <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span>, respectively, will not
see the writes if the writes have not propagated from the buffers to the main
memory.</p>
<!--TOC section id="s:drf_sc" 10.2â€ƒData race freedom implies sequential consistency-->
<h2 class="section" id="s:drf_sc"><a class="section-anchor" href="#s:drf_sc" aria-hidden="true">ï»¿</a>10.2â€ƒData race freedom implies sequential consistency</h2><!--SEC END --><p>The aim of the OCaml relaxed memory model is to precisely describe which orders
are preserved by the OCaml program. The compiler and the hardware are free to
optimize the program as long as they respect the ordering guarantees of the
memory model. While programming directly under the relaxed memory model is
difficult, the memory model also describes the conditions under which a program
will only exhibit sequentially consistent behaviours. This guarantee is known
as <em>data race freedom implies sequential consistency</em> (DRF-SC). In this
section, we shall describe this guarantee. In order to do this, we first need a
number of definitions.</p>
<!--TOC subsection id="s:atomics" 10.2.1â€ƒMemory locations-->
<h3 class="subsection" id="s:atomics"><a class="section-anchor" href="#s:atomics" aria-hidden="true">ï»¿</a>10.2.1â€ƒMemory locations</h3><!--SEC END --><p>OCaml classifies memory locations into <em>atomic</em> and <em>non-atomic</em>
locations. Reference cells, array fields and mutable record fields are
non-atomic memory locations. Immutable objects are non-atomic locations with an
initialising write but no further updates. Atomic memory locations are those
that are created using the <a href="libref/Atomic.html"><span class="font-tt">Atomic</span></a> module.</p>
<!--TOC subsection id="s:happens_before" 10.2.2â€ƒHappens-before relation-->
<h3 class="subsection" id="s:happens_before"><a class="section-anchor" href="#s:happens_before" aria-hidden="true">ï»¿</a>10.2.2â€ƒHappens-before relation</h3><!--SEC END --><p>Let us imagine that the OCaml programs are executed by an abstract machine that
executes one action at a time, arbitrarily picking one of the available domains
at each step. We classify actions into two: <em>inter-domain</em> and
<em>intra-domain</em>. An inter-domain action is one which can be observed and be
influenced by actions on other domains. There are several inter-domain actions:</p><ul class="itemize"><li class="li-itemize">Reads and writes of atomic and non-atomic locations.
</li><li class="li-itemize">Spawn and join of domains.
</li><li class="li-itemize">Operations on mutexes.
</li></ul><p>On the other hand, intra-domain actions can neither be observed nor influence
the execution of other domains. Examples include evaluating an arithmetic
expression, calling a function, etc. The memory model specification ignores
such intra-domain actions. In the sequel, we use the term action to indicate
inter-domain actions.</p><p>A totally ordered list of actions executed by the abstract machine is called an
<em>execution trace</em>. There might be several possible execution traces for a
given program due to non-determinism.</p><p>For a given execution trace, we define an irreflexive, transitive
<em>happens-before relation</em> that captures the causality between actions in
the OCaml program. The happens-before relation is defined as the smallest
transitive relation satisfying the following properties:</p><ul class="itemize"><li class="li-itemize">We define the order in which a domain executes its actions as the
<em>program order</em>. If an action <span class="machine"><span class="font-tt">x</span></span> precedes another action <span class="machine"><span class="font-tt">y</span></span> in
program order, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is a write to an atomic location and <span class="machine"><span class="font-tt">y</span></span> is a subsequent read or
write to that memory location in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span>
in happens-before order. For atomic locations, <span class="machine"><span class="font-tt">compare_and_set</span></span>,
<span class="machine"><span class="font-tt">fetch_and_add</span></span>, <span class="machine"><span class="font-tt">exchange</span></span>, <span class="machine"><span class="font-tt">incr</span></span> and <span class="machine"><span class="font-tt">decr</span></span> are considered to perform
both a read and a write.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is <span class="machine"><span class="font-tt">Domain.spawn f</span></span> and <span class="machine"><span class="font-tt">y</span></span> is the first action in the newly
spawned domain executing <span class="machine"><span class="font-tt">f</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before
order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is the last action in a domain <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">y</span></span> is <span class="machine"><span class="font-tt">Domain.join     d</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an unlock operation on a mutex, and <span class="machine"><span class="font-tt">y</span></span> is any subsequent
operation on the mutex in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in
happens-before order.
</li></ul>
<!--TOC subsection id="s:datarace" 10.2.3â€ƒData race-->
<h3 class="subsection" id="s:datarace"><a class="section-anchor" href="#s:datarace" aria-hidden="true">ï»¿</a>10.2.3â€ƒData race</h3><!--SEC END --><p>In a given trace, two actions are said to be <em>conflicting</em> if they access
the same non-atomic location, at least one is a write and neither is an
initialising write to that location.</p><p>We say that a program has a <em>data race</em> if there exists some execution
trace of the program with two conflicting actions and there does not exist a
happens-before relationship between the conflicting accesses. A program without
data races is said to be <em>correctly synchronised</em>.</p>
<!--TOC subsection id="ss:drf_sc" 10.2.4â€ƒDRF-SC-->
<h3 class="subsection" id="ss:drf_sc"><a class="section-anchor" href="#ss:drf_sc" aria-hidden="true">ï»¿</a>10.2.4â€ƒDRF-SC</h3><!--SEC END --><p><span class="font-bold">DRF-SC guarantee:</span> A program without data races will only exhibit
sequentially consistent behaviours.</p><p>DRF-SC is a strong guarantee for the programmers. Programmers can use
<em>sequential reasoning</em> i.e., reasoning by executing one inter-domain
action after the other, to identify whether their program has a data race. In
particular, they do not need to reason about reorderings described in
sectionÂ <a href="#s%3Awhy_relaxed_memory">10.1</a> in order to determine whether their program
has a data race. Once the determination that a particular program is data race
free is made, they do not need to worry about reorderings in their code.</p>
<!--TOC section id="s:drf_reasoning" 10.3â€ƒReasoning with DRF-SC-->
<h2 class="section" id="s:drf_reasoning"><a class="section-anchor" href="#s:drf_reasoning" aria-hidden="true">ï»¿</a>10.3â€ƒReasoning with DRF-SC</h2><!--SEC END --><p>In this section, we will look at examples of using DRF-SC for program
reasoning. In this section, we will use the functions with names <span class="machine"><span class="font-tt">dN</span></span> to
represent domains executing in parallel with other domains. That is, we assume
that there is a <span class="machine"><span class="font-tt">main</span></span> function that runs the <span class="machine"><span class="font-tt">dN</span></span> functions in parallel as
follows:</p><pre>let main () =
  let h1 = Domain.spawn d1 in
  let h2 = Domain.spawn d2 in
  ...
  ignore @@ Domain.join h1;
  ignore @@ Domain.join h2
</pre><p>
Here is a simple example with a data race:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* Has data race *)</span>
<span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> d1 () = r := 1
<span class="ocamlkeyword">let</span> d2 () = !r</div></div>

</div><p><span class="machine"><span class="font-tt">r</span></span> is a non-atomic reference. The two domains race to access the reference,
and <span class="machine"><span class="font-tt">d1</span></span> is a write. Since there is no happens-before relationship between the
conflicting accesses, there is a data race.</p><p>Both of the programs that we had seen in the sectionÂ <a href="#s%3Awhy_relaxed_memory">10.1</a>
have data races. It is no surprise that they exhibit non sequentially
consistent behaviours.</p><p>Accessing disjoint array indices and fields of a record in parallel is not a
data race. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> a = [| 0; 1 |]
<span class="ocamlkeyword">let</span> d1 () = a.(0) &lt;- 42
<span class="ocamlkeyword">let</span> d2 () = a.(1) &lt;- 42</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">type</span> t = {
  <span class="ocamlkeyword">mutable</span> a : int;
  <span class="ocamlkeyword">mutable</span> b : int
}
<span class="ocamlkeyword">let</span> r = {a = 0; b = 1}
<span class="ocamlkeyword">let</span> d1 () = r.a &lt;- 42
<span class="ocamlkeyword">let</span> d2 () = r.b &lt;- 42</div></div>

</div><p>do not have data races.</p><p>Races on atomic locations do not lead to a data race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> r = Atomic.make 0
<span class="ocamlkeyword">let</span> d1 () = Atomic.set r 1
<span class="ocamlkeyword">let</span> d2 () = Atomic.get r</div></div>

</div>
<!--TOC subsubsection id="s:mm_msg_passing" Message-passing-->
<h4 class="subsubsection" id="s:mm_msg_passing"><a class="section-anchor" href="#s:mm_msg_passing" aria-hidden="true">ï»¿</a>Message-passing</h4><!--SEC END --><p>Atomic variables may be used for implementing non-blocking communication
between domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">if</span> Atomic.get flag <span class="ocamlcomment">(* c *)</span> <span class="ocamlkeyword">then</span>
    !msg <span class="ocamlcomment">(* d *)</span>
  <span class="ocamlkeyword">else</span> 0</div></div>

</div><p>Observe that the actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> write and read from the same non-atomic
location <span class="machine"><span class="font-tt">msg</span></span>, respectively, and hence are conflicting. We need to establish
that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> have a happens-before relationship in order to show that this
program does not have a data race.</p><p>The action <span class="machine"><span class="font-tt">a</span></span> precedes <span class="machine"><span class="font-tt">b</span></span> in program order, and hence, <span class="machine"><span class="font-tt">a</span></span> happens-before
<span class="machine"><span class="font-tt">b</span></span>. Similarly, <span class="machine"><span class="font-tt">c</span></span> happens-before <span class="machine"><span class="font-tt">d</span></span>. If <span class="machine"><span class="font-tt">d2</span></span> observes the atomic variable
<span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">true</span></span>, then <span class="machine"><span class="font-tt">b</span></span> precedes <span class="machine"><span class="font-tt">c</span></span> in happens-before order. Since
happens-before is transitive, the conflicting actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> are in
happens-before order. If <span class="machine"><span class="font-tt">d2</span></span> observes the <span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">false</span></span>, then the read
of <span class="machine"><span class="font-tt">msg</span></span> is not done. Hence, there is no conflicting access in this execution
trace. Hence, the program does not have a data race.</p><p>The following modified version of the message passing program does have a data
race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* Has data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  ignore (Atomic.get flag); <span class="ocamlcomment">(* c *)</span>
  !msg <span class="ocamlcomment">(* d *)</span></div></div>

</div><p>The domain <span class="machine"><span class="font-tt">d2</span></span> now unconditionally reads the non-atomic reference <span class="machine"><span class="font-tt">msg</span></span>.
Consider the execution trace:</p><pre>Atomic.get flag; (* c *)
!msg; (* d *)
msg := 42; (* a *)
Atomic.set flag true (* b *)
</pre><p>
In this trace, <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">a</span></span> are conflicting operations. But there is no
happens-before relationship between them. Hence, this program has a data race.</p>
<!--TOC section id="s:local_drf" 10.4â€ƒLocal data race freedom-->
<h2 class="section" id="s:local_drf"><a class="section-anchor" href="#s:local_drf" aria-hidden="true">ï»¿</a>10.4â€ƒLocal data race freedom</h2><!--SEC END --><p>The OCaml memory model offers strong guarantees even for programs with data
races. It offers what is known as <em>local data race freedom sequential
consistency (LDRF-SC)</em> guarantee. A formal definition of this property is beyond
the scope of this manual chapter. Interested readers are encouraged to read the
PLDI 2018 paper on <a href="https://doi.org/10.1145/3192366.3192421">Bounding Data
Races in Space and Time</a>.</p><p>Informally, LDRF-SC says that the data race free parts of the program remain
sequentially consistent. That is, even if the program has data races, those
parts of the program that are disjoint from the parts with data races are
amenable to sequential reasoning.</p><p>Consider the following snippet:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> snippet () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  (a, c)</div></div>

</div><p>Observe that <span class="machine"><span class="font-tt">c</span></span> is a newly allocated reference. Can the read of <span class="machine"><span class="font-tt">c</span></span> return a
value which is not 42? That is, can <span class="machine"><span class="font-tt">a</span></span> ever be not <span class="machine"><span class="font-tt">42</span></span>? Surprisingly, in the
C++ and Java memory models, the answer is yes. With the C++ memory model, if
the program has a data race, even in unrelated parts, then the semantics is
undefined. If this snippet were linked with a library that had a data race,
then, under the C++ memory model, the read may return any value. Since data
races on unrelated locations can affect program behaviour, we say that C++
memory model is not bounded in space.</p><p>Unlike C++, Java memory model is bounded in space. But Java memory model is not
bounded in time; data races in the future will affect the past behaviour. For
example, consider the translation of this example to Java. We assume a prior
definition of <span class="machine"><span class="font-tt">Class c {int x;}</span></span> and a shared <em>non-volatile</em> variable <span class="machine"><span class="font-tt">C g</span></span>. Now the snippet may be part of a larger program with parallel threads:</p><pre>(* Thread 1 *)
C c = new C();
c.x = 42;
a = c.x;
g = c;

(* Thread 2 *)
g.x = 7;
</pre><p>
The read of <span class="machine"><span class="font-tt">c.x</span></span> and the write of <span class="machine"><span class="font-tt">g</span></span> in the first thread are done on separate
memory locations. Hence, the Java memory model allows them to be reordered. As
a result, the write in the second thread may occur before the read of <span class="machine"><span class="font-tt">c.x</span></span>,
and hence, <span class="machine"><span class="font-tt">c.x</span></span> returns <span class="machine"><span class="font-tt">7</span></span>.</p><p>The OCaml equivalent of the Java code above is:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> g = <span class="ocamlkeyword">ref</span> None

<span class="ocamlkeyword">let</span> snippet () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  (a, c)

<span class="ocamlkeyword">let</span> d1 () =
  <span class="ocamlkeyword">let</span> (a,c) = snippet () <span class="ocamlkeyword">in</span>
  g := Some c;
  a

<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">match</span> !g <span class="ocamlkeyword">with</span>
  | None -&gt; ()
  | Some c -&gt; c := 7</div></div>

</div><p>Observe that there is a data race on both <span class="machine"><span class="font-tt">g</span></span> and <span class="machine"><span class="font-tt">c</span></span>. Consider only the first
three instructions in <span class="machine"><span class="font-tt">snippet</span></span>:</p><pre>let c = ref 0 in
c := 42;
let a = !c in
...
</pre><p>
The OCaml memory model is bounded both in space and time. The only memory
location here is <span class="machine"><span class="font-tt">c</span></span>. Reasoning only about this snippet, there is neither the
data race in space (the race on <span class="machine"><span class="font-tt">g</span></span>) nor in time (the future race on <span class="machine"><span class="font-tt">c</span></span>).
Hence, the snippet will have sequentially consistent behaviour, and the value
returned by <span class="machine"><span class="font-tt">!c</span></span> will be <span class="machine"><span class="font-tt">42</span></span>.</p><p>The OCaml memory model guarantees that even for programs with data races,
memory safety is preserved. While programs with data races may observe
non-sequentially consistent behaviours, they will not crash.</p>
<!--TOC section id="s:mm_semantics" 10.5â€ƒAn operational view of the memory model-->
<h2 class="section" id="s:mm_semantics"><a class="section-anchor" href="#s:mm_semantics" aria-hidden="true">ï»¿</a>10.5â€ƒAn operational view of the memory model</h2><!--SEC END --><p>In this section, we describe the semantics of the OCaml memory model. A formal
definition of the operational view of the memory model is presented in section
3 of the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>. This section presents an informal description of the memory model with
the help of an example.</p><p>Given an OCaml program, which may possibly contain data races, the operational
semantics tells you the values that may be observed by the read of a memory
location. For simplicity, we restrict the intra-thread actions to just the
accesses to atomic and non-atomic locations, ignoring domain spawn and join
operations, and the operations on mutexes.</p><p>We describe the semantics of the OCaml memory model in a straightforward
small-step operational manner. That is, the semantics is described by an
abstract machine that executes one action at a time, arbitrarily picking one of
the available domains at each step. This is similar to the abstract machine
that we had used to describe the happens-before relationship in
sectionÂ <a href="#s%3Ahappens_before">10.2.2</a>.</p>
<!--TOC subsection id="ss:mm_non_atomic" 10.5.1â€ƒNon-atomic locations-->
<h3 class="subsection" id="ss:mm_non_atomic"><a class="section-anchor" href="#ss:mm_non_atomic" aria-hidden="true">ï»¿</a>10.5.1â€ƒNon-atomic locations</h3><!--SEC END --><p>In the semantics, we model non-atomic locations as finite maps from timestamps
<span class="machine"><span class="font-tt">t</span></span> to values <span class="machine"><span class="font-tt">v</span></span>. We take timestamps to be rational numbers. The timestamps
are totally ordered but dense; there is a timestamp between any two others.</p><p>For example,</p><pre>a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t8 -&gt; 7]
</pre><p>
represents three non-atomic locations <span class="machine"><span class="font-tt">a</span></span>, <span class="machine"><span class="font-tt">b</span></span> and <span class="machine"><span class="font-tt">c</span></span> and their
histories. The location <span class="machine"><span class="font-tt">a</span></span> has two writes at timestamps <span class="machine"><span class="font-tt">t1</span></span> and <span class="machine"><span class="font-tt">t2</span></span> with
values <span class="machine"><span class="font-tt">1</span></span> and <span class="machine"><span class="font-tt">2</span></span>, respectively. When we write <span class="machine"><span class="font-tt">a: [t1 -&gt; 1; t2 -&gt; 2]</span></span>, we
assume that <span class="machine"><span class="font-tt">t1 &lt; t2</span></span>. We assume that the locations are initialised with a
history that has a single entry at timestamp 0 that maps to the initial value.</p>
<!--TOC subsection id="ss:mm_domains" 10.5.2â€ƒDomains-->
<h3 class="subsection" id="ss:mm_domains"><a class="section-anchor" href="#ss:mm_domains" aria-hidden="true">ï»¿</a>10.5.2â€ƒDomains</h3><!--SEC END --><p>Each domain is equipped with a <em>frontier</em>, which is a map from non-atomic
locations to timestamps. Intuitively, each domainâ€™s frontier records, for each
non-atomic location, the latest write known to the thread. More recent writes
may have occurred, but are not guaranteed to be visible.</p><p>For example,</p><pre>d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t7]
</pre><p>
represents two domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> and their frontiers.</p>
<!--TOC subsection id="ss:mm_na_access" 10.5.3â€ƒNon-atomic accesses-->
<h3 class="subsection" id="ss:mm_na_access"><a class="section-anchor" href="#ss:mm_na_access" aria-hidden="true">ï»¿</a>10.5.3â€ƒNon-atomic accesses</h3><!--SEC END --><p>Let us now define the semantics of non-atomic reads and writes. Suppose domain
<span class="machine"><span class="font-tt">d1</span></span> performs the read of <span class="machine"><span class="font-tt">b</span></span>. For non-atomic reads, the domains may read an
arbitrary element of the history for that location, as long as it is not older
than the timestamp in the domainsâ€™s frontier. In this case, since <span class="machine"><span class="font-tt">d1</span></span> frontier
at <span class="machine"><span class="font-tt">b</span></span> is at <span class="machine"><span class="font-tt">t3</span></span>, the read may return the value <span class="machine"><span class="font-tt">3</span></span>, <span class="machine"><span class="font-tt">4</span></span> or <span class="machine"><span class="font-tt">5</span></span>. A non-atomic
read does not change the frontier of the current domain.</p><p>Suppose domain <span class="machine"><span class="font-tt">d2</span></span> writes the value <span class="machine"><span class="font-tt">10</span></span> to <span class="machine"><span class="font-tt">c</span></span> (<span class="machine"><span class="font-tt">c := 10</span></span>). We pick a new
timestamp <span class="machine"><span class="font-tt">t9</span></span> for this write such that it is later than <span class="machine"><span class="font-tt">d2</span></span>â€™s frontier at
<span class="machine"><span class="font-tt">c</span></span>. Note a subtlety here: this new timestamp might not be later than everything
else in the history, but merely later than any other write known to the writing
domain. Hence, <span class="machine"><span class="font-tt">t9</span></span> may be inserted in <span class="machine"><span class="font-tt">c</span></span>â€™s history either (a) between <span class="machine"><span class="font-tt">t7</span></span>
and <span class="machine"><span class="font-tt">t8</span></span> or (b) after <span class="machine"><span class="font-tt">t8</span></span>. Let us pick the former option for our discussion.
Since the new write appears after all the writes known by the domain <span class="machine"><span class="font-tt">d2</span></span> to
the location <span class="machine"><span class="font-tt">c</span></span>, <span class="machine"><span class="font-tt">d2</span></span>â€™s frontier at <span class="machine"><span class="font-tt">c</span></span> is also updated. The new state of the
abstract machine is:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7] (* new write at t9 *)

(* Domains *)
d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9] (* frontier updated at c *)
</pre>
<!--TOC subsection id="ss:mm_at_access" 10.5.4â€ƒAtomic accesses-->
<h3 class="subsection" id="ss:mm_at_access"><a class="section-anchor" href="#ss:mm_at_access" aria-hidden="true">ï»¿</a>10.5.4â€ƒAtomic accesses</h3><!--SEC END --><p>Atomic locations carry not only values but also synchronization information. We
model atomic locations as a pair of the value held by that location and a
frontier. The frontier models the synchronization information, which is merged
with the frontiers of threads that operate on the location. In this way,
non-atomic writes made by one thread can become known to another by
communicating via an atomic location.</p><p>For example,</p><pre>(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
shows two atomic variables <span class="machine"><span class="font-tt">A</span></span> and <span class="machine"><span class="font-tt">B</span></span> with values <span class="machine"><span class="font-tt">10</span></span> and <span class="machine"><span class="font-tt">5</span></span>,
respectively, and frontiers of their own. We use upper-case variable names to
indicate atomic locations.</p><p>During atomic reads, the frontier of the location is merged into that of the
domain performing the read. For example, suppose <span class="machine"><span class="font-tt">d1</span></span> reads <span class="machine"><span class="font-tt">B</span></span>. The read
returns <span class="machine"><span class="font-tt">5</span></span>, and <span class="machine"><span class="font-tt">d1</span></span>â€™s frontier updated by merging it with <span class="machine"><span class="font-tt">B</span></span>â€™s frontier,
choosing the later timestamp for each location. The abstract machine state
before the atomic read is:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9]

(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
As a result of the atomic read, the abstract machine state is updated to:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t4; c -&gt; t7] (* frontier updated at a and b *)
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9]

(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
During atomic writes, the value held by the atomic location is updated. The
frontiers of both the writing domain and that of the location being written to
are updated to the merge of the two frontiers. For example, if <span class="machine"><span class="font-tt">d2</span></span> writes <span class="machine"><span class="font-tt">20</span></span>
to <span class="machine"><span class="font-tt">A</span></span> in the current machine state, the machine state is updated to:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t4; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t5; c -&gt; t9] (* frontier updated at b *)

(* Atomic locations *)
A: 20, [a -&gt; t1; b -&gt; t5; c -&gt; t9] (* value updated. frontier updated at c. *)
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre>
<!--TOC subsection id="s:mm_semantics_reasoning" 10.5.5â€ƒReasoning with the semantics-->
<h3 class="subsection" id="s:mm_semantics_reasoning"><a class="section-anchor" href="#s:mm_semantics_reasoning" aria-hidden="true">ï»¿</a>10.5.5â€ƒReasoning with the semantics</h3><!--SEC END --><p>Let us revisit an example from earlier (section <a href="#s%3Awhy_relaxed_memory">10.1</a>).</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>This program has a data race on <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span>, and hence, the program may exhibit
non sequentially consistent behaviour. Let us use the semantics to show that
the program may exhibit <span class="machine"><span class="font-tt">r1 = 0 &amp;&amp; r2 = 0</span></span>.</p><p>The initial state of the abstract machine is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0]
b: [t1 -&gt; 0]

(* Domains *)
d1: [a -&gt; t0; b -&gt; t1]
d2: [a -&gt; t0; b -&gt; t1]
</pre><p>
There are several possible schedules for executing this program. Let us
consider the following schedule:</p><pre>1: a := 1 @ d1
2: b := 1 @ d2
3: !b     @ d1
4: !a     @ d2
</pre><p>
After the first action <span class="machine"><span class="font-tt">a:=1</span></span> by <span class="machine"><span class="font-tt">d1</span></span>, the machine state is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0; t2 -&gt; 1] (* new write at t2 *)
b: [t1 -&gt; 0]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t1] (* frontier updated at a *)
d2: [a -&gt; t0; b -&gt; t1]
</pre><p>
After the second action <span class="machine"><span class="font-tt">b:=1</span></span> by <span class="machine"><span class="font-tt">d2</span></span>, the machine state is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0; t2 -&gt; 1]
b: [t1 -&gt; 0; t3 -&gt; 1] (* new write at t3 *)

(* Domains *)
d1: [a -&gt; t2; b -&gt; t1]
d2: [a -&gt; t0; b -&gt; t3] (* frontier updated at b *)
</pre><p>
Now, for the third action <span class="machine"><span class="font-tt">!b</span></span> by <span class="machine"><span class="font-tt">d1</span></span>, observe that <span class="machine"><span class="font-tt">d1</span></span>â€™s frontier at <span class="machine"><span class="font-tt">b</span></span>
is at <span class="machine"><span class="font-tt">t1</span></span>. Hence, the read may return either <span class="machine"><span class="font-tt">0</span></span> or <span class="machine"><span class="font-tt">1</span></span>. Let us assume that it
returns <span class="machine"><span class="font-tt">0</span></span>. The machine state is not updated by the non-atomic read.</p><p>Similarly, for the fourth action <span class="machine"><span class="font-tt">!a</span></span> by <span class="machine"><span class="font-tt">d2</span></span>, <span class="machine"><span class="font-tt">d2</span></span>â€™s frontier at <span class="machine"><span class="font-tt">a</span></span> is at
<span class="machine"><span class="font-tt">t0</span></span>. Hence, this read may also return either <span class="machine"><span class="font-tt">0</span></span> or <span class="machine"><span class="font-tt">1</span></span>. Let us assume that it
returns <span class="machine"><span class="font-tt">0</span></span>. Hence, the assertion in the original program, <span class="machine"><span class="font-tt">assert (not (r1 = 0 &amp;&amp; r2 = 0))</span></span>, will fail for this particular execution.</p>
<!--TOC section id="s:mm_tearing" 10.6â€ƒNon-compliant operations-->
<h2 class="section" id="s:mm_tearing"><a class="section-anchor" href="#s:mm_tearing" aria-hidden="true">ï»¿</a>10.6â€ƒNon-compliant operations</h2><!--SEC END --><p>There are certain operations which are not memory model compliant.</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">Array.blit</span></span> function on float arrays may cause <em>tearing</em>. When an
unsynchronized blit operation runs concurrently with some overlapping write
to the fields of the same float array, the field may end up with bits from
either of the writes.
</li><li class="li-itemize">With flat-float arrays or records with only float fields on 32-bit
architectures, getting or setting a field involves two separate memory
accesses. In the presence of data races, the user may observe tearing.
</li><li class="li-itemize">The <span class="machine"><span class="font-tt">Bytes</span></span> moduleÂ <a href="libref/Bytes.html"><span class="font-tt">Bytes</span></a> permits mixed-mode accesses
where reads and writes may be of different sizes. Unsynchronized mixed-mode
accesses lead to tearing.
</li></ul>
<!--TOC part id="sec111" PartÂ IIâ€ƒThe OCaml language-->
<table class="center"><tr><td><h1 class="part" id="sec111">PartÂ II<br>
The OCaml language</h1></td></tr>
</table><!--SEC END --><p>
<a id="p:refman"></a>
</p>
<!--TOC chapter id="sec112" ChapterÂ 11â€ƒThe OCaml language-->
<h1 class="chapter" id="sec112">ChapterÂ 11â€ƒThe OCaml language</h1><!--SEC END --><p> <a id="c:refman"></a>
</p><!--NAME language.html-->
<!--TOC subsection id="ss:foreword" Foreword-->
<h3 class="subsection" id="ss:foreword"><a class="section-anchor" href="#ss:foreword" aria-hidden="true">ï»¿</a>Foreword</h3><!--SEC END --><p>This document is intended as a reference manual for the OCaml
language. It lists the language constructs, and gives their precise
syntax and informal semantics. It is by no means a tutorial
introduction to the language. A good
working knowledge of OCaml is assumed.</p><p>No attempt has been made at mathematical rigor: words are employed
with their intuitive meaning, without further definition. As a
consequence, the typing rules have been left out, by lack of the
mathematical framework required to express them, while they are
definitely part of a full formal definition of the language.</p><!--TOC subsection id="ss:notations" Notations-->
<h3 class="subsection" id="ss:notations"><a class="section-anchor" href="#ss:notations" aria-hidden="true">ï»¿</a>Notations</h3><!--SEC END --><p>The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (<span class="syntax-token">like</span> <span class="syntax-token">this</span>).
Non-terminal symbols are set in italic font (<span class="nonterminal">like</span> <span class="nonterminal">that</span>).
Square brackets [â€¦] denote optional components. Curly brackets
{â€¦} denotes zero, one or several repetitions of the enclosed
components. Curly brackets with a trailing plus sign {â€¦}<sup>+</sup>
denote one or several repetitions of the enclosed components.
Parentheses (â€¦) denote grouping.</p><!--CUT DEF section  -->
<!--TOC section id="s:lexical-conventions" 11.1â€ƒLexical conventions-->
<h2 class="section" id="s:lexical-conventions"><a class="section-anchor" href="#s:lexical-conventions" aria-hidden="true">ï»¿</a>11.1â€ƒLexical conventions</h2><!--SEC END --><!--NAME lex.html-->
<!--TOC subsubsection id="sss:lex:blanks" Blanks-->
<h4 class="subsubsection" id="sss:lex:blanks"><a class="section-anchor" href="#sss:lex:blanks" aria-hidden="true">ï»¿</a>Blanks</h4><!--SEC END --><p>The following characters are considered as blanks: space,
horizontal tabulation, carriage return, line feed and form feed. Blanks are
ignored, but they separate adjacent identifiers, literals and
keywords that would otherwise be confused as one single identifier,
literal or keyword.</p><!--TOC subsubsection id="sss:lex:comments" Comments-->
<h4 class="subsubsection" id="sss:lex:comments"><a class="section-anchor" href="#sss:lex:comments" aria-hidden="true">ï»¿</a>Comments</h4><!--SEC END --><p>Comments are introduced by the two characters <span class="syntax-token">(*</span>, with no
intervening blanks, and terminated by the characters <span class="syntax-token">*)</span>, with
no intervening blanks. Comments are treated as blank characters.
Comments do not occur inside string or character literals. Nested
comments are handled correctly.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* single line comment *)</span>

<span class="ocamlcomment">(* multiple line comment, commenting out part of a program, and containing a
nested comment:
let f = function
  | 'A'..'Z' -&gt; "Uppercase"
    (* Add other cases later... *)
*)</span></div></div>

</div><!--TOC subsubsection id="sss:lex:identifiers" Identifiers-->
<h4 class="subsubsection" id="sss:lex:identifiers"><a class="section-anchor" href="#sss:lex:identifiers" aria-hidden="true">ï»¿</a>Identifiers</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="ident"><span class="nonterminal">ident</span></a></td><td class="c005">::=</td><td class="c007">â€„(<a class="syntax" href="#letter"><span class="nonterminal">letter</span></a>â€„âˆ£â€„<span class="syntax-token">_</span>)â€„{â€„<a class="syntax" href="#letter"><span class="nonterminal">letter</span></a>â€„âˆ£â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„âˆ£â€„<span class="syntax-token">'</span>â€„}â€„</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="capitalized-ident"><span class="nonterminal">capitalized-ident</span></a></td><td class="c005">::=</td><td class="c007">â€„(<span class="syntax-token">A</span>â€¦<span class="syntax-token">Z</span>)â€„{â€„<a class="syntax" href="#letter"><span class="nonterminal">letter</span></a>â€„âˆ£â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„âˆ£â€„<span class="syntax-token">'</span>â€„}â€„</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="lowercase-ident"><span class="nonterminal">lowercase-ident</span></a></td><td class="c005">::=</td><td class="c007">
(<span class="syntax-token">a</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">_</span>)â€„{â€„<a class="syntax" href="#letter"><span class="nonterminal">letter</span></a>â€„âˆ£â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„âˆ£â€„<span class="syntax-token">'</span>â€„}â€„</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="letter"><span class="nonterminal">letter</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">Z</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">z</span>
</td></tr>
</table></td></tr>
</table></div><p>Identifiers are sequences of letters, digits, <span class="machine"><span class="font-tt">_</span></span> (the underscore
character), and <span class="machine"><span class="font-tt">'</span></span> (the single quote), starting with a
letter or an underscore.
Letters contain at least the 52 lowercase and uppercase
letters from the ASCII set. The current implementation
also recognizes as letters some characters from the ISO
8859-1 set (characters 192â€“214 and 216â€“222 as uppercase letters;
characters 223â€“246 and 248â€“255 as lowercase letters). This
feature is deprecated and should be avoided for future compatibility.</p><p>All characters in an identifier are
meaningful. The current implementation accepts identifiers up to
16000000 characters in length.</p><p>In many places, OCaml makes a distinction between capitalized
identifiers and identifiers that begin with a lowercase letter. The
underscore character is considered a lowercase letter for this
purpose.</p><!--TOC subsubsection id="sss:integer-literals" Integer literals-->
<h4 class="subsubsection" id="sss:integer-literals"><a class="section-anchor" href="#sss:integer-literals" aria-hidden="true">ï»¿</a>Integer literals</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="integer-literal"><span class="nonterminal">integer-literal</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0x</span>â€„âˆ£â€„<span class="syntax-token">0X</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0o</span>â€„âˆ£â€„<span class="syntax-token">0O</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0b</span>â€„âˆ£â€„<span class="syntax-token">0B</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">1</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">1</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="int32-literal"><span class="nonterminal">int32-literal</span></a></td><td class="c005">::=</td><td class="c007">â€„<a class="syntax" href="#integer-literal"><span class="nonterminal">integer-literal</span></a>â€„<span class="syntax-token">l</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="int64-literal"><span class="nonterminal">int64-literal</span></a></td><td class="c005">::=</td><td class="c007">â€„<a class="syntax" href="#integer-literal"><span class="nonterminal">integer-literal</span></a>â€„<span class="syntax-token">L</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="nativeint-literal"><span class="nonterminal">nativeint-literal</span></a></td><td class="c005">::=</td><td class="c007">â€„<a class="syntax" href="#integer-literal"><span class="nonterminal">integer-literal</span></a>â€„<span class="syntax-token">n</span>
</td></tr>
</table></td></tr>
</table></div><p>An integer literal is a sequence of one or more digits, optionally
preceded by a minus sign. By default, integer literals are in decimal
(radix 10). The following prefixes select a different radix:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Prefix</span></td><td class="c004"><span class="font-bold">Radix</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">0x</span></span>, <span class="machine"><span class="font-tt">0X</span></span></td><td class="c006">hexadecimal (radix 16) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">0o</span></span>, <span class="machine"><span class="font-tt">0O</span></span></td><td class="c006">octal (radix 8) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">0b</span></span>, <span class="machine"><span class="font-tt">0B</span></span></td><td class="c006">binary (radix 2) </td></tr>
</table></div></div><p>
(The initial <span class="syntax-token">0</span> is the digit zero; the <span class="syntax-token">O</span> for octal is the letter O.)
An integer literal can be followed by one of the letters <span class="machine"><span class="font-tt">l</span></span>, <span class="machine"><span class="font-tt">L</span></span> or <span class="machine"><span class="font-tt">n</span></span>
to indicate that this integer has type <span class="machine"><span class="font-tt">int32</span></span>, <span class="machine"><span class="font-tt">int64</span></span> or <span class="machine"><span class="font-tt">nativeint</span></span>
respectively, instead of the default type <span class="machine"><span class="font-tt">int</span></span> for integer literals.
The interpretation of integer literals that fall outside the range of
representable integer values is undefined.</p><p>For convenience and readability, underscore characters (<span class="syntax-token">_</span>) are accepted
(and ignored) within integer literals.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> house_number = 37
  <span class="ocamlkeyword">let</span> million = 1_000_000
  <span class="ocamlkeyword">let</span> copyright = 0x00A9
  <span class="ocamlkeyword">let</span> counter64bit = <span class="ocamlkeyword">ref</span> 0L;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> house_number : int = 37
<span class="ocamlkeyword">val</span> million : int = 1000000
<span class="ocamlkeyword">val</span> copyright : int = 169
<span class="ocamlkeyword">val</span> counter64bit : int64 <span class="ocamlkeyword">ref</span> = {contents = 0L}</div></div>

</div><!--TOC subsubsection id="sss:floating-point-literals" Floating-point literals-->
<h4 class="subsubsection" id="sss:floating-point-literals"><a class="section-anchor" href="#sss:floating-point-literals" aria-hidden="true">ï»¿</a>Floating-point literals</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="float-literal"><span class="nonterminal">float-literal</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}â€„[<span class="syntax-token">.</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[(<span class="syntax-token">e</span>â€„âˆ£â€„<span class="syntax-token">E</span>)â€„[<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0x</span>â€„âˆ£â€„<span class="syntax-token">0X</span>)
(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}â€„
[<span class="syntax-token">.</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[(<span class="syntax-token">p</span>â€„âˆ£â€„<span class="syntax-token">P</span>)â€„[<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
</td></tr>
</table></td></tr>
</table></div><p>Floating-point decimal literals consist in an integer part, a
fractional part and
an exponent part. The integer part is a sequence of one or more
digits, optionally preceded by a minus sign. The fractional part is a
decimal point followed by zero, one or more digits.
The exponent part is the character <span class="syntax-token">e</span> or <span class="syntax-token">E</span> followed by an
optional <span class="syntax-token">+</span> or <span class="syntax-token">-</span> sign, followed by one or more digits. It is
interpreted as a power of 10.
The fractional part or the exponent part can be omitted but not both, to
avoid ambiguity with integer literals.
The interpretation of floating-point literals that fall outside the
range of representable floating-point values is undefined.</p><p>Floating-point hexadecimal literals are denoted with the <span class="syntax-token">0x</span> or <span class="syntax-token">0X</span>
prefix. The syntax is similar to that of floating-point decimal
literals, with the following differences.
The integer part and the fractional part use hexadecimal
digits. The exponent part starts with the character <span class="syntax-token">p</span> or <span class="syntax-token">P</span>.
It is written in decimal and interpreted as a power of 2.</p><p>For convenience and readability, underscore characters (<span class="syntax-token">_</span>) are accepted
(and ignored) within floating-point literals.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pi = 3.141_592_653_589_793_12
  <span class="ocamlkeyword">let</span> small_negative = -1e-5
  <span class="ocamlkeyword">let</span> machine_epsilon = 0x1p-52;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pi : float = 3.14159265358979312
<span class="ocamlkeyword">val</span> small_negative : float = -1e-05
<span class="ocamlkeyword">val</span> machine_epsilon : float = 2.22044604925031308e-16</div></div>

</div><!--TOC subsubsection id="sss:character-literals" Character literals-->
<h4 class="subsubsection" id="sss:character-literals"><a class="section-anchor" href="#sss:character-literals" aria-hidden="true">ï»¿</a>Character literals</h4><!--SEC END --><p>
<a id="s:characterliteral"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="char-literal"><span class="nonterminal">char-literal</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">'</span>â€„<span class="nonterminal">regular-char</span>â€„<span class="syntax-token">'</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">'</span>â€„<a class="syntax" href="#escape-sequence"><span class="nonterminal">escape-sequence</span></a>â€„<span class="syntax-token">'</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="escape-sequence"><span class="nonterminal">escape-sequence</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">\</span>â€„(<span class="syntax-token">\</span>â€„âˆ£â€„<span class="syntax-token">"</span>â€„âˆ£â€„<span class="syntax-token">'</span>â€„âˆ£â€„<span class="syntax-token">n</span>â€„âˆ£â€„<span class="syntax-token">t</span>â€„âˆ£â€„<span class="syntax-token">b</span>â€„âˆ£â€„<span class="syntax-token">r</span>â€„âˆ£â€„<span class="nonterminal">space</span>)
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">\</span>â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">\x</span>â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">\o</span>â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">3</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>)
</td></tr>
</table></td></tr>
</table></div><p>Character literals are delimited by <span class="syntax-token">'</span> (single quote) characters.
The two single quotes enclose either one character different from
<span class="syntax-token">'</span> and <span class="syntax-token">\</span>, or one of the escape sequences below:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Sequence</span></td><td class="c004"><span class="font-bold">Character denoted</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">\\</span></span></td><td class="c006">backslash (<span class="machine"><span class="font-tt">\</span></span>) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\"</span></span></td><td class="c006">double quote (<span class="machine"><span class="font-tt">"</span></span>) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\'</span></span></td><td class="c006">single quote (<span class="machine"><span class="font-tt">'</span></span>) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\n</span></span></td><td class="c006">linefeed (LF) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\r</span></span></td><td class="c006">carriage return (CR) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\t</span></span></td><td class="c006">horizontal tabulation (TAB) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\b</span></span></td><td class="c006">backspace (BS) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\</span></span><span class="font-it">space</span></td><td class="c006">space (SPC) </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\</span></span><span class="font-it">ddd</span></td><td class="c006">the character with ASCII code <span class="font-it">ddd</span> in decimal </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\x</span></span><span class="font-it">hh</span></td><td class="c006">the character with ASCII code <span class="font-it">hh</span> in hexadecimal </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">\o</span></span><span class="font-it">ooo</span></td><td class="c006">the character with ASCII code <span class="font-it">ooo</span> in octal </td></tr>
</table></div></div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> a = 'a'
  <span class="ocamlkeyword">let</span> single_quote = '\''
  <span class="ocamlkeyword">let</span> copyright = '\xA9';;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> a : char = 'a'
<span class="ocamlkeyword">val</span> single_quote : char = '\''
<span class="ocamlkeyword">val</span> copyright : char = '\169'</div></div>

</div><!--TOC subsubsection id="sss:stringliterals" String literals-->
<h4 class="subsubsection" id="sss:stringliterals"><a class="section-anchor" href="#sss:stringliterals" aria-hidden="true">ï»¿</a>String literals</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="string-literal"><span class="nonterminal">string-literal</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">"</span>â€„{â€„<a class="syntax" href="#string-character"><span class="nonterminal">string-character</span></a>â€„}â€„<span class="syntax-token">"</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a>â€„<span class="syntax-token">|</span>â€„{â€„<span class="nonterminal">any-char</span>â€„}â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a>â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="quoted-string-id"><span class="nonterminal">quoted-string-id</span></a></td><td class="c005">::=</td><td class="c007">
{â€„<span class="syntax-token">a</span>...<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="string-character"><span class="nonterminal">string-character</span></a></td><td class="c005">::=</td><td class="c007">
<span class="nonterminal">regular-string-char</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#escape-sequence"><span class="nonterminal">escape-sequence</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">\u{</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„}<sup>+</sup>â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">\</span>â€„<span class="nonterminal">newline</span>â€„{â€„<span class="nonterminal">space</span>â€„âˆ£â€„<span class="nonterminal">tab</span>â€„}
</td></tr>
</table></td></tr>
</table></div><p>String literals are delimited by <span class="syntax-token">"</span> (double quote) characters.
The two double quotes enclose a sequence of either characters
different from <span class="syntax-token">"</span> and <span class="syntax-token">\</span>, or escape sequences from the
table given above for character literals, or a Unicode character
escape sequence.</p><p>A Unicode character escape sequence is substituted by the UTF-8
encoding of the specified Unicode scalar value. The Unicode scalar
value, an integer in the ranges 0x0000...0xD7FF or 0xE000...0x10FFFF,
is defined using 1 to 6 hexadecimal digits; leading zeros are allowed.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> greeting = <span class="ocamlstring">"Hello, World!\n"</span>
  <span class="ocamlkeyword">let</span> superscript_plus = <span class="ocamlstring">"\u{207A}"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> greeting : string = <span class="ocamlstring">"Hello, World!\n"</span>
<span class="ocamlkeyword">val</span> superscript_plus : string = <span class="ocamlstring">"âº"</span></div></div>

</div><p>To allow splitting long string literals across lines, the sequence
<span class="machine"><span class="font-tt">\</span></span><span class="font-it">newline</span>Â <span class="font-it">spaces-or-tabs</span> (a backslash at the end of a line
followed by any number of spaces and horizontal tabulations at the
beginning of the next line) is ignored inside string literals.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> longstr =
    <span class="ocamlstring">"Call me Ishmael. Some years ago â€” never mind how long \
    precisely â€” having little or no money in my purse, and \
    nothing particular to interest me on shore, I thought I\
    \ would sail about a little and see the watery part of t\
    he world."</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> longstr : string =
  <span class="ocamlstring">"Call me Ishmael. Some years ago â€” never mind how long precisely â€” having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world."</span></div></div>

</div><p>Quoted string literals provide an alternative lexical syntax for
string literals. They are useful to represent strings of arbitrary content
without escaping. Quoted strings are delimited by a matching pair
of <span class="syntax-token">{</span> <a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a> <span class="syntax-token">|</span> and <span class="syntax-token">|</span> <a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a> <span class="syntax-token">}</span> with
the same <a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a> on both sides. Quoted strings do not interpret
any character in a special way but requires that the
sequence <span class="syntax-token">|</span> <a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a> <span class="syntax-token">}</span> does not occur in the string itself.
The identifier <a class="syntax" href="#quoted-string-id"><span class="nonterminal">quoted-string-id</span></a> is a (possibly empty) sequence of
lowercase letters and underscores that can be freely chosen to avoid
such issue.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> quoted_greeting = <span class="ocamlstring">{|"Hello, World!"|}</span>
  <span class="ocamlkeyword">let</span> nested = {ext|hello <span class="ocamlstring">{|world|}</span>|ext};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> quoted_greeting : string = <span class="ocamlstring">"\"Hello, World!\""</span>
<span class="ocamlkeyword">val</span> nested : string = <span class="ocamlstring">"hello {|world|}"</span></div></div>

</div><p>The current implementation places practically no restrictions on the
length of string literals.</p><!--TOC subsubsection id="sss:labelname" Naming labels-->
<h4 class="subsubsection" id="sss:labelname"><a class="section-anchor" href="#sss:labelname" aria-hidden="true">ï»¿</a>Naming labels</h4><!--SEC END --><p>To avoid ambiguities, naming labels in expressions cannot just be defined
syntactically as the sequence of the three tokens <span class="machine"><span class="font-tt">~</span></span>, <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> and
<span class="machine"><span class="font-tt">:</span></span>, and have to be defined at the lexical level.</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="label-name"><span class="nonterminal">label-name</span></a></td><td class="c005">::=</td><td class="c007">â€„<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="label"><span class="nonterminal">label</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="optlabel"><span class="nonterminal">optlabel</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>
</td></tr>
</table></td></tr>
</table></div><p>Naming labels come in two flavours: <a class="syntax" href="#label"><span class="nonterminal">label</span></a> for normal arguments and
<a class="syntax" href="#optlabel"><span class="nonterminal">optlabel</span></a> for optional ones. They are simply distinguished by their
first character, either <span class="machine"><span class="font-tt">~</span></span> or <span class="machine"><span class="font-tt">?</span></span>.</p><p>Despite <a class="syntax" href="#label"><span class="nonterminal">label</span></a> and <a class="syntax" href="#optlabel"><span class="nonterminal">optlabel</span></a> being lexical entities in expressions,
their expansions <span class="syntax-token">~</span> <a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> and <span class="syntax-token">?</span> <a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> will be
used in grammars, for the sake of readability. Note also that inside
type expressions, this expansion can be taken literally, <em>i.e.</em>
there are really 3 tokens, with optional blanks between them.</p><!--TOC subsubsection id="sss:lex-ops-symbols" Prefix and infix symbols-->
<h4 class="subsubsection" id="sss:lex-ops-symbols"><a class="section-anchor" href="#sss:lex-ops-symbols" aria-hidden="true">ï»¿</a>Prefix and infix symbols</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="infix-symbol"><span class="nonterminal">infix-symbol</span></a></td><td class="c005">::=</td><td class="c007">
(<a class="syntax" href="#core-operator-char"><span class="nonterminal">core-operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">%</span>â€„âˆ£â€„<span class="syntax-token">&lt;</span>)â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">#</span>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="prefix-symbol"><span class="nonterminal">prefix-symbol</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">!</span>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„(<span class="syntax-token">?</span>â€„âˆ£â€„<span class="syntax-token">~</span>)â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="operator-char"><span class="nonterminal">operator-char</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">~</span>â€„âˆ£â€„<span class="syntax-token">!</span>â€„âˆ£â€„<span class="syntax-token">?</span>â€„âˆ£â€„<a class="syntax" href="#core-operator-char"><span class="nonterminal">core-operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">%</span>â€„âˆ£â€„<span class="syntax-token">&lt;</span>â€„âˆ£â€„<span class="syntax-token">:</span>â€„âˆ£â€„<span class="syntax-token">.</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="core-operator-char"><span class="nonterminal">core-operator-char</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">$</span>â€„âˆ£â€„<span class="syntax-token">&amp;</span>â€„âˆ£â€„<span class="syntax-token">*</span>â€„âˆ£â€„<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>â€„âˆ£â€„<span class="syntax-token">/</span>â€„âˆ£â€„<span class="syntax-token">=</span>â€„âˆ£â€„<span class="syntax-token">&gt;</span>â€„âˆ£â€„<span class="syntax-token">@</span>â€„âˆ£â€„<span class="syntax-token">^</span>â€„âˆ£â€„<span class="syntax-token">|</span>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Aext-ops">extension operators</a>,
<a href="#s%3Aindex-operators">extended indexing operators</a>,
and <a href="#s%3Abinding-operators">binding operators</a>.</p><p>Sequences of â€œoperator charactersâ€, such as <span class="machine"><span class="font-tt">&lt;=&gt;</span></span> or <span class="machine"><span class="font-tt">!!</span></span>,
are read as a single token from the <a class="syntax" href="#infix-symbol"><span class="nonterminal">infix-symbol</span></a> or <a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a>
class. These symbols are parsed as prefix and infix operators inside
expressions, but otherwise behave like normal identifiers.
</p><!--TOC subsubsection id="sss:keywords" Keywords-->
<h4 class="subsubsection" id="sss:keywords"><a class="section-anchor" href="#sss:keywords" aria-hidden="true">ï»¿</a>Keywords</h4><!--SEC END --><p>The identifiers below are reserved as keywords, and cannot be employed
otherwise:
</p><pre>      and         as          assert      asr         begin       class
      constraint  do          done        downto      else        end
      exception   external    false       for         fun         function
      functor     if          in          include     inherit     initializer
      land        lazy        let         lor         lsl         lsr
      lxor        match       method      mod         module      mutable
      new         nonrec      object      of          open        or
      private     rec         sig         struct      then        to
      true        try         type        val         virtual     when
      while       with
</pre><p> <br>
The following character sequences are also keywords:
</p><pre>
<span class="machine"><span class="font-tt">    !=    #     &amp;     &amp;&amp;    '     (     )     *     +     ,     -</span></span>
<span class="machine"><span class="font-tt">    -.    -&gt;    .     ..    .~    :     ::    :=    :&gt;    ;     ;;</span></span>
<span class="machine"><span class="font-tt">    &lt;     &lt;-    =     &gt;     &gt;]    &gt;}    ?     [     [&lt;    [&gt;    [|</span></span>
<span class="machine"><span class="font-tt">    ]     _     `     {     {&lt;    |     |]    ||    }     ~</span></span>
</pre><p>
Note that the following identifiers are keywords of the now unmaintained Camlp4
system and should be avoided for backwards compatibility reasons.
</p><pre>    parser    value    $     $$    $:    &lt;:    &lt;&lt;    &gt;&gt;    ??
</pre><!--TOC subsubsection id="sss:lex-ambiguities" Ambiguities-->
<h4 class="subsubsection" id="sss:lex-ambiguities"><a class="section-anchor" href="#sss:lex-ambiguities" aria-hidden="true">ï»¿</a>Ambiguities</h4><!--SEC END --><p>Lexical ambiguities are resolved according to the â€œlongest matchâ€
rule: when a character sequence can be decomposed into two tokens in
several different ways, the decomposition retained is the one with the
longest first token.</p><!--TOC subsubsection id="sss:lex-linedir" Line number directives-->
<h4 class="subsubsection" id="sss:lex-linedir"><a class="section-anchor" href="#sss:lex-linedir" aria-hidden="true">ï»¿</a>Line number directives</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="linenum-directive"><span class="nonterminal">linenum-directive</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">#</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„}<sup>+</sup>â€„<span class="syntax-token">"</span>â€„{â€„<a class="syntax" href="#string-character"><span class="nonterminal">string-character</span></a>â€„}â€„<span class="syntax-token">"</span>
</td></tr>
</table></td></tr>
</table></div><p>Preprocessors that generate OCaml source code can insert line number
directives in their output so that error messages produced by the
compiler contain line numbers and file names referring to the source
file before preprocessing, instead of after preprocessing.
A line number directive starts at the beginning of a line,
is composed of a <span class="syntax-token">#</span> (sharp sign), followed by
a positive integer (the source line number), followed by a
character string (the source file name).
Line number directives are treated as blanks during lexical
analysis.</p>
<!--TOC section id="s:values" 11.2â€ƒValues-->
<h2 class="section" id="s:values"><a class="section-anchor" href="#s:values" aria-hidden="true">ï»¿</a>11.2â€ƒValues</h2><!--SEC END --><!--NAME values.html-->
<p>This section describes the kinds of values that are manipulated by
OCaml programs.</p>
<!--TOC subsection id="ss:values:base" 11.2.1â€ƒBase values-->
<h3 class="subsection" id="ss:values:base"><a class="section-anchor" href="#ss:values:base" aria-hidden="true">ï»¿</a>11.2.1â€ƒBase values</h3><!--SEC END --><!--TOC subsubsection id="sss:values:integer" Integer numbers-->
<h4 class="subsubsection" id="sss:values:integer"><a class="section-anchor" href="#sss:values:integer" aria-hidden="true">ï»¿</a>Integer numbers</h4><!--SEC END --><p>Integer values are integer numbers from âˆ’2<sup>30</sup> to 2<sup>30</sup>âˆ’1, that
is âˆ’1073741824 to 1073741823. The implementation may support a
wider range of integer values: on 64-bit platforms, the current
implementation supports integers ranging from âˆ’2<sup>62</sup> to 2<sup>62</sup>âˆ’1.</p><!--TOC subsubsection id="sss:values:float" Floating-point numbers-->
<h4 class="subsubsection" id="sss:values:float"><a class="section-anchor" href="#sss:values:float" aria-hidden="true">ï»¿</a>Floating-point numbers</h4><!--SEC END --><p>Floating-point values are numbers in floating-point representation.
The current implementation uses double-precision floating-point
numbers conforming to the IEEE 754 standard, with 53 bits of mantissa
and an exponent ranging from âˆ’1022 to 1023.</p><!--TOC subsubsection id="sss:values:char" Characters-->
<h4 class="subsubsection" id="sss:values:char"><a class="section-anchor" href="#sss:values:char" aria-hidden="true">ï»¿</a>Characters</h4><!--SEC END --><p>Character values are represented as 8-bit integers between 0 and 255.
Character codes between 0 and 127 are interpreted following the ASCII
standard. The current implementation interprets character codes
between 128 and 255 following the ISO 8859-1 standard.</p><!--TOC subsubsection id="sss:values:string" Character strings-->
<h4 class="subsubsection" id="sss:values:string"><a class="section-anchor" href="#sss:values:string" aria-hidden="true">ï»¿</a>Character strings</h4><!--SEC END --><p>String values are finite sequences of characters. The current
implementation supports strings containing up to 2<sup>24</sup> âˆ’ 5
characters (16777211 characters); on 64-bit platforms, the limit is
2<sup>57</sup> âˆ’ 9.</p>
<!--TOC subsection id="ss:values:tuple" 11.2.2â€ƒTuples-->
<h3 class="subsection" id="ss:values:tuple"><a class="section-anchor" href="#ss:values:tuple" aria-hidden="true">ï»¿</a>11.2.2â€ƒTuples</h3><!--SEC END --><p>Tuples of values are written <span class="syntax-token">(</span><span class="nonterminal">v</span><sub>1</sub><span class="syntax-token">,</span> â€¦<span class="syntax-token">,</span> <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub><span class="syntax-token">)</span>, standing for the
<span class="font-it">n</span>-tuple of values <span class="nonterminal">v</span><sub>1</sub> to <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub>. The current implementation
supports tuple of up to 2<sup>22</sup> âˆ’ 1 elements (4194303 elements).</p>
<!--TOC subsection id="ss:values:records" 11.2.3â€ƒRecords-->
<h3 class="subsection" id="ss:values:records"><a class="section-anchor" href="#ss:values:records" aria-hidden="true">ï»¿</a>11.2.3â€ƒRecords</h3><!--SEC END --><p>Record values are labeled tuples of values. The record value written
<span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">=</span> <span class="nonterminal">v</span><sub>1</sub><span class="syntax-token">;</span> â€¦<span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span> associates the value
<span class="nonterminal">v</span><sub><span class="font-it">i</span></sub> to the record field <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">i</span></sub>, for <span class="font-it">i</span> = 1 â€¦ <span class="font-it">n</span>. The current
implementation supports records with up to 2<sup>22</sup> âˆ’ 1 fields
(4194303 fields).</p>
<!--TOC subsection id="ss:values:array" 11.2.4â€ƒArrays-->
<h3 class="subsection" id="ss:values:array"><a class="section-anchor" href="#ss:values:array" aria-hidden="true">ï»¿</a>11.2.4â€ƒArrays</h3><!--SEC END --><p>Arrays are finite, variable-sized sequences of values of the same
type. The current implementation supports arrays containing up to
2<sup>22</sup> âˆ’ 1 elements (4194303 elements) unless the elements are
floating-point numbers (2097151 elements in this case); on 64-bit
platforms, the limit is 2<sup>54</sup> âˆ’ 1 for all arrays.</p>
<!--TOC subsection id="ss:values:variant" 11.2.5â€ƒVariant values-->
<h3 class="subsection" id="ss:values:variant"><a class="section-anchor" href="#ss:values:variant" aria-hidden="true">ï»¿</a>11.2.5â€ƒVariant values</h3><!--SEC END --><p>Variant values are either a constant constructor, or a non-constant
constructor applied to a number of values. The former case is written
<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>; the latter case is written <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span><span class="nonterminal">v</span><sub>1</sub><span class="syntax-token">,</span> ... <span class="syntax-token">,</span> <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub>
<span class="syntax-token">)</span>, where the <span class="nonterminal">v</span><sub><span class="font-it">i</span></sub> are said to be the arguments of the non-constant
constructor <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>. The parentheses may be omitted if there is only
one argument.</p><p>The following constants are treated like built-in constant
constructors:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Constant</span></td><td class="c004"><span class="font-bold">Constructor</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">false</span></span></td><td class="c006">the boolean false </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">true</span></span></td><td class="c006">the boolean true </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">()</span></span></td><td class="c006">the â€œunitâ€ value </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">[]</span></span></td><td class="c006">the empty list </td></tr>
</table></div></div><p>The current implementation limits each variant type to have at most
246 non-constant constructors and 2<sup>30</sup>âˆ’1 constant constructors.</p>
<!--TOC subsection id="ss:values:polyvars" 11.2.6â€ƒPolymorphic variants-->
<h3 class="subsection" id="ss:values:polyvars"><a class="section-anchor" href="#ss:values:polyvars" aria-hidden="true">ï»¿</a>11.2.6â€ƒPolymorphic variants</h3><!--SEC END --><p>Polymorphic variants are an alternate form of variant values, not
belonging explicitly to a predefined variant type, and following
specific typing rules. They can be either constant, written
<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>, or non-constant, written <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a><span class="syntax-token">(</span><span class="nonterminal">v</span><span class="syntax-token">)</span>.</p>
<!--TOC subsection id="ss:values:fun" 11.2.7â€ƒFunctions-->
<h3 class="subsection" id="ss:values:fun"><a class="section-anchor" href="#ss:values:fun" aria-hidden="true">ï»¿</a>11.2.7â€ƒFunctions</h3><!--SEC END --><p>Functional values are mappings from values to values.</p>
<!--TOC subsection id="ss:values:obj" 11.2.8â€ƒObjects-->
<h3 class="subsection" id="ss:values:obj"><a class="section-anchor" href="#ss:values:obj" aria-hidden="true">ï»¿</a>11.2.8â€ƒObjects</h3><!--SEC END --><p>Objects are composed of a hidden internal state which is a
record of instance variables, and a set of methods for accessing and
modifying these variables. The structure of an object is described by
the toplevel class that created it.

</p>
<!--TOC section id="s:names" 11.3â€ƒNames-->
<h2 class="section" id="s:names"><a class="section-anchor" href="#s:names" aria-hidden="true">ï»¿</a>11.3â€ƒNames</h2><!--SEC END --><!--NAME names.html-->
<p>Identifiers are used to give names to several classes of language
objects and refer to these objects by name later:
</p><ul class="itemize"><li class="li-itemize">value names (syntactic class <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>),
</li><li class="li-itemize">value constructors and exception constructors (class <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>),
</li><li class="li-itemize">labels (<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>, defined in sectionÂ <a href="#sss%3Alabelname">11.1</a>),
</li><li class="li-itemize">polymorphic variant tags (<a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>),
</li><li class="li-itemize">type constructors (<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>),
</li><li class="li-itemize">record fields (<a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a>),
</li><li class="li-itemize">class names (<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>),
</li><li class="li-itemize">method names (<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>),
</li><li class="li-itemize">instance variable names (<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>),
</li><li class="li-itemize">module names (<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>),
</li><li class="li-itemize">module type names (<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>).
</li></ul><p>
These eleven name spaces are distinguished both by the context and by the
capitalization of the identifier: whether the first letter of the
identifier is in lowercase (written <a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a> below) or in
uppercase (written <a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>). Underscore is considered a
lowercase letter for this purpose.</p><!--TOC subsubsection id="sss:naming-objects" Naming objects-->
<h4 class="subsubsection" id="sss:naming-objects"><a class="section-anchor" href="#sss:naming-objects" aria-hidden="true">ï»¿</a>Naming objects</h4><!--SEC END --><p>
<a id="hevea_manual.kwd0"></a>
<a id="hevea_manual.kwd1"></a>
<a id="hevea_manual.kwd2"></a>
<a id="hevea_manual.kwd3"></a>
<a id="hevea_manual.kwd4"></a>
<a id="hevea_manual.kwd5"></a>
<a id="hevea_manual.kwd6"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="value-name"><span class="nonterminal">value-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#operator-name"><span class="nonterminal">operator-name</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="operator-name"><span class="nonterminal">operator-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a>â€„âˆ£â€„<a class="syntax" href="#infix-op"><span class="nonterminal">infix-op</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="infix-op"><span class="nonterminal">infix-op</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#infix-symbol"><span class="nonterminal">infix-symbol</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">*</span>â€„âˆ£â€„<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>â€„âˆ£â€„<span class="syntax-token">-.</span>â€„âˆ£â€„<span class="syntax-token">=</span>â€„âˆ£â€„<span class="syntax-token">!=</span>â€„âˆ£â€„<span class="syntax-token">&lt;</span>â€„âˆ£â€„<span class="syntax-token">&gt;</span>â€„âˆ£â€„<span class="syntax-token">or</span>â€„âˆ£â€„<span class="syntax-token">||</span>
âˆ£â€„<span class="syntax-token">&amp;</span>â€„âˆ£â€„<span class="syntax-token">&amp;&amp;</span>â€„âˆ£â€„<span class="syntax-token">:=</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">mod</span>â€„âˆ£â€„<span class="syntax-token">land</span>â€„âˆ£â€„<span class="syntax-token">lor</span>â€„âˆ£â€„<span class="syntax-token">lxor</span>â€„âˆ£â€„<span class="syntax-token">lsl</span>â€„âˆ£â€„<span class="syntax-token">lsr</span>â€„âˆ£â€„<span class="syntax-token">asr</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="constr-name"><span class="nonterminal">constr-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="tag-name"><span class="nonterminal">tag-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="typeconstr-name"><span class="nonterminal">typeconstr-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="field-name"><span class="nonterminal">field-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="module-name"><span class="nonterminal">module-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="modtype-name"><span class="nonterminal">modtype-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-name"><span class="nonterminal">class-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="inst-var-name"><span class="nonterminal">inst-var-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="method-name"><span class="nonterminal">method-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extension:
<a href="#s%3Aindex-operators">extended indexing operators</a>.</p><p>As shown above, prefix and infix symbols as well as some keywords can
be used as value names, provided they are written between parentheses.
The capitalization rules are summarized in the table below.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Name space</span></td><td class="c004"><span class="font-bold">Case of first letter</span> </td></tr>
<tr><td class="c006">
Values</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Constructors</td><td class="c006">uppercase </td></tr>
<tr><td class="c006">Labels</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Polymorphic variant tags</td><td class="c006">uppercase </td></tr>
<tr><td class="c006">Exceptions</td><td class="c006">uppercase </td></tr>
<tr><td class="c006">Type constructors</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Record fields</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Classes</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Instance variables</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Methods</td><td class="c006">lowercase </td></tr>
<tr><td class="c006">Modules</td><td class="c006">uppercase </td></tr>
<tr><td class="c006">Module types</td><td class="c006">any </td></tr>
</table></div></div><p><span class="font-it">Note on polymorphic variant tags:</span> the current implementation accepts
lowercase variant tags in addition to capitalized variant tags, but we
suggest you avoid lowercase variant tags for portability and
compatibility with future OCaml versions.</p><!--TOC subsubsection id="sss:refer-named" Referring to named objects-->
<h4 class="subsubsection" id="sss:refer-named"><a class="section-anchor" href="#sss:refer-named" aria-hidden="true">ï»¿</a>Referring to named objects</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="value-path"><span class="nonterminal">value-path</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="constr"><span class="nonterminal">constr</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="typeconstr"><span class="nonterminal">typeconstr</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="field"><span class="nonterminal">field</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="modtype-path"><span class="nonterminal">modtype-path</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-path"><span class="nonterminal">class-path</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="classtype-path"><span class="nonterminal">classtype-path</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>â€„<span class="syntax-token">.</span>â€„]â€„<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="module-path"><span class="nonterminal">module-path</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="extended-module-path"><span class="nonterminal">extended-module-path</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#extended-module-name"><span class="nonterminal">extended-module-name</span></a>â€„{â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#extended-module-name"><span class="nonterminal">extended-module-name</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="extended-module-name"><span class="nonterminal">extended-module-name</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>â€„<span class="syntax-token">)</span>â€„}
</td></tr>
</table></td></tr>
</table></div><p>A named object can be referred to either by its name (following the
usual static scoping rules for names) or by an access path <span class="nonterminal">prefix</span> <span class="syntax-token">.</span> <span class="nonterminal">name</span>,
where <span class="nonterminal">prefix</span> designates a module and <span class="nonterminal">name</span> is the name of an object
defined in that module. The first component of the path, <span class="nonterminal">prefix</span>, is
either a simple module name or an access path <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">.</span> <span class="nonterminal">name</span><sub>2</sub> â€¦,
in case the defining module is itself nested inside other modules.
For referring to type constructors, module types, or class types,
the <span class="nonterminal">prefix</span> can
also contain simple functor applications (as in the syntactic class
<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a> above) in case the defining module is the
result of a functor application.</p><p>Label names, tag names, method names and instance variable names need
not be qualified: the former three are global labels, while the latter
are local to a class.

</p>
<!--TOC section id="s:typexpr" 11.4â€ƒType expressions-->
<h2 class="section" id="s:typexpr"><a class="section-anchor" href="#s:typexpr" aria-hidden="true">ï»¿</a>11.4â€ƒType expressions</h2><!--SEC END --><!--NAME types.html-->
<p>
<a id="hevea_manual.kwd7"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="typexpr"><span class="nonterminal">typexpr</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">_</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[[<span class="syntax-token">?</span>]<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>]â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">*</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}â€„<span class="syntax-token">)</span>â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">as</span>â€„<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#polymorphic-variant-type"><span class="nonterminal">polymorphic-variant-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">&lt;</span>â€„[<span class="syntax-token">..</span>]â€„<span class="syntax-token">&gt;</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">&lt;</span>â€„<a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a>â€„}â€„[<span class="syntax-token">;</span>â€„âˆ£â€„<span class="syntax-token">;</span>â€„<span class="syntax-token">..</span>]â€„<span class="syntax-token">&gt;</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">#</span>â€„<a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">#</span>â€„<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}â€„<span class="syntax-token">)</span>â€„<span class="syntax-token">#</span>â€„<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="poly-typexpr"><span class="nonterminal">poly-typexpr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„{â€„<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="method-type"><span class="nonterminal">method-type</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Afirst-class-modules">first-class modules</a>,
<a href="#s%3Aattributes">attributes</a> and
<a href="#s%3Aextension-nodes">extension nodes</a>.</p><p>The table below shows the relative precedences and associativity of
operators and non-closed type constructions. The constructions with
higher precedences come first.
<a id="hevea_manual.kwd8"></a>
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Operator</span></td><td class="c004"><span class="font-bold">Associativity</span> </td></tr>
<tr><td class="c006">
Type constructor application</td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">#</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">*</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">-&gt;</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">as</span></span></td><td class="c006">â€“ </td></tr>
</table></div></div><p>Type expressions denote types in definitions of data types as well as
in type constraints over patterns and expressions.</p><!--TOC subsubsection id="sss:typexpr-variables" Type variables-->
<h4 class="subsubsection" id="sss:typexpr-variables"><a class="section-anchor" href="#sss:typexpr-variables" aria-hidden="true">ï»¿</a>Type variables</h4><!--SEC END --><p>The type expression <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> stands for the type variable named
<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>. The type expression <span class="syntax-token">_</span> stands for either an anonymous type
variable or anonymous type parameters. In data type definitions, type
variables are names for the data type parameters. In type constraints,
they represent unspecified types that can be instantiated by any type
to satisfy the type constraint. In general the scope of a named type
variable is the whole top-level phrase where it appears, and it can
only be generalized when leaving this scope. Anonymous variables have
no such restriction. In the following cases, the scope of named type
variables is restricted to the type expression where they appear:
1) for universal (explicitly polymorphic) type variables;
2) for type variables that only appear in public method specifications
(as those variables will be made universal, as described in
sectionÂ <a href="#sss%3Aclty-meth">11.9.1</a>);
3) for variables used as aliases, when the type they are aliased to
would be invalid in the scope of the enclosing definition (<span class="font-it">i.e.</span>
when it contains free universal type variables, or locally
defined types.)</p><!--TOC subsubsection id="sss:typexr:parenthesized" Parenthesized types-->
<h4 class="subsubsection" id="sss:typexr:parenthesized"><a class="section-anchor" href="#sss:typexr:parenthesized" aria-hidden="true">ï»¿</a>Parenthesized types</h4><!--SEC END --><p>The type expression <span class="syntax-token">(</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span> denotes the same type as
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.</p><!--TOC subsubsection id="sss:typexr-fun" Function types-->
<h4 class="subsubsection" id="sss:typexr-fun"><a class="section-anchor" href="#sss:typexr-fun" aria-hidden="true">ï»¿</a>Function types</h4><!--SEC END --><p>The type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> denotes the type of
functions mapping arguments of type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> to results of type
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>.</p><p><a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> denotes the same function type, but
the argument is labeled <a class="syntax" href="#label"><span class="nonterminal">label</span></a>.</p><p><span class="syntax-token">?</span> <a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> denotes the type of functions
mapping an optional labeled argument of type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> to results of
type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>. That is, the physical type of the function will be
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">option</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>.</p><!--TOC subsubsection id="sss:typexpr-tuple" Tuple types-->
<h4 class="subsubsection" id="sss:typexpr-tuple"><a class="section-anchor" href="#sss:typexpr-tuple" aria-hidden="true">ï»¿</a>Tuple types</h4><!--SEC END --><p>The type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">*</span> â€¦ <span class="syntax-token">*</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>
denotes the type of tuples whose elements belong to types <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub>,
â€¦ <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> respectively.</p><!--TOC subsubsection id="sss:typexpr-constructed" Constructed types-->
<h4 class="subsubsection" id="sss:typexpr-constructed"><a class="section-anchor" href="#sss:typexpr-constructed" aria-hidden="true">ï»¿</a>Constructed types</h4><!--SEC END --><p>Type constructors with no parameter, as in <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>, are type
expressions.</p><p>The type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>, where <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> is a type
constructor with one parameter, denotes the application of the unary type
constructor <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> to the type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.</p><p>The type expression (<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub>,â€¦,<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>) <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>, where
<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> is a type constructor with <span class="font-it">n</span> parameters, denotes the
application of the <span class="font-it">n</span>-ary type constructor <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> to the types
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> through <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>.</p><p>In the type expression  <span class="syntax-token">_</span> <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> , the anonymous type expression
 <span class="syntax-token">_</span>  stands in for anonymous type parameters and is equivalent to
 (<span class="syntax-token">_</span>, â€¦,<span class="syntax-token">_</span>)  with as many repetitions of <span class="machine"><span class="font-tt">_</span></span> as the arity of
<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>.</p><!--TOC subsubsection id="sss:typexpr-aliased-recursive" Aliased and recursive types-->
<h4 class="subsubsection" id="sss:typexpr-aliased-recursive"><a class="section-anchor" href="#sss:typexpr-aliased-recursive" aria-hidden="true">ï»¿</a>Aliased and recursive types</h4><!--SEC END --><p><a id="hevea_manual.kwd9"></a></p><p>The type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">as</span> <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> denotes the same type as
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>, and also binds the type variable <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> to type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> both
in <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> and in other types. In general the scope of an alias is
the same as for a named type variable, and covers the whole enclosing
definition. If the type variable
<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> actually occurs in <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>, a recursive type is created. Recursive
types for which there exists a recursive path that does not contain
an object or polymorphic variant type constructor are rejected, except
when the <span class="machine"><span class="font-tt">-rectypes</span></span> mode is selected.</p><p>If <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> denotes an explicit polymorphic variable, and <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
denotes either an object or polymorphic variant type, the row variable
of <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> is captured by <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>, and quantified upon.</p><!--TOC subsubsection id="sss:typexpr-polyvar" Polymorphic variant types-->
<h4 class="subsubsection" id="sss:typexpr-polyvar"><a class="section-anchor" href="#sss:typexpr-polyvar" aria-hidden="true">ï»¿</a>Polymorphic variant types</h4><!--SEC END --><p>
<a id="hevea_manual.kwd10"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="polymorphic-variant-type"><span class="nonterminal">polymorphic-variant-type</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[</span>â€„<a class="syntax" href="#tag-spec-first"><span class="nonterminal">tag-spec-first</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#tag-spec"><span class="nonterminal">tag-spec</span></a>â€„}â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[&gt;</span>â€„[â€„<a class="syntax" href="#tag-spec"><span class="nonterminal">tag-spec</span></a>â€„]â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#tag-spec"><span class="nonterminal">tag-spec</span></a>â€„}â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[&lt;</span>â€„[<span class="syntax-token">|</span>]â€„<a class="syntax" href="#tag-spec-full"><span class="nonterminal">tag-spec-full</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#tag-spec-full"><span class="nonterminal">tag-spec-full</span></a>â€„}
[â€„<span class="syntax-token">&gt;</span>â€„{â€„<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„}<sup>+</sup>â€„]â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="tag-spec-first"><span class="nonterminal">tag-spec-first</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„[â€„<span class="syntax-token">of</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„]â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#tag-spec"><span class="nonterminal">tag-spec</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="tag-spec"><span class="nonterminal">tag-spec</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„[â€„<span class="syntax-token">of</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="tag-spec-full"><span class="nonterminal">tag-spec-full</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„[â€„<span class="syntax-token">of</span>â€„[<span class="syntax-token">&amp;</span>]â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">&amp;</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Polymorphic variant types describe the values a polymorphic variant
may take.</p><p>The first case is an exact variant type: all possible tags are
known, with their associated types, and they can all be present.
Its structure is fully known.</p><p>The second case is an open variant type, describing a polymorphic
variant value: it gives the list of all tags the value could take,
with their associated types. This type is still compatible with a
variant type containing more tags. A special case is the unknown
type, which does not define any tag, and is compatible with any
variant type.</p><p>The third case is a closed variant type. It gives information about
all the possible tags and their associated types, and which tags are
known to potentially appear in values. The exact variant type (first
case) is
just an abbreviation for a closed variant type where all possible tags
are also potentially present.</p><p>In all three cases, tags may be either specified directly in the
<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a> [<span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>] form, or indirectly through a type
expression, which must expand to an
exact variant type, whose tag specifications are inserted in its
place.</p><p>Full specifications of variant tags are only used for non-exact closed
types. They can be understood as a conjunctive type for the argument:
it is intended to have all the types enumerated in the
specification.</p><p>Such conjunctive constraints may be unsatisfiable. In such a case the
corresponding tag may not be used in a value of this type. This
does not mean that the whole type is not valid: one can still use
other available tags.
Conjunctive constraints are mainly intended as output from the type
checker. When they are used in source programs, unsolvable constraints
may cause early failures.</p><!--TOC subsubsection id="sss:typexpr-obj" Object types-->
<h4 class="subsubsection" id="sss:typexpr-obj"><a class="section-anchor" href="#sss:typexpr-obj" aria-hidden="true">ï»¿</a>Object types</h4><!--SEC END --><p>An object type
<span class="syntax-token">&lt;</span> [<a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a> }] <span class="syntax-token">&gt;</span>
is a record of method types.</p><p>Each method may have an explicit polymorphic type: { <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> }<sup>+</sup>
<span class="syntax-token">.</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>. Explicit polymorphic variables have a local scope, and
an explicit polymorphic type can only be unified to an
equivalent one, where only the order and names of polymorphic
variables may change.</p><p>The type <span class="syntax-token">&lt;</span> { <a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a> <span class="syntax-token">;</span> } <span class="syntax-token">..</span> <span class="syntax-token">&gt;</span> is the
type of an object whose method names and types are described by
<a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a><sub><span class="font-it">n</span></sub>, and possibly some other
methods represented by the ellipsis. This ellipsis actually is
a special kind of type variable (called <em>row variable</em> in the
literature) that stands for any number of extra method types.</p><!--TOC subsubsection id="sss:typexpr-sharp-types" #-types-->
<h4 class="subsubsection" id="sss:typexpr-sharp-types"><a class="section-anchor" href="#sss:typexpr-sharp-types" aria-hidden="true">ï»¿</a>#-types</h4><!--SEC END --><p>The type <span class="syntax-token">#</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> is a special kind of abbreviation. This
abbreviation unifies with the type of any object belonging to a subclass
of the class type <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a>.
It is handled in a special way as it usually hides a type variable (an
ellipsis, representing the methods that may be added in a subclass).
In particular, it vanishes when the ellipsis gets instantiated.
Each type expression <span class="syntax-token">#</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> defines a new type variable, so
type <span class="syntax-token">#</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> <span class="syntax-token">-&gt;</span> <span class="syntax-token">#</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> is usually not the same as
type (<span class="syntax-token">#</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> <span class="syntax-token">as</span> <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>) <span class="syntax-token">-&gt;</span> <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>.
</p><p>Use of #-types to abbreviate polymorphic variant types is deprecated.
If <span class="nonterminal">t</span> is an exact variant type then <span class="syntax-token">#</span><span class="nonterminal">t</span> translates to <span class="syntax-token">[&lt;</span> <span class="nonterminal">t</span><span class="syntax-token">]</span>,
and <span class="syntax-token">#</span><span class="nonterminal">t</span><span class="syntax-token">[&gt;</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag</span></a><sub>1</sub> â€¦<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag</span></a><sub><span class="font-it">k</span></sub><span class="syntax-token">]</span> translates to
<span class="syntax-token">[&lt;</span> <span class="nonterminal">t</span> <span class="syntax-token">&gt;</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag</span></a><sub>1</sub> â€¦<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag</span></a><sub><span class="font-it">k</span></sub><span class="syntax-token">]</span></p><!--TOC subsubsection id="sss:typexpr-variant-record" Variant and record types-->
<h4 class="subsubsection" id="sss:typexpr-variant-record"><a class="section-anchor" href="#sss:typexpr-variant-record" aria-hidden="true">ï»¿</a>Variant and record types</h4><!--SEC END --><p>There are no type expressions describing (defined) variant types nor
record types, since those are always named, i.e. defined before use
and referred to by name. Type definitions are described in
sectionÂ <a href="#ss%3Atypedefs">11.8.1</a>.

</p>
<!--TOC section id="s:const" 11.5â€ƒConstants-->
<h2 class="section" id="s:const"><a class="section-anchor" href="#s:const" aria-hidden="true">ï»¿</a>11.5â€ƒConstants</h2><!--SEC END --><!--NAME const.html-->
<p><a id="hevea_manual.kwd11"></a>
<a id="hevea_manual.kwd12"></a>
<a id="hevea_manual.kwd13"></a>
<a id="hevea_manual.kwd14"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="constant"><span class="nonterminal">constant</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#integer-literal"><span class="nonterminal">integer-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#int32-literal"><span class="nonterminal">int32-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#int64-literal"><span class="nonterminal">int64-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#nativeint-literal"><span class="nonterminal">nativeint-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#float-literal"><span class="nonterminal">float-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#char-literal"><span class="nonterminal">char-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#string-literal"><span class="nonterminal">string-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">false</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">true</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">()</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">begin</span>â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[||]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extension:
<a href="#ss%3Aextension-literals">extension literals</a>.</p><p>The syntactic class of constants comprises literals from the four
base types (integers, floating-point numbers, characters, character
strings), the integer variants, and constant constructors
from both normal and polymorphic variants, as well as the special
constants <span class="syntax-token">false</span>, <span class="syntax-token">true</span>, <span class="syntax-token">()</span>,
<span class="syntax-token">[]</span>, and <span class="syntax-token">[||]</span>, which behave like constant constructors, and
<span class="syntax-token">begin</span> <span class="syntax-token">end</span>, which is equivalent to <span class="syntax-token">()</span>.

</p>
<!--TOC section id="s:patterns" 11.6â€ƒPatterns-->
<h2 class="section" id="s:patterns"><a class="section-anchor" href="#s:patterns" aria-hidden="true">ï»¿</a>11.6â€ƒPatterns</h2><!--SEC END --><p>
<a id="hevea_manual.kwd15"></a>
</p><!--NAME patterns.html-->
<div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">_</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constant"><span class="nonterminal">constant</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">as</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">#</span><a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>]{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>]â€„}â€„[<span class="syntax-token">;</span>â€„<span class="syntax-token">_</span>â€„]â€„[â€„<span class="syntax-token">;</span>â€„]â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„}â€„[â€„<span class="syntax-token">;</span>â€„]â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">::</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[|</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„}â€„[â€„<span class="syntax-token">;</span>â€„]â€„<span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#char-literal"><span class="nonterminal">char-literal</span></a>â€„<span class="syntax-token">..</span>â€„<a class="syntax" href="#char-literal"><span class="nonterminal">char-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">lazy</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.[</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.[|</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.{</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">}</span>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Afirst-class-modules">first-class modules</a>,
<a href="#s%3Aattributes">attributes</a> and
<a href="#s%3Aextension-nodes">extension nodes</a>.</p><p>The table below shows the relative precedences and associativity of
operators and non-closed pattern constructions. The constructions with
higher precedences come first.
<a id="hevea_manual.kwd16"></a>
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Operator</span></td><td class="c004"><span class="font-bold">Associativity</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">..</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">lazy</span></span> (see sectionÂ <a href="#sss%3Apat-lazy">11.6</a>)</td><td class="c006">â€“ </td></tr>
<tr><td class="c006">Constructor application, Tag application</td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">::</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">,</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">|</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">as</span></span></td><td class="c006">â€“ </td></tr>
</table></div></div><p>Patterns are templates that allow selecting data structures of a
given shape, and binding identifiers to components of the data
structure. This selection operation is called pattern matching; its
outcome is either â€œthis value does not match this patternâ€, or
â€œthis value matches this pattern, resulting in the following bindings
of names to valuesâ€.</p><!--TOC subsubsection id="sss:pat-variable" Variable patterns-->
<h4 class="subsubsection" id="sss:pat-variable"><a class="section-anchor" href="#sss:pat-variable" aria-hidden="true">ï»¿</a>Variable patterns</h4><!--SEC END --><p>A pattern that consists in a value name matches any value,
binding the name to the value. The pattern <span class="syntax-token">_</span> also matches
any value, but does not bind any name.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> is_empty = <span class="ocamlkeyword">function</span>
    | [] -&gt; <span class="ocamlkeyword">true</span>
    | _ :: _ -&gt; <span class="ocamlkeyword">false</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> is_empty : 'a list -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Patterns are <em>linear</em>: a variable cannot be bound several times by
a given pattern. In particular, there is no way to test for equality
between two parts of a data structure using only a pattern:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pair_equal = <span class="ocamlkeyword">function</span>
    | x, <span class="ocamlhighlight">x</span> -&gt; <span class="ocamlkeyword">true</span>
    | x, y -&gt; <span class="ocamlkeyword">false</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Variable x is bound several times in this matching</div></div>

</div><p>However, we can use a <span class="syntax-token">when</span> guard for this purpose:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> pair_equal = <span class="ocamlkeyword">function</span>
    | x, y <span class="ocamlkeyword">when</span> x = y -&gt; <span class="ocamlkeyword">true</span>
    | _ -&gt; <span class="ocamlkeyword">false</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> pair_equal : 'a * 'a -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-const" Constant patterns-->
<h4 class="subsubsection" id="sss:pat-const"><a class="section-anchor" href="#sss:pat-const" aria-hidden="true">ï»¿</a>Constant patterns</h4><!--SEC END --><p>A pattern consisting in a constant matches the values that
are equal to this constant.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bool_of_string = <span class="ocamlkeyword">function</span>
    | <span class="ocamlstring">"true"</span> -&gt; <span class="ocamlkeyword">true</span>
    | <span class="ocamlstring">"false"</span> -&gt; <span class="ocamlkeyword">false</span>
    | _ -&gt; raise (Invalid_argument <span class="ocamlstring">"bool_of_string"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bool_of_string : string -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-alias" Alias patterns-->
<h4 class="subsubsection" id="sss:pat-alias"><a class="section-anchor" href="#sss:pat-alias" aria-hidden="true">ï»¿</a>Alias patterns</h4><!--SEC END --><p>
<a id="hevea_manual.kwd17"></a></p><p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">as</span> <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> matches the same values as
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>. If the matching against <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> is successful,
the name <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> is bound to the matched value, in addition to the
bindings performed by the matching against <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> sort_pair ((x, y) <span class="ocamlkeyword">as</span> p) =
    <span class="ocamlkeyword">if</span> x &lt;= y <span class="ocamlkeyword">then</span> p <span class="ocamlkeyword">else</span> (y, x);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sort_pair : 'a * 'a -&gt; 'a * 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-parenthesized" Parenthesized patterns-->
<h4 class="subsubsection" id="sss:pat-parenthesized"><a class="section-anchor" href="#sss:pat-parenthesized" aria-hidden="true">ï»¿</a>Parenthesized patterns</h4><!--SEC END --><p>The pattern <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">)</span> matches the same values as
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>. A type constraint can appear in a
parenthesized pattern, as in <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>. This
constraint forces the type of <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to be compatible with
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> int_triple_is_ordered ((a, b, c) : int * int * int) =
    a &lt;= b &amp;&amp; b &lt;= c;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> int_triple_is_ordered : int * int * int -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-or" â€œOrâ€ patterns-->
<h4 class="subsubsection" id="sss:pat-or"><a class="section-anchor" href="#sss:pat-or" aria-hidden="true">ï»¿</a>â€œOrâ€ patterns</h4><!--SEC END --><p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> represents the logical â€œorâ€ of
the two patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> and <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>. A value matches
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> if it matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> or
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>. The two sub-patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> and <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>
must bind exactly the same identifiers to values having the same types.
Matching is performed from left to right.
More precisely,
in case some valueÂ <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>, the bindings
performed are those of <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> when <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>.
Otherwise, valueÂ <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> whose bindings are performed.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> shape = Square <span class="ocamlkeyword">of</span> float | Rect <span class="ocamlkeyword">of</span> (float * float) | Circle <span class="ocamlkeyword">of</span> float

  <span class="ocamlkeyword">let</span> is_rectangular = <span class="ocamlkeyword">function</span>
    | Square _ | Rect _ -&gt; <span class="ocamlkeyword">true</span>
    | Circle _ -&gt; <span class="ocamlkeyword">false</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> shape = Square <span class="ocamlkeyword">of</span> float | Rect <span class="ocamlkeyword">of</span> (float * float) | Circle <span class="ocamlkeyword">of</span> float
<span class="ocamlkeyword">val</span> is_rectangular : shape -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-variant" Variant patterns-->
<h4 class="subsubsection" id="sss:pat-variant"><a class="section-anchor" href="#sss:pat-variant" aria-hidden="true">ï»¿</a>Variant patterns</h4><!--SEC END --><p>The pattern <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> matches
all variants whose
constructor is equal to <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>, and whose arguments match
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> â€¦ <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. It is a type error if <span class="font-it">n</span> is not the
number of arguments expected by the constructor.</p><p>The pattern <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">_</span> matches all variants whose constructor is
<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a tree = Lf | Br <span class="ocamlkeyword">of</span> 'a tree * 'a * 'a tree

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> total = <span class="ocamlkeyword">function</span>
    | Br (l, x, r) -&gt; total l + x + total r
    | Lf -&gt; 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a tree = Lf | Br <span class="ocamlkeyword">of</span> 'a tree * 'a * 'a tree
<span class="ocamlkeyword">val</span> total : int tree -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">::</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> matches non-empty lists whose
heads match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>, and whose tails match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>.</p><p>The pattern <span class="syntax-token">[</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> matches lists
of length <span class="font-it">n</span> whose elements match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> â€¦<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>,
respectively. This pattern behaves like
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">::</span> â€¦ <span class="syntax-token">::</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">::</span> <span class="syntax-token">[]</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> destutter = <span class="ocamlkeyword">function</span>
    | [] -&gt; []
    | [a] -&gt; [a]
    | a :: b :: t -&gt; <span class="ocamlkeyword">if</span> a = b <span class="ocamlkeyword">then</span> destutter (b :: t) <span class="ocamlkeyword">else</span> a :: destutter (b :: t);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> destutter : 'a list -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-polyvar" Polymorphic variant patterns-->
<h4 class="subsubsection" id="sss:pat-polyvar"><a class="section-anchor" href="#sss:pat-polyvar" aria-hidden="true">ï»¿</a>Polymorphic variant patterns</h4><!--SEC END --><p>The pattern <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> matches all polymorphic variants
whose tag is equal to <a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>, and whose argument matches
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> split = <span class="ocamlkeyword">function</span>
    | [] -&gt; ([], [])
    | h :: t -&gt;
        <span class="ocamlkeyword">let</span> ss, gs = split t <span class="ocamlkeyword">in</span>
          <span class="ocamlkeyword">match</span> h <span class="ocamlkeyword">with</span>
          | `Sheep _ <span class="ocamlkeyword">as</span> s -&gt; (s :: ss, gs)
          | `Goat _ <span class="ocamlkeyword">as</span> g -&gt; (ss, g :: gs);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> split :
  [&lt; `Goat <span class="ocamlkeyword">of</span> 'a | `Sheep <span class="ocamlkeyword">of</span> 'b ] list -&gt;
  [&gt; `Sheep <span class="ocamlkeyword">of</span> 'b ] list * [&gt; `Goat <span class="ocamlkeyword">of</span> 'a ] list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-polyvar-abbrev" Polymorphic variant abbreviation patterns-->
<h4 class="subsubsection" id="sss:pat-polyvar-abbrev"><a class="section-anchor" href="#sss:pat-polyvar-abbrev" aria-hidden="true">ï»¿</a>Polymorphic variant abbreviation patterns</h4><!--SEC END --><p>If the type [<span class="syntax-token">('a,'b,</span>â€¦<span class="syntax-token">)</span>] <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> = <span class="syntax-token">[</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a><sub>1</sub> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">|</span>
â€¦ <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a><sub><span class="font-it">n</span></sub> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">]</span> is defined, then the pattern <span class="syntax-token">#</span><a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
is a shorthand for the following or-pattern:
<span class="syntax-token">(</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a><sub>1</sub><span class="syntax-token">(_</span> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub><span class="syntax-token">)</span> <span class="syntax-token">|</span> â€¦ <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">(_</span>
<span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">))</span>. It matches all values of type <span class="syntax-token">[&lt;</span> <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> <span class="syntax-token">]</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> 'a rectangle = [`Square <span class="ocamlkeyword">of</span> 'a | `Rectangle <span class="ocamlkeyword">of</span> 'a * 'a]
  <span class="ocamlkeyword">type</span> 'a shape = [`Circle <span class="ocamlkeyword">of</span> 'a | 'a rectangle]

  <span class="ocamlkeyword">let</span> try_rectangle = <span class="ocamlkeyword">function</span>
    | #rectangle <span class="ocamlkeyword">as</span> r -&gt; Some r
    | `Circle _ -&gt; None;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> 'a rectangle = [ `Rectangle <span class="ocamlkeyword">of</span> 'a * 'a | `Square <span class="ocamlkeyword">of</span> 'a ]
<span class="ocamlkeyword">type</span> 'a shape = [ `Circle <span class="ocamlkeyword">of</span> 'a | `Rectangle <span class="ocamlkeyword">of</span> 'a * 'a | `Square <span class="ocamlkeyword">of</span> 'a ]
<span class="ocamlkeyword">val</span> try_rectangle :
  [&lt; `Circle <span class="ocamlkeyword">of</span> 'a | `Rectangle <span class="ocamlkeyword">of</span> 'b * 'b | `Square <span class="ocamlkeyword">of</span> 'b ] -&gt;
  [&gt; `Rectangle <span class="ocamlkeyword">of</span> 'b * 'b | `Square <span class="ocamlkeyword">of</span> 'b ] option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-tuple" Tuple patterns-->
<h4 class="subsubsection" id="sss:pat-tuple"><a class="section-anchor" href="#sss:pat-tuple" aria-hidden="true">ï»¿</a>Tuple patterns</h4><!--SEC END --><p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> matches <span class="font-it">n</span>-tuples
whose components match the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> through <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. That
is, the pattern matches the tuple values (<span class="font-it">v</span><sub>1</sub>, â€¦, <span class="font-it">v</span><sub><span class="font-it">n</span></sub>) such that
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> matches <span class="font-it">v</span><sub><span class="font-it">i</span></sub> for <span class="font-it">i</span> = 1,â€¦ , <span class="font-it">n</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> vector (x0, y0) (x1, y1) =
    (x1 -. x0, y1 -. y0);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> vector : float * float -&gt; float * float -&gt; float * float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-record" Record patterns-->
<h4 class="subsubsection" id="sss:pat-record"><a class="section-anchor" href="#sss:pat-record" aria-hidden="true">ï»¿</a>Record patterns</h4><!--SEC END --><p>The pattern <span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>] <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span>
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>] <span class="syntax-token">}</span> matches records that define at least the fields
<a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> through <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>, and such that the value associated to
<a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">i</span></sub> matches the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>, for <span class="font-it">i</span> = 1,â€¦ , <span class="font-it">n</span>.
A single identifier <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> ,
and a single qualified identifier <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands
for <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> .
The record value can define more fields than <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> â€¦<a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>; the values associated to these extra fields are not taken
into account for matching. Optionally, a record pattern can be terminated
by <span class="syntax-token">;</span> <span class="syntax-token">_</span> to convey the fact that not all fields of the record type are
listed in the record pattern and that it is intentional.
Optional type constraints can be added field by field with
<span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span>â€¦ <span class="syntax-token">;</span><a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span> to force the type
of <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> to be compatible with <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">k</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bytes_allocated
      {Gc.minor_words = minor;
       Gc.major_words = major;
       Gc.promoted_words = prom;
       _}
    =
      (Sys.word_size / 4) * int_of_float (minor +. major -. prom);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bytes_allocated : Gc.stat -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-array" Array patterns-->
<h4 class="subsubsection" id="sss:pat-array"><a class="section-anchor" href="#sss:pat-array" aria-hidden="true">ï»¿</a>Array patterns</h4><!--SEC END --><p>The pattern <span class="syntax-token">[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span>
matches arrays of length <span class="font-it">n</span> such that the <span class="font-it">i</span>-th array element
matches the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>, for <span class="font-it">i</span> = 1,â€¦ , <span class="font-it">n</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> matrix3_is_symmetric = <span class="ocamlkeyword">function</span>
    | [|[|_; b; c|];
        [|d; _; f|];
        [|g; h; _|]|] -&gt; b = d &amp;&amp; c = g &amp;&amp; f = h
    | _ -&gt; failwith <span class="ocamlstring">"matrix3_is_symmetric: not a 3x3 matrix"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> matrix3_is_symmetric : 'a array array -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-range" Range patterns-->
<h4 class="subsubsection" id="sss:pat-range"><a class="section-anchor" href="#sss:pat-range" aria-hidden="true">ï»¿</a>Range patterns</h4><!--SEC END --><p>The pattern
<span class="syntax-token">'</span> <span class="nonterminal">c</span> <span class="syntax-token">'</span> <span class="syntax-token">..</span> <span class="syntax-token">'</span> <span class="nonterminal">d</span> <span class="syntax-token">'</span> is a shorthand for the pattern
</p><div class="center">
<span class="syntax-token">'</span> <span class="nonterminal">c</span> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>1</sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>2</sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> â€¦
<span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">d</span> <span class="syntax-token">'</span>
</div><p>
where <span class="font-it">c</span><sub>1</sub>, <span class="font-it">c</span><sub>2</sub>, â€¦, <span class="font-it">c</span><sub><span class="font-it">n</span></sub> are the characters
that occur between <span class="font-it">c</span> and <span class="font-it">d</span> in the ASCII character set. For
instance, the pattern <span class="machine"><span class="font-tt">'0'</span></span><span class="syntax-token">..</span><span class="machine"><span class="font-tt">'9'</span></span> matches all characters that are digits.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> char_class = Uppercase | Lowercase | Digit | Other

  <span class="ocamlkeyword">let</span> classify_char = <span class="ocamlkeyword">function</span>
    | 'A'..'Z' -&gt; Uppercase
    | 'a'..'z' -&gt; Lowercase
    | '0'..'9' -&gt; Digit
    | _ -&gt; Other;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> char_class = Uppercase | Lowercase | Digit | Other
<span class="ocamlkeyword">val</span> classify_char : char -&gt; char_class = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC subsubsection id="sss:pat-lazy" Lazy patterns-->
<h4 class="subsubsection" id="sss:pat-lazy"><a class="section-anchor" href="#sss:pat-lazy" aria-hidden="true">ï»¿</a>Lazy patterns</h4><!--SEC END --><p><a id="hevea_manual.kwd18"></a></p><p>(Introduced in Objective Caml 3.11)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
</table></td></tr>
</table></div><p>The pattern <span class="syntax-token">lazy</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> matches a value <span class="font-it">v</span> of type <span class="machine"><span class="font-tt">Lazy.t</span></span>,
provided <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> matches the result of forcing <span class="font-it">v</span> with
<span class="machine"><span class="font-tt">Lazy.force</span></span>. A successful match of a pattern containing <span class="syntax-token">lazy</span>
sub-patterns forces the corresponding parts of the value being matched, even
those that imply no test such as <span class="syntax-token">lazy</span> <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> or <span class="syntax-token">lazy</span> <span class="syntax-token">_</span>.
Matching a value with a <a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a> where some patterns
contain <span class="syntax-token">lazy</span> sub-patterns may imply forcing parts of the value,
even when the pattern selected in the end has no <span class="syntax-token">lazy</span> sub-pattern.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> force_opt = <span class="ocamlkeyword">function</span>
    | Some (<span class="ocamlkeyword">lazy</span> n) -&gt; n
    | None -&gt; 0;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> force_opt : int lazy_t option -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>For more information, see the description of module <span class="machine"><span class="font-tt">Lazy</span></span> in the
standard library (module <a href="libref/Lazy.html"><span class="font-tt">Lazy</span></a>).
<a id="hevea_manual0"></a><a id="hevea_manual1"></a></p><!--TOC subsubsection id="sss:exception-match" Exception patterns-->
<h4 class="subsubsection" id="sss:exception-match"><a class="section-anchor" href="#sss:exception-match" aria-hidden="true">ï»¿</a>Exception patterns</h4><!--SEC END --><p>
(Introduced in OCaml 4.02)</p><p>A new form of exception pattern,  <span class="syntax-token">exception</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> , is allowed
only as a toplevel pattern or inside a toplevel or-pattern under
a <span class="machine"><span class="font-tt">match</span></span>...<span class="machine"><span class="font-tt">with</span></span> pattern-matching
(other occurrences are rejected by the type-checker).</p><p>Cases with such a toplevel pattern are called â€œexception casesâ€,
as opposed to regular â€œvalue casesâ€. Exception cases are applied
when the evaluation of the matched expression raises an exception.
The exception value is then matched against all the exception cases
and re-raised if none of them accept the exception (as with a
<span class="machine"><span class="font-tt">try</span></span>...<span class="machine"><span class="font-tt">with</span></span> block). Since the bodies of all exception and value
cases are outside the scope of the exception handler, they are all
considered to be in tail-position: if the <span class="machine"><span class="font-tt">match</span></span>...<span class="machine"><span class="font-tt">with</span></span> block
itself is in tail position in the current function, any function call
in tail position in one of the case bodies results in an actual tail
call.</p><p>A pattern match must contain at least one value case. It is an error if
all cases are exceptions, because there would be no code to handle
the return of a value.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> find_opt p l =
    <span class="ocamlkeyword">match</span> List.find p l <span class="ocamlkeyword">with</span>
    | <span class="ocamlkeyword">exception</span> Not_found -&gt; None
    | x -&gt; Some x;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:pat-open" Local opens for patterns-->
<h4 class="subsubsection" id="sss:pat-open"><a class="section-anchor" href="#sss:pat-open" aria-hidden="true">ï»¿</a>Local opens for patterns</h4><!--SEC END --><p>
<a id="hevea_manual.kwd19"></a>
(Introduced in OCaml 4.04)</p><p>For patterns, local opens are limited to the
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.(</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">)</span> construction. This
construction locally opens the module referred to by the module path
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> in the scope of the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>.</p><p>When the body of a local open pattern is delimited by
<span class="syntax-token">[</span> <span class="syntax-token">]</span>, <span class="syntax-token">[|</span> <span class="syntax-token">|]</span>, or <span class="syntax-token">{</span> <span class="syntax-token">}</span>, the parentheses can be omitted.
For example, <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">]</span> is equivalent to
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">])</span>, and <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|]</span> is
equivalent to <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|])</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bytes_allocated Gc.{minor_words; major_words; promoted_words; _} =
      (Sys.word_size / 4)
    * int_of_float (minor_words +. major_words -. promoted_words);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bytes_allocated : Gc.stat -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:value-expr" 11.7â€ƒExpressions-->
<h2 class="section" id="s:value-expr"><a class="section-anchor" href="#s:value-expr" aria-hidden="true">ï»¿</a>11.7â€ƒExpressions</h2><!--SEC END --><!--NAME expr.html-->
<p>
<a id="hevea_manual.kwd20"></a>
<a id="hevea_manual.kwd21"></a>
<a id="hevea_manual.kwd22"></a>
<a id="hevea_manual.kwd23"></a>
<a id="hevea_manual.kwd24"></a>
<a id="hevea_manual.kwd25"></a>
<a id="hevea_manual.kwd26"></a>
<a id="hevea_manual.kwd27"></a>
<a id="hevea_manual.kwd28"></a>
<a id="hevea_manual.kwd29"></a>
<a id="hevea_manual.kwd30"></a>
<a id="hevea_manual.kwd31"></a>
<a id="hevea_manual.kwd32"></a>
<a id="hevea_manual.kwd33"></a>
<a id="hevea_manual.kwd34"></a>
<a id="hevea_manual.kwd35"></a>
<a id="hevea_manual.kwd36"></a>
<a id="hevea_manual.kwd37"></a>
<a id="hevea_manual.kwd38"></a>
<a id="hevea_manual.kwd39"></a>
<a id="hevea_manual.kwd40"></a>
<a id="hevea_manual.kwd41"></a>
<a id="hevea_manual.kwd42"></a>
<a id="hevea_manual.kwd43"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#value-path"><span class="nonterminal">value-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constant"><span class="nonterminal">constant</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">begin</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">::</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}â€„[<span class="syntax-token">;</span>]â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">[|</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}â€„[<span class="syntax-token">;</span>]â€„<span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„}â€„[<span class="syntax-token">;</span>]â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">with</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„}â€„[<span class="syntax-token">;</span>]â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">-.</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<a class="syntax" href="#infix-op"><span class="nonterminal">infix-op</span></a>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#field"><span class="nonterminal">field</span></a>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">)</span>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">]</span>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">if</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">then</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„[â€„<span class="syntax-token">else</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">while</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">do</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">done</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">for</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„(â€„<span class="syntax-token">to</span>â€„âˆ£â€„<span class="syntax-token">downto</span>â€„)â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">do</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">done</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">match</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">with</span>â€„<a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">function</span>â€„<a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">fun</span>â€„{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}<sup>+</sup>â€„[â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„]â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">try</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">with</span>â€„<a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„[<span class="syntax-token">rec</span>]â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„}â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„}
[â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„]â€„â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">:&gt;</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">:&gt;</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">assert</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">lazy</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#local-open"><span class="nonterminal">local-open</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#object-expr"><span class="nonterminal">object-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="argument"><span class="nonterminal">argument</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="pattern-matching"><span class="nonterminal">pattern-matching</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<span class="syntax-token">|</span>â€„]â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">when</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">when</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="let-binding"><span class="nonterminal">let-binding</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">:&gt;</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="parameter"><span class="nonterminal">parameter</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">~</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a>â€„<span class="syntax-token">:</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="local-open"><span class="nonterminal">local-open</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.[|</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.{&lt;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">&gt;}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="object-expr"><span class="nonterminal">object-expr</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">new</span>â€„<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">object</span>â€„<a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a>â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">#</span>â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">{&lt;</span>â€„[â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„[<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„}â€„[<span class="syntax-token">;</span>]â€„]â€„<span class="syntax-token">&gt;}</span>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Afirst-class-modules">first-class modules</a>,
<a href="#s%3Aexplicit-overriding-open">overriding in open statements</a>,
<a href="#s%3Abigarray-access">syntax for Bigarray access</a>,
<a href="#s%3Aattributes">attributes</a>,
<a href="#s%3Aextension-nodes">extension nodes</a> and
<a href="#s%3Aindex-operators">extended indexing operators</a>.</p>
<!--TOC subsection id="ss:precedence-and-associativity" 11.7.1â€ƒPrecedence and associativity-->
<h3 class="subsection" id="ss:precedence-and-associativity"><a class="section-anchor" href="#ss:precedence-and-associativity" aria-hidden="true">ï»¿</a>11.7.1â€ƒPrecedence and associativity</h3><!--SEC END --><p>
The table below shows the relative precedences and associativity of
operators and non-closed constructions. The constructions with higher
precedence come first. For infix and prefix symbols, we write
â€œ<span class="machine"><span class="font-tt">*</span></span>â€¦â€ to mean â€œany symbol starting with <span class="machine"><span class="font-tt">*</span></span>â€.
<a id="hevea_manual.kwd44"></a><a id="hevea_manual.kwd45"></a><a id="hevea_manual.kwd46"></a><a id="hevea_manual.kwd47"></a><a id="hevea_manual.kwd48"></a><a id="hevea_manual.kwd49"></a><a id="hevea_manual.kwd50"></a><a id="hevea_manual.kwd51"></a>
<a id="hevea_manual.kwd52"></a>
<a id="hevea_manual.kwd53"></a>
<a id="hevea_manual.kwd54"></a>
<a id="hevea_manual.kwd55"></a>
<a id="hevea_manual.kwd56"></a>
<a id="hevea_manual.kwd57"></a>
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Construction or operator</span></td><td class="c004"><span class="font-bold">Associativity</span> </td></tr>
<tr><td class="c006">
prefix-symbol</td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">.   .(   .[   .{</span></span> (see sectionÂ <a href="#s%3Abigarray-access">12.11</a>)</td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">#</span></span>â€¦</td><td class="c006">left </td></tr>
<tr><td class="c006">function application, constructor application, tag
application, <span class="machine"><span class="font-tt">assert</span></span>,
<span class="machine"><span class="font-tt">lazy</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">-   -.</span></span> (prefix)</td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">**</span></span>â€¦<span class="machine"><span class="font-tt">   lsl   lsr   asr</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">*</span></span>â€¦<span class="machine"><span class="font-tt">   /</span></span>â€¦<span class="machine"><span class="font-tt">   %</span></span>â€¦<span class="machine"><span class="font-tt">   mod   land   lor   lxor</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"> <span class="machine"><span class="font-tt">+</span></span>â€¦<span class="machine"><span class="font-tt">   -</span></span>â€¦</td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">::</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="font-tt">@</span>â€¦<span class="machine"><span class="font-tt">   ^</span></span>â€¦</td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">=</span></span>â€¦<span class="machine"><span class="font-tt">   &lt;</span></span>â€¦<span class="machine"><span class="font-tt">   &gt;</span></span>â€¦<span class="machine"><span class="font-tt">   |</span></span>â€¦<span class="machine"><span class="font-tt">   &amp;</span></span>â€¦<span class="machine"><span class="font-tt">   $</span></span>â€¦<span class="machine"><span class="font-tt">   !=</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">&amp;   &amp;&amp;</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">or  ||</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">,</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">&lt;-   :=</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">if</span></span></td><td class="c006">â€“ </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">;</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">let  match  fun  function  try</span></span></td><td class="c006">â€“ </td></tr>
</table></div></div><p>It is simple to test or refresh oneâ€™s understanding:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> 3 + 3 <span class="ocamlkeyword">mod</span> 2, 3 + (3 <span class="ocamlkeyword">mod</span> 2), (3 + 3) <span class="ocamlkeyword">mod</span> 2;;</div>



<div class="pre caml-output ok">- : int * int * int = (4, 4, 0)</div></div>

</div>
<!--TOC subsection id="ss:expr-basic" 11.7.2â€ƒBasic expressions-->
<h3 class="subsection" id="ss:expr-basic"><a class="section-anchor" href="#ss:expr-basic" aria-hidden="true">ï»¿</a>11.7.2â€ƒBasic expressions</h3><!--SEC END --><!--TOC subsubsection id="sss:expr-constants" Constants-->
<h4 class="subsubsection" id="sss:expr-constants"><a class="section-anchor" href="#sss:expr-constants" aria-hidden="true">ï»¿</a>Constants</h4><!--SEC END --><p>An expression consisting in a constant evaluates to this constant. For example,
<span class="font-tt">3.14</span> or <span class="font-tt">[||]</span>.</p><!--TOC subsubsection id="sss:expr-var" Value paths-->
<h4 class="subsubsection" id="sss:expr-var"><a class="section-anchor" href="#sss:expr-var" aria-hidden="true">ï»¿</a>Value paths</h4><!--SEC END --><p>An expression consisting in an access path evaluates to the value bound to
this path in the current evaluation environment. The path can
be either a value name or an access path to a value component of a module.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Float.ArrayLabels.to_list;;</div>



<div class="pre caml-output ok">- : Float.ArrayLabels.t -&gt; float list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-parenthesized" Parenthesized expressions-->
<h4 class="subsubsection" id="sss:expr-parenthesized"><a class="section-anchor" href="#sss:expr-parenthesized" aria-hidden="true">ï»¿</a>Parenthesized expressions</h4><!--SEC END --><p>
<a id="hevea_manual.kwd58"></a>
<a id="hevea_manual.kwd59"></a></p><p>The expressions <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span> and <span class="syntax-token">begin</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">end</span> have the same
value as <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. The two constructs are semantically equivalent, but it
is good style to use <span class="syntax-token">begin</span> â€¦ <span class="syntax-token">end</span> inside control structures:
</p><pre>
        if â€¦ then begin â€¦ ; â€¦ end else begin â€¦ ; â€¦ end
</pre><p>
and <span class="syntax-token">(</span> â€¦ <span class="syntax-token">)</span> for the other grouping situations.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> x = 1 + 2 * 3
  <span class="ocamlkeyword">let</span> y = (1 + 2) * 3;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x : int = 7
<span class="ocamlkeyword">val</span> y : int = 9</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f a b =
    <span class="ocamlkeyword">if</span> a = b <span class="ocamlkeyword">then</span>
      print_endline <span class="ocamlstring">"Equal"</span>
    <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">begin</span>
        print_string <span class="ocamlstring">"Not Equal: "</span>;
        print_int a;
        print_string <span class="ocamlstring">" and "</span>;
        print_int b;
        print_newline ()
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Parenthesized expressions can contain a type constraint, as in <span class="syntax-token">(</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>. This constraint forces the type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> to be
compatible with <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.</p><p>Parenthesized expressions can also contain coercions
<span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>] <span class="syntax-token">:&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><span class="syntax-token">)</span> (see
subsectionÂ <a href="#ss%3Aexpr-coercions">11.7.7</a> below).</p><!--TOC subsubsection id="sss:expr-functions-application" Function application-->
<h4 class="subsubsection" id="sss:expr-functions-application"><a class="section-anchor" href="#sss:expr-functions-application" aria-hidden="true">ï»¿</a>Function application</h4><!--SEC END --><p>Function application is denoted by juxtaposition of (possibly labeled)
expressions. The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub> â€¦ <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>
evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and those appearing in <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>
to <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>. The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> must evaluate to a
functional value <span class="font-it">f</span>, which is then applied to the values of
<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>.</p><p>The order in which the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>, â€¦,
<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub> are evaluated is not specified.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.fold_left ( + ) 0 [1; 2; 3; 4; 5];;</div>



<div class="pre caml-output ok">- : int = 15</div></div>

</div><p>Arguments and parameters are matched according to their respective
labels. Argument order is irrelevant, except among arguments with the
same label, or no label.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.fold_left ~f:( @ ) ~init:[] [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]];;</div>



<div class="pre caml-output ok">- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]</div></div>

</div><p>If a parameter is specified as optional (label prefixed by <span class="syntax-token">?</span>) in the
type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the corresponding argument will be automatically
wrapped with the constructor <span class="machine"><span class="font-tt">Some</span></span>, except if the argument itself is
also prefixed by <span class="syntax-token">?</span>, in which case it is passed as is.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fullname ?title first second =
    <span class="ocamlkeyword">match</span> title <span class="ocamlkeyword">with</span>
    | Some t -&gt; t ^ <span class="ocamlstring">" "</span> ^ first ^ <span class="ocamlstring">" "</span> ^ second
    | None -&gt; first ^ <span class="ocamlstring">" "</span> ^ second

  <span class="ocamlkeyword">let</span> name = fullname ~title:<span class="ocamlstring">"Mrs"</span> <span class="ocamlstring">"Jane"</span> <span class="ocamlstring">"Fisher"</span>

  <span class="ocamlkeyword">let</span> address ?title first second town =
    fullname ?title first second ^ <span class="ocamlstring">"\n"</span> ^ town;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fullname : ?title:string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> name : string = <span class="ocamlstring">"Mrs Jane Fisher"</span>
<span class="ocamlkeyword">val</span> address : ?title:string -&gt; string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>If a non-labeled argument is passed, and its corresponding parameter
is preceded by one or several optional parameters, then these
parameters are <em>defaulted</em>, <em>i.e.</em> the value <span class="machine"><span class="font-tt">None</span></span> will be
passed for them.
All other missing parameters (without corresponding argument), both
optional and non-optional, will be kept, and the result of the
function will still be a function of these missing parameters to the
body of <span class="font-it">f</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fullname ?title first second =
    <span class="ocamlkeyword">match</span> title <span class="ocamlkeyword">with</span>
    | Some t -&gt; t ^ <span class="ocamlstring">" "</span> ^ first ^ <span class="ocamlstring">" "</span> ^ second
    | None -&gt; first ^ <span class="ocamlstring">" "</span> ^ second

  <span class="ocamlkeyword">let</span> name = fullname <span class="ocamlstring">"Jane"</span> <span class="ocamlstring">"Fisher"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fullname : ?title:string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> name : string = <span class="ocamlstring">"Jane Fisher"</span></div></div>

</div><p>In all cases but exact match of order and labels, without optional
parameters, the function type should be known at the application
point. This can be ensured by adding a type constraint. Principality
of the derivation can be checked in the <span class="machine"><span class="font-tt">-principal</span></span> mode.</p><p>As a special case, OCaml supports <span class="machine"><span class="font-tt">labels-omitted</span></span> full applications:
if the function has a known arity, all the arguments are unlabeled,
and their number matches the number of non-optional parameters, then
labels are ignored and non-optional parameters are matched in their
definition order. Optional arguments are defaulted. This omission of
labels is discouraged and results in a warning, see <a href="#ss%3Awarn6">13.5.1</a>.</p><!--TOC subsubsection id="sss:expr-function-definition" Function definition-->
<h4 class="subsubsection" id="sss:expr-function-definition"><a class="section-anchor" href="#sss:expr-function-definition" aria-hidden="true">ï»¿</a>Function definition</h4><!--SEC END --><p>Two syntactic forms are provided to define functions. The first form
is introduced by the keyword <span class="machine"><span class="font-tt">function</span></span>:
<a id="hevea_manual.kwd60"></a></p><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="syntax-token">function</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">â€¦â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</table></td></tr>
</table><p>
This expression evaluates to a functional value with one argument.
When this function is applied to a value <span class="font-it">v</span>, this value is
matched against each pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>.
If one of these matchings succeeds, that is, if the value <span class="font-it">v</span>
matches the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> for some <span class="font-it">i</span>,
then the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> associated to the selected pattern
is evaluated, and its value becomes the value of the function
application. The evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an
environment enriched by the bindings performed during the matching.</p><p>If several patterns match the argument <span class="font-it">v</span>, the one that occurs
first in the function definition is selected. If none of the patterns
matches the argument, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual2"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (<span class="ocamlkeyword">function</span> (0, 0) -&gt; <span class="ocamlstring">"both zero"</span>
          | (0, _) -&gt; <span class="ocamlstring">"first only zero"</span>
          | (_, 0) -&gt; <span class="ocamlstring">"second only zero"</span>
          | (_, _) -&gt; <span class="ocamlstring">"neither zero"</span>)
  (7, 0);;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"second only zero"</span></div></div>

</div><p>The other form of function definition is introduced by the keyword <span class="machine"><span class="font-tt">fun</span></span>:
<a id="hevea_manual.kwd61"></a>
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
This expression is equivalent to:
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = (<span class="ocamlkeyword">fun</span> a -&gt; <span class="ocamlkeyword">fun</span> b -&gt; <span class="ocamlkeyword">fun</span> c -&gt; a + b + c)
  <span class="ocamlkeyword">let</span> g = (<span class="ocamlkeyword">fun</span> a b c -&gt; a + b + c);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> g : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>An optional type constraint <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> can be added before <span class="machine"><span class="font-tt">-&gt;</span></span> to enforce
the type of the result to be compatible with the constraint <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>:
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
is equivalent to
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> (<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> )
</div><p>Beware of the small syntactic difference between a type constraint on
the last parameter
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ (<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">:</span><a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>)<span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><p>
and one on the result
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> eq = <span class="ocamlkeyword">fun</span> (a : int) (b : int) -&gt; a = b
  <span class="ocamlkeyword">let</span> eq2 = <span class="ocamlkeyword">fun</span> a b : bool -&gt; a = b
  <span class="ocamlkeyword">let</span> eq3 = <span class="ocamlkeyword">fun</span> (a : int) (b : int) : bool -&gt; a = b;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> eq : int -&gt; int -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eq2 : 'a -&gt; 'a -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eq3 : int -&gt; int -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The parameter patterns <span class="syntax-token">~</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> and <span class="syntax-token">~(</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>]<span class="syntax-token">)</span>
are shorthands for respectively <span class="syntax-token">~</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a><span class="syntax-token">:</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> and
<span class="syntax-token">~</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a><span class="syntax-token">:(</span><a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>]<span class="syntax-token">)</span>, and similarly for their optional
counterparts.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bool_map ~cmp:(cmp : int -&gt; int -&gt; bool) l =
    List.map cmp l

  <span class="ocamlkeyword">let</span> bool_map' ~(cmp : int -&gt; int -&gt; bool) l =
    List.map cmp l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bool_map : cmp:(int -&gt; int -&gt; bool) -&gt; int list -&gt; (int -&gt; bool) list =
  &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> bool_map' : cmp:(int -&gt; int -&gt; bool) -&gt; int list -&gt; (int -&gt; bool) list =
  &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>A function of the form <span class="syntax-token">fun</span> <span class="syntax-token">?</span> <a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> <span class="syntax-token">:(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is equivalent to
</p><div class="center">
<span class="syntax-token">fun</span> <span class="syntax-token">?</span> <a class="syntax" href="#label-name"><span class="nonterminal">lab</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">-&gt;</span>
<span class="syntax-token">let</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">=</span>
<span class="syntax-token">match</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">with</span> <span class="syntax-token">Some</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">|</span> <span class="syntax-token">None</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
where <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>
is a fresh variable, except that it is unspecified when <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> is evaluated.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> open_file_for_input ?binary filename =
    <span class="ocamlkeyword">match</span> binary <span class="ocamlkeyword">with</span>
    | Some <span class="ocamlkeyword">true</span> -&gt; open_in_bin filename
    | Some <span class="ocamlkeyword">false</span> | None -&gt; open_in filename

  <span class="ocamlkeyword">let</span> open_file_for_input' ?(binary=<span class="ocamlkeyword">false</span>) filename =
    <span class="ocamlkeyword">if</span> binary <span class="ocamlkeyword">then</span> open_in_bin filename <span class="ocamlkeyword">else</span> open_in filename;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> open_file_for_input : ?binary:bool -&gt; string -&gt; in_channel = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> open_file_for_input' : ?binary:bool -&gt; string -&gt; in_channel = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>After these two transformations, expressions are of the form
</p><div class="center">
<span class="syntax-token">fun</span> [<a class="syntax" href="#label"><span class="nonterminal">label</span></a><sub>1</sub>] <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">fun</span> [<a class="syntax" href="#label"><span class="nonterminal">label</span></a><sub><span class="font-it">n</span></sub>] <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
If we ignore labels, which will only be meaningful at function
application, this is equivalent to
</p><div class="center">
<span class="syntax-token">function</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">function</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
That is, the <span class="syntax-token">fun</span> expression above evaluates to a curried function
with <span class="font-it">n</span> arguments: after applying this function <span class="font-it">n</span> times to the
values <span class="nonterminal">v</span><sub>1</sub> â€¦ <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub>, the values will be matched
in parallel against the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> â€¦ <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>.
If the matching succeeds, the function returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> in
an environment enriched by the bindings performed during the matchings.
If the matching fails, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.</p><!--TOC subsubsection id="sss:guards-in-pattern-matchings" Guards in pattern-matchings-->
<h4 class="subsubsection" id="sss:guards-in-pattern-matchings"><a class="section-anchor" href="#sss:guards-in-pattern-matchings" aria-hidden="true">ï»¿</a>Guards in pattern-matchings</h4><!--SEC END --><p><a id="hevea_manual.kwd62"></a>
The cases of a pattern matching (in the <span class="syntax-token">function</span>, <span class="syntax-token">match</span> and
<span class="syntax-token">try</span> constructs) can include guard expressions, which are
arbitrary boolean expressions that must evaluate to <span class="machine"><span class="font-tt">true</span></span> for the
match case to be selected. Guards occur just before the <span class="syntax-token">-&gt;</span> token and
are introduced by the <span class="syntax-token">when</span> keyword:</p><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="syntax-token">function</span></td><td class="c007"><span class="nonterminal">pattern</span><sub>1</sub>â€„â€„â€„[<span class="syntax-token">when</span>â€„â€„â€„<span class="nonterminal">cond</span><sub>1</sub>]</td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="nonterminal">expr</span><sub>1</sub>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">â€¦â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="nonterminal">pattern</span><sub><span class="font-it">n</span></sub>â€„â€„â€„â€„[<span class="syntax-token">when</span>â€„â€„â€„<span class="nonterminal">cond</span><sub><span class="font-it">n</span></sub>]</td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="nonterminal">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</table></td></tr>
</table><p>Matching proceeds as described before, except that if the value
matches some pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> which has a guard <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub>, then the
expression <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> is evaluated (in an environment enriched by the
bindings performed during matching). If <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> evaluates to <span class="machine"><span class="font-tt">true</span></span>,
then <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated and its value returned as the result of the
matching, as usual. But if <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> evaluates to <span class="machine"><span class="font-tt">false</span></span>, the matching
is resumed against the patterns following <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> repeat f = <span class="ocamlkeyword">function</span>
    | 0 -&gt; ()
    | n <span class="ocamlkeyword">when</span> n &gt; 0 -&gt; f (); repeat f (n - 1)
    | _ -&gt; raise (Invalid_argument <span class="ocamlstring">"repeat"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> repeat : (unit -&gt; 'a) -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-localdef" Local definitions-->
<h4 class="subsubsection" id="sss:expr-localdef"><a class="section-anchor" href="#sss:expr-localdef" aria-hidden="true">ï»¿</a>Local definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd63"></a></p><p>The <span class="syntax-token">let</span> and <span class="syntax-token">let</span> <span class="syntax-token">rec</span> constructs bind value names locally.
The construct
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> â€¦ <span class="syntax-token">and</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> in some unspecified order and matches
their values against the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> â€¦ <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the
matchings succeed, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is evaluated in the environment enriched by
the bindings performed during matching, and the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
returned as the value of the whole <span class="syntax-token">let</span> expression. If one of the
matchings fails, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual3"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> v =
    <span class="ocamlkeyword">let</span> x = 1 <span class="ocamlkeyword">in</span> [x; x; x]

  <span class="ocamlkeyword">let</span> v' =
    <span class="ocamlkeyword">let</span> a, b = (1, 2) <span class="ocamlkeyword">in</span> a + b

  <span class="ocamlkeyword">let</span> v'' =
    <span class="ocamlkeyword">let</span> a = 1 <span class="ocamlkeyword">and</span> b = 2 <span class="ocamlkeyword">in</span> a + b;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> v : int list = [1; 1; 1]
<span class="ocamlkeyword">val</span> v' : int = 3
<span class="ocamlkeyword">val</span> v'' : int = 3</div></div>

</div><p>An alternate syntax is provided to bind variables to functional
values: instead of writing
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
in a <span class="syntax-token">let</span> expression, one may instead write
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">fun</span> x -&gt; <span class="ocamlkeyword">fun</span> y -&gt; <span class="ocamlkeyword">fun</span> z -&gt; x + y + z

  <span class="ocamlkeyword">let</span> f' = <span class="ocamlkeyword">fun</span> x y z -&gt; x + y + z

  <span class="ocamlkeyword">let</span> f'' x y z = x + y + z;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> f' : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> f'' : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Recursive definitions of names are introduced by <span class="syntax-token">let</span> <span class="syntax-token">rec</span>:
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> â€¦ <span class="syntax-token">and</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>The only difference with the <span class="syntax-token">let</span> construct described above is
that the bindings of names to values performed by the
pattern-matching are considered already performed when the expressions
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are evaluated. That is, the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>
to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> can reference identifiers that are bound by one of the
patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>, and expect them to have the
same value as in <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the body of the <span class="syntax-token">let</span> <span class="syntax-token">rec</span> construct.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> even =
    <span class="ocamlkeyword">function</span> 0 -&gt; <span class="ocamlkeyword">true</span> | n -&gt; odd (n - 1)
  <span class="ocamlkeyword">and</span> odd =
    <span class="ocamlkeyword">function</span> 0 -&gt; <span class="ocamlkeyword">false</span> | n -&gt; even (n - 1)
  <span class="ocamlkeyword">in</span>
    even 1000;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div><p>The recursive definition is guaranteed to behave as described above if
the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are function definitions
(<span class="syntax-token">fun</span> â€¦ or <span class="syntax-token">function</span> â€¦), and the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>
â€¦ <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> are just value names, as in:
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> â€¦
<span class="syntax-token">and</span> â€¦
<span class="syntax-token">and</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> â€¦
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
This defines <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> as mutually recursive functions
local to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><p>The behavior of other forms of <span class="syntax-token">let</span> <span class="syntax-token">rec</span> definitions is
implementation-dependent. The current implementation also supports
a certain class of recursive definitions of non-functional values,
as explained in sectionÂ <a href="#s%3Aletrecvalues">12.1</a>.</p>
<!--TOC subsubsection id="sss:expr-let-exception" Local exceptions-->
<h4 class="subsubsection" id="sss:expr-let-exception"><a class="section-anchor" href="#sss:expr-let-exception" aria-hidden="true">ï»¿</a>Local exceptions</h4><!--SEC END --><p>
(Introduced in OCaml 4.04)</p><p>It is possible to define local exceptions in expressions:
 <span class="syntax-token">let</span> <span class="nonterminal">exception</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>  .</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> map_empty_on_negative f l =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">exception</span> Negative <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> aux x = <span class="ocamlkeyword">if</span> x &lt; 0 <span class="ocamlkeyword">then</span> raise Negative <span class="ocamlkeyword">else</span> f x <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">try</span> List.map aux l <span class="ocamlkeyword">with</span> Negative -&gt; [];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map_empty_on_negative : (int -&gt; 'a) -&gt; int list -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The syntactic scope of the exception constructor is the inner
expression, but nothing prevents exception values created with this
constructor from escaping this scope. Two executions of the definition
above result in two incompatible exception constructors (as for any
exception definition). For instance:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> gen () = <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">exception</span> A <span class="ocamlkeyword">in</span> A

  <span class="ocamlkeyword">let</span> () = <span class="ocamlkeyword">assert</span>(gen () = gen ());;</div>



<div class="pre caml-output ok">Exception: Assert_failure (<span class="ocamlstring">"expr.etex"</span>, 3, 9).</div></div>

</div>
<!--TOC subsubsection id="sss:expr-explicit-polytype" Explicit polymorphic type annotations-->
<h4 class="subsubsection" id="sss:expr-explicit-polytype"><a class="section-anchor" href="#sss:expr-explicit-polytype" aria-hidden="true">ï»¿</a>Explicit polymorphic type annotations</h4><!--SEC END --><p>
(Introduced in OCaml 3.12)</p><p>Polymorphic type annotations in <span class="syntax-token">let</span>-definitions behave in a way
similar to polymorphic methods:</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> â€¦ <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">.</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><p>These annotations explicitly require the defined value to be polymorphic,
and allow one to use this polymorphism in recursive occurrences
(when using <span class="syntax-token">let</span> <span class="syntax-token">rec</span>). Note however that this is a normal polymorphic
type, unifiable with any instance of itself.</p>
<!--TOC subsection id="ss:expr-control" 11.7.3â€ƒControl structures-->
<h3 class="subsection" id="ss:expr-control"><a class="section-anchor" href="#ss:expr-control" aria-hidden="true">ï»¿</a>11.7.3â€ƒControl structures</h3><!--SEC END --><!--TOC subsubsection id="sss:expr-sequence" Sequence-->
<h4 class="subsubsection" id="sss:expr-sequence"><a class="section-anchor" href="#sss:expr-sequence" aria-hidden="true">ï»¿</a>Sequence</h4><!--SEC END --><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> first, then
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, and returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> print_pair (a, b) =
    print_string <span class="ocamlstring">"("</span>;
    print_string (string_of_int a);
    print_string <span class="ocamlstring">","</span>;
    print_string (string_of_int b);
    print_endline <span class="ocamlstring">")"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> print_pair : int * int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-conditional" Conditional-->
<h4 class="subsubsection" id="sss:expr-conditional"><a class="section-anchor" href="#sss:expr-conditional" aria-hidden="true">ï»¿</a>Conditional</h4><!--SEC END --><p>
<a id="hevea_manual.kwd64"></a></p><p>The expression <span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> evaluates to
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to the boolean <span class="syntax-token">true</span>,
and to the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to the boolean
<span class="syntax-token">false</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> factorial x =
    <span class="ocamlkeyword">if</span> x &lt;= 1 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> x * factorial (x - 1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> factorial : int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> part can be omitted, in which case it defaults to
<span class="syntax-token">else</span> <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> debug = <span class="ocamlkeyword">ref</span> <span class="ocamlkeyword">false</span>

  <span class="ocamlkeyword">let</span> log msg =
    <span class="ocamlkeyword">if</span> !debug <span class="ocamlkeyword">then</span> prerr_endline msg;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> debug : bool <span class="ocamlkeyword">ref</span> = {contents = <span class="ocamlkeyword">false</span>}
<span class="ocamlkeyword">val</span> log : string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-case" Case expression-->
<h4 class="subsubsection" id="sss:expr-case"><a class="section-anchor" href="#sss:expr-case" aria-hidden="true">ï»¿</a>Case expression</h4><!--SEC END --><p><a id="hevea_manual.kwd65"></a></p><p>The expression
</p><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="syntax-token">match</span></td><td class="c007"><span class="font-sl">expr</span>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">with</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">â€¦â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</table></td></tr>
</table><p>
matches the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> against the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the matching against <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> succeeds, the
associated expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated, and its value becomes the
value of the whole <span class="syntax-token">match</span> expression. The evaluation of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an environment enriched by the bindings
performed during matching. If several patterns match the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the one that occurs first in the <span class="syntax-token">match</span> expression is
selected.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> sum l =
    <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
    | [] -&gt; 0
    | h :: t -&gt; h + sum t;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : int list -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>If none of the patterns match the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the
exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual4"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> unoption o =
    <span class="ocamlhighlight">match o with
    | Some x -&gt; x</span>

  <span class="ocamlkeyword">let</span> l = List.map unoption [Some 1; Some 10; None; Some 2];;</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None
Exception: Match_failure ("expr.etex", 2, 2).</div></div>

</div><!--TOC subsubsection id="sss:expr-boolean-operators" Boolean operators-->
<h4 class="subsubsection" id="sss:expr-boolean-operators"><a class="section-anchor" href="#sss:expr-boolean-operators" aria-hidden="true">ï»¿</a>Boolean operators</h4><!--SEC END --><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">&amp;&amp;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span> if both
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluate to <span class="syntax-token">true</span>; otherwise, it evaluates to
<span class="syntax-token">false</span>. The first component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, is evaluated first. The
second component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, is not evaluated if the first component
evaluates to <span class="syntax-token">false</span>. Hence, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">&amp;&amp;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> behaves
exactly as
</p><div class="center">
<span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">else</span> <span class="syntax-token">false</span>.
</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">||</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span> if one of
the expressions
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span>; otherwise, it evaluates to
<span class="syntax-token">false</span>. The first component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, is evaluated first. The
second component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, is not evaluated if the first component
evaluates to <span class="syntax-token">true</span>. Hence, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">||</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> behaves
exactly as
</p><div class="center">
<span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <span class="syntax-token">true</span> <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.
</div><p><a id="hevea_manual.kwd66"></a>
The boolean operators <span class="syntax-token">&amp;</span> and <span class="syntax-token">or</span> are deprecated synonyms for
(respectively) <span class="syntax-token">&amp;&amp;</span> and <span class="syntax-token">||</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> xor a b =
    (a || b) &amp;&amp; not (a &amp;&amp; b);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> xor : bool -&gt; bool -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-loops" Loops-->
<h4 class="subsubsection" id="sss:expr-loops"><a class="section-anchor" href="#sss:expr-loops" aria-hidden="true">ï»¿</a>Loops</h4><!--SEC END --><p><a id="hevea_manual.kwd67"></a>
The expression <span class="syntax-token">while</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">done</span> repeatedly
evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> while <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to <span class="syntax-token">true</span>. The loop
condition <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> is evaluated and tested at the beginning of each
iteration. The whole <span class="syntax-token">while</span> â€¦ <span class="syntax-token">done</span> expression evaluates to
the unit value <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> i = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> chars = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">while</span> !i &lt; String.length s <span class="ocamlkeyword">do</span>
        chars := s.[!i] :: !chars;
        i := !i + 1
      <span class="ocamlkeyword">done</span>;
      List.rev !chars;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p><a id="hevea_manual.kwd68"></a>
The expression <span class="syntax-token">for</span> <span class="nonterminal">name</span> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">to</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> <span class="syntax-token">done</span>
first evaluates the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> (the boundaries)
into integer values <span class="font-it">n</span> and <span class="font-it">p</span>. Then, the loop body <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> is
repeatedly evaluated in an environment where <span class="nonterminal">name</span> is successively
bound to the values
<span class="font-it">n</span>, <span class="font-it">n</span>+1, â€¦, <span class="font-it">p</span>âˆ’1, <span class="font-it">p</span>.
The loop body is never evaluated if <span class="font-it">n</span> &gt; <span class="font-it">p</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">for</span> p = 0 <span class="ocamlkeyword">to</span> String.length s - 1 <span class="ocamlkeyword">do</span>
        l := s.[p] :: !l
      <span class="ocamlkeyword">done</span>;
      List.rev !l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <span class="syntax-token">for</span> <span class="nonterminal">name</span> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">downto</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> <span class="syntax-token">done</span>
evaluates similarly, except that <span class="nonterminal">name</span> is successively bound to the values
<span class="font-it">n</span>, <span class="font-it">n</span>âˆ’1, â€¦, <span class="font-it">p</span>+1, <span class="font-it">p</span>.
The loop body is never evaluated if <span class="font-it">n</span> &lt; <span class="font-it">p</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">for</span> p = String.length s - 1 <span class="ocamlkeyword">downto</span> 0 <span class="ocamlkeyword">do</span>
        l := s.[p] :: !l
      <span class="ocamlkeyword">done</span>;
      !l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>In both cases, the whole <span class="syntax-token">for</span> expression evaluates to the unit
value <span class="syntax-token">()</span>.</p><!--TOC subsubsection id="sss:expr-exception-handling" Exception handling-->
<h4 class="subsubsection" id="sss:expr-exception-handling"><a class="section-anchor" href="#sss:expr-exception-handling" aria-hidden="true">ï»¿</a>Exception handling</h4><!--SEC END --><p>
<a id="hevea_manual.kwd69"></a></p><p>The expression
</p><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="syntax-token">tryÂ </span></td><td class="c007"><span class="font-sl">expr</span>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">with</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub>â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">â€¦â€„</td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</table></td></tr>
</table><p>
evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and returns its value if the
evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> does not raise any exception. If the evaluation
of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> raises an exception, the exception value is matched against
the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the matching against
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> succeeds, the associated expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated,
and its value becomes the value of the whole <span class="syntax-token">try</span> expression. The
evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an environment enriched by the
bindings performed during matching. If several patterns match the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the one that occurs first in the <span class="syntax-token">try</span> expression is
selected. If none of the patterns matches the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the
exception value is raised again, thereby transparently â€œpassing
throughâ€ the <span class="syntax-token">try</span> construct.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> find_opt p l =
    <span class="ocamlkeyword">try</span> Some (List.find p l) <span class="ocamlkeyword">with</span> Not_found -&gt; None;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC subsection id="ss:expr-ops-on-data" 11.7.4â€ƒOperations on data structures-->
<h3 class="subsection" id="ss:expr-ops-on-data"><a class="section-anchor" href="#ss:expr-ops-on-data" aria-hidden="true">ï»¿</a>11.7.4â€ƒOperations on data structures</h3><!--SEC END --><!--TOC subsubsection id="sss:expr-products" Products-->
<h4 class="subsubsection" id="sss:expr-products"><a class="section-anchor" href="#sss:expr-products" aria-hidden="true">ï»¿</a>Products</h4><!--SEC END --><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> evaluates to the
<span class="font-it">n</span>-tuple of the values of expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>. The
evaluation order of the subexpressions is not specified.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (1 + 2 * 3, (1 + 2) * 3, 1 + (2 * 3));;</div>



<div class="pre caml-output ok">- : int * int * int = (7, 9, 7)</div></div>

</div><!--TOC subsubsection id="sss:expr-variants" Variants-->
<h4 class="subsubsection" id="sss:expr-variants"><a class="section-anchor" href="#sss:expr-variants" aria-hidden="true">ï»¿</a>Variants</h4><!--SEC END --><p>The expression <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to the unary variant value
whose constructor is <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>, and whose argument is the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Similarly, the expression <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> evaluates to the n-ary variant value whose constructor is
<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> and whose arguments are the values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, â€¦,
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><p>The expression <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">)</span> evaluates to the
variant value whose constructor is <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>, and whose arguments are
the values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = Var <span class="ocamlkeyword">of</span> string | Not <span class="ocamlkeyword">of</span> t | And <span class="ocamlkeyword">of</span> t * t | Or <span class="ocamlkeyword">of</span> t * t

  <span class="ocamlkeyword">let</span> test = And (Var <span class="ocamlstring">"x"</span>, Not (Or (Var <span class="ocamlstring">"y"</span>, Var <span class="ocamlstring">"z"</span>)));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = Var <span class="ocamlkeyword">of</span> string | Not <span class="ocamlkeyword">of</span> t | And <span class="ocamlkeyword">of</span> t * t | Or <span class="ocamlkeyword">of</span> t * t
<span class="ocamlkeyword">val</span> test : t = And (Var <span class="ocamlstring">"x"</span>, Not (Or (Var <span class="ocamlstring">"y"</span>, Var <span class="ocamlstring">"z"</span>)))</div></div>

</div><p>For lists, some syntactic sugar is provided. The expression
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">::</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> stands for the constructor <span class="syntax-token">(</span> <span class="syntax-token">::</span> <span class="syntax-token">)</span> 
applied to the arguments <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span>, and therefore
evaluates to the list whose head is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and whose tail
is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>. The expression <span class="syntax-token">[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> is equivalent to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">::</span> â€¦ <span class="syntax-token">::</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">::</span>
<span class="syntax-token">[]</span>, and therefore evaluates to the list whose elements are the
values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> 0 :: [1; 2; 3] = 0 :: 1 :: 2 :: 3 :: [];;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div><!--TOC subsubsection id="sss:expr-polyvars" Polymorphic variants-->
<h4 class="subsubsection" id="sss:expr-polyvars"><a class="section-anchor" href="#sss:expr-polyvars" aria-hidden="true">ï»¿</a>Polymorphic variants</h4><!--SEC END --><p>The expression <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to the polymorphic variant
value whose tag is <a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>, and whose argument is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> with_counter x = `V (x, <span class="ocamlkeyword">ref</span> 0);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> with_counter : 'a -&gt; [&gt; `V <span class="ocamlkeyword">of</span> 'a * int <span class="ocamlkeyword">ref</span> ] = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-records" Records-->
<h4 class="subsubsection" id="sss:expr-records"><a class="section-anchor" href="#sss:expr-records" aria-hidden="true">ï»¿</a>Records</h4><!--SEC END --><p>The expression <span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>] <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]}</span> evaluates to the record value
{ <span class="font-it">field</span><sub>1</sub> = <span class="font-it">v</span><sub>1</sub>; â€¦; <span class="font-it">field</span><sub><span class="font-it">n</span></sub> = <span class="font-it">v</span><sub><span class="font-it">n</span></sub> }
where <span class="font-it">v</span><sub><span class="font-it">i</span></sub> is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> for <span class="font-it">i</span> = 1,â€¦ , <span class="font-it">n</span>.
A single identifier <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>,
and a qualified identifier <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>.
The fields <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> to <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> must all belong to the same record
type; each field of this record type must appear exactly
once in the record expression, though they can appear in any
order. The order in which <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are evaluated is not
specified. Optional type constraints can be added after each field
<span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span>â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span>
to force the type of <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> to be compatible with <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">k</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {house_no : int; street : string; town : string; postcode : string}

  <span class="ocamlkeyword">let</span> address x =
    Printf.sprintf <span class="ocamlstring">"The occupier\n%i %s\n%s\n%s"</span>
      x.house_no x.street x.town x.postcode;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = {
  house_no : int;
  street : string;
  town : string;
  postcode : string;
}
<span class="ocamlkeyword">val</span> address : t -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression
<span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>] <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>] <span class="syntax-token">}</span>
builds a fresh record with fields <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> â€¦ <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> equal to
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>, and all other fields having the same value as
in the record <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. In other terms, it returns a shallow copy of
the record <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, except for the fields <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> â€¦ <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>,
which are initialized to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>. As previously,
single identifier <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>,
a qualified identifier <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> and it is
possible to add an optional type constraint on each field being updated
with
<span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {house_no : int; street : string; town : string; postcode : string}

  <span class="ocamlkeyword">let</span> uppercase_town address =
    {address <span class="ocamlkeyword">with</span> town = String.uppercase_ascii address.town};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = {
  house_no : int;
  street : string;
  town : string;
  postcode : string;
}
<span class="ocamlkeyword">val</span> uppercase_town : t -&gt; t = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to a record
value, and returns the value associated to <a class="syntax" href="#field"><span class="nonterminal">field</span></a> in this record
value.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to a record
value, which is then modified in-place by replacing the value
associated to <a class="syntax" href="#field"><span class="nonterminal">field</span></a> in this record by the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>. This operation is permitted only if <a class="syntax" href="#field"><span class="nonterminal">field</span></a> has been
declared <span class="syntax-token">mutable</span> in the definition of the record type. The whole
expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to the unit value
<span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {<span class="ocamlkeyword">mutable</span> upper : int; <span class="ocamlkeyword">mutable</span> lower : int; <span class="ocamlkeyword">mutable</span> other : int}

  <span class="ocamlkeyword">let</span> stats = {upper = 0; lower = 0; other = 0}

  <span class="ocamlkeyword">let</span> collect =
    String.iter
      (<span class="ocamlkeyword">function</span>
       | 'A'..'Z' -&gt; stats.upper &lt;- stats.upper + 1
       | 'a'..'z' -&gt; stats.lower &lt;- stats.lower + 1
       | _ -&gt; stats.other &lt;- stats.other + 1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = { <span class="ocamlkeyword">mutable</span> upper : int; <span class="ocamlkeyword">mutable</span> lower : int; <span class="ocamlkeyword">mutable</span> other : int; }
<span class="ocamlkeyword">val</span> stats : t = {upper = 0; lower = 0; other = 0}
<span class="ocamlkeyword">val</span> collect : string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-arrays" Arrays-->
<h4 class="subsubsection" id="sss:expr-arrays"><a class="section-anchor" href="#sss:expr-arrays" aria-hidden="true">ï»¿</a>Arrays</h4><!--SEC END --><p>The expression <span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span> evaluates to
a <span class="font-it">n</span>-element array, whose elements are initialized with the values of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> respectively. The order in which these
expressions are evaluated is unspecified.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span> returns the value of element
number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> in the array denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>. The first element
has number 0; the last element has number <span class="font-it">n</span>âˆ’1, where <span class="font-it">n</span> is the
size of the array. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if the
access is out of bounds.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> modifies in-place
the array denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, replacing element number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> by
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub>. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if
the access is out of bounds. The value of the whole expression is <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> scale arr n =
    <span class="ocamlkeyword">for</span> x = 0 <span class="ocamlkeyword">to</span> Array.length arr - 1 <span class="ocamlkeyword">do</span>
      arr.(x) &lt;- arr.(x) * n
    <span class="ocamlkeyword">done</span>

  <span class="ocamlkeyword">let</span> x = [|1; 10; 100|]
  <span class="ocamlkeyword">let</span> _ = scale x 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> scale : int array -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> x : int array = [|2; 20; 200|]</div></div>

</div><!--TOC subsubsection id="sss:expr-strings" Strings-->
<h4 class="subsubsection" id="sss:expr-strings"><a class="section-anchor" href="#sss:expr-strings" aria-hidden="true">ï»¿</a>Strings</h4><!--SEC END --><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">]</span> returns the value of character
number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> in the string denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>. The first character
has number 0; the last character has number <span class="font-it">n</span>âˆ’1, where <span class="font-it">n</span> is the
length of the string. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if the
access is out of bounds.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> iter f s =
    <span class="ocamlkeyword">for</span> x = 0 <span class="ocamlkeyword">to</span> String.length s - 1 <span class="ocamlkeyword">do</span> f s.[x] <span class="ocamlkeyword">done</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> iter : (char -&gt; 'a) -&gt; string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">]</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> modifies in-place
the string denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, replacing character number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> by
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub>. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if
the access is out of bounds. The value of the whole expression is <span class="syntax-token">()</span>.
<span class="font-bold">Note:</span> this possibility is offered only for backward
compatibility with older versions of OCaml and will be removed in a
future version. New code should use byte sequences and the <span class="machine"><span class="font-tt">Bytes.set</span></span>
function.</p>
<!--TOC subsection id="ss:expr-operators" 11.7.5â€ƒOperators-->
<h3 class="subsection" id="ss:expr-operators"><a class="section-anchor" href="#ss:expr-operators" aria-hidden="true">ï»¿</a>11.7.5â€ƒOperators</h3><!--SEC END --><p>
<a id="hevea_manual.kwd70"></a>
<a id="hevea_manual.kwd71"></a>
<a id="hevea_manual.kwd72"></a>
<a id="hevea_manual.kwd73"></a>
<a id="hevea_manual.kwd74"></a>
<a id="hevea_manual.kwd75"></a>
<a id="hevea_manual.kwd76"></a></p><p>Symbols from the class <a class="syntax" href="#infix-symbol"><span class="nonterminal">infix-symbol</span></a>, as well as the keywords
<span class="syntax-token">*</span>, <span class="syntax-token">+</span>, <span class="syntax-token">-</span>, <span class="syntax-token">-.</span>, <span class="syntax-token">=</span>, <span class="syntax-token">!=</span>, <span class="syntax-token">&lt;</span>, <span class="syntax-token">&gt;</span>, <span class="syntax-token">or</span>, <span class="syntax-token">||</span>,
<span class="syntax-token">&amp;</span>, <span class="syntax-token">&amp;&amp;</span>, <span class="syntax-token">:=</span>, <span class="syntax-token">mod</span>, <span class="syntax-token">land</span>, <span class="syntax-token">lor</span>, <span class="syntax-token">lxor</span>, <span class="syntax-token">lsl</span>, <span class="syntax-token">lsr</span>,
and <span class="syntax-token">asr</span> can appear in infix position (between two
expressions). Symbols from the class <a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a>, as well as
the keywords <span class="syntax-token">-</span> and <span class="syntax-token">-.</span>
can appear in prefix position (in front of an expression).</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (( * ), ( := ), ( || ));;</div>



<div class="pre caml-output ok">- : (int -&gt; int -&gt; int) * ('a <span class="ocamlkeyword">ref</span> -&gt; 'a -&gt; unit) * (bool -&gt; bool -&gt; bool) =
(&lt;<span class="ocamlkeyword">fun</span>&gt;, &lt;<span class="ocamlkeyword">fun</span>&gt;, &lt;<span class="ocamlkeyword">fun</span>&gt;)</div></div>

</div><p>Infix and prefix symbols do not have a fixed meaning: they are simply
interpreted as applications of functions bound to the names
corresponding to the symbols. The expression <a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
interpreted as the application <span class="syntax-token">(</span> <a class="syntax" href="#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a> <span class="syntax-token">)</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Similarly, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#infix-symbol"><span class="nonterminal">infix-symbol</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> is
interpreted as the application <span class="syntax-token">(</span> <a class="syntax" href="#infix-symbol"><span class="nonterminal">infix-symbol</span></a> <span class="syntax-token">)</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.</p><p>The table below lists the symbols defined in the initial environment
and their initial meaning. (See the description of the core
library module <span class="machine"><span class="font-tt">Stdlib</span></span> in chapterÂ <a href="#c%3Acorelib">27</a> for more
details). Their meaning may be changed at any time using
<span class="syntax-token">let</span> <span class="syntax-token">(</span> <a class="syntax" href="#infix-op"><span class="nonterminal">infix-op</span></a> <span class="syntax-token">)</span> <span class="nonterminal">name</span><sub>1</sub> <span class="nonterminal">name</span><sub>2</sub> <span class="syntax-token">=</span> â€¦</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ( + ), ( - ), ( * ), ( / ) = Int64.(add, sub, mul, div);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ( + ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( - ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( * ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( / ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Note: the operators <span class="syntax-token">&amp;&amp;</span>, <span class="syntax-token">||</span>, and <span class="syntax-token">~-</span> are handled specially
and it is not advisable to change their meaning.</p><p>The keywords <span class="syntax-token">-</span> and <span class="syntax-token">-.</span> can appear both as infix and
prefix operators. When they appear as prefix operators, they are
interpreted respectively as the functions <span class="syntax-token">(~-)</span> and <span class="syntax-token">(~-.)</span>.</p><p><a id="hevea_manual.kwd77"></a><a id="hevea_manual.kwd78"></a><a id="hevea_manual.kwd79"></a><a id="hevea_manual.kwd80"></a><a id="hevea_manual.kwd81"></a><a id="hevea_manual.kwd82"></a><a id="hevea_manual.kwd83"></a></p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Operator</span></td><td class="c004"><span class="font-bold">Initial meaning</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">+</span></span></td><td class="c011">Integer addition. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">-</span></span> (infix)</td><td class="c011">Integer subtraction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">~-   -</span></span> (prefix)</td><td class="c011">Integer negation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">*</span></span></td><td class="c011">Integer multiplication. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">/</span></span></td><td class="c011">Integer division.
Raise <span class="machine"><span class="font-tt">Division_by_zero</span></span> if second argument is zero. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">mod</span></span></td><td class="c011">Integer modulus. Raise
<span class="machine"><span class="font-tt">Division_by_zero</span></span> if second argument is zero. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">land</span></span></td><td class="c011">Bitwise logical â€œandâ€ on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lor</span></span></td><td class="c011">Bitwise logical â€œorâ€ on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lxor</span></span></td><td class="c011">Bitwise logical â€œexclusive orâ€ on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lsl</span></span></td><td class="c011">Bitwise logical shift left on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lsr</span></span></td><td class="c011">Bitwise logical shift right on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">asr</span></span></td><td class="c011">Bitwise arithmetic shift right on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">+.</span></span></td><td class="c011">Floating-point addition. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">-.</span></span> (infix)</td><td class="c011">Floating-point subtraction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">~-.   -.</span></span> (prefix)</td><td class="c011">Floating-point negation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">*.</span></span></td><td class="c011">Floating-point multiplication. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">/.</span></span></td><td class="c011">Floating-point division. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">**</span></span></td><td class="c011">Floating-point exponentiation. </td></tr>
<tr><td class="c012"><span class="font-tt">@</span> </td><td class="c011">List concatenation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">^</span></span> </td><td class="c011">String concatenation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">!</span></span> </td><td class="c011">Dereferencing (return the current
contents of a reference). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">:=</span></span></td><td class="c011">Reference assignment (update the
reference given as first argument with the value of the second
argument). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">=</span></span> </td><td class="c011">Structural equality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;&gt;</span></span> </td><td class="c011">Structural inequality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">==</span></span> </td><td class="c011">Physical equality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">!=</span></span> </td><td class="c011">Physical inequality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;</span></span> </td><td class="c011">Test â€œless thanâ€. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;=</span></span> </td><td class="c011">Test â€œless than or equalâ€. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&gt;</span></span> </td><td class="c011">Test â€œgreater thanâ€. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&gt;=</span></span> </td><td class="c011">Test â€œgreater than or equalâ€. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&amp;&amp;   &amp;</span></span></td><td class="c011">Boolean conjunction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">||   or</span></span></td><td class="c011">Boolean disjunction. </td></tr>
</table></div></div>
<!--TOC subsection id="ss:expr-obj" 11.7.6â€ƒObjects-->
<h3 class="subsection" id="ss:expr-obj"><a class="section-anchor" href="#ss:expr-obj" aria-hidden="true">ï»¿</a>11.7.6â€ƒObjects</h3><!--SEC END --><p> <a id="s:objects"></a></p><!--TOC subsubsection id="sss:expr-obj-creation" Object creation-->
<h4 class="subsubsection" id="sss:expr-obj-creation"><a class="section-anchor" href="#sss:expr-obj-creation" aria-hidden="true">ï»¿</a>Object creation</h4><!--SEC END --><p><a id="hevea_manual.kwd84"></a></p><p>When <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a> evaluates to a class body, <span class="syntax-token">new</span> <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
evaluates to a new object containing the instance variables and
methods of this class.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">new</span> of_list [1; 1; 2; 3; 5; 8; 13]

  <span class="ocamlkeyword">let</span> b = <span class="ocamlkeyword">new</span> of_list;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">val</span> a : of_list = &lt;obj&gt;
<span class="ocamlkeyword">val</span> b : int list -&gt; of_list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>When <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a> evaluates to a class function, <span class="syntax-token">new</span> <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
evaluates to a function expecting the same number of arguments and
returning a new object of this class.</p><!--TOC subsubsection id="sss:expr-obj-immediate" Immediate object creation-->
<h4 class="subsubsection" id="sss:expr-obj-immediate"><a class="section-anchor" href="#sss:expr-obj-immediate" aria-hidden="true">ï»¿</a>Immediate object creation</h4><!--SEC END --><p><a id="hevea_manual.kwd85"></a></p><p>Creating directly an object through the <span class="syntax-token">object</span> <a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span>
construct is operationally equivalent to defining locally a <span class="syntax-token">class</span>
<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> <span class="syntax-token">=</span> <span class="syntax-token">object</span> <a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span> â€”see sections
<a href="#sss%3Aclass-body">11.9.2</a> and following for the syntax of <a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a>â€”
and immediately creating a single object from it by <span class="syntax-token">new</span> <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> o =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> secret = 99
      <span class="ocamlkeyword">val</span> password = <span class="ocamlstring">"unlock"</span>
      <span class="ocamlkeyword">method</span> get guess = <span class="ocamlkeyword">if</span> guess &lt;&gt; password <span class="ocamlkeyword">then</span> None <span class="ocamlkeyword">else</span> Some secret
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> o : &lt; get : string -&gt; int option &gt; = &lt;obj&gt;</div></div>

</div><p>The typing of immediate objects is slightly different from explicitly
defining a class in two respects. First, the inferred object type may
contain free type variables. Second, since the class body of an
immediate object will never be extended, its self type can be unified
with a closed object type.</p><!--TOC subsubsection id="sss:expr-method" Method invocation-->
<h4 class="subsubsection" id="sss:expr-method"><a class="section-anchor" href="#sss:expr-method" aria-hidden="true">ï»¿</a>Method invocation</h4><!--SEC END --><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">#</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> invokes the method
<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> of the object denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">new</span> of_list [1; 1; 2; 3; 5; 8; 13]

  <span class="ocamlkeyword">let</span> third = ignore a#next; ignore a#next; a#next;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">val</span> a : of_list = &lt;obj&gt;
<span class="ocamlkeyword">val</span> third : int = 2</div></div>

</div><p>If <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> is a polymorphic method, its type should be known at
the invocation site. This is true for instance if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is the name
of a fresh object (<span class="syntax-token">let</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> = <span class="syntax-token">new</span> <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a> â€¦ ) or if
there is a type constraint. Principality of the derivation can be
checked in the <span class="machine"><span class="font-tt">-principal</span></span> mode.</p><!--TOC subsubsection id="sss:expr-obj-variables" Accessing and modifying instance variables-->
<h4 class="subsubsection" id="sss:expr-obj-variables"><a class="section-anchor" href="#sss:expr-obj-variables" aria-hidden="true">ï»¿</a>Accessing and modifying instance variables</h4><!--SEC END --><p>The instance variables of a class are visible only in the body of the
methods defined in the same class or a class that inherits from the
class defining the instance variables. The expression <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>
evaluates to the value of the given instance variable. The expression
<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> assigns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> to the instance
variable <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>, which must be mutable. The whole expression
<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>                            <span class="ocamlcomment">(* access instance variable *)</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h                     <span class="ocamlcomment">(* modify instance variable *)</span>
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span></div></div>

</div><!--TOC subsubsection id="sss:expr-obj-duplication" Object duplication-->
<h4 class="subsubsection" id="sss:expr-obj-duplication"><a class="section-anchor" href="#sss:expr-obj-duplication" aria-hidden="true">ï»¿</a>Object duplication</h4><!--SEC END --><p>An object can be duplicated using the library function <span class="machine"><span class="font-tt">Oo.copy</span></span>
(see module <a href="libref/Oo.html"><span class="font-tt">Oo</span></a>). Inside a method, the expression
 <span class="syntax-token">{&lt;</span> [<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] { <span class="syntax-token">;</span> <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] }] <span class="syntax-token">&gt;}</span>
returns a copy of self with the given instance variables replaced by
the values of the associated expressions. A single instance variable
name <span class="nonterminal">id</span> stands for <span class="nonterminal">id</span> <span class="syntax-token">=</span> <span class="nonterminal">id</span>. Other instance variables have the same
value in the returned object as in self.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> o =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> secret = 99
      <span class="ocamlkeyword">val</span> password = <span class="ocamlstring">"unlock"</span>
      <span class="ocamlkeyword">method</span> get guess = <span class="ocamlkeyword">if</span> guess &lt;&gt; password <span class="ocamlkeyword">then</span> None <span class="ocamlkeyword">else</span> Some secret
      <span class="ocamlkeyword">method</span> with_new_secret s = {&lt; secret = s &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> o : &lt; get : string -&gt; int option; with_new_secret : int -&gt; 'a &gt; <span class="ocamlkeyword">as</span> 'a =
  &lt;obj&gt;</div></div>

</div>
<!--TOC subsection id="ss:expr-coercions" 11.7.7â€ƒCoercions-->
<h3 class="subsection" id="ss:expr-coercions"><a class="section-anchor" href="#ss:expr-coercions" aria-hidden="true">ï»¿</a>11.7.7â€ƒCoercions</h3><!--SEC END --><p>Expressions whose type contains object or polymorphic variant types
can be explicitly coerced (weakened) to a supertype.
The expression <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><span class="syntax-token">)</span> coerces the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
to type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.
The expression <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">:&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub><span class="syntax-token">)</span> coerces the
expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> from type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> to type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>.</p><p>The former operator will sometimes fail to coerce an expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
from a type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> to a type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>
even if type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype of type
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>: in the current implementation it only expands two levels of
type abbreviations containing objects and/or polymorphic variants,
keeping only recursion when it is explicit in the class type (for objects).
As an exception to the above algorithm, if both the inferred type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
and <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a> are ground (<em>i.e.</em> do not contain type variables), the
former operator behaves as the latter one, taking the inferred type of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> as <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub>. In case of failure with the former operator,
the latter one should be used.</p><p>It is only possible to coerce an expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> from type
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> to type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>, if the type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is an instance of
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> (like for a type annotation), and <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype
of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. The type of the coerced expression is an
instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. If the types contain variables,
they may be instantiated by the subtyping algorithm, but this is only
done after determining whether <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a potential subtype of
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. This means that typing may fail during this latter
unification step, even if some instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype of
some instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>.
In the following paragraphs we describe the subtyping relation used.</p><!--TOC subsubsection id="sss:expr-obj-types" Object types-->
<h4 class="subsubsection" id="sss:expr-obj-types"><a class="section-anchor" href="#sss:expr-obj-types" aria-hidden="true">ï»¿</a>Object types</h4><!--SEC END --><p>A fixed object type admits as subtype any object type that includes all
its methods. The types of the methods shall be subtypes of those in
the supertype. Namely,
</p><div class="center">
 <span class="syntax-token">&lt;</span> <a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">&gt;</span> 
</div><p>
is a supertype of
</p><div class="center">
 <span class="syntax-token">&lt;</span> <a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span></sub> <span class="syntax-token">;</span>
<a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span>+<span class="font-it">m</span></sub>
Â [<span class="syntax-token">;</span> <span class="syntax-token">..</span>] <span class="syntax-token">&gt;</span> 
</div><p>
which may contain an ellipsis <span class="machine"><span class="font-tt">..</span></span> if every <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">i</span></sub> is a supertype of
the corresponding <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">i</span></sub>.</p><p>A monomorphic method type can be a supertype of a polymorphic method
type. Namely, if <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a> is an instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€², then  <span class="syntax-token">'</span><span class="nonterminal">a</span><sub>1</sub>
â€¦ <span class="syntax-token">'</span><span class="nonterminal">a</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">.</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€² is a subtype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>.</p><p>Inside a class definition, newly defined types are not available for
subtyping, as the type abbreviations are not yet completely
defined. There is an exception for coercing <span class="nonterminal">self</span> to the (exact)
type of its class: this is allowed if the type of <span class="nonterminal">self</span> does not
appear in a contravariant position in the class type, <em>i.e.</em> if
there are no binary methods.</p><!--TOC subsubsection id="sss:expr-polyvar-types" Polymorphic variant types-->
<h4 class="subsubsection" id="sss:expr-polyvar-types"><a class="section-anchor" href="#sss:expr-polyvar-types" aria-hidden="true">ï»¿</a>Polymorphic variant types</h4><!--SEC END --><p>A polymorphic variant type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a> is a subtype of another polymorphic
variant type <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€² if the upper bound of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a> (<em>i.e.</em> the
maximum set of constructors that may appear in an instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>)
is included in the lower bound of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€², and the types of arguments
for the constructors of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a> are subtypes of those in
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€². Namely,
</p><div class="center">
 <span class="syntax-token">[</span>[<span class="syntax-token">&lt;</span>] <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub>1</sub> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">|</span> â€¦ <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> 
</div><p>
which may be a shrinkable type, is a subtype of
</p><div class="center">
 <span class="syntax-token">[</span>[<span class="syntax-token">&gt;</span>] <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub>1</sub> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub> <span class="syntax-token">|</span> â€¦ <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span></sub>
<span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">|</span> â€¦ <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">of</span>
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">]</span> 
</div><p>
which may be an extensible type, if every <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">i</span></sub> is a subtype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub><span class="font-it">i</span></sub>.</p><!--TOC subsubsection id="sss:expr-variance" Variance-->
<h4 class="subsubsection" id="sss:expr-variance"><a class="section-anchor" href="#sss:expr-variance" aria-hidden="true">ï»¿</a>Variance</h4><!--SEC END --><p>Other types do not introduce new subtyping, but they may propagate the
subtyping of their arguments. For instance, <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">*</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a
subtype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub> <span class="syntax-token">*</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>2</sub> when <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> and <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> are
respectively subtypes of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub> and <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>2</sub>.
For function types, the relation is more subtle:
<a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a subtype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub>Â <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>2</sub>
if <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a supertype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>1</sub> and <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a
subtype of <a class="syntax" href="#typexpr"><span class="nonterminal">typ</span></a>â€²<sub>2</sub>. For this reason, function types are covariant in
their second argument (like tuples), but contravariant in their first
argument. Mutable types, like <span class="machine"><span class="font-tt">array</span></span> or <span class="machine"><span class="font-tt">ref</span></span> are neither covariant
nor contravariant, they are nonvariant, that is they do not propagate
subtyping.</p><p>For user-defined types, the variance is automatically inferred: a
parameter is covariant if it has only covariant occurrences,
contravariant if it has only contravariant occurrences,
variance-free if it has no occurrences, and nonvariant otherwise.
A variance-free parameter may change freely through subtyping, it does
not have to be a subtype or a supertype.
For abstract and private types, the variance must be given explicitly
(see sectionÂ <a href="#ss%3Atypedefs">11.8.1</a>),
otherwise the default is nonvariant. This is also the case for
constrained arguments in type definitions.</p>
<!--TOC subsection id="ss:expr-other" 11.7.8â€ƒOther-->
<h3 class="subsection" id="ss:expr-other"><a class="section-anchor" href="#ss:expr-other" aria-hidden="true">ï»¿</a>11.7.8â€ƒOther</h3><!--SEC END --><!--TOC subsubsection id="sss:expr-assertion" Assertion checking-->
<h4 class="subsubsection" id="sss:expr-assertion"><a class="section-anchor" href="#sss:expr-assertion" aria-hidden="true">ï»¿</a>Assertion checking</h4><!--SEC END --><p><a id="hevea_manual.kwd86"></a></p><p>OCaml supports the <span class="syntax-token">assert</span> construct to check debugging assertions.
The expression <span class="syntax-token">assert</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and
returns <span class="syntax-token">()</span> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to <span class="syntax-token">true</span>. If it evaluates to
<span class="syntax-token">false</span> the exception
<span class="machine"><span class="font-tt">Assert_failure</span></span> is raised with the source file name and the
location of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> as arguments. Assertion
checking can be turned off with the <span class="machine"><span class="font-tt">-noassert</span></span> compiler option. In
this case, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is not evaluated at all.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f a b c =
    <span class="ocamlkeyword">assert</span> (a &lt;= b &amp;&amp; b &lt;= c);
    (b -. a) /. (c -. b);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : float -&gt; float -&gt; float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>As a special case, <span class="syntax-token">assert false</span> is reduced to
<span class="syntax-token">raise</span> <span class="syntax-token">(</span><span class="machine"><span class="font-tt">Assert_failure ...</span></span><span class="syntax-token">)</span>, which gives it a polymorphic
type. This means that it can be used in place of any expression (for
example as a branch of any pattern-matching). It also means that
the <span class="syntax-token">assert false</span> â€œassertionsâ€ cannot be turned off by the
<span class="machine"><span class="font-tt">-noassert</span></span> option.
<a id="hevea_manual5"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> min_known_nonempty = <span class="ocamlkeyword">function</span>
    | [] -&gt; <span class="ocamlkeyword">assert</span> <span class="ocamlkeyword">false</span>
    | l -&gt; List.hd (List.sort compare l);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> min_known_nonempty : 'a list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:expr-lazy" Lazy expressions-->
<h4 class="subsubsection" id="sss:expr-lazy"><a class="section-anchor" href="#sss:expr-lazy" aria-hidden="true">ï»¿</a>Lazy expressions</h4><!--SEC END --><p>
<a id="hevea_manual.kwd87"></a></p><p>The expression <span class="syntax-token">lazy</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> returns a value <span class="font-it">v</span> of type <span class="machine"><span class="font-tt">Lazy.t</span></span> that
encapsulates the computation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. The argument <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is not
evaluated at this point in the program. Instead, its evaluation will
be performed the first time the function <span class="machine"><span class="font-tt">Lazy.force</span></span> is applied to the value
<span class="font-it">v</span>, returning the actual value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Subsequent applications
of <span class="machine"><span class="font-tt">Lazy.force</span></span> to <span class="font-it">v</span> do not evaluate <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> again. Applications
of <span class="machine"><span class="font-tt">Lazy.force</span></span> may be implicit through pattern matching (seeÂ <a href="#sss%3Apat-lazy">11.6</a>).</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> lazy_greeter = <span class="ocamlkeyword">lazy</span> (print_string <span class="ocamlstring">"Hello, World!\n"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lazy_greeter : unit lazy_t = &lt;<span class="ocamlkeyword">lazy</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Lazy.force lazy_greeter;;</div>



<div class="pre caml-output ok">Hello, World!
- : unit = ()</div></div>

</div><!--TOC subsubsection id="sss:expr-local-modules" Local modules-->
<h4 class="subsubsection" id="sss:expr-local-modules"><a class="section-anchor" href="#sss:expr-local-modules" aria-hidden="true">ï»¿</a>Local modules</h4><!--SEC END --><p>
<a id="hevea_manual.kwd88"></a>
<a id="hevea_manual.kwd89"></a></p><p>The expression
<span class="syntax-token">let</span> <span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
locally binds the module expression <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> to the identifier
<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> during the evaluation of the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.
It then returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. For example:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> remove_duplicates comparison_fun string_list =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> StringSet =
      Set.Make(<span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = string
                      <span class="ocamlkeyword">let</span> compare = comparison_fun <span class="ocamlkeyword">end</span>)
    <span class="ocamlkeyword">in</span>
      StringSet.elements
        (List.fold_right StringSet.add string_list StringSet.empty);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> remove_duplicates :
  (string -&gt; string -&gt; int) -&gt; string list -&gt; string list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><!--TOC subsubsection id="sss:local-opens" Local opens-->
<h4 class="subsubsection" id="sss:local-opens"><a class="section-anchor" href="#sss:local-opens" aria-hidden="true">ï»¿</a>Local opens</h4><!--SEC END --><p>
<a id="hevea_manual.kwd90"></a>
<a id="hevea_manual.kwd91"></a></p><p>The expressions <span class="syntax-token">let</span> <span class="syntax-token">open</span> <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">)</span> are strictly equivalent. These
constructions locally open the module referred to by the module path
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> in the respective scope of the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> map_3d_matrix f m =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> Array <span class="ocamlkeyword">in</span>
      map (map (map f)) m

  <span class="ocamlkeyword">let</span> map_3d_matrix' f =
    Array.(map (map (map f)));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map_3d_matrix :
  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> map_3d_matrix' :
  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>When the body of a local open expression is delimited by
<span class="syntax-token">[</span> <span class="syntax-token">]</span>, <span class="syntax-token">[|</span> <span class="syntax-token">|]</span>, or <span class="syntax-token">{</span> <span class="syntax-token">}</span>, the parentheses can be omitted.
For expression, parentheses can also be omitted for <span class="syntax-token">{&lt;</span> <span class="syntax-token">&gt;}</span>.
For example, <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">]</span> is equivalent to
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">])</span>, and <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">|]</span> is
equivalent to <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">|])</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> vector = Random.[|int 255; int 255; int 255; int 255|];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> vector : int array = [|220; 90; 247; 144|]</div></div>

</div>
<!--TOC section id="s:tydef" 11.8â€ƒType and exception definitions-->
<h2 class="section" id="s:tydef"><a class="section-anchor" href="#s:tydef" aria-hidden="true">ï»¿</a>11.8â€ƒType and exception definitions</h2><!--SEC END --><!--NAME typedecl.html-->

<!--TOC subsection id="ss:typedefs" 11.8.1â€ƒType definitions-->
<h3 class="subsection" id="ss:typedefs"><a class="section-anchor" href="#ss:typedefs" aria-hidden="true">ï»¿</a>11.8.1â€ƒType definitions</h3><!--SEC END --><p>Type definitions bind type constructors to data types: either
variant types, record types, type abbreviations, or abstract data
types. They also bind the value constructors and record fields
associated with the definition.</p><p><a id="hevea_manual.kwd92"></a>
<a id="hevea_manual.kwd93"></a>
<a id="hevea_manual.kwd94"></a>
<a id="hevea_manual.kwd95"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="type-definition"><span class="nonterminal">type-definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">type</span>â€„[<span class="syntax-token">nonrec</span>]â€„<a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="typedef"><span class="nonterminal">typedef</span></a></td><td class="c005">::=</td><td class="c007">
[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„<a class="syntax" href="#type-information"><span class="nonterminal">type-information</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-information"><span class="nonterminal">type-information</span></a></td><td class="c005">::=</td><td class="c007">
[<a class="syntax" href="#type-equation"><span class="nonterminal">type-equation</span></a>]â€„[<a class="syntax" href="#type-representation"><span class="nonterminal">type-representation</span></a>]â€„{â€„<a class="syntax" href="#type-constraint"><span class="nonterminal">type-constraint</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-equation"><span class="nonterminal">type-equation</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-representation"><span class="nonterminal">type-representation</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">=</span>â€„[<span class="syntax-token">|</span>]â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#record-decl"><span class="nonterminal">record-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">|</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-params"><span class="nonterminal">type-params</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#type-param"><span class="nonterminal">type-param</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#type-param"><span class="nonterminal">type-param</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#type-param"><span class="nonterminal">type-param</span></a>â€„}â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-param"><span class="nonterminal">type-param</span></a></td><td class="c005">::=</td><td class="c007">
[<a class="syntax" href="#ext-variance"><span class="nonterminal">ext-variance</span></a>]â€„<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="ext-variance"><span class="nonterminal">ext-variance</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#variance"><span class="nonterminal">variance</span></a>â€„[<a class="syntax" href="#injectivity"><span class="nonterminal">injectivity</span></a>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#injectivity"><span class="nonterminal">injectivity</span></a>â€„[<a class="syntax" href="#variance"><span class="nonterminal">variance</span></a>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="variance"><span class="nonterminal">variance</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">+</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">-</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="injectivity"><span class="nonterminal">injectivity</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">!</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="record-decl"><span class="nonterminal">record-decl</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">{</span>â€„<a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a>â€„}â€„[<span class="syntax-token">;</span>]â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="constr-decl"><span class="nonterminal">constr-decl</span></a></td><td class="c005">::=</td><td class="c007">
(<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„âˆ£â€„<span class="syntax-token">[]</span>â€„âˆ£â€„<span class="syntax-token">(::)</span>)â€„[â€„<span class="syntax-token">of</span>â€„<a class="syntax" href="#constr-args"><span class="nonterminal">constr-args</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="constr-args"><span class="nonterminal">constr-args</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">*</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="field-decl"><span class="nonterminal">field-decl</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">mutable</span>]â€„<a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-constraint"><span class="nonterminal">type-constraint</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">constraint</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
<a id="hevea_manual.kwd96"></a>
<a id="hevea_manual.kwd97"></a>
See also the following language extensions:
<a href="#s%3Aprivate-types">private types</a>,
<a href="#s%3Agadts">generalized algebraic datatypes</a>,
<a href="#s%3Aattributes">attributes</a>,
<a href="#s%3Aextension-nodes">extension nodes</a>,
<a href="#s%3Aextensible-variants">extensible variant types</a> and
<a href="#s%3Ainline-records">inline records</a>.</p><p>Type definitions are introduced by the <span class="machine"><span class="font-tt">type</span></span> keyword, and
consist in one or several simple definitions, possibly mutually
recursive, separated by the <span class="machine"><span class="font-tt">and</span></span> keyword. Each simple definition
defines one type constructor.</p><p>A simple definition consists in a lowercase identifier, possibly
preceded by one or several type parameters, and followed by an
optional type equation, then an optional type representation, and then
a constraint clause. The identifier is the name of the type
constructor being defined.</p><pre>type colour =
  | Red | Green | Blue | Yellow | Black | White
  | RGB of {r : int; g : int; b : int}

type 'a tree = Lf | Br of 'a * 'a tree * 'a;;

type t = {decoration : string; substance : t'}
and t' = Int of int | List of t list
</pre><p>
In the right-hand side of type definitions, references to one of the
type constructor name being defined are considered as recursive,
unless <span class="machine"><span class="font-tt">type</span></span> is followed by <span class="machine"><span class="font-tt">nonrec</span></span>. The <span class="machine"><span class="font-tt">nonrec</span></span> keyword was
introduced in OCaml 4.02.2.</p><p>The optional type parameters are either one type variable <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>,
for type constructors with one parameter, or a list of type variables
<span class="syntax-token">('</span><a class="syntax" href="#ident"><span class="nonterminal">ident</span></a><sub>1</sub>,â€¦,<span class="syntax-token">'</span><a class="syntax" href="#ident"><span class="nonterminal">ident</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">)</span>, for type constructors with several
parameters. Each type parameter may be prefixed by a variance
constraint <span class="syntax-token">+</span> (resp. <span class="syntax-token">-</span>) indicating that the parameter is
covariant (resp. contravariant), and an injectivity annotation <span class="syntax-token">!</span>
indicating that the parameter can be deduced from the whole type.
These type parameters can appear in
the type expressions of the right-hand side of the definition,
optionally restricted by a variance constraint ; <em>i.e.</em> a
covariant parameter may only appear on the right side of a functional
arrow (more precisely, follow the left branch of an even number of
arrows), and a contravariant parameter only the left side (left branch of
an odd number of arrows). If the type has a representation or
an equation, and the parameter is free (<em>i.e.</em> not bound via a
type constraint to a constructed type), its variance constraint is
checked but subtyping <em>etc.</em> will use the inferred variance of the
parameter, which may be less restrictive; otherwise (<em>i.e.</em> for abstract
types or non-free parameters), the variance must be given explicitly,
and the parameter is invariant if no variance is given.</p><p>The optional type equation <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> makes the defined type
equivalent to the type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>:
one can be substituted for the other during typing.
If no type equation is given, a new type is generated: the defined type
is incompatible with any other type.</p><p>The optional type representation describes the data structure
representing the defined type, by giving the list of associated
constructors (if it is a variant type) or associated fields (if it is
a record type). If no type representation is given, nothing is
assumed on the structure of the type besides what is stated in the
optional type equation.</p><p>The type representation <span class="syntax-token">=</span> [<span class="syntax-token">|</span>] <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a> { <span class="syntax-token">|</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a> }
describes a variant type. The constructor declarations
<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a><sub><span class="font-it">n</span></sub> describe the constructors
associated to this variant type. The constructor
declaration <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a> <span class="syntax-token">of</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">*</span> â€¦ <span class="syntax-token">*</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>
declares the name <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a> as a non-constant constructor, whose
arguments have types <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> â€¦<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>.
The constructor declaration <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>
declares the name <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a> as a constant
constructor. Constructor names must be capitalized.</p><p>The type representation <span class="syntax-token">=</span> <span class="syntax-token">{</span> <a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a> } [<span class="syntax-token">;</span>] <span class="syntax-token">}</span>
describes a record type. The field declarations <a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a><sub>1</sub>, â€¦,
<a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a><sub><span class="font-it">n</span></sub> describe the fields associated to this record type.
The field declaration <a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a> declares
<a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a> as a field whose argument has type <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>.
The field declaration <span class="syntax-token">mutable</span> <a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
<a id="hevea_manual.kwd98"></a>
behaves similarly; in addition, it allows physical modification of
this field.
Immutable fields are covariant, mutable fields are non-variant.
Both mutable and immutable fields may have explicitly polymorphic
types. The polymorphism of the contents is statically checked whenever
a record value is created or modified. Extracted values may have their
types instantiated.</p><p>The two components of a type definition, the optional equation and the
optional representation, can be combined independently, giving
rise to four typical situations:</p><dl class="description"><dt class="dt-description"><span class="font-bold">Abstract type: no equation, no representation.</span></dt><dd class="dd-description"> Â <br>
When appearing in a module signature, this definition specifies
nothing on the type constructor, besides its number of parameters:
its representation is hidden and it is assumed incompatible with any
other type.</dd><dt class="dt-description"><span class="font-bold">Type abbreviation: an equation, no representation.</span></dt><dd class="dd-description"> Â <br>
This defines the type constructor as an abbreviation for the type
expression on the right of the <span class="syntax-token">=</span> sign.</dd><dt class="dt-description"><span class="font-bold">New variant type or record type: no equation, a representation.</span></dt><dd class="dd-description"> Â <br>
This generates a new type constructor and defines associated
constructors or fields, through which values of that type can be
directly built or inspected.</dd><dt class="dt-description"><span class="font-bold">Re-exported variant type or record type: an equation,
a representation.</span></dt><dd class="dd-description"> Â <br>
In this case, the type constructor is defined as an abbreviation for
the type expression given in the equation, but in addition the
constructors or fields given in the representation remain attached to
the defined type constructor. The type expression in the equation part
must agree with the representation: it must be of the same kind
(record or variant) and have exactly the same constructors or fields,
in the same order, with the same arguments. Moreover, the new type
constructor must have the same arity and the same type constraints as the
original type constructor.
</dd></dl><p>The type variables appearing as type parameters can optionally be
prefixed by <span class="machine"><span class="font-tt">+</span></span> or <span class="machine"><span class="font-tt">-</span></span> to indicate that the type constructor is
covariant or contravariant with respect to this parameter. This
variance information is used to decide subtyping relations when
checking the validity of <span class="syntax-token">:&gt;</span> coercions
(see section <a href="#ss%3Aexpr-coercions">11.7.7</a>).</p><p>For instance, <span class="machine"><span class="font-tt">type +'a t</span></span> declares <span class="machine"><span class="font-tt">t</span></span> as an abstract type that is
covariant in its parameter; this means that if the type Ï„ is a
subtype of the type Ïƒ, then Ï„<span class="machine"><span class="font-tt"> t</span></span> is a subtype of Ïƒ<span class="machine"><span class="font-tt"> t</span></span>.
Similarly, <span class="machine"><span class="font-tt">type -'a t</span></span> declares that the abstract type <span class="machine"><span class="font-tt">t</span></span> is
contravariant in its parameter: if Ï„ is a subtype of Ïƒ, then
Ïƒ<span class="machine"><span class="font-tt"> t</span></span> is a subtype of Ï„<span class="machine"><span class="font-tt"> t</span></span>. If no <span class="machine"><span class="font-tt">+</span></span> or <span class="machine"><span class="font-tt">-</span></span> variance
annotation is given, the type constructor is assumed non-variant in the
corresponding parameter. For instance, the abstract type declaration
<span class="machine"><span class="font-tt">type 'a t</span></span> means that Ï„<span class="machine"><span class="font-tt"> t</span></span> is neither a subtype nor a
supertype of Ïƒ<span class="machine"><span class="font-tt"> t</span></span> if Ï„ is subtype of Ïƒ.</p><p>The variance indicated by the <span class="machine"><span class="font-tt">+</span></span> and <span class="machine"><span class="font-tt">-</span></span> annotations on parameters
is enforced only for abstract and private types, or when there are
type constraints.
Otherwise, for abbreviations, variant and record types without type
constraints, the variance properties of the type constructor
are inferred from its definition, and the variance annotations are
only checked for conformance with the definition.</p><p>Injectivity annotations are only necessary for abstract types and
private row types, since they can otherwise be deduced from the type
declaration: all parameters are injective for record and variant type
declarations (including extensible types); for type abbreviations a
parameter is injective if it has an injective occurrence in its
defining equation (be it private or not). For constrained type
parameters in type abbreviations, they are injective if either they
appear at an injective position in the body, or if all their type
variables are injective; in particular, if a constrained type
parameter contains a variable that doesnâ€™t appear in the body, it
cannot be injective.</p><p><a id="hevea_manual.kwd99"></a>
The construct  <span class="syntax-token">constraint</span> <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>  allows the
specification of
type parameters. Any actual type argument corresponding to the type
parameter <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> has to be an instance of <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> (more precisely,
<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> and <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> are unified). Type variables of <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> can
appear in the type equation and the type declaration.</p>
<!--TOC subsection id="ss:exndef" 11.8.2â€ƒException definitions-->
<h3 class="subsection" id="ss:exndef"><a class="section-anchor" href="#ss:exndef" aria-hidden="true">ï»¿</a>11.8.2â€ƒException definitions</h3><!--SEC END --><p>
<a id="hevea_manual.kwd100"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="exception-definition"><span class="nonterminal">exception-definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Exception definitions add new constructors to the built-in variant
type <code class="verb">exn</code> of exception values. The constructors are declared as
for a definition of a variant type.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">exception</span> E <span class="ocamlkeyword">of</span> int * string;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">exception</span> E <span class="ocamlkeyword">of</span> int * string</div></div>

</div><p>The form <span class="syntax-token">exception</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
generates a new exception, distinct from all other exceptions in the system.
The form <span class="syntax-token">exception</span> <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
gives an alternate name to an existing exception.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">exception</span> E <span class="ocamlkeyword">of</span> int * string

  <span class="ocamlkeyword">exception</span> F = E

  <span class="ocamlkeyword">let</span> eq =
     E (1, <span class="ocamlstring">"one"</span>) = F (1, <span class="ocamlstring">"one"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">exception</span> E <span class="ocamlkeyword">of</span> int * string
<span class="ocamlkeyword">exception</span> F <span class="ocamlkeyword">of</span> int * string
<span class="ocamlkeyword">val</span> eq : bool = <span class="ocamlkeyword">true</span></div></div>

</div>
<!--TOC section id="s:classes" 11.9â€ƒClasses-->
<h2 class="section" id="s:classes"><a class="section-anchor" href="#s:classes" aria-hidden="true">ï»¿</a>11.9â€ƒClasses</h2><!--SEC END --><!--NAME classes.html-->
<p>
Classes are defined using a small language, similar to the module
language.</p>
<!--TOC subsection id="ss:classes:class-types" 11.9.1â€ƒClass types-->
<h3 class="subsection" id="ss:classes:class-types"><a class="section-anchor" href="#ss:classes:class-types" aria-hidden="true">ï»¿</a>11.9.1â€ƒClass types</h3><!--SEC END --><p>Class types are the class-level equivalent of type expressions: they
specify the general shape and type properties of classes.</p><p><a id="hevea_manual.kwd101"></a>
<a id="hevea_manual.kwd102"></a>
<a id="hevea_manual.kwd103"></a>
<a id="hevea_manual.kwd104"></a>
<a id="hevea_manual.kwd105"></a>
<a id="hevea_manual.kwd106"></a>
<a id="hevea_manual.kwd107"></a>
<a id="hevea_manual.kwd108"></a>
<a id="hevea_manual.kwd109"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-type"><span class="nonterminal">class-type</span></a></td><td class="c005">::=</td><td class="c007">
[[<span class="syntax-token">?</span>]<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>]â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„â€„<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-body-type"><span class="nonterminal">class-body-type</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">object</span>â€„[<span class="syntax-token">(</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">)</span>]â€„{â€„<a class="syntax" href="#class-field-spec"><span class="nonterminal">class-field-spec</span></a>â€„}â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„[<span class="syntax-token">[</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}â€„<span class="syntax-token">]</span>]â€„<a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-field-spec"><span class="nonterminal">class-field-spec</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">inherit</span>â€„<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val</span>â€„[<span class="syntax-token">mutable</span>]â€„[<span class="syntax-token">virtual</span>]â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val</span>â€„<span class="syntax-token">virtual</span>â€„<span class="syntax-token">mutable</span>â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„[<span class="syntax-token">private</span>]â€„[<span class="syntax-token">virtual</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„<span class="syntax-token">virtual</span>â€„<span class="syntax-token">private</span>â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">constraint</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Aattributes">attributes</a> and
<a href="#s%3Aextension-nodes">extension nodes</a>.</p><!--TOC subsubsection id="sss:clty:simple" Simple class expressions-->
<h4 class="subsubsection" id="sss:clty:simple"><a class="section-anchor" href="#sss:clty:simple" aria-hidden="true">ï»¿</a>Simple class expressions</h4><!--SEC END --><p>The expression <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> is equivalent to the class type bound to
the name <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a>. Similarly, the expression
<span class="syntax-token">[</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a> is equivalent to
the parametric class type bound to the name <a class="syntax" href="#classtype-path"><span class="nonterminal">classtype-path</span></a>, in which
type parameters have been instantiated to respectively <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub>,
â€¦<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>.</p><!--TOC subsubsection id="sss:clty-fun" Class function type-->
<h4 class="subsubsection" id="sss:clty-fun"><a class="section-anchor" href="#sss:clty-fun" aria-hidden="true">ï»¿</a>Class function type</h4><!--SEC END --><p>The class type expression <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a> is the type of
class functions (functions from values to classes) that take as
argument a value of type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> and return as result a class of
type <a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>.</p><!--TOC subsubsection id="sss:clty:body" Class body type-->
<h4 class="subsubsection" id="sss:clty:body"><a class="section-anchor" href="#sss:clty:body" aria-hidden="true">ï»¿</a>Class body type</h4><!--SEC END --><p>The class type expression
<span class="syntax-token">object</span> [<span class="syntax-token">(</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>] { <a class="syntax" href="#class-field-spec"><span class="nonterminal">class-field-spec</span></a> } <span class="syntax-token">end</span>
is the type of a class body. It specifies its instance variables and
methods. In this type, <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> is matched against the self type, therefore
providing a name for the self type.</p><p>A class body will match a class body type if it provides definitions
for all the components specified in the class body type, and these
definitions meet the type requirements given in the class body type.
Furthermore, all methods either virtual or public present in the class
body must also be present in the class body type (on the other hand, some
instance variables and concrete private methods may be omitted). A
virtual method will match a concrete method, which makes it possible
to forget its implementation. An immutable instance variable will match a
mutable instance variable.</p><!--TOC subsubsection id="sss:clty-open" Local opens-->
<h4 class="subsubsection" id="sss:clty-open"><a class="section-anchor" href="#sss:clty-open" aria-hidden="true">ï»¿</a>Local opens</h4><!--SEC END --><p>Local opens are supported in class types since OCaml 4.06.</p><!--TOC subsubsection id="sss:clty-inheritance" Inheritance-->
<h4 class="subsubsection" id="sss:clty-inheritance"><a class="section-anchor" href="#sss:clty-inheritance" aria-hidden="true">ï»¿</a>Inheritance</h4><!--SEC END --><p><a id="hevea_manual.kwd110"></a></p><p>The inheritance construct <span class="syntax-token">inherit</span> <a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a> provides for inclusion of
methods and instance variables from other class types.
The instance variable and method types from <a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a> are added
into the current class type.</p><!--TOC subsubsection id="sss:clty-variable" Instance variable specification-->
<h4 class="subsubsection" id="sss:clty-variable"><a class="section-anchor" href="#sss:clty-variable" aria-hidden="true">ï»¿</a>Instance variable specification</h4><!--SEC END --><p><a id="hevea_manual.kwd111"></a>
<a id="hevea_manual.kwd112"></a></p><p>A specification of an instance variable is written
<span class="syntax-token">val</span> [<span class="syntax-token">mutable</span>] [<span class="syntax-token">virtual</span>] <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>, where
<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>
is the name of the instance variable and <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> its expected type.
The flag <span class="syntax-token">mutable</span> indicates whether this instance variable can be
physically modified.
The flag <span class="syntax-token">virtual</span> indicates that this instance variable is not
initialized. It can be initialized later through inheritance.</p><p>An instance variable specification will hide any previous
specification of an instance variable of the same name.</p><!--TOC subsubsection id="sss:clty-meth" Method specification-->
<h4 class="subsubsection" id="sss:clty-meth"><a class="section-anchor" href="#sss:clty-meth" aria-hidden="true">ï»¿</a>Method specification</h4><!--SEC END --><p><a id="hevea_manual.kwd113"></a>
<a id="hevea_manual.kwd114"></a></p><p>The specification of a method is written
<span class="syntax-token">method</span> [<span class="syntax-token">private</span>] <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>, where
<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> is the name of the method and <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a> its
expected type, possibly polymorphic. The flag <span class="syntax-token">private</span> indicates
that the method cannot be accessed from outside the object.</p><p>The polymorphism may be left implicit in public method specifications:
any type variable which is not bound to a class parameter and does not
appear elsewhere inside the class specification will be assumed to be
universal, and made polymorphic in the resulting method type.
Writing an explicit polymorphic type will disable this behaviour.</p><p>If several specifications are present for the same method, they
must have compatible types.
Any non-private specification of a method forces it to be public.</p><!--TOC subsubsection id="sss:class-virtual-meth-spec" Virtual method specification-->
<h4 class="subsubsection" id="sss:class-virtual-meth-spec"><a class="section-anchor" href="#sss:class-virtual-meth-spec" aria-hidden="true">ï»¿</a>Virtual method specification</h4><!--SEC END --><p><a id="hevea_manual.kwd115"></a>
<a id="hevea_manual.kwd116"></a></p><p>A virtual method specification is written <span class="syntax-token">method</span> [<span class="syntax-token">private</span>]
<span class="syntax-token">virtual</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>, where <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> is the
name of the method and <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a> its expected type.</p><!--TOC subsubsection id="sss:class-constraints" Constraints on type parameters-->
<h4 class="subsubsection" id="sss:class-constraints"><a class="section-anchor" href="#sss:class-constraints" aria-hidden="true">ï»¿</a>Constraints on type parameters</h4><!--SEC END --><p><a id="hevea_manual.kwd117"></a></p><p>The construct <span class="syntax-token">constraint</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> forces the two
type expressions to be equal. This is typically used to specify type
parameters: in this way, they can be bound to specific type
expressions.</p>
<!--TOC subsection id="ss:class-expr" 11.9.2â€ƒClass expressions-->
<h3 class="subsection" id="ss:class-expr"><a class="section-anchor" href="#ss:class-expr" aria-hidden="true">ï»¿</a>11.9.2â€ƒClass expressions</h3><!--SEC END --><p>Class expressions are the class-level equivalent of value expressions:
they evaluate to classes, thus providing implementations for the
specifications expressed in class types.</p><p><a id="hevea_manual.kwd118"></a>
<a id="hevea_manual.kwd119"></a>
<a id="hevea_manual.kwd120"></a>
<a id="hevea_manual.kwd121"></a>
<a id="hevea_manual.kwd122"></a>
<a id="hevea_manual.kwd123"></a>
<a id="hevea_manual.kwd124"></a>
<a id="hevea_manual.kwd125"></a>
<a id="hevea_manual.kwd126"></a>
<a id="hevea_manual.kwd127"></a>
<a id="hevea_manual.kwd128"></a>
<a id="hevea_manual.kwd129"></a>
<a id="hevea_manual.kwd130"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-expr"><span class="nonterminal">class-expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">[</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„}â€„<span class="syntax-token">]</span>â€„<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„{â€„<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">fun</span>â€„{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">let</span>â€„[<span class="syntax-token">rec</span>]â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„}â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">object</span>â€„<a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a>â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-field"><span class="nonterminal">class-field</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">inherit</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„[<span class="syntax-token">as</span>â€„<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">inherit!</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„[<span class="syntax-token">as</span>â€„<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val</span>â€„[<span class="syntax-token">mutable</span>]â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val!</span>â€„[<span class="syntax-token">mutable</span>]â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val</span>â€„[<span class="syntax-token">mutable</span>]â€„<span class="syntax-token">virtual</span>â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">val</span>â€„<span class="syntax-token">virtual</span>â€„<span class="syntax-token">mutable</span>â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method!</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method!</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„[<span class="syntax-token">private</span>]â€„<span class="syntax-token">virtual</span>â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">method</span>â€„<span class="syntax-token">virtual</span>â€„<span class="syntax-token">private</span>â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">constraint</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">initializer</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Alocally-abstract">locally abstract types</a>,
<a href="#s%3Aattributes">attributes</a> and
<a href="#s%3Aextension-nodes">extension nodes</a>.</p><!--TOC subsubsection id="sss:class-simple" Simple class expressions-->
<h4 class="subsubsection" id="sss:class-simple"><a class="section-anchor" href="#sss:class-simple" aria-hidden="true">ï»¿</a>Simple class expressions</h4><!--SEC END --><p>The expression <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a> evaluates to the class bound to the name
<a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>. Similarly, the expression
<span class="syntax-token">[</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">,</span> â€¦ <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>
evaluates to the parametric class bound to the name <a class="syntax" href="#class-path"><span class="nonterminal">class-path</span></a>,
in which type parameters have been instantiated respectively to
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub>, â€¦<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> <span class="syntax-token">)</span> evaluates to the same module as
<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a> <span class="syntax-token">)</span> checks that
<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a> matches the type of <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> (that is, that the
implementation <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> meets the type specification
<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>). The whole expression evaluates to the same class as
<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>, except that all components not specified in
<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a> are hidden and can no longer be accessed.</p><!--TOC subsubsection id="sss:class-app" Class application-->
<h4 class="subsubsection" id="sss:class-app"><a class="section-anchor" href="#sss:class-app" aria-hidden="true">ï»¿</a>Class application</h4><!--SEC END --><p>Class application is denoted by juxtaposition of (possibly labeled)
expressions. It denotes the class whose constructor is the first
expression applied to the given arguments. The arguments are
evaluated as for expression application, but the constructor itself will
only be evaluated when objects are created. In particular, side-effects
caused by the application of the constructor will only occur at object
creation time.</p><!--TOC subsubsection id="sss:class-fun" Class function-->
<h4 class="subsubsection" id="sss:class-fun"><a class="section-anchor" href="#sss:class-fun" aria-hidden="true">ï»¿</a>Class function</h4><!--SEC END --><p>The expression <span class="syntax-token">fun</span> [[<span class="syntax-token">?</span>]<a class="syntax" href="#label-name"><span class="nonterminal">label-name</span></a><span class="syntax-token">:</span>]<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> evaluates
to a function from values to classes.
When this function is applied to a value <span class="font-it">v</span>, this value is
matched against the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> and the result is the result of
the evaluation of <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> in the extended environment.</p><p>Conversion from functions with default values to functions with
patterns only works identically for class functions as for normal
functions.</p><p>The expression
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> â€¦ <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</div><p>
is a short form for
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><!--TOC subsubsection id="sss:class-localdefs" Local definitions-->
<h4 class="subsubsection" id="sss:class-localdefs"><a class="section-anchor" href="#sss:class-localdefs" aria-hidden="true">ï»¿</a>Local definitions</h4><!--SEC END --><p>The <span class="font-tt">let</span> and <span class="font-tt">let rec</span> constructs bind value names locally,
as for the core language expressions.</p><p>If a local definition occurs at the very beginning of a class
definition, it will be evaluated when the class is created (just as if
the definition was outside of the class).
Otherwise, it will be evaluated when the object constructor is called.</p><!--TOC subsubsection id="sss:class-opens" Local opens-->
<h4 class="subsubsection" id="sss:class-opens"><a class="section-anchor" href="#sss:class-opens" aria-hidden="true">ï»¿</a>Local opens</h4><!--SEC END --><p>Local opens are supported in class expressions since OCaml 4.06.</p><!--TOC subsubsection id="sss:class-body" Class body-->
<h4 class="subsubsection" id="sss:class-body"><a class="section-anchor" href="#sss:class-body" aria-hidden="true">ï»¿</a>Class body</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-body"><span class="nonterminal">class-body</span></a></td><td class="c005">::=</td><td class="c007">â€„â€„[<span class="syntax-token">(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>]â€„<span class="syntax-token">)</span>]â€„{â€„<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a>â€„}
</td></tr>
</table></td></tr>
</table></div><p>
The expression
<span class="syntax-token">object</span> <a class="syntax" href="#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span> denotes
a class body. This is the prototype for an object : it lists the
instance variables and methods of an object of this class.</p><p>A class body is a class value: it is not evaluated at once. Rather,
its components are evaluated each time an object is created.</p><p>In a class body, the pattern <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>] <span class="syntax-token">)</span> is
matched against self, therefore providing a binding for self and self
type. Self can only be used in method and initializers.</p><p>Self type cannot be a closed object type, so that the class remains
extensible.</p><p>Since OCaml 4.01, it is an error if the same method or instance
variable name is defined several times in the same class body.</p><!--TOC subsubsection id="sss:class-inheritance" Inheritance-->
<h4 class="subsubsection" id="sss:class-inheritance"><a class="section-anchor" href="#sss:class-inheritance" aria-hidden="true">ï»¿</a>Inheritance</h4><!--SEC END --><p><a id="hevea_manual.kwd131"></a></p><p>The inheritance construct <span class="syntax-token">inherit</span> <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> allows reusing
methods and instance variables from other classes. The class
expression <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> must evaluate to a class body. The instance
variables, methods and initializers from this class body are added
into the current class. The addition of a method will override any
previously defined method of the same name.</p><p><a id="hevea_manual.kwd132"></a>
An ancestor can be bound by appending <span class="syntax-token">as</span> <a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
to the inheritance construct. <a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a> is not a true
variable and can only be used to select a method, i.e. in an expression
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a> <span class="syntax-token">#</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>. This gives access to the
method <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> as it was defined in the parent class even if it is
redefined in the current class.
The scope of this ancestor binding is limited to the current class.
The ancestor method may be called from a subclass but only indirectly.</p><!--TOC subsubsection id="sss:class-variables" Instance variable definition-->
<h4 class="subsubsection" id="sss:class-variables"><a class="section-anchor" href="#sss:class-variables" aria-hidden="true">ï»¿</a>Instance variable definition</h4><!--SEC END --><p><a id="hevea_manual.kwd133"></a>
<a id="hevea_manual.kwd134"></a></p><p>The definition <span class="syntax-token">val</span> [<span class="syntax-token">mutable</span>] <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> adds an
instance variable <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> whose initial value is the value of
expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.
The flag <span class="syntax-token">mutable</span> allows physical modification of this variable by
methods.</p><p>An instance variable can only be used in the methods and
initializers that follow its definition.</p><p>Since version 3.10, redefinitions of a visible instance variable with
the same name do not create a new variable, but are merged, using the
last value for initialization. They must have identical types and
mutability.
However, if an instance variable is hidden by
omitting it from an interface, it will be kept distinct from
other instance variables with the same name.</p><!--TOC subsubsection id="sss:class-virtual-variable" Virtual instance variable definition-->
<h4 class="subsubsection" id="sss:class-virtual-variable"><a class="section-anchor" href="#sss:class-virtual-variable" aria-hidden="true">ï»¿</a>Virtual instance variable definition</h4><!--SEC END --><p><a id="hevea_manual.kwd135"></a>
<a id="hevea_manual.kwd136"></a></p><p>A variable specification is written <span class="syntax-token">val</span> [<span class="syntax-token">mutable</span>] <span class="syntax-token">virtual</span>
<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>. It specifies whether the variable is
modifiable, and gives its type.</p><p>Virtual instance variables were added in version 3.10.</p><!--TOC subsubsection id="sss:class-method" Method definition-->
<h4 class="subsubsection" id="sss:class-method"><a class="section-anchor" href="#sss:class-method" aria-hidden="true">ï»¿</a>Method definition</h4><!--SEC END --><p><a id="hevea_manual.kwd137"></a>
<a id="hevea_manual.kwd138"></a></p><p>A method definition is written <span class="syntax-token">method</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. The
definition of a method overrides any previous definition of this
method. The method will be public (that is, not private) if any of
the definition states so.</p><p>A private method, <span class="syntax-token">method</span> <span class="syntax-token">private</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, is a
method that can only be invoked on self (from other methods of the
same object, defined in this class or one of its subclasses). This
invocation is performed using the expression
<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">#</span> <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>, where <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> is directly bound to
self at the beginning of the class definition. Private methods do
not appear in object types. A method may have both public and private
definitions, but as soon as there is a public one, all subsequent
definitions will be made public.</p><p>Methods may have an explicitly polymorphic type, allowing them to be
used polymorphically in programs (even for the same object). The
explicit declaration may be done in one of three ways: (1) by giving an
explicit polymorphic type in the method definition, immediately after
the method name, <em>i.e.</em>
<span class="syntax-token">method</span> [<span class="syntax-token">private</span>] <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">:</span> { <span class="syntax-token">'</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> }<sup>+</sup> <span class="syntax-token">.</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>; (2) by a forward declaration of the explicit polymorphic type
through a virtual method definition; (3) by importing such a
declaration through inheritance and/or constraining the type of <em>self</em>.</p><p>Some special expressions are available in method bodies for
manipulating instance variables and duplicating self:
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
â€¦
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">{&lt;</span>â€„[â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}â€„[<span class="syntax-token">;</span>]â€„]â€„<span class="syntax-token">&gt;}</span>
</td></tr>
</table></td></tr>
</table></div><p>The expression <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> modifies in-place the current
object by replacing the value associated to <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> by the
value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Of course, this instance variable must have been
declared mutable.</p><p>The expression
<span class="syntax-token">{&lt;</span> <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">&gt;}</span>
evaluates to a copy of the current object in which the values of
instance variables <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a><sub>1</sub>, â€¦, <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a><sub><span class="font-it">n</span></sub> have
been replaced by the values of the corresponding expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>,
â€¦, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><!--TOC subsubsection id="sss:class-virtual-meth" Virtual method definition-->
<h4 class="subsubsection" id="sss:class-virtual-meth"><a class="section-anchor" href="#sss:class-virtual-meth" aria-hidden="true">ï»¿</a>Virtual method definition</h4><!--SEC END --><p><a id="hevea_manual.kwd139"></a>
<a id="hevea_manual.kwd140"></a></p><p>A method specification is written <span class="syntax-token">method</span> [<span class="syntax-token">private</span>] <span class="syntax-token">virtual</span>
<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>. It specifies whether the method is
public or private, and gives its type. If the method is intended to be
polymorphic, the type must be explicitly polymorphic.</p><!--TOC subsubsection id="sss:class-explicit-overriding" Explicit overriding-->
<h4 class="subsubsection" id="sss:class-explicit-overriding"><a class="section-anchor" href="#sss:class-explicit-overriding" aria-hidden="true">ï»¿</a>Explicit overriding</h4><!--SEC END --><p>Since Ocaml 3.12, the keywords <span class="syntax-token">inherit!</span>, <span class="syntax-token">val!</span> and <span class="syntax-token">method!</span>
have the same semantics as <span class="syntax-token">inherit</span>, <span class="syntax-token">val</span> and <span class="syntax-token">method</span>, but
they additionally require the definition they introduce to be
overriding. Namely, <span class="syntax-token">method!</span> requires <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> to be already
defined in this class, <span class="syntax-token">val!</span> requires <a class="syntax" href="#inst-var-name"><span class="nonterminal">inst-var-name</span></a> to be already
defined in this class, and <span class="syntax-token">inherit!</span> requires <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a> to
override some definitions. If no such overriding occurs, an error is
signaled.</p><p>As a side-effect, these 3 keywords avoid the warningsÂ 7
(method override) andÂ 13 (instance variable override).
Note that warningÂ 7 is disabled by default.</p><!--TOC subsubsection id="sss:class-type-constraints" Constraints on type parameters-->
<h4 class="subsubsection" id="sss:class-type-constraints"><a class="section-anchor" href="#sss:class-type-constraints" aria-hidden="true">ï»¿</a>Constraints on type parameters</h4><!--SEC END --><p><a id="hevea_manual.kwd141"></a>
The construct <span class="syntax-token">constraint</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> forces the two
type expressions to be equals. This is typically used to specify type
parameters: in that way they can be bound to specific type
expressions.</p><!--TOC subsubsection id="sss:class-initializers" Initializers-->
<h4 class="subsubsection" id="sss:class-initializers"><a class="section-anchor" href="#sss:class-initializers" aria-hidden="true">ï»¿</a>Initializers</h4><!--SEC END --><p><a id="hevea_manual.kwd142"></a></p><p>A class initializer <span class="syntax-token">initializer</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> specifies an expression that
will be evaluated whenever an object is created from the class, once
all its instance variables have been initialized.</p>
<!--TOC subsection id="ss:class-def" 11.9.3â€ƒClass definitions-->
<h3 class="subsection" id="ss:class-def"><a class="section-anchor" href="#ss:class-def" aria-hidden="true">ï»¿</a>11.9.3â€ƒClass definitions</h3><!--SEC END --><p>
<a id="s:classdef"></a></p><p><a id="hevea_manual.kwd143"></a>
<a id="hevea_manual.kwd144"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-definition"><span class="nonterminal">class-definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">class</span>â€„<a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-binding"><span class="nonterminal">class-binding</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">virtual</span>]â€„[<span class="syntax-token">[</span>â€„<a class="syntax" href="#type-parameters"><span class="nonterminal">type-parameters</span></a>â€„<span class="syntax-token">]</span>]â€„<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>
{â€„<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a>â€„}â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>]â€„â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-parameters"><span class="nonterminal">type-parameters</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<span class="syntax-token">'</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>â€„}
</td></tr>
</table></td></tr>
</table></div><p>A class definition <span class="syntax-token">class</span> <a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a> } is
recursive. Each <a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a> defines a <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> that can be
used in the whole expression except for inheritance. It can also be
used for inheritance, but only in the definitions that follow its own.</p><p>A class binding binds the class name <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> to the value of
expression <a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>. It also binds the class type <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> to
the type of the class, and defines two type abbreviations :
<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> and <span class="syntax-token">#</span> <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>. The first one is the type of
objects of this class, while the second is more general as it unifies
with the type of any object belonging to a subclass (see
sectionÂ <a href="#sss%3Atypexpr-sharp-types">11.4</a>).</p><!--TOC subsubsection id="sss:class-virtual" Virtual class-->
<h4 class="subsubsection" id="sss:class-virtual"><a class="section-anchor" href="#sss:class-virtual" aria-hidden="true">ï»¿</a>Virtual class</h4><!--SEC END --><p>A class must be flagged virtual if one of its methods is virtual (that
is, appears in the class type, but is not actually defined).
Objects cannot be created from a virtual class.</p><!--TOC subsubsection id="sss:class-type-params" Type parameters-->
<h4 class="subsubsection" id="sss:class-type-params"><a class="section-anchor" href="#sss:class-type-params" aria-hidden="true">ï»¿</a>Type parameters</h4><!--SEC END --><p>The class type parameters correspond to the ones of the class type and
of the two type abbreviations defined by the class binding. They must
be bound to actual types in the class definition using type
constraints. So that the abbreviations are well-formed, type
variables of the inferred type of the class must either be type
parameters or be bound in the constraint clause.</p>
<!--TOC subsection id="ss:class-spec" 11.9.4â€ƒClass specifications-->
<h3 class="subsection" id="ss:class-spec"><a class="section-anchor" href="#ss:class-spec" aria-hidden="true">ï»¿</a>11.9.4â€ƒClass specifications</h3><!--SEC END --><p><a id="hevea_manual.kwd145"></a>
<a id="hevea_manual.kwd146"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="class-specification"><span class="nonterminal">class-specification</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">class</span>â€„<a class="syntax" href="#class-spec"><span class="nonterminal">class-spec</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#class-spec"><span class="nonterminal">class-spec</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="class-spec"><span class="nonterminal">class-spec</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">virtual</span>]â€„[<span class="syntax-token">[</span>â€„<a class="syntax" href="#type-parameters"><span class="nonterminal">type-parameters</span></a>â€„<span class="syntax-token">]</span>]â€„<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>â€„<span class="syntax-token">:</span>
<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>
</td></tr>
</table></td></tr>
</table></div><p>This is the counterpart in signatures of class definitions.
A class specification matches a class definition if they have the same
type parameters and their types match.</p>
<!--TOC subsection id="ss:classtype" 11.9.5â€ƒClass type definitions-->
<h3 class="subsection" id="ss:classtype"><a class="section-anchor" href="#ss:classtype" aria-hidden="true">ï»¿</a>11.9.5â€ƒClass type definitions</h3><!--SEC END --><p><a id="hevea_manual.kwd147"></a>
<a id="hevea_manual.kwd148"></a>
<a id="hevea_manual.kwd149"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="classtype-definition"><span class="nonterminal">classtype-definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">class</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a>
{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="classtype-def"><span class="nonterminal">classtype-def</span></a></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">virtual</span>]â€„[<span class="syntax-token">[</span>â€„<a class="syntax" href="#type-parameters"><span class="nonterminal">type-parameters</span></a>â€„<span class="syntax-token">]</span>]â€„<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
</td></tr>
</table></td></tr>
</table></div><p>A class type definition <span class="syntax-token">class</span> <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
defines an abbreviation <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> for the class body type
<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>. As for class definitions, two type abbreviations
<a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> and <span class="syntax-token">#</span> <a class="syntax" href="#class-name"><span class="nonterminal">class-name</span></a> are also defined. The definition can
be parameterized by some type parameters. If any method in the class
type body is virtual, the definition must be flagged <span class="syntax-token">virtual</span>.</p><p>Two class type definitions match if they have the same type parameters
and they expand to matching types.

</p>
<!--TOC section id="s:modtypes" 11.10â€ƒModule types (module specifications)-->
<h2 class="section" id="s:modtypes"><a class="section-anchor" href="#s:modtypes" aria-hidden="true">ï»¿</a>11.10â€ƒModule types (module specifications)</h2><!--SEC END --><!--NAME modtypes.html-->
<p>Module types are the module-level equivalent of type expressions: they
specify the general shape and type properties of modules.</p><p><a id="hevea_manual.kwd150"></a>
<a id="hevea_manual.kwd151"></a>
<a id="hevea_manual.kwd152"></a>
<a id="hevea_manual.kwd153"></a>
<a id="hevea_manual.kwd154"></a>
<a id="hevea_manual.kwd155"></a>
<a id="hevea_manual.kwd156"></a>
<a id="hevea_manual.kwd157"></a>
<a id="hevea_manual.kwd158"></a>
<a id="hevea_manual.kwd159"></a>
<a id="hevea_manual.kwd160"></a>
<a id="hevea_manual.kwd161"></a>
<a id="hevea_manual.kwd162"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="module-type"><span class="nonterminal">module-type</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">sig</span>â€„{â€„<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a>â€„[<span class="syntax-token">;;</span>]â€„}â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">functor</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">with</span>â€„<a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="mod-constraint"><span class="nonterminal">mod-constraint</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">type</span>â€„[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>â€„<a class="syntax" href="#type-equation"><span class="nonterminal">type-equation</span></a>â€„{â€„<a class="syntax" href="#type-constraint"><span class="nonterminal">type-constraint</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">val</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">external</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#type-definition"><span class="nonterminal">type-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-specification"><span class="nonterminal">class-specification</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#classtype-definition"><span class="nonterminal">classtype-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„}
<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">include</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Amodule-type-of">recovering the type of a module</a>,
<a href="#s%3Asignature-substitution">substitution inside a signature</a>,
<a href="#s%3Amodule-alias">type-level module aliases</a>,
<a href="#s%3Aattributes">attributes</a>,
<a href="#s%3Aextension-nodes">extension nodes</a>,
<a href="#s%3Agenerative-functors">generative functors</a>,
and <a href="#ss%3Amodule-type-substitution">module type substitutions</a>.</p>
<!--TOC subsection id="ss:mty-simple" 11.10.1â€ƒSimple module types-->
<h3 class="subsection" id="ss:mty-simple"><a class="section-anchor" href="#ss:mty-simple" aria-hidden="true">ï»¿</a>11.10.1â€ƒSimple module types</h3><!--SEC END --><p>The expression <a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a> is equivalent to the module type bound
to the name <a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>.
The expression <span class="syntax-token">(</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> denotes the same type as
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>.</p>
<!--TOC subsection id="ss:mty-signatures" 11.10.2â€ƒSignatures-->
<h3 class="subsection" id="ss:mty-signatures"><a class="section-anchor" href="#ss:mty-signatures" aria-hidden="true">ï»¿</a>11.10.2â€ƒSignatures</h3><!--SEC END --><p><a id="hevea_manual.kwd163"></a>
<a id="hevea_manual.kwd164"></a></p><p>Signatures are type specifications for structures. Signatures
<span class="syntax-token">sig</span> â€¦ <span class="syntax-token">end</span> are collections of type specifications for value
names, type names, exceptions, module names and module type names. A
structure will match a signature if the structure provides definitions
(implementations) for all the names specified in the signature (and
possibly more), and these definitions meet the type requirements given
in the signature.</p><p>An optional <span class="syntax-token">;;</span> is allowed after each specification in a
signature. It serves as a syntactic separator with no semantic
meaning.</p><!--TOC subsubsection id="sss:mty-values" Value specifications-->
<h4 class="subsubsection" id="sss:mty-values"><a class="section-anchor" href="#sss:mty-values" aria-hidden="true">ï»¿</a>Value specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd165"></a></p><p>A specification of a value component in a signature is written
<span class="syntax-token">val</span> <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>, where <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> is the name of the
value and <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> its expected type.</p><p><a id="hevea_manual.kwd166"></a></p><p>The form <span class="syntax-token">external</span> <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
is similar, except that it requires in addition the name to be
implemented as the external function specified in <a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
(see chapterÂ <a href="#c%3Aintf-c">22</a>).</p><!--TOC subsubsection id="sss:mty-type" Type specifications-->
<h4 class="subsubsection" id="sss:mty-type"><a class="section-anchor" href="#sss:mty-type" aria-hidden="true">ï»¿</a>Type specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd167"></a></p><p>A specification of one or several type components in a signature is
written <span class="syntax-token">type</span> <a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a> } and consists of a sequence
of mutually recursive definitions of type names.</p><p>Each type definition in the signature specifies an optional type
equation <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> and an optional type representation
<span class="syntax-token">=</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a> â€¦ or <span class="syntax-token">=</span> <span class="syntax-token">{</span> <a class="syntax" href="#field-decl"><span class="nonterminal">field-decl</span></a> â€¦ <span class="syntax-token">}</span>.
The implementation of the type name in a matching structure must
be compatible with the type expression specified in the equation (if
given), and have the specified representation (if given). Conversely,
users of that signature will be able to rely on the type equation
or type representation, if given. More precisely, we have the
following four situations:</p><dl class="description"><dt class="dt-description"><span class="font-bold">Abstract type: no equation, no representation.</span></dt><dd class="dd-description"> Â  <br>
Names that are defined as abstract types in a signature can be
implemented in a matching structure by any kind of type definition
(provided it has the same number of type parameters). The exact
implementation of the type will be hidden to the users of the
structure. In particular, if the type is implemented as a variant type
or record type, the associated constructors and fields will not be
accessible to the users; if the type is implemented as an
abbreviation, the type equality between the type name and the
right-hand side of the abbreviation will be hidden from the users of the
structure. Users of the structure consider that type as incompatible
with any other type: a fresh type has been generated.</dd><dt class="dt-description"><span class="font-bold">Type abbreviation: an equation </span><span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><span class="font-bold">, no representation.</span></dt><dd class="dd-description"> Â  <br>
The type name must be implemented by a type compatible with <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.
All users of the structure know that the type name is
compatible with <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.</dd><dt class="dt-description"><span class="font-bold">New variant type or record type: no equation, a representation.</span></dt><dd class="dd-description"> Â  <br>
The type name must be implemented by a variant type or record type
with exactly the constructors or fields specified. All users of the
structure have access to the constructors or fields, and can use them
to create or inspect values of that type. However, users of the
structure consider that type as incompatible with any other type: a
fresh type has been generated.</dd><dt class="dt-description"><span class="font-bold">Re-exported variant type or record type: an equation,
a representation.</span></dt><dd class="dd-description"> Â  <br>
This case combines the previous two: the representation of the type is
made visible to all users, and no fresh type is generated.
</dd></dl><!--TOC subsubsection id="sss:mty-exn" Exception specification-->
<h4 class="subsubsection" id="sss:mty-exn"><a class="section-anchor" href="#sss:mty-exn" aria-hidden="true">ï»¿</a>Exception specification</h4><!--SEC END --><p><a id="hevea_manual.kwd168"></a></p><p>The specification <span class="syntax-token">exception</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a> in a signature requires the
matching structure to provide an exception with the name and arguments
specified in the definition, and makes the exception available to all
users of the structure.</p><!--TOC subsubsection id="sss:mty-class" Class specifications-->
<h4 class="subsubsection" id="sss:mty-class"><a class="section-anchor" href="#sss:mty-class" aria-hidden="true">ï»¿</a>Class specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd169"></a></p><p>A specification of one or several classes in a signature is written
<span class="syntax-token">class</span> <a class="syntax" href="#class-spec"><span class="nonterminal">class-spec</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#class-spec"><span class="nonterminal">class-spec</span></a> } and consists of a sequence
of mutually recursive definitions of class names.</p><p>Class specifications are described more precisely in
sectionÂ <a href="#ss%3Aclass-spec">11.9.4</a>.</p><!--TOC subsubsection id="sss:mty-classtype" Class type specifications-->
<h4 class="subsubsection" id="sss:mty-classtype"><a class="section-anchor" href="#sss:mty-classtype" aria-hidden="true">ï»¿</a>Class type specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd170"></a>
<a id="hevea_manual.kwd171"></a></p><p>A specification of one or several class types in a signature is
written <span class="syntax-token">class</span> <span class="syntax-token">type</span> <a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a> } and
consists of a sequence of mutually recursive definitions of class type
names. Class type specifications are described more precisely in
sectionÂ <a href="#ss%3Aclasstype">11.9.5</a>.</p><!--TOC subsubsection id="sss:mty-module" Module specifications-->
<h4 class="subsubsection" id="sss:mty-module"><a class="section-anchor" href="#sss:mty-module" aria-hidden="true">ï»¿</a>Module specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd172"></a></p><p>A specification of a module component in a signature is written
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>, where <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> is the
name of the module component and <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> its expected type.
Modules can be nested arbitrarily; in particular, functors can appear
as components of structures and functor types as components of
signatures.</p><p>For specifying a module component that is a functor, one may write
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span>
â€¦ <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span>
<span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</div><p>
instead of
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> â€¦
<span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</div><!--TOC subsubsection id="sss:mty-mty" Module type specifications-->
<h4 class="subsubsection" id="sss:mty-mty"><a class="section-anchor" href="#sss:mty-mty" aria-hidden="true">ï»¿</a>Module type specifications</h4><!--SEC END --><p><a id="hevea_manual.kwd173"></a>
<a id="hevea_manual.kwd174"></a></p><p>A module type component of a signature can be specified either as a
manifest module type or as an abstract module type.</p><p>An abstract module type specification
<span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> allows the name <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> to be
implemented by any module type in a matching signature, but hides the
implementation of the module type to all users of the signature.</p><p>A manifest module type specification
<span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
requires the name <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> to be implemented by the module type
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> in a matching signature, but makes the equality between
<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> and <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> apparent to all users of the signature.</p>
<!--TOC subsubsection id="sss:mty-open" Opening a module path-->
<h4 class="subsubsection" id="sss:mty-open"><a class="section-anchor" href="#sss:mty-open" aria-hidden="true">ï»¿</a>Opening a module path</h4><!--SEC END --><p><a id="hevea_manual.kwd175"></a></p><p>The expression <span class="syntax-token">open</span> <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> in a signature does not specify
any components. It simply affects the parsing of the following items
of the signature, allowing components of the module denoted by
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> to be referred to by their simple names <span class="nonterminal">name</span> instead of
path accesses <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <span class="nonterminal">name</span>. The scope of the <span class="syntax-token">open</span>
stops at the end of the signature expression.</p>
<!--TOC subsubsection id="sss:mty-include" Including a signature-->
<h4 class="subsubsection" id="sss:mty-include"><a class="section-anchor" href="#sss:mty-include" aria-hidden="true">ï»¿</a>Including a signature</h4><!--SEC END --><p><a id="hevea_manual.kwd176"></a></p><p>The expression <span class="syntax-token">include</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> in a signature performs textual
inclusion of the components of the signature denoted by <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>.
It behaves as if the components of the included signature were copied
at the location of the <span class="syntax-token">include</span>. The <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> argument must
refer to a module type that is a signature, not a functor type.</p>
<!--TOC subsection id="ss:mty-functors" 11.10.3â€ƒFunctor types-->
<h3 class="subsection" id="ss:mty-functors"><a class="section-anchor" href="#ss:mty-functors" aria-hidden="true">ï»¿</a>11.10.3â€ƒFunctor types</h3><!--SEC END --><p><a id="hevea_manual.kwd177"></a></p><p>The module type expression
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>2</sub>
is the type of functors (functions from modules to modules) that take
as argument a module of type <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> and return as result a
module of type <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>2</sub>. The module type <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>2</sub> can
use the name <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> to refer to type components of the actual
argument of the functor. If the type <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>2</sub> does not
depend on type components of <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>, the module type expression
can be simplified with the alternative short syntax
 <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>2</sub> .
No restrictions are placed on the type of the functor argument; in
particular, a functor may take another functor as argument
(â€œhigher-orderâ€ functor).</p><p>When the result module type is itself a functor,
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">-&gt;</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</div><p>
one may use the abbreviated form
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> â€¦
<span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</div>
<!--TOC subsection id="ss:mty-with" 11.10.4â€ƒThe <span class="machine"><span class="font-tt">with</span></span> operator-->
<h3 class="subsection" id="ss:mty-with"><a class="section-anchor" href="#ss:mty-with" aria-hidden="true">ï»¿</a>11.10.4â€ƒThe <span class="machine"><span class="font-tt">with</span></span> operator</h3><!--SEC END --><p><a id="hevea_manual.kwd178"></a></p><p>Assuming <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> denotes a signature, the expression
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">with</span> <a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a> } denotes
the same signature where type equations have been added to some of the
type specifications, as described by the constraints following the
<span class="machine"><span class="font-tt">with</span></span> keyword. The constraint <span class="syntax-token">type</span> [<a class="syntax" href="#type-parameters"><span class="nonterminal">type-parameters</span></a>] <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>
<span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> adds the type equation <span class="syntax-token">=</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> to the specification
of the type component named <a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a> of the constrained signature.
The constraint <span class="syntax-token">module</span> <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a> adds
type equations to all type components of the sub-structure denoted by
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>, making them equivalent to the corresponding type
components of the structure denoted by <a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>.</p><p>For instance, if the module type name <span class="machine"><span class="font-tt">S</span></span> is bound to the signature
</p><pre>        sig type t module M: (sig type u end) end
</pre><p>then <span class="machine"><span class="font-tt">S with type t=int</span></span> denotes the signature
</p><pre>        sig type t=int module M: (sig type u end) end
</pre><p>and <span class="machine"><span class="font-tt">S with module M = N</span></span> denotes the signature
</p><pre>        sig type t module M: (sig type u=N.u end) end
</pre><p>A functor taking two arguments of type <span class="machine"><span class="font-tt">S</span></span> that share their <span class="machine"><span class="font-tt">t</span></span> component
is written
</p><pre>        functor (A: S) (B: S with type t = A.t) ...
</pre><p>
Constraints are added left to right. After each constraint has been
applied, the resulting signature must be a subtype of the signature
before the constraint was applied. Thus, the <span class="syntax-token">with</span> operator can
only add information on the type components of a signature, but never
remove information.

</p>
<!--TOC section id="s:module-expr" 11.11â€ƒModule expressions (module implementations)-->
<h2 class="section" id="s:module-expr"><a class="section-anchor" href="#s:module-expr" aria-hidden="true">ï»¿</a>11.11â€ƒModule expressions (module implementations)</h2><!--SEC END --><!--NAME modules.html-->
<p>Module expressions are the module-level equivalent of value
expressions: they evaluate to modules, thus providing implementations
for the specifications expressed in module types.</p><p><a id="hevea_manual.kwd179"></a>
<a id="hevea_manual.kwd180"></a>
<a id="hevea_manual.kwd181"></a>
<a id="hevea_manual.kwd182"></a>
<a id="hevea_manual.kwd183"></a>
<a id="hevea_manual.kwd184"></a>
<a id="hevea_manual.kwd185"></a>
<a id="hevea_manual.kwd186"></a>
<a id="hevea_manual.kwd187"></a>
<a id="hevea_manual.kwd188"></a>
<a id="hevea_manual.kwd189"></a>
<a id="hevea_manual.kwd190"></a></p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">struct</span>â€„[â€„<a class="syntax" href="#module-items"><span class="nonterminal">module-items</span></a>â€„]â€„<span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">functor</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="module-items"><span class="nonterminal">module-items</span></a></td><td class="c005">::=</td><td class="c007">
{â€„<span class="syntax-token">;;</span>â€„}â€„(â€„<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a>â€„âˆ£â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„)â€„{â€„{â€„<span class="syntax-token">;;</span>â€„}â€„(â€„<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a>â€„âˆ£â€„<span class="syntax-token">;;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>)â€„}â€„{â€„<span class="syntax-token">;;</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">let</span>â€„[<span class="syntax-token">rec</span>]â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">external</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#type-definition"><span class="nonterminal">type-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#exception-definition"><span class="nonterminal">exception-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-definition"><span class="nonterminal">class-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#classtype-definition"><span class="nonterminal">classtype-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„}
[â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„]â€„â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">include</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>
See also the following language extensions:
<a href="#s%3Arecursive-modules">recursive modules</a>,
<a href="#s%3Afirst-class-modules">first-class modules</a>,
<a href="#s%3Aexplicit-overriding-open">overriding in open statements</a>,
<a href="#s%3Aattributes">attributes</a>,
<a href="#s%3Aextension-nodes">extension nodes</a> and
<a href="#s%3Agenerative-functors">generative functors</a>.</p>
<!--TOC subsection id="ss:mexpr-simple" 11.11.1â€ƒSimple module expressions-->
<h3 class="subsection" id="ss:mexpr-simple"><a class="section-anchor" href="#ss:mexpr-simple" aria-hidden="true">ï»¿</a>11.11.1â€ƒSimple module expressions</h3><!--SEC END --><p>The expression <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> evaluates to the module bound to the name
<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">)</span> evaluates to the same module as
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>.</p><p>The expression <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> checks that the
type of <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> is a subtype of <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>, that is, that all
components specified in <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> are implemented in
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, and their implementation meets the requirements given
in <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>. In other terms, it checks that the implementation
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> meets the type specification <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>. The whole
expression evaluates to the same module as <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, except that
all components not specified in <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> are hidden and can no
longer be accessed.</p>
<!--TOC subsection id="ss:mexpr-structures" 11.11.2â€ƒStructures-->
<h3 class="subsection" id="ss:mexpr-structures"><a class="section-anchor" href="#ss:mexpr-structures" aria-hidden="true">ï»¿</a>11.11.2â€ƒStructures</h3><!--SEC END --><p><a id="hevea_manual.kwd191"></a>
<a id="hevea_manual.kwd192"></a></p><p>Structures <span class="syntax-token">struct</span> â€¦ <span class="syntax-token">end</span> are collections of definitions for
value names, type names, exceptions, module names and module type
names. The definitions are evaluated in the order in which they appear
in the structure. The scopes of the bindings performed by the
definitions extend to the end of the structure. As a consequence, a
definition may refer to names bound by earlier definitions in the same
structure.</p><p>For compatibility with toplevel phrases (chapterÂ <a href="#c%3Acamllight">14</a>),
optional <span class="syntax-token">;;</span> are allowed after and before each definition in a structure. These
<span class="syntax-token">;;</span> have no semantic meanings. Similarly, an <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> preceded by <span class="machine"><span class="font-tt">;;</span></span> is allowed as
a component of a structure. It is equivalent to <span class="syntax-token">let</span> <span class="syntax-token">_</span> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, i.e. <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
evaluated for its side-effects but is not bound to any identifier. If <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
the first component of a structure, the preceding <span class="machine"><span class="font-tt">;;</span></span> can be omitted.</p><!--TOC subsubsection id="sss:mexpr-value-defs" Value definitions-->
<h4 class="subsubsection" id="sss:mexpr-value-defs"><a class="section-anchor" href="#sss:mexpr-value-defs" aria-hidden="true">ï»¿</a>Value definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd193"></a></p><p>A value definition <span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a> }
bind value names in the same way as a <span class="syntax-token">let</span> â€¦ <span class="syntax-token">in</span> â€¦ expression
(see sectionÂ <a href="#sss%3Aexpr-localdef">11.7.2</a>). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values
in the right-hand sides.</p><p><a id="hevea_manual.kwd194"></a></p><p>A value definition <span class="syntax-token">external</span> <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
implements <a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a> as the external function specified in
<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a> (see chapterÂ <a href="#c%3Aintf-c">22</a>).</p><!--TOC subsubsection id="sss:mexpr-type-defs" Type definitions-->
<h4 class="subsubsection" id="sss:mexpr-type-defs"><a class="section-anchor" href="#sss:mexpr-type-defs" aria-hidden="true">ï»¿</a>Type definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd195"></a></p><p>A definition of one or several type components is written
<span class="syntax-token">type</span> <a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a> } and consists of a sequence
of mutually recursive definitions of type names.</p><!--TOC subsubsection id="sss:mexpr-exn-defs" Exception definitions-->
<h4 class="subsubsection" id="sss:mexpr-exn-defs"><a class="section-anchor" href="#sss:mexpr-exn-defs" aria-hidden="true">ï»¿</a>Exception definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd196"></a></p><p>Exceptions are defined with the syntax <span class="syntax-token">exception</span> <a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
or <span class="syntax-token">exception</span> <a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>.</p><!--TOC subsubsection id="sss:mexpr-class-defs" Class definitions-->
<h4 class="subsubsection" id="sss:mexpr-class-defs"><a class="section-anchor" href="#sss:mexpr-class-defs" aria-hidden="true">ï»¿</a>Class definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd197"></a></p><p>A definition of one or several classes is written <span class="syntax-token">class</span>
<a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a> } and consists of a sequence of
mutually recursive definitions of class names. Class definitions are
described more precisely in sectionÂ <a href="#ss%3Aclass-def">11.9.3</a>.</p><!--TOC subsubsection id="sss:mexpr-classtype-defs" Class type definitions-->
<h4 class="subsubsection" id="sss:mexpr-classtype-defs"><a class="section-anchor" href="#sss:mexpr-classtype-defs" aria-hidden="true">ï»¿</a>Class type definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd198"></a>
<a id="hevea_manual.kwd199"></a></p><p>A definition of one or several classes is written
<span class="syntax-token">class</span> <span class="syntax-token">type</span> <a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a> } and consists of
a sequence of mutually recursive definitions of class type names.
Class type definitions are described more precisely in
sectionÂ <a href="#ss%3Aclasstype">11.9.5</a>.</p><!--TOC subsubsection id="sss:mexpr-module-defs" Module definitions-->
<h4 class="subsubsection" id="sss:mexpr-module-defs"><a class="section-anchor" href="#sss:mexpr-module-defs" aria-hidden="true">ï»¿</a>Module definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd200"></a></p><p>The basic form for defining a module component is
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>, which evaluates <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> and binds
the result to the name <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>.</p><p>One can write
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
instead of
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span>.
</div><p>
Another derived form is
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> â€¦
<span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
which is equivalent to
</p><div class="center">
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> â€¦
<span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><!--TOC subsubsection id="sss:mexpr-modtype-defs" Module type definitions-->
<h4 class="subsubsection" id="sss:mexpr-modtype-defs"><a class="section-anchor" href="#sss:mexpr-modtype-defs" aria-hidden="true">ï»¿</a>Module type definitions</h4><!--SEC END --><p><a id="hevea_manual.kwd201"></a>
<a id="hevea_manual.kwd202"></a></p><p>A definition for a module type is written
<span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>.
It binds the name <a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a> to the module type denoted by the
expression <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>.</p><!--TOC subsubsection id="sss:mexpr-open" Opening a module path-->
<h4 class="subsubsection" id="sss:mexpr-open"><a class="section-anchor" href="#sss:mexpr-open" aria-hidden="true">ï»¿</a>Opening a module path</h4><!--SEC END --><p><a id="hevea_manual.kwd203"></a></p><p>The expression <span class="syntax-token">open</span> <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> in a structure does not define any
components nor perform any bindings. It simply affects the parsing of
the following items of the structure, allowing components of the
module denoted by <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> to be referred to by their simple names
<span class="nonterminal">name</span> instead of path accesses <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <span class="nonterminal">name</span>. The scope of
the <span class="syntax-token">open</span> stops at the end of the structure expression.</p><!--TOC subsubsection id="sss:mexpr-include" Including the components of another structure-->
<h4 class="subsubsection" id="sss:mexpr-include"><a class="section-anchor" href="#sss:mexpr-include" aria-hidden="true">ï»¿</a>Including the components of another structure</h4><!--SEC END --><p><a id="hevea_manual.kwd204"></a></p><p>The expression <span class="syntax-token">include</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> in a structure re-exports in
the current structure all definitions of the structure denoted by
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>. For instance, if you define a module <span class="machine"><span class="font-tt">S</span></span> as below

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> S = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = int  <span class="ocamlkeyword">let</span> x = 2 <span class="ocamlkeyword">end</span></div></div>

</div><p>

defining the module <span class="machine"><span class="font-tt">B</span></span> as

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> B = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">include</span> S  <span class="ocamlkeyword">let</span> y = (x + 1 : t) <span class="ocamlkeyword">end</span></div></div>

</div><p>

is equivalent to defining it as

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> B = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = S.t  <span class="ocamlkeyword">let</span> x = S.x  <span class="ocamlkeyword">let</span> y = (x + 1 : t) <span class="ocamlkeyword">end</span></div></div>

</div><p>

The difference between <span class="syntax-token">open</span> and <span class="syntax-token">include</span> is that <span class="syntax-token">open</span>
simply provides short names for the components of the opened
structure, without defining any components of the current structure,
while <span class="syntax-token">include</span> also adds definitions for the components of the
included structure.</p>
<!--TOC subsection id="ss:mexpr-functors" 11.11.3â€ƒFunctors-->
<h3 class="subsection" id="ss:mexpr-functors"><a class="section-anchor" href="#ss:mexpr-functors" aria-hidden="true">ï»¿</a>11.11.3â€ƒFunctors</h3><!--SEC END --><!--TOC subsubsection id="sss:mexpr-functor-defs" Functor definition-->
<h4 class="subsubsection" id="sss:mexpr-functor-defs"><a class="section-anchor" href="#sss:mexpr-functor-defs" aria-hidden="true">ï»¿</a>Functor definition</h4><!--SEC END --><p><a id="hevea_manual.kwd205"></a></p><p>The expression <span class="syntax-token">functor</span> <span class="syntax-token">(</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span>
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> evaluates to a functor that takes as argument modules of
the type <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub>, binds <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> to these modules,
evaluates <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> in the extended environment, and returns the
resulting modules as results. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (â€œhigher-orderâ€ functor).</p><p>When the result module expression is itself a functor,
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">-&gt;</span>
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><p>
one may use the abbreviated form
</p><div class="center">
<span class="syntax-token">functor</span> <span class="syntax-token">(</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub>1</sub> <span class="syntax-token">)</span> â€¦
<span class="syntax-token">(</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</div><!--TOC subsubsection id="sss:mexpr-functor-app" Functor application-->
<h4 class="subsubsection" id="sss:mexpr-functor-app"><a class="section-anchor" href="#sss:mexpr-functor-app" aria-hidden="true">ï»¿</a>Functor application</h4><!--SEC END --><p>The expression <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub> <span class="syntax-token">(</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> <span class="syntax-token">)</span> evaluates
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub> to a functor and <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> to a module, and
applies the former to the latter. The type of <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>2</sub> must
match the type expected for the arguments of the functor <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a><sub>1</sub>.</p>
<!--TOC section id="s:compilation-units" 11.12â€ƒCompilation units-->
<h2 class="section" id="s:compilation-units"><a class="section-anchor" href="#s:compilation-units" aria-hidden="true">ï»¿</a>11.12â€ƒCompilation units</h2><!--SEC END --><!--NAME compunit.html-->
<div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="unit-interface"><span class="nonterminal">unit-interface</span></a></td><td class="c005">::=</td><td class="c007">â€„{â€„<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a>â€„[<span class="syntax-token">;;</span>]â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="unit-implementation"><span class="nonterminal">unit-implementation</span></a></td><td class="c005">::=</td><td class="c007">â€„[â€„<a class="syntax" href="#module-items"><span class="nonterminal">module-items</span></a>â€„]
</td></tr>
</table></td></tr>
</table></div><p>Compilation units bridge the module system and the separate
compilation system. A compilation unit is composed of two parts: an
interface and an implementation. The interface contains a sequence of
specifications, just as the inside of a <span class="syntax-token">sig</span> â€¦ <span class="syntax-token">end</span>
signature expression. The implementation contains a sequence of
definitions and expressions, just as the inside of a
<span class="syntax-token">struct</span> â€¦ <span class="syntax-token">end</span> module
expression. A compilation unit also has a name <span class="nonterminal">unit-name</span>, derived
from the names of the files containing the interface and the
implementation (see chapterÂ <a href="#c%3Acamlc">13</a> for more details). A
compilation unit behaves roughly as the module definition
</p><div class="center">
<span class="syntax-token">module</span> <span class="nonterminal">unit-name</span> <span class="syntax-token">:</span> <span class="syntax-token">sig</span> <a class="syntax" href="#unit-interface"><span class="nonterminal">unit-interface</span></a> <span class="syntax-token">end</span> <span class="syntax-token">=</span>
<span class="syntax-token">struct</span> <a class="syntax" href="#unit-implementation"><span class="nonterminal">unit-implementation</span></a> <span class="syntax-token">end</span>
</div><p>A compilation unit can refer to other compilation units by their
names, as if they were regular modules. For instance, if <span class="machine"><span class="font-tt">U</span></span> is a
compilation unit that defines a type <span class="machine"><span class="font-tt">t</span></span>, other compilation units can
refer to that type under the name <span class="machine"><span class="font-tt">U.t</span></span>; they can also refer to <span class="machine"><span class="font-tt">U</span></span> as
a whole structure. Except for names of other compilation units, a unit
interface or unit implementation must not have any other free variables.
In other terms, the type-checking and compilation of an interface or
implementation proceeds in the initial environment
</p><div class="center">
<span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">:</span> <span class="syntax-token">sig</span> <a class="syntax" href="#specification"><span class="nonterminal">specification</span></a><sub>1</sub> <span class="syntax-token">end</span> â€¦
<span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <span class="syntax-token">sig</span> <a class="syntax" href="#specification"><span class="nonterminal">specification</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">end</span>
</div><p>
where <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> are the names of the other
compilation units available in the search path (see
chapterÂ <a href="#c%3Acamlc">13</a> for more details) and <a class="syntax" href="#specification"><span class="nonterminal">specification</span></a><sub>1</sub> â€¦
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a><sub><span class="font-it">n</span></sub> are their respective interfaces.

</p><!--CUT END -->

<!--TOC chapter id="sec278" ChapterÂ 12â€ƒLanguage extensions-->
<h1 class="chapter" id="sec278">ChapterÂ 12â€ƒLanguage extensions</h1><!--SEC END --><p> <a id="c:extensions"></a>
</p><!--NAME extn.html-->
<p>This chapter describes language extensions and convenience features
that are implemented in OCaml, but not described in chapter <a href="#c%3Arefman">11</a>.</p><!--CUT DEF section  -->
<!--TOC section id="s:letrecvalues" 12.1â€ƒRecursive definitions of values-->
<h2 class="section" id="s:letrecvalues"><a class="section-anchor" href="#s:letrecvalues" aria-hidden="true">ï»¿</a>12.1â€ƒRecursive definitions of values</h2><!--SEC END --><!--NAME letrecvalues.html-->
<p>(Introduced in Objective Caml 1.00)</p><p>As mentioned in sectionÂ <a href="#sss%3Aexpr-localdef">11.7.2</a>, the <span class="syntax-token">let</span> <span class="syntax-token">rec</span> binding
construct, in addition to the definition of recursive functions,
also supports a certain class of recursive definitions of
non-functional values, such as
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">=</span> <span class="syntax-token">1</span> <span class="syntax-token">::</span> <span class="nonterminal">name</span><sub>2</sub>
<span class="syntax-token">and</span> <span class="nonterminal">name</span><sub>2</sub> <span class="syntax-token">=</span> <span class="syntax-token">2</span> <span class="syntax-token">::</span> <span class="nonterminal">name</span><sub>1</sub>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
which binds <span class="nonterminal">name</span><sub>1</sub> to the cyclic list <span class="machine"><span class="font-tt">1::2::1::2::</span></span>â€¦, and
<span class="nonterminal">name</span><sub>2</sub> to the cyclic list <span class="machine"><span class="font-tt">2::1::2::1::</span></span>â€¦Informally, the class of accepted definitions consists of those
definitions where the defined names occur only inside function
bodies or as argument to a data constructor.</p><p>More precisely, consider the expression:
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> â€¦ <span class="syntax-token">and</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
It will be accepted if each one of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> is
statically constructive with respect to <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>,
is not immediately linked to any of <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>,
and is not an array constructor whose arguments have abstract type.</p><p>An expression <span class="nonterminal">e</span> is said to be <em>statically constructive
with respect to</em> the variables <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> if at least
one of the following conditions is true:
</p><ul class="itemize"><li class="li-itemize"><span class="nonterminal">e</span> has no free occurrence of any of <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>
</li><li class="li-itemize"><span class="nonterminal">e</span> is a variable
</li><li class="li-itemize"><span class="nonterminal">e</span> has the form <span class="syntax-token">fun</span> â€¦ <span class="syntax-token">-&gt;</span> â€¦
</li><li class="li-itemize"><span class="nonterminal">e</span> has the form <span class="syntax-token">function</span> â€¦ <span class="syntax-token">-&gt;</span> â€¦
</li><li class="li-itemize"><span class="nonterminal">e</span> has the form <span class="syntax-token">lazy</span> <span class="syntax-token">(</span> â€¦ <span class="syntax-token">)</span>
</li><li class="li-itemize"><span class="nonterminal">e</span> has one of the following forms, where each one of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> â€¦ <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> is statically constructive with respect to
<span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>, and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> is statically constructive with
respect to <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>, <span class="nonterminal">xname</span><sub>1</sub> â€¦ <span class="nonterminal">xname</span><sub><span class="font-it">m</span></sub>:
<ul class="itemize"><li class="li-itemize"><span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <span class="nonterminal">xname</span><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> â€¦
<span class="syntax-token">and</span> <span class="nonterminal">xname</span><sub><span class="font-it">m</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub>
</li><li class="li-itemize"><span class="syntax-token">let</span> <span class="syntax-token">module</span> â€¦ <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>
</li><li class="li-itemize"><a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub><span class="syntax-token">)</span>
</li><li class="li-itemize"><span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a> <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub><span class="syntax-token">)</span>
</li><li class="li-itemize"><span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">|]</span>
</li><li class="li-itemize"><span class="syntax-token">{</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">m</span></sub> = <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">}</span>
</li><li class="li-itemize"><span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">with</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub>2</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub><span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span>
<a class="syntax" href="#field"><span class="nonterminal">field</span></a><sub><span class="font-it">m</span></sub> = <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">}</span> where <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> is not immediately
linked to <span class="nonterminal">name</span><sub>1</sub> â€¦ <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub>
</li><li class="li-itemize"><span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">)</span>
</li><li class="li-itemize"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub>
</li></ul>
</li></ul><p>An expression <span class="nonterminal">e</span> is said to be <em>immediately linked to</em> the variable
<span class="nonterminal">name</span> in the following cases:
</p><ul class="itemize"><li class="li-itemize"><span class="nonterminal">e</span> is <span class="nonterminal">name</span>
</li><li class="li-itemize"><span class="nonterminal">e</span> has the form <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">;</span> â€¦ <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> where <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub>
is immediately linked to <span class="nonterminal">name</span>
</li><li class="li-itemize"><span class="nonterminal">e</span> has the form <span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <span class="nonterminal">xname</span><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> â€¦
<span class="syntax-token">and</span> <span class="nonterminal">xname</span><sub><span class="font-it">m</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> where <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> is immediately
linked to <span class="nonterminal">name</span> or to one of the <span class="nonterminal">xname</span><sub><span class="font-it">i</span></sub> such that <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub>
is immediately linked to <span class="nonterminal">name</span>.
</li></ul>
<!--TOC section id="s:recursive-modules" 12.2â€ƒRecursive modules-->
<h2 class="section" id="s:recursive-modules"><a class="section-anchor" href="#s:recursive-modules" aria-hidden="true">ï»¿</a>12.2â€ƒRecursive modules</h2><!--SEC END --><p>
<a id="hevea_manual.kwd206"></a>
<a id="hevea_manual.kwd207"></a>
</p><!--NAME recursivemodules.html-->
<p>(Introduced in Objective Caml 3.07)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">rec</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„
{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">rec</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a><span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„}
</td></tr>
</table></td></tr>
</table></div><p>Recursive module definitions, introduced by the <span class="syntax-token">module rec</span> â€¦<span class="syntax-token">and</span> â€¦ construction, generalize regular module definitions
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> and module specifications
<span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> by allowing the defining
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> and the <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a> to refer recursively to the module
identifiers being defined. A typical example of a recursive module
definition is:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">rec</span> A : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t = Leaf <span class="ocamlkeyword">of</span> string | Node <span class="ocamlkeyword">of</span> ASet.t
  <span class="ocamlkeyword">val</span> compare: t -&gt; t -&gt; int
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = Leaf <span class="ocamlkeyword">of</span> string | Node <span class="ocamlkeyword">of</span> ASet.t
  <span class="ocamlkeyword">let</span> compare t1 t2 =
    <span class="ocamlkeyword">match</span> (t1, t2) <span class="ocamlkeyword">with</span>
    | (Leaf s1, Leaf s2) -&gt; Stdlib.compare s1 s2
    | (Leaf _, Node _) -&gt; 1
    | (Node _, Leaf _) -&gt; -1
    | (Node n1, Node n2) -&gt; ASet.compare n1 n2
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">and</span> ASet
  : Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = A.t
  = Set.Make(A)</div></div>

</div><p>

It can be given the following specification:

</p><div class="caml-example signature">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">rec</span> A : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t = Leaf <span class="ocamlkeyword">of</span> string | Node <span class="ocamlkeyword">of</span> ASet.t
  <span class="ocamlkeyword">val</span> compare: t -&gt; t -&gt; int
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">and</span> ASet : Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = A.t</div></div>

</div><p>This is an experimental extension of OCaml: the class of
recursive definitions accepted, as well as its dynamic semantics are
not final and subject to change in future releases.</p><p>Currently, the compiler requires that all dependency cycles between
the recursively-defined module identifiers go through at least one
â€œsafeâ€ module. A module is â€œsafeâ€ if all value definitions that
it contains have function types <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>. Evaluation of a
recursive module definition proceeds by building initial values for
the safe modules involved, binding all (functional) values to
<span class="syntax-token">fun</span> <span class="syntax-token">_</span> <span class="syntax-token">-&gt;</span> <span class="syntax-token">raise</span> <span class="machine"><span class="font-tt">Undefined_recursive_module</span></span>. The defining
module expressions are then evaluated, and the initial values
for the safe modules are replaced by the values thus computed. If a
function component of a safe module is applied during this computation
(which corresponds to an ill-founded recursive definition), the
<span class="machine"><span class="font-tt">Undefined_recursive_module</span></span> exception is raised at runtime:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">rec</span> M: <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> f: unit -&gt; int <span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">let</span> f () = N.x <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">and</span> N:<span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> x: int <span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">let</span> x = M.f () <span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok">Exception:
Undefined_recursive_module (<span class="ocamlstring">"extensions/recursivemodules.etex"</span>, 1, 43).</div></div>

</div><p>If there are no safe modules along a dependency cycle, an error is raised</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">rec</span> M: <span class="ocamlkeyword">sig</span> <span class="ocamlhighlight">val x: int</span> <span class="ocamlkeyword">end</span> = <span class="ocamlhighlight">struct let x = N.y end</span>
<span class="ocamlkeyword">and</span> N:<span class="ocamlkeyword">sig</span> <span class="ocamlhighlight">val x: int</span> <span class="ocamlkeyword">val</span> y:int <span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">let</span> x = M.x <span class="ocamlkeyword">let</span> y = 0 <span class="ocamlkeyword">end</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Cannot safely evaluate the definition of the following cycle
       of recursively-defined modules: M -&gt; N -&gt; M.
       There are no safe modules in this cycle (see manual section 12.2).
  Module M defines an unsafe value, x .
  Module N defines an unsafe value, x .</div></div>

</div><p>Note that, in the <a class="syntax" href="#specification"><span class="nonterminal">specification</span></a> case, the <a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>s must be
parenthesized if they use the <span class="syntax-token">with</span> <a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a> construct.
</p>
<!--TOC section id="s:private-types" 12.3â€ƒPrivate types-->
<h2 class="section" id="s:private-types"><a class="section-anchor" href="#s:private-types" aria-hidden="true">ï»¿</a>12.3â€ƒPrivate types</h2><!--SEC END --><!--NAME privatetypes.html-->
<p>
<a id="hevea_manual.kwd208"></a>
</p><p>Private type declarations in module signatures, of the form
<span class="machine"><span class="font-tt">type t = private ...</span></span>, enable libraries to
reveal some, but not all aspects of the implementation of a type to
clients of the library. In this respect, they strike a middle ground
between abstract type declarations, where no information is revealed
on the type implementation, and data type definitions and type
abbreviations, where all aspects of the type implementation are
publicized. Private type declarations come in three flavors: for
variant and record types (sectionÂ <a href="#ss%3Aprivate-types-variant">12.3.1</a>),
for type abbreviations (sectionÂ <a href="#ss%3Aprivate-types-abbrev">12.3.2</a>),
and for row types (sectionÂ <a href="#ss%3Aprivate-rows">12.3.3</a>).</p>
<!--TOC subsection id="ss:private-types-variant" 12.3.1â€ƒPrivate variant and record types-->
<h3 class="subsection" id="ss:private-types-variant"><a class="section-anchor" href="#ss:private-types-variant" aria-hidden="true">ï»¿</a>12.3.1â€ƒPrivate variant and record types</h3><!--SEC END --><p>(Introduced in Objective Caml 3.07)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-representation"><span class="nonterminal">type-representation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">private</span>â€„[â€„<span class="syntax-token">|</span>â€„]â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">private</span>â€„<a class="syntax" href="#record-decl"><span class="nonterminal">record-decl</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Values of a variant or record type declared <span class="syntax-token">private</span>
can be de-structured normally in pattern-matching or via
the <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.</span> <a class="syntax" href="#field"><span class="nonterminal">field</span></a> notation for record accesses. However, values of
these types cannot be constructed directly by constructor application
or record construction. Moreover, assignment on a mutable field of a
private record type is not allowed.</p><p>The typical use of private types is in the export signature of a
module, to ensure that construction of values of the private type always
go through the functions provided by the module, while still allowing
pattern-matching outside the defining module. For example:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t = <span class="ocamlkeyword">private</span> A | B <span class="ocamlkeyword">of</span> int
  <span class="ocamlkeyword">val</span> a : t
  <span class="ocamlkeyword">val</span> b : int -&gt; t
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = A | B <span class="ocamlkeyword">of</span> int
  <span class="ocamlkeyword">let</span> a = A
  <span class="ocamlkeyword">let</span> b n = <span class="ocamlkeyword">assert</span> (n &gt; 0); B n
<span class="ocamlkeyword">end</span></div></div>

</div><p>

Here, the <span class="syntax-token">private</span> declaration ensures that in any value of type
<span class="machine"><span class="font-tt">M.t</span></span>, the argument to the <span class="machine"><span class="font-tt">B</span></span> constructor is always a positive integer.</p><p>With respect to the variance of their parameters, private types are
handled like abstract types. That is, if a private type has
parameters, their variance is the one explicitly given by prefixing
the parameter by a â€˜<span class="machine"><span class="font-tt">+</span></span>â€™ or a â€˜<span class="machine"><span class="font-tt">-</span></span>â€™, it is invariant otherwise.</p>
<!--TOC subsection id="ss:private-types-abbrev" 12.3.2â€ƒPrivate type abbreviations-->
<h3 class="subsection" id="ss:private-types-abbrev"><a class="section-anchor" href="#ss:private-types-abbrev" aria-hidden="true">ï»¿</a>12.3.2â€ƒPrivate type abbreviations</h3><!--SEC END --><p>(Introduced in Objective Caml 3.11)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-equation"><span class="nonterminal">type-equation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">private</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Unlike a regular type abbreviation, a private type abbreviation
declares a type that is distinct from its implementation type <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>.
However, coercions from the type to <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> are permitted.
Moreover, the compiler â€œknowsâ€ the implementation type and can take
advantage of this knowledge to perform type-directed optimizations.</p><p>The following example uses a private type abbreviation to define a
module of nonnegative integers:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> N : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t = <span class="ocamlkeyword">private</span> int
  <span class="ocamlkeyword">val</span> of_int: int -&gt; t
  <span class="ocamlkeyword">val</span> to_int: t -&gt; int
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = int
  <span class="ocamlkeyword">let</span> of_int n = <span class="ocamlkeyword">assert</span> (n &gt;= 0); n
  <span class="ocamlkeyword">let</span> to_int n = n
<span class="ocamlkeyword">end</span></div></div>

</div><p>

The type <span class="machine"><span class="font-tt">N.t</span></span> is incompatible with <span class="machine"><span class="font-tt">int</span></span>, ensuring that nonnegative
integers and regular integers are not confused. However, if <span class="machine"><span class="font-tt">x</span></span> has
type <span class="machine"><span class="font-tt">N.t</span></span>, the coercion <span class="machine"><span class="font-tt">(x :&gt; int)</span></span> is legal and returns the
underlying integer, just like <span class="machine"><span class="font-tt">N.to_int x</span></span>. Deep coercions are also
supported: if <span class="machine"><span class="font-tt">l</span></span> has type <span class="machine"><span class="font-tt">N.t list</span></span>, the coercion <span class="machine"><span class="font-tt">(l :&gt; int list)</span></span>
returns the list of underlying integers, like <span class="machine"><span class="font-tt">List.map N.to_int l</span></span>
but without copying the list <span class="machine"><span class="font-tt">l</span></span>.</p><p>Note that the coercion <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span> is actually an abbreviated
form,
and will only work in presence of private abbreviations if neither the
type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> nor <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> contain any type variables. If they do,
you must use the full form <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">:&gt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub> <span class="syntax-token">)</span> where
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> is the expected type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Concretely, this would be <span class="machine"><span class="font-tt">(x : N.t :&gt; int)</span></span> and <span class="machine"><span class="font-tt">(l : N.t list :&gt; int list)</span></span> for the above examples.</p>
<!--TOC subsection id="ss:private-rows" 12.3.3â€ƒPrivate row types-->
<h3 class="subsection" id="ss:private-rows"><a class="section-anchor" href="#ss:private-rows" aria-hidden="true">ï»¿</a>12.3.3â€ƒPrivate row types</h3><!--SEC END --><p>
<a id="hevea_manual.kwd209"></a></p><p>(Introduced in Objective Caml 3.09)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-equation"><span class="nonterminal">type-equation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">private</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Private row types are type abbreviations where part of the
structure of the type is left abstract. Concretely <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> in the
above should denote either an object type or a polymorphic variant
type, with some possibility of refinement left. If the private
declaration is used in an interface, the corresponding implementation
may either provide a ground instance, or a refined private type.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> c = <span class="ocamlkeyword">private</span> &lt; x : int; .. &gt; <span class="ocamlkeyword">val</span> o : c <span class="ocamlkeyword">end</span> =
<span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">class</span> c = <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">method</span> x = 3 <span class="ocamlkeyword">method</span> y = 2 <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">let</span> o = <span class="ocamlkeyword">new</span> c
<span class="ocamlkeyword">end</span></div></div>

</div><p>

This declaration does more than hiding the <span class="machine"><span class="font-tt">y</span></span> method, it also makes
the type <span class="machine"><span class="font-tt">c</span></span> incompatible with any other closed object type, meaning
that only <span class="machine"><span class="font-tt">o</span></span> will be of type <span class="machine"><span class="font-tt">c</span></span>. In that respect it behaves
similarly to private record types. But private row types are
more flexible with respect to incremental refinement. This feature can
be used in combination with functors.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> F(X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> c = <span class="ocamlkeyword">private</span> &lt; x : int; .. &gt; <span class="ocamlkeyword">end</span>) =
<span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">let</span> get_x (o : X.c) = o#x
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> G(X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> c = <span class="ocamlkeyword">private</span> &lt; x : int; y : int; .. &gt; <span class="ocamlkeyword">end</span>) =
<span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">include</span> F(X)
  <span class="ocamlkeyword">let</span> get_y (o : X.c) = o#y
<span class="ocamlkeyword">end</span></div></div>

</div><p>A polymorphic variant type [t], for example

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = [ `A <span class="ocamlkeyword">of</span> int | `B <span class="ocamlkeyword">of</span> bool ]</div></div>

</div><p>

can be refined in two ways. A definition [u] may add new field to [t],
and the declaration

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> u = <span class="ocamlkeyword">private</span> [&gt; t]</div></div>

</div><p>

will keep those new fields abstract. Construction of values of type
[u] is possible using the known variants of [t], but any
pattern-matching will require a default case to handle the potential
extra fields. Dually, a declaration [u] may restrict the fields of [t]
through abstraction: the declaration

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> v = <span class="ocamlkeyword">private</span> [&lt; t &gt; `A]</div></div>

</div><p>

corresponds to private variant types. One cannot create a value of the
private type [v], except using the constructors that are explicitly
listed as present, <span class="machine"><span class="font-tt">(`A n)</span></span> in this example; yet, when
patter-matching on a [v], one should assume that any of the
constructors of [t] could be present.</p><p>Similarly to abstract types, the variance of type parameters
is not inferred, and must be given explicitly.
</p>
<!--TOC section id="s:locally-abstract" 12.4â€ƒLocally abstract types-->
<h2 class="section" id="s:locally-abstract"><a class="section-anchor" href="#s:locally-abstract" aria-hidden="true">ï»¿</a>12.4â€ƒLocally abstract types</h2><!--SEC END --><p>
<a id="hevea_manual.kwd210"></a>
<a id="hevea_manual.kwd211"></a>
</p><!--NAME locallyabstract.html-->
<p>(Introduced in OCaml 3.12, short syntax added in 4.03)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<span class="syntax-token">type</span>â€„{â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">)</span>
</td></tr>
</table></td></tr>
</table></div><p>The expression <span class="syntax-token">fun</span> <span class="syntax-token">(</span> <span class="syntax-token">type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> introduces a
type constructor named <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a> which is considered abstract
in the scope of the sub-expression, but then replaced by a fresh type
variable. Note that contrary to what the syntax could suggest, the
expression <span class="syntax-token">fun</span> <span class="syntax-token">(</span> <span class="syntax-token">type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> itself does not
suspend the evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> as a regular abstraction would. The
syntax has been chosen to fit nicely in the context of function
declarations, where it is generally used. It is possible to freely mix
regular function parameters with pseudo type parameters, as in:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> t) (foo : t list) -&gt; â€¦</div></div>

</div><p>

and even use the alternative syntax for declaring functions:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> f (<span class="ocamlkeyword">type</span> t) (foo : t list) = â€¦</div></div>

</div><p>

If several locally abstract types need to be introduced, it is possible to use
the syntax
<span class="syntax-token">fun</span> <span class="syntax-token">(</span> <span class="syntax-token">type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a><sub>1</sub> â€¦ <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
as syntactic sugar for <span class="syntax-token">fun</span> <span class="syntax-token">(</span> <span class="syntax-token">type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a><sub>1</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> â€¦ <span class="syntax-token">-&gt;</span>
<span class="syntax-token">fun</span> <span class="syntax-token">(</span> <span class="syntax-token">type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. For instance,

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> t u v) -&gt; <span class="ocamlkeyword">fun</span> (foo : (t * u * v) list) -&gt; â€¦
<span class="ocamlkeyword">let</span> f' (<span class="ocamlkeyword">type</span> t u v) (foo : (t * u * v) list) = â€¦</div></div>

</div><p>This construction is useful because the type constructors it introduces
can be used in places where a type variable is not allowed. For
instance, one can use it to define an exception in a local module
within a polymorphic function.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> f (<span class="ocamlkeyword">type</span> t) () =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">exception</span> E <span class="ocamlkeyword">of</span> t <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">in</span>
  (<span class="ocamlkeyword">fun</span> x -&gt; M.E x), (<span class="ocamlkeyword">function</span> M.E x -&gt; Some x | _ -&gt; None)</div></div>

</div><p>Here is another example:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> sort_uniq (<span class="ocamlkeyword">type</span> s) (cmp : s -&gt; s -&gt; int) =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> S = Set.Make(<span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = s <span class="ocamlkeyword">let</span> compare = cmp <span class="ocamlkeyword">end</span>) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">fun</span> l -&gt;
    S.elements (List.fold_right S.add l S.empty)</div></div>

</div><p>It is also extremely useful for first-class modules (see
sectionÂ <a href="#s%3Afirst-class-modules">12.5</a>) and generalized algebraic datatypes
(GADTs: see sectionÂ <a href="#s%3Agadts">12.10</a>).</p>
<!--TOC paragraph id="p:polymorpic-locally-abstract" Polymorphic syntax-->
<h5 class="paragraph" id="p:polymorpic-locally-abstract"><a class="section-anchor" href="#p:polymorpic-locally-abstract" aria-hidden="true">ï»¿</a>Polymorphic syntax</h5><!--SEC END --><p> (Introduced in OCaml 4.00)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<span class="syntax-token">type</span>â€„{â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">method</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<span class="syntax-token">type</span>
{â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">method!</span>â€„[<span class="syntax-token">private</span>]â€„<a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a>â€„<span class="syntax-token">:</span>â€„<span class="syntax-token">type</span>
{â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>The <span class="syntax-token">(type</span> <a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a><span class="syntax-token">)</span> syntax construction by itself does not make
polymorphic the type variable it introduces, but it can be combined
with explicit polymorphic annotations where needed.
The above rule is provided as syntactic sugar to make this easier:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> f : <span class="ocamlkeyword">type</span> t1 t2. t1 * t2 list -&gt; t1 = â€¦</div></div>

</div><p>

is automatically expanded into

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> f : 't1 't2. 't1 * 't2 list -&gt; 't1 =
  <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> t1) (<span class="ocamlkeyword">type</span> t2) -&gt; ( â€¦ : t1 * t2 list -&gt; t1)</div></div>

</div><p>

This syntax can be very useful when defining recursive functions involving
GADTs, see the sectionÂ <a href="#s%3Agadts">12.10</a> for a more detailed explanation.</p><p>The same feature is provided for method definitions.
</p>
<!--TOC section id="s:first-class-modules" 12.5â€ƒFirst-class modules-->
<h2 class="section" id="s:first-class-modules"><a class="section-anchor" href="#s:first-class-modules" aria-hidden="true">ï»¿</a>12.5â€ƒFirst-class modules</h2><!--SEC END --><p>
<a id="hevea_manual.kwd212"></a>
<a id="hevea_manual.kwd213"></a>
<a id="hevea_manual.kwd214"></a>
<a id="hevea_manual.kwd215"></a>
</p><!--NAME firstclassmodules.html-->
<p>(Introduced in OCaml 3.12; pattern syntax and package type inference
introduced in 4.00; structural comparison of package types introduced in 4.02.;
fewer parens required starting from 4.05)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(module</span>â€„<a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a><span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(val</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a>]<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(module</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a>]<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„[<span class="syntax-token">:</span>â€„<a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a>]<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="package-type"><span class="nonterminal">package-type</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>â€„<span class="syntax-token">with</span>â€„<a class="syntax" href="#package-constraint"><span class="nonterminal">package-constraint</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#package-constraint"><span class="nonterminal">package-constraint</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="package-constraint"><span class="nonterminal">package-constraint</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">type</span>â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Modules are typically thought of as static components. This extension
makes it possible to pack a module as a first-class value, which can
later be dynamically unpacked into a module.</p><p>The expression <span class="syntax-token">(</span> <span class="syntax-token">module</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span> converts the
module (structure or functor) denoted by module expression <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
to a value of the core language that encapsulates this module. The
type of this core language value is <span class="syntax-token">(</span> <span class="syntax-token">module</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span>.
The <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> annotation can be omitted if it can be inferred
from the context.</p><p>Conversely, the module expression <span class="syntax-token">(</span> <span class="syntax-token">val</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span>
evaluates the core language expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> to a value, which must
have type <span class="syntax-token">module</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a>, and extracts the module that was
encapsulated in this value. Again <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> can be omitted if the
type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is known.
If the module expression is already parenthesized, like the arguments
of functors are, no additional parens are needed: <span class="machine"><span class="font-tt">Map.Make(val key)</span></span>.</p><p>The pattern <span class="syntax-token">(</span> <span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span> matches a
package with type <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> and binds it to <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>.
It is not allowed in toplevel let bindings.
Again <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> can be omitted if it can be inferred from the
enclosing pattern.</p><p>The <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> syntactic class appearing in the <span class="syntax-token">(</span> <span class="syntax-token">module</span>
<a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span> type expression and in the annotated forms represents a
subset of module types.
This subset consists of named module types with optional constraints
of a limited form: only non-parametrized types can be specified.</p><p>For type-checking purposes (and starting from OCaml 4.02), package types
are compared using the structural comparison of module types.</p><p>In general, the module expression <span class="syntax-token">(</span> <span class="syntax-token">val</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a>
<span class="syntax-token">)</span> cannot be used in the body of a functor, because this could cause
unsoundness in conjunction with applicative functors.
Since OCaml 4.02, this is relaxed in two ways:
if <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> does not contain nominal type declarations (<em>i.e.</em> types that are created with a proper identity), then this
expression can be used anywhere, and even if it contains such types
it can be used inside the body of a generative
functor, described in sectionÂ <a href="#s%3Agenerative-functors">12.15</a>.
It can also be used anywhere in the context of a local module binding
<span class="syntax-token">let</span> <span class="syntax-token">module</span> <a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <span class="syntax-token">(</span> <span class="syntax-token">val</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="#package-type"><span class="nonterminal">package-type</span></a> <span class="syntax-token">)</span>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.</p>
<!--TOC paragraph id="p:fst-mod-example" Basic example-->
<h5 class="paragraph" id="p:fst-mod-example"><a class="section-anchor" href="#p:fst-mod-example" aria-hidden="true">ï»¿</a>Basic example</h5><!--SEC END --><p> A typical use of first-class modules is to
select at run-time among several implementations of a signature.
Each implementation is a structure that we can encapsulate as a
first-class module, then store in a data structure such as a hash
table:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> picture = â€¦
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> DEVICE = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">val</span> draw : picture -&gt; unit
  â€¦
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">let</span> devices : (string, (<span class="ocamlkeyword">module</span> DEVICE)) Hashtbl.t = Hashtbl.create 17

<span class="ocamlkeyword">module</span> SVG = <span class="ocamlkeyword">struct</span> â€¦ <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">let</span> _ = Hashtbl.add devices <span class="ocamlstring">"SVG"</span> (<span class="ocamlkeyword">module</span> SVG : DEVICE)

<span class="ocamlkeyword">module</span> PDF = <span class="ocamlkeyword">struct</span> â€¦ <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">let</span> _ = Hashtbl.add devices <span class="ocamlstring">"PDF"</span> (<span class="ocamlkeyword">module</span> PDF : DEVICE)</div></div>

</div><p>We can then select one implementation based on command-line
arguments, for instance:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> parse_cmdline () = â€¦
<span class="ocamlkeyword">module</span> Device =
  (<span class="ocamlkeyword">val</span> (<span class="ocamlkeyword">let</span> device_name = parse_cmdline () <span class="ocamlkeyword">in</span>
        <span class="ocamlkeyword">try</span> Hashtbl.find devices device_name
        <span class="ocamlkeyword">with</span> Not_found -&gt;
          Printf.eprintf <span class="ocamlstring">"Unknown device %s\n"</span> device_name;
          exit 2)
   : DEVICE)</div></div>

</div><p>

Alternatively, the selection can be performed within a function:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> draw_using_device device_name picture =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> Device =
    (<span class="ocamlkeyword">val</span> (Hashtbl.find devices device_name) : DEVICE)
  <span class="ocamlkeyword">in</span>
  Device.draw picture</div></div>

</div>
<!--TOC paragraph id="p:fst-mod-advexamples" Advanced examples-->
<h5 class="paragraph" id="p:fst-mod-advexamples"><a class="section-anchor" href="#p:fst-mod-advexamples" aria-hidden="true">ï»¿</a>Advanced examples</h5><!--SEC END --><p>
With first-class modules, it is possible to parametrize some code over the
implementation of a module without using a functor.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> sort (<span class="ocamlkeyword">type</span> s) (<span class="ocamlkeyword">module</span> Set : Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = s) l =
  Set.elements (List.fold_right Set.add l Set.empty)</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sort : (<span class="ocamlkeyword">module</span> Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = 's) -&gt; 's list -&gt; 's list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>To use this function, one can wrap the <span class="machine"><span class="font-tt">Set.Make</span></span> functor:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> make_set (<span class="ocamlkeyword">type</span> s) cmp =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> S = Set.Make(<span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">type</span> t = s
    <span class="ocamlkeyword">let</span> compare = cmp
  <span class="ocamlkeyword">end</span>) <span class="ocamlkeyword">in</span>
  (<span class="ocamlkeyword">module</span> S : Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = s)</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> make_set : ('s -&gt; 's -&gt; int) -&gt; (<span class="ocamlkeyword">module</span> Set.S <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> elt = 's) = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC section id="s:module-type-of" 12.6â€ƒRecovering the type of a module-->
<h2 class="section" id="s:module-type-of"><a class="section-anchor" href="#s:module-type-of" aria-hidden="true">ï»¿</a>12.6â€ƒRecovering the type of a module</h2><!--SEC END --><!--NAME moduletypeof.html-->
<p>
<a id="hevea_manual.kwd216"></a>
<a id="hevea_manual.kwd217"></a>
<a id="hevea_manual.kwd218"></a>
<a id="hevea_manual.kwd219"></a>
</p><p>(Introduced in OCaml 3.12)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<span class="syntax-token">of</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>The construction <span class="syntax-token">module</span> <span class="syntax-token">type</span> <span class="syntax-token">of</span> <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a> expands to the module type
(signature or functor type) inferred for the module expression <a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>.
To make this module type reusable in many situations, it is
intentionally not strengthened: abstract types and datatypes are not
explicitly related with the types of the original module.
For the same reason, module aliases in the inferred type are expanded.</p><p>A typical use, in conjunction with the signature-level <span class="syntax-token">include</span>
construct, is to extend the signature of an existing structure.
In that case, one wants to keep the types equal to types in the
original module. This can done using the following idiom.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> MYHASH = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">include</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> <span class="ocamlkeyword">of</span> <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">include</span> Hashtbl <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">val</span> replace: ('a, 'b) t -&gt; 'a -&gt; 'b -&gt; unit
<span class="ocamlkeyword">end</span></div></div>

</div><p>

The signature <span class="machine"><span class="font-tt">MYHASH</span></span> then contains all the fields of the signature
of the module <span class="machine"><span class="font-tt">Hashtbl</span></span> (with strengthened type definitions), plus the
new field <span class="machine"><span class="font-tt">replace</span></span>. An implementation of this signature can be
obtained easily by using the <span class="syntax-token">include</span> construct again, but this
time at the structure level:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> MyHash : MYHASH = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">include</span> Hashtbl
  <span class="ocamlkeyword">let</span> replace t k v = remove t k; add t k v
<span class="ocamlkeyword">end</span></div></div>

</div><p>Another application where the absence of strengthening comes handy, is
to provide an alternative implementation for an existing module.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> MySet : <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> <span class="ocamlkeyword">of</span> Set = <span class="ocamlkeyword">struct</span>
  â€¦
<span class="ocamlkeyword">end</span></div></div>

</div><p>

This idiom guarantees that <span class="machine"><span class="font-tt">Myset</span></span> is compatible with Set, but allows
it to represent sets internally in a different way.
</p>
<!--TOC section id="s:signature-substitution" 12.7â€ƒSubstituting inside a signature-->
<h2 class="section" id="s:signature-substitution"><a class="section-anchor" href="#s:signature-substitution" aria-hidden="true">ï»¿</a>12.7â€ƒSubstituting inside a signature</h2><!--SEC END --><p>
<a id="hevea_manual.kwd220"></a>
<a id="hevea_manual.kwd221"></a>
<a id="hevea_manual.kwd222"></a>
</p><!--NAME signaturesubstitution.html-->

<!--TOC subsection id="ss:destructive-substitution" 12.7.1â€ƒDestructive substitutions-->
<h3 class="subsection" id="ss:destructive-substitution"><a class="section-anchor" href="#ss:destructive-substitution" aria-hidden="true">ï»¿</a>12.7.1â€ƒDestructive substitutions</h3><!--SEC END --><p>(Introduced in OCaml 3.12, generalized in 4.06)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">type</span>â€„[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>
</td></tr>
</table></td></tr>
</table></div><p>A â€œdestructiveâ€ substitution (<span class="syntax-token">with</span> ... <span class="syntax-token">:=</span> ...) behaves essentially like
normal signature constraints (<span class="syntax-token">with</span> ... <span class="syntax-token">=</span> ...), but it additionally removes
the redefined type or module from the signature.</p><p>Prior to OCaml 4.06, there were a number of restrictions: one could only remove
types and modules at the outermost level (not inside submodules), and in the
case of <span class="syntax-token">with type</span> the definition had to be another type constructor with the
same type parameters.</p><p>A natural application of destructive substitution is merging two
signatures sharing a type name.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> Printable = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t
  <span class="ocamlkeyword">val</span> print : Format.formatter -&gt; t -&gt; unit
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> Comparable = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t
  <span class="ocamlkeyword">val</span> compare : t -&gt; t -&gt; int
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> PrintableComparable = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">include</span> Printable
  <span class="ocamlkeyword">include</span> Comparable <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> t := t
<span class="ocamlkeyword">end</span></div></div>

</div><p>One can also use this to completely remove a field:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = Comparable <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> t := int</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> compare : int -&gt; int -&gt; int <span class="ocamlkeyword">end</span></div></div>

</div><p>

or to rename one:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> u
  <span class="ocamlkeyword">include</span> Comparable <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> t := u
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> u <span class="ocamlkeyword">val</span> compare : u -&gt; u -&gt; int <span class="ocamlkeyword">end</span></div></div>

</div><p>Note that you can also remove manifest types, by substituting with the
same type.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ComparableInt = Comparable <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> t = int ;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ComparableInt = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t = int <span class="ocamlkeyword">val</span> compare : t -&gt; t -&gt; int <span class="ocamlkeyword">end</span></div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> CompareInt = ComparableInt <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> t := int</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> CompareInt = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> compare : int -&gt; int -&gt; int <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC subsection id="ss:local-substitution" 12.7.2â€ƒLocal substitution declarations-->
<h3 class="subsection" id="ss:local-substitution"><a class="section-anchor" href="#ss:local-substitution" aria-hidden="true">ï»¿</a>12.7.2â€ƒLocal substitution declarations</h3><!--SEC END --><p>(Introduced in OCaml 4.08)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#type-subst"><span class="nonterminal">type-subst</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#type-subst"><span class="nonterminal">type-subst</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a></td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008"><a class="syntax" id="type-subst"><span class="nonterminal">type-subst</span></a></td><td class="c005">::=</td><td class="c007">
[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<a class="syntax" href="#type-constraint"><span class="nonterminal">type-constraint</span></a>â€„}
</td></tr>
</table></td></tr>
</table></div><p>Local substitutions behave like destructive substitutions (<span class="syntax-token">with</span> ... <span class="syntax-token">:=</span> ...)
but instead of being applied to a whole signature after the fact, they are
introduced during the specification of the signature, and will apply to all the
items that follow.</p><p>This provides a convenient way to introduce local names for types and modules
when defining a signature:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t
  <span class="ocamlkeyword">module</span> Sub : <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> outer := t
    <span class="ocamlkeyword">type</span> t
    <span class="ocamlkeyword">val</span> to_outer : t -&gt; outer
  <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S =
  <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">module</span> Sub : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">val</span> to_outer : t/1 -&gt; t/2 <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">end</span></div></div>

</div><p>Note that, unlike type declarations, type substitution declarations are not
recursive, so substitutions like the following are rejected:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> 'a poly_list := [ `Cons <span class="ocamlkeyword">of</span> 'a * 'a <span class="ocamlhighlight">poly_list</span> | `Nil ]
  <span class="ocamlkeyword">end</span> ;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Unbound type constructor poly_list</div></div>

</div>
<!--TOC subsection id="ss:module-type-substitution" 12.7.3â€ƒModule type substitutions-->
<h3 class="subsection" id="ss:module-type-substitution"><a class="section-anchor" href="#ss:module-type-substitution" aria-hidden="true">ï»¿</a>12.7.3â€ƒModule type substitutions</h3><!--SEC END --><p>(Introduced in OCaml 4.13)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#mod-constraint"><span class="nonterminal">mod-constraint</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-path"><span class="nonterminal">modtype-path</span></a>â€„<span class="syntax-token">:=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
</table></td></tr>
</table></div><p>Module type substitution essentially behaves like type substitutions.
They are useful to refine an abstract module type in a signature into
a concrete module type,</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ENDO = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T
    <span class="ocamlkeyword">module</span> F: T -&gt; T
  <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">module</span> Endo(X: <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T <span class="ocamlkeyword">end</span>): ENDO <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T = X.T =
  <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T = X.T
      <span class="ocamlkeyword">module</span> F(X:T) = X
   <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ENDO = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T <span class="ocamlkeyword">module</span> F : T -&gt; T <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> Endo :
  <span class="ocamlkeyword">functor</span> (X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T <span class="ocamlkeyword">end</span>) -&gt;
    <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T = X.T <span class="ocamlkeyword">module</span> F : T -&gt; T <span class="ocamlkeyword">end</span></div></div>

</div><p>It is also possible to substitute a concrete module type with an
equivalent module types.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> A = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> x
  <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> R = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> a = A <span class="ocamlkeyword">of</span> x
    <span class="ocamlkeyword">type</span> b
  <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> a = A <span class="ocamlkeyword">of</span> int
  <span class="ocamlkeyword">type</span> b
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> B = A <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">type</span> x = int <span class="ocamlkeyword">and</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> R = S</div></div>

</div><p>

However, such substitutions are never necessary.</p><p>Destructive module type substitution removes the module type substitution
from the signature

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ENDO' = ENDO <span class="ocamlkeyword">with</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T := ENDO;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> ENDO' = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> F : ENDO -&gt; ENDO <span class="ocamlkeyword">end</span></div></div>

</div><p>

If the right hand side of the substitution is not a path, then the destructive
substitution is only valid if the left-hand side of the substitution is never
used as the type of a first-class module in the original module type.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> T = <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S <span class="ocamlkeyword">val</span> x: (<span class="ocamlkeyword">module</span> S) <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> Error = <span class="ocamlhighlight">T with module type S := sig end</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This `with' constraint S := sig end makes a packed module ill-formed.</div></div>

</div>
<!--TOC section id="s:module-alias" 12.8â€ƒType-level module aliases-->
<h2 class="section" id="s:module-alias"><a class="section-anchor" href="#s:module-alias" aria-hidden="true">ï»¿</a>12.8â€ƒType-level module aliases</h2><!--SEC END --><p>
<a id="hevea_manual.kwd223"></a>
</p><!--NAME modulealias.html-->
<p>(Introduced in OCaml 4.02)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
</table></td></tr>
</table></div><p>The above specification, inside a signature, only matches a module
definition equal to <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>. Conversely, a type-level module
alias can be matched by itself, or by any supertype of the type of the
module it references.</p><p>There are several restrictions on <a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>:
</p><ol class="enumerate" type=1><li class="li-enumerate">it should be of the form <span class="font-it">M</span><sub>0</sub>.<span class="font-it">M</span><sub>1</sub>...<span class="font-it">M</span><sub><span class="font-it">n</span></sub> (<em>i.e.</em> without
functor applications);
</li><li class="li-enumerate">inside the body of a functor, <span class="font-it">M</span><sub>0</sub> should not be one of the
functor parameters;
</li><li class="li-enumerate">inside a recursive module definition, <span class="font-it">M</span><sub>0</sub> should not be one of
the recursively defined modules.
</li></ol><p>Such specifications are also inferred. Namely, when <span class="nonterminal">P</span> is a path
satisfying the above constraints,

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> N = P</div></div>

</div><p>

has type

</p><div class="caml-example signature">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> N = P</div></div>

</div><p>Type-level module aliases are used when checking module path
equalities. That is, in a context where module name <span class="nonterminal">N</span> is known to be
an alias for <span class="nonterminal">P</span>, not only these two module paths check as equal, but
<span class="nonterminal">F</span>(<span class="nonterminal">N</span>) and <span class="nonterminal">F</span>(<span class="nonterminal">P</span>) are also recognized as equal. In the default
compilation mode, this is the only difference with the previous
approach of module aliases having just the same module type as the
module they reference.</p><p>When the compiler flag <span class="syntax-token">-no-alias-deps</span> is enabled, type-level
module aliases are also exploited to avoid introducing dependencies
between compilation units. Namely, a module alias referring to a
module inside another compilation unit does not introduce a link-time
dependency on that compilation unit, as long as it is not
dereferenced; it still introduces a compile-time dependency if the
interface needs to be read, <em>i.e.</em> if the module is a submodule
of the compilation unit, or if some type components are referred to.
Additionally, accessing a module alias introduces a link-time
dependency on the compilation unit containing the module referenced by
the alias, rather than the compilation unit containing the alias.
Note that these differences in link-time behavior may be incompatible
with the previous behavior, as some compilation units might not be
extracted from libraries, and their side-effects ignored.</p><p>These weakened dependencies make possible to use module aliases in
place of the <span class="syntax-token">-pack</span> mechanism. Suppose that you have a library
<span class="syntax-token">Mylib</span> composed of modules <span class="syntax-token">A</span> and <span class="syntax-token">B</span>. Using <span class="syntax-token">-pack</span>, one
would issue the command line
</p><pre>ocamlc -pack a.cmo b.cmo -o mylib.cmo
</pre><p>and as a result obtain a <span class="syntax-token">Mylib</span> compilation unit, containing
physically <span class="syntax-token">A</span> and <span class="syntax-token">B</span> as submodules, and with no dependencies on
their respective compilation units.
Here is a concrete example of a possible alternative approach:
</p><ol class="enumerate" type=1><li class="li-enumerate">Rename the files containing <span class="syntax-token">A</span> and <span class="syntax-token">B</span> to <span class="syntax-token">Mylib__A</span> and
<span class="syntax-token">Mylib__B</span>.
</li><li class="li-enumerate">Create a packing interface <span class="syntax-token">Mylib.ml</span>, containing the
following lines.
<pre>module A = Mylib__A
module B = Mylib__B
</pre></li><li class="li-enumerate">Compile <span class="syntax-token">Mylib.ml</span> using <span class="syntax-token">-no-alias-deps</span>, and the other
files using <span class="syntax-token">-no-alias-deps</span> and <span class="syntax-token">-open</span> <span class="syntax-token">Mylib</span> (the last one is
equivalent to adding the line <span class="syntax-token">open!</span> <span class="syntax-token">Mylib</span> at the top of each
file).
<pre>ocamlc -c -no-alias-deps Mylib.ml
ocamlc -c -no-alias-deps -open Mylib Mylib__*.mli Mylib__*.ml
</pre></li><li class="li-enumerate">Finally, create a library containing all the compilation units,
and export all the compiled interfaces.
<pre>ocamlc -a Mylib*.cmo -o Mylib.cma
</pre></li></ol><p>
This approach lets you access <span class="syntax-token">A</span> and <span class="syntax-token">B</span> directly inside the
library, and as <span class="syntax-token">Mylib.A</span> and <span class="syntax-token">Mylib.B</span> from outside.
It also has the advantage that <span class="syntax-token">Mylib</span> is no longer monolithic: if
you use <span class="syntax-token">Mylib.A</span>, only <span class="syntax-token">Mylib__A</span> will be linked in, not
<span class="syntax-token">Mylib__B</span>.
</p><p>Note the use of double underscores in <span class="syntax-token">Mylib__A</span> and
<span class="syntax-token">Mylib__B</span>. These were chosen on purpose; the compiler uses the
following heuristic when printing paths: given a path <span class="syntax-token">Lib__fooBar</span>,
if <span class="syntax-token">Lib.FooBar</span> exists and is an alias for <span class="syntax-token">Lib__fooBar</span>, then the
compiler will always display <span class="syntax-token">Lib.FooBar</span> instead of
<span class="syntax-token">Lib__fooBar</span>. This way the long <span class="syntax-token">Mylib__</span> names stay hidden and
all the user sees is the nicer dot names. This is how the OCaml
standard library is compiled.
</p>
<!--TOC section id="s:explicit-overriding-open" 12.9â€ƒOverriding in open statements-->
<h2 class="section" id="s:explicit-overriding-open"><a class="section-anchor" href="#s:explicit-overriding-open" aria-hidden="true">ï»¿</a>12.9â€ƒOverriding in open statements</h2><!--SEC END --><p>
<a id="hevea_manual.kwd224"></a>
</p><!--NAME overridingopen.html-->
<p>(Introduced in OCaml 4.01)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-body-type</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#class-body-type"><span class="nonterminal">class-body-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-expr</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Since OCaml 4.01, <span class="syntax-token">open</span> statements shadowing an existing identifier
(which is later used) trigger the warning 44. Adding a <span class="syntax-token">!</span>
character after the <span class="syntax-token">open</span> keyword indicates that such a shadowing is
intentional and should not trigger the warning.</p><p>This is also available (since OCaml 4.06) for local opens in class
expressions and class type expressions.
</p>
<!--TOC section id="s:gadts" 12.10â€ƒGeneralized algebraic datatypes-->
<h2 class="section" id="s:gadts"><a class="section-anchor" href="#s:gadts" aria-hidden="true">ï»¿</a>12.10â€ƒGeneralized algebraic datatypes</h2><!--SEC END --><p> <a id="hevea_manual.kwd225"></a>
<a id="hevea_manual.kwd226"></a>
</p><!--NAME gadts.html-->
<p>Generalized algebraic datatypes, or GADTs, extend usual sum types in
two ways: constraints on type parameters may change depending on the
value constructor, and some type variables may be existentially
quantified. They are described in chapter <a href="#c%3Agadts-tutorial">7</a>.</p><p>(Introduced in OCaml 4.00)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„<span class="syntax-token">:</span>â€„[â€„<a class="syntax" href="#constr-args"><span class="nonterminal">constr-args</span></a>â€„<span class="syntax-token">-&gt;</span>â€„]â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#type-param"><span class="nonterminal">type-param</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<a class="syntax" href="#variance"><span class="nonterminal">variance</span></a>]â€„<span class="syntax-token">_</span>
</td></tr>
</table></td></tr>
</table></div><p>Refutation cases. (Introduced in OCaml 4.03)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="matching-case"><span class="nonterminal">matching-case</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">when</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">-&gt;</span>â€„<span class="syntax-token">.</span>
</td></tr>
</table></td></tr>
</table></div><p>Explicit naming of existentials. (Introduced in OCaml 4.13.0)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>â€„<span class="syntax-token">(</span>â€„<span class="syntax-token">type</span>â€„{â€„<a class="syntax" href="#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">)</span>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div>
<!--TOC section id="s:bigarray-access" 12.11â€ƒSyntax for Bigarray access-->
<h2 class="section" id="s:bigarray-access"><a class="section-anchor" href="#s:bigarray-access" aria-hidden="true">ï»¿</a>12.11â€ƒSyntax for Bigarray access</h2><!--SEC END --><!--NAME bigarray.html-->
<p>(Introduced in Objective Caml 3.00)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}â€„<span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">,</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}â€„<span class="syntax-token">}</span>â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
</table></td></tr>
</table></div><p>This extension provides syntactic sugar for getting and setting
elements in the arrays provided by the <a href="libref/Bigarray.html"><span class="font-tt">Bigarray</span></a> module.</p><p>The short expressions are translated into calls to functions of the
<span class="machine"><span class="font-tt">Bigarray</span></span> module as described in the following table.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">expression</span></td><td class="c004"><span class="font-bold">translation</span> </td></tr>
<tr><td class="c006">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">}</span></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array1.get </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">}</span> <span class="syntax-token">&lt;-</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array1.set </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub><span class="syntax-token">}</span></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array2.get </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub><span class="syntax-token">}</span> <span class="syntax-token">&lt;-</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array2.set </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub><span class="syntax-token">}</span></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array3.get </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub><span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub><span class="syntax-token">}</span> <span class="syntax-token">&lt;-</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Array3.set </span></span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦<span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">}</span></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Genarray.get </span></span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span> </td></tr>
<tr><td class="c006"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub><span class="syntax-token">.{</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦<span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">}</span> <span class="syntax-token">&lt;-</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c006"><span class="machine"><span class="font-tt">Bigarray.Genarray.set </span></span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub><span class="syntax-token">,</span> â€¦ <span class="syntax-token">,</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> </td></tr>
</table></div></div><p>The last two entries are valid for any <span class="font-it">n</span> &gt; 3.
</p>
<!--TOC section id="s:attributes" 12.12â€ƒAttributes-->
<h2 class="section" id="s:attributes"><a class="section-anchor" href="#s:attributes" aria-hidden="true">ï»¿</a>12.12â€ƒAttributes</h2><!--SEC END --><!--NAME attributes.html-->
<p>
<a id="hevea_manual.kwd227"></a>
</p><p>(Introduced in OCaml 4.02,
infix notations for constructs other than expressions added in 4.03)</p><p>Attributes are â€œdecorationsâ€ of the syntax tree which are mostly
ignored by the type-checker but can be used by external tools. An
attribute is made of an identifier and a payload, which can be a
structure, a type expression (prefixed with <span class="machine"><span class="font-tt">:</span></span>), a signature
(prefixed with <span class="machine"><span class="font-tt">:</span></span>) or a pattern (prefixed with <span class="machine"><span class="font-tt">?</span></span>) optionally
followed by a <span class="machine"><span class="font-tt">when</span></span> clause:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="attr-id"><span class="nonterminal">attr-id</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="attr-payload"><span class="nonterminal">attr-payload</span></a></td><td class="c005">::=</td><td class="c007">
[â€„<a class="syntax" href="#module-items"><span class="nonterminal">module-items</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">:</span>â€„[â€„<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">?</span>â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„[<span class="syntax-token">when</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>The first form of attributes is attached with a postfix notation on
â€œalgebraicâ€ categories:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="attribute"><span class="nonterminal">attribute</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[@</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<a class="syntax" href="#attr-payload"><span class="nonterminal">attr-payload</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-expr</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-expr"><span class="nonterminal">class-expr</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-type</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-type"><span class="nonterminal">class-type</span></a>â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>This form of attributes can also be inserted after the <span class="syntax-token">`</span><a class="syntax" href="#tag-name"><span class="nonterminal">tag-name</span></a>
in polymorphic variant type expressions (<a class="syntax" href="#tag-spec-first"><span class="nonterminal">tag-spec-first</span></a>, <a class="syntax" href="#tag-spec"><span class="nonterminal">tag-spec</span></a>,
<a class="syntax" href="#tag-spec-full"><span class="nonterminal">tag-spec-full</span></a>) or after the <a class="syntax" href="#method-name"><span class="nonterminal">method-name</span></a> in <a class="syntax" href="#method-type"><span class="nonterminal">method-type</span></a>.</p><p>The same syntactic form is also used to attach attributes to labels and
constructors in type declarations:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="nonterminal">field-decl</span></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">mutable</span>]â€„<a class="syntax" href="#field-name"><span class="nonterminal">field-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a>â€„{â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a></td><td class="c005">::=</td><td class="c007">
(<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„âˆ£â€„<span class="syntax-token">()</span>)â€„[â€„<span class="syntax-token">of</span>â€„<a class="syntax" href="#constr-args"><span class="nonterminal">constr-args</span></a>â€„]â€„{â€„<a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Note: when a label declaration is followed by a semi-colon, attributes
can also be put after the semi-colon (in which case they are merged to
those specified before).</p><p>The second form of attributes are attached to â€œblocksâ€ such as type
declarations, class fields, etc:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="item-attribute"><span class="nonterminal">item-attribute</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[@@</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<a class="syntax" href="#attr-payload"><span class="nonterminal">attr-payload</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">typedef</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#typedef"><span class="nonterminal">typedef</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">exception-definition</span></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">module-items</span></td><td class="c005">::=</td><td class="c007">
[<span class="syntax-token">;;</span>]â€„(â€„<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a>â€„âˆ£â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}â€„)â€„{â€„[<span class="syntax-token">;;</span>]â€„<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a>â€„âˆ£â€„<span class="syntax-token">;;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}â€„}â€„[<span class="syntax-token">;;</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-binding</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-binding"><span class="nonterminal">class-binding</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-spec</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-spec"><span class="nonterminal">class-spec</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">classtype-def</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#classtype-def"><span class="nonterminal">classtype-def</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">let</span>â€„[<span class="syntax-token">rec</span>]â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">external</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#type-definition"><span class="nonterminal">type-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#exception-definition"><span class="nonterminal">exception-definition</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-definition"><span class="nonterminal">class-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#classtype-definition"><span class="nonterminal">classtype-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„}
[â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„]â€„â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">include</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">rec</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">=</span>â€„
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}â€„
{â€„<span class="syntax-token">and</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„
{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">val</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">external</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#type-definition"><span class="nonterminal">type-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">exception</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-specification"><span class="nonterminal">class-specification</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#classtype-definition"><span class="nonterminal">classtype-definition</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„}
<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<span class="syntax-token">type</span>â€„<a class="syntax" href="#modtype-name"><span class="nonterminal">modtype-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">open</span>â€„<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">include</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„{â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-field-spec</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-field-spec"><span class="nonterminal">class-field-spec</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a>â€„<a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>A third form of attributes appears as stand-alone structure or
signature items in the module or class sub-languages. They are not
attached to any specific node in the syntax tree:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="floating-attribute"><span class="nonterminal">floating-attribute</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[@@@</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<a class="syntax" href="#attr-payload"><span class="nonterminal">attr-payload</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#floating-attribute"><span class="nonterminal">floating-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#floating-attribute"><span class="nonterminal">floating-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-field-spec</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#floating-attribute"><span class="nonterminal">floating-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#floating-attribute"><span class="nonterminal">floating-attribute</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>(Note: contrary to what the grammar above describes, <span class="nonterminal">item-attributes</span>
cannot be attached to these floating attributes in <a class="syntax" href="#class-field-spec"><span class="nonterminal">class-field-spec</span></a>
and <a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a>.)</p><p>It is also possible to specify attributes using an infix syntax. For instance:</p><pre>let[@foo] x = 2 in x + 1          === (let x = 2 [@@foo] in x + 1)
begin[@foo][@bar x] ... end       === (begin ... end)[@foo][@bar x]
module[@foo] M = ...              === module M = ... [@@foo]
type[@foo] t = T                  === type t = T [@@foo]
method[@foo] m = ...              === method m = ... [@@foo]
</pre><p>
For <span class="machine"><span class="font-tt">let</span></span>, the attributes are applied to each bindings:</p><pre>let[@foo] x = 2 and y = 3 in x + y === (let x = 2 [@@foo] and y = 3 in x + y)
let[@foo] x = 2
and[@bar] y = 3 in x + y           === (let x = 2 [@@foo] and y = 3 [@@bar] in x + y)
</pre>
<!--TOC subsection id="ss:builtin-attributes" 12.12.1â€ƒBuilt-in attributes-->
<h3 class="subsection" id="ss:builtin-attributes"><a class="section-anchor" href="#ss:builtin-attributes" aria-hidden="true">ï»¿</a>12.12.1â€ƒBuilt-in attributes</h3><!--SEC END --><p>Some attributes are understood by the type-checker:
</p><ul class="itemize"><li class="li-itemize">â€œocaml.warningâ€ or â€œwarningâ€, with a string literal payload.
This can be used as floating attributes in a
signature/structure/object/object type. The string is parsed and has
the same effect as the <span class="machine"><span class="font-tt">-w</span></span> command-line option, in the scope between
the attribute and the end of the current
signature/structure/object/object type. The attribute can also be
attached to any kind of syntactic item which support attributes
(such as an expression, or a type expression)
in which case its scope is limited to that item.
Note that it is not well-defined which scope is used for a specific
warning. This is implementation dependent and can change between versions.
Some warnings are even completely outside the control of â€œocaml.warningâ€
(for instance, warnings 1, 2, 14, 29 and 50).</li><li class="li-itemize">â€œocaml.warnerrorâ€ or â€œwarnerrorâ€, with a string literal payload.
Same as â€œocaml.warningâ€, for the <span class="machine"><span class="font-tt">-warn-error</span></span> command-line option.</li><li class="li-itemize">â€œocaml.alertâ€ or â€œalertâ€: see sectionÂ <a href="#s%3Aalerts">12.21</a>.</li><li class="li-itemize">â€œocaml.deprecatedâ€ or â€œdeprecatedâ€: alias for the
â€œdeprecatedâ€ alert, see sectionÂ <a href="#s%3Aalerts">12.21</a>.
</li><li class="li-itemize">â€œocaml.deprecated_mutableâ€ or â€œdeprecated_mutableâ€.
Can be applied to a mutable record label. If the label is later
used to modify the field (with â€œexpr.l &lt;- exprâ€), the â€œdeprecatedâ€ alert
will be triggered. If the payload of the attribute is a string literal,
the alert message includes this text.
</li><li class="li-itemize">â€œocaml.ppwarningâ€ or â€œppwarningâ€, in any context, with
a string literal payload. The text is reported as warning (22)
by the compiler (currently, the warning location is the location
of the string payload). This is mostly useful for preprocessors which
need to communicate warnings to the user. This could also be used
to mark explicitly some code location for further inspection.
</li><li class="li-itemize">â€œocaml.warn_on_literal_patternâ€ or â€œwarn_on_literal_patternâ€ annotate
constructors in type definition. A warning (52) is then emitted when this
constructor is pattern matched with a constant literal as argument. This
attribute denotes constructors whose argument is purely informative and
may change in the future. Therefore, pattern matching on this argument
with a constant literal is unreliable. For instance, all built-in exception
constructors are marked as â€œwarn_on_literal_patternâ€.
Note that, due to an implementation limitation, this warning (52) is only
triggered for single argument constructor.
</li><li class="li-itemize">â€œocaml.tailcallâ€ or â€œtailcallâ€ can be applied to function
application in order to check that the call is tailcall optimized.
If it it not the case, a warning (51) is emitted.
</li><li class="li-itemize">â€œocaml.inlineâ€ or â€œinlineâ€ take either â€œneverâ€, â€œalwaysâ€
or nothing as payload on a function or functor definition. If no payload
is provided, the default value is â€œalwaysâ€. This payload controls when
applications of the annotated functions should be inlined.
</li><li class="li-itemize">â€œocaml.inlinedâ€ or â€œinlinedâ€ can be applied to any function or functor
application to check that the call is inlined by the compiler. If the call
is not inlined, a warning (55) is emitted.
</li><li class="li-itemize">â€œocaml.noallocâ€, â€œocaml.unboxedâ€and â€œocaml.untaggedâ€ or
â€œnoallocâ€, â€œunboxedâ€ and â€œuntaggedâ€ can be used on external
definitions to obtain finer control over the C-to-OCaml interface. See
<a href="#s%3AC-cheaper-call">22.11</a> for more details.
</li><li class="li-itemize">â€œocaml.immediateâ€ or â€œimmediateâ€ applied on an abstract type mark the type as
having a non-pointer implementation (e.g. â€œintâ€, â€œboolâ€, â€œcharâ€ or
enumerated types). Mutation of these immediate types does not activate the
garbage collectorâ€™s write barrier, which can significantly boost performance in
programs relying heavily on mutable state.
</li><li class="li-itemize">â€œocaml.immediate64â€ or â€œimmediate64â€ applied on an abstract type mark the
type as having a non-pointer implementation on 64 bit platforms. No assumption
is made on other platforms. In order to produce a type with the
â€œimmediate64â€œ attribute, one must use â€œSys.Immediate64.Makeâ€œ functor.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">ocaml.unboxed</span></span> or <span class="machine"><span class="font-tt">unboxed</span></span> can be used on a type definition if the
type is a single-field record or a concrete type with a single
constructor that has a single argument. It tells the compiler to
optimize the representation of the type by removing the block that
represents the record or the constructor (i.e. a value of this type
is physically equal to its argument). In the case of GADTs, an
additional restriction applies: the argument must not be an
existential variable, represented by an existential type variable,
or an abstract type constructor applied to an existential type
variable.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">ocaml.boxed</span></span> or <span class="machine"><span class="font-tt">boxed</span></span> can be used on type definitions to mean
the opposite of <span class="machine"><span class="font-tt">ocaml.unboxed</span></span>: keep the unoptimized
representation of the type. When there is no annotation, the
default is currently <span class="machine"><span class="font-tt">boxed</span></span> but it may change in the future.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">ocaml.local</span></span> or <span class="machine"><span class="font-tt">local</span></span> take either <span class="machine"><span class="font-tt">never</span></span>, <span class="machine"><span class="font-tt">always</span></span>, <span class="machine"><span class="font-tt">maybe</span></span> or
nothing as payload on a function definition. If no payload is
provided, the default is <span class="machine"><span class="font-tt">always</span></span>. The attribute controls an
optimization which consists in compiling a function into a static
continuation. Contrary to inlining, this optimization does not
duplicate the functionâ€™s body. This is possible when all
references to the function are full applications, all sharing the
same continuation (for instance, the returned value of several
branches of a pattern matching). <span class="machine"><span class="font-tt">never</span></span> disables the optimization,
<span class="machine"><span class="font-tt">always</span></span> asserts that the optimization applies (otherwise a warning
55 is emitted) and <span class="machine"><span class="font-tt">maybe</span></span> lets the optimization apply when
possible (this is the default behavior when the attribute is not
specified). The optimization is implicitly disabled when using the
bytecode compiler in debug mode (-g), and for functions marked with
an <span class="machine"><span class="font-tt">ocaml.inline always</span></span> or <span class="machine"><span class="font-tt">ocaml.unrolled</span></span> attribute which
supersede <span class="machine"><span class="font-tt">ocaml.local</span></span>.
</li></ul><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> X = <span class="ocamlkeyword">struct</span>
  [@@@warning <span class="ocamlstring">"+9"</span>]  <span class="ocamlcomment">(* locally enable warning 9 in this structure *)</span>
  â€¦
<span class="ocamlkeyword">end</span>
[@@deprecated <span class="ocamlstring">"Please use module 'Y' instead."</span>]

<span class="ocamlkeyword">let</span> x = <span class="ocamlkeyword">begin</span>[@warning <span class="ocamlstring">"+9"</span>] [â€¦] <span class="ocamlkeyword">end</span>

<span class="ocamlkeyword">type</span> t = A | B
  [@@deprecated <span class="ocamlstring">"Please use type 's' instead."</span>]</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> fires_warning_22 x =
  <span class="ocamlkeyword">assert</span> (x &gt;= 0) [@ppwarning <span class="ocamlhighlight">"TODO: remove this later"</span>]</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 22 [preprocessor]: TODO: remove this later</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> is_a_tail_call = <span class="ocamlkeyword">function</span>
  | [] -&gt; ()
  | _ :: q -&gt; (is_a_tail_call[@tailcall]) q

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> not_a_tail_call = <span class="ocamlkeyword">function</span>
  | [] -&gt; []
  | x :: q -&gt; x :: <span class="ocamlhighlight">(not_a_tail_call[@tailcall]) q</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 51 [wrong-tailcall-expectation]: expected tailcall</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> f x = x [@@inline]

<span class="ocamlkeyword">let</span> () = (f[@inlined]) ()</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> fragile =
  | Int <span class="ocamlkeyword">of</span> int [@warn_on_literal_pattern]
  | String <span class="ocamlkeyword">of</span> string [@warn_on_literal_pattern]</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> fragile_match_1 = <span class="ocamlkeyword">function</span>
| Int <span class="ocamlhighlight">0</span> -&gt; ()
| _ -&gt; ()</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 52 [fragile-literal-pattern]: Code should not depend on the actual values of
this constructor's arguments. They are only for information
and may change in future versions. (See manual section 13.5)
val fragile_match_1 : fragile -&gt; unit = &lt;fun&gt;</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> fragile_match_2 = <span class="ocamlkeyword">function</span>
| String <span class="ocamlhighlight">"constant"</span> -&gt; ()
| _ -&gt; ()</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 52 [fragile-literal-pattern]: Code should not depend on the actual values of
this constructor's arguments. They are only for information
and may change in future versions. (See manual section 13.5)
val fragile_match_2 : fragile -&gt; unit = &lt;fun&gt;</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Immediate: <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t [@@immediate]
  <span class="ocamlkeyword">val</span> x: t <span class="ocamlkeyword">ref</span>
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = A | B
  <span class="ocamlkeyword">let</span> x = <span class="ocamlkeyword">ref</span> A
<span class="ocamlkeyword">end</span></div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Int_or_int64 : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t [@@immediate64]
  <span class="ocamlkeyword">val</span> zero : t
  <span class="ocamlkeyword">val</span> one : t
  <span class="ocamlkeyword">val</span> add : t -&gt; t -&gt; t
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>

  <span class="ocamlkeyword">include</span> Sys.Immediate64.Make(Int)(Int64)

  <span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">val</span> zero : t
    <span class="ocamlkeyword">val</span> one : t
    <span class="ocamlkeyword">val</span> add : t -&gt; t -&gt; t
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">let</span> impl : (<span class="ocamlkeyword">module</span> S) =
    <span class="ocamlkeyword">match</span> repr <span class="ocamlkeyword">with</span>
    | Immediate -&gt;
        (<span class="ocamlkeyword">module</span> Int : S)
    | Non_immediate -&gt;
        (<span class="ocamlkeyword">module</span> Int64 : S)

  <span class="ocamlkeyword">include</span> (<span class="ocamlkeyword">val</span> impl : S)
<span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:extension-nodes" 12.13â€ƒExtension nodes-->
<h2 class="section" id="s:extension-nodes"><a class="section-anchor" href="#s:extension-nodes" aria-hidden="true">ï»¿</a>12.13â€ƒExtension nodes</h2><!--SEC END --><!--NAME extensionnodes.html-->
<p>(Introduced in OCaml 4.02,
infix notations for constructs other than expressions added in 4.03,
infix notation (e1 ;%ext e2) added in 4.04.
)</p><p>Extension nodes are generic placeholders in the syntax tree. They are
rejected by the type-checker and are intended to be â€œexpandedâ€ by external
tools such as <span class="machine"><span class="font-tt">-ppx</span></span> rewriters.</p><p>Extension nodes share the same notion of identifier and payload as
attributesÂ <a href="#s%3Aattributes">12.12</a>.</p><p>The first form of extension node is used for â€œalgebraicâ€ categories:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="extension"><span class="nonterminal">extension</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[%</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<a class="syntax" href="#attr-payload"><span class="nonterminal">attr-payload</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-expr</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-type</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#extension"><span class="nonterminal">extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>A second form of extension node can be used in structures and
signatures, both in the module and object languages:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="item-extension"><span class="nonterminal">item-extension</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">[%%</span>â€„<a class="syntax" href="#attr-id"><span class="nonterminal">attr-id</span></a>â€„<a class="syntax" href="#attr-payload"><span class="nonterminal">attr-payload</span></a>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#item-extension"><span class="nonterminal">item-extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#item-extension"><span class="nonterminal">item-extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">class-field-spec</span></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#item-extension"><span class="nonterminal">item-extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#class-field"><span class="nonterminal">class-field</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#item-extension"><span class="nonterminal">item-extension</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>An infix form is available for extension nodes when
the payload is of the same kind
(expression with expression, pattern with pattern ...).</p><p>Examples:</p><pre>let%foo x = 2 in x + 1     === [%foo let x = 2 in x + 1]
begin%foo ... end          === [%foo begin ... end]
x ;%foo 2                  === [%foo x; 2]
module%foo M = ..          === [%%foo module M = ... ]
val%foo x : t              === [%%foo: val x : t]
</pre><p>
When this form is used together with the infix syntax for attributes,
the attributes are considered to apply to the payload:</p><pre>fun%foo[@bar] x -&gt; x + 1 === [%foo (fun x -&gt; x + 1)[@bar ] ];
</pre><p>
An additional shorthand <span class="machine"><span class="font-tt">let%foo x in ...</span></span> is available for
convenience when extension nodes are used to implement binding
operators (See <a href="#ss%3Aletops-punning">12.23.1</a>).</p><p>Furthermore, quoted strings <span class="machine"><span class="font-tt">{|...|}</span></span> can be combined with extension nodes
to embed foreign syntax fragments. Those fragments can be interpreted
by a preprocessor and turned into OCaml code without requiring escaping
quotes. A syntax shortcut is available for them:</p><pre>{%%foo|...|}               === [%%foo{|...|}]
let x = {%foo|...|}        === let x = [%foo{|...|}]
let y = {%foo bar|...|bar} === let y = [%foo{bar|...|bar}]
</pre><p>
For instance, you can use <span class="machine"><span class="font-tt">{%sql|...|}</span></span> to
represent arbitrary SQL statements â€“ assuming you have a ppx-rewriter
that recognizes the <span class="machine"><span class="font-tt">%sql</span></span> extension.</p><p>Note that the word-delimited form, for example <span class="machine"><span class="font-tt">{sql|...|sql}</span></span>, should
not be used for signaling that an extension is in use.
Indeed, the user cannot see from the code whether this string literal has
different semantics than they expect. Moreover, giving semantics to a
specific delimiter limits the freedom to change the delimiter to avoid
escaping issues.</p>
<!--TOC subsection id="ss:builtin-extension-nodes" 12.13.1â€ƒBuilt-in extension nodes-->
<h3 class="subsection" id="ss:builtin-extension-nodes"><a class="section-anchor" href="#ss:builtin-extension-nodes" aria-hidden="true">ï»¿</a>12.13.1â€ƒBuilt-in extension nodes</h3><!--SEC END --><p>(Introduced in OCaml 4.03)</p><p>Some extension nodes are understood by the compiler itself:
</p><ul class="itemize"><li class="li-itemize">â€œocaml.extension_constructorâ€ or â€œextension_constructorâ€
take as payload a constructor from an extensible variant type
(see <a href="#s%3Aextensible-variants">12.14</a>) and return its extension
constructor slot.
</li></ul><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = ..
<span class="ocamlkeyword">type</span> t += X <span class="ocamlkeyword">of</span> int | Y <span class="ocamlkeyword">of</span> string
<span class="ocamlkeyword">let</span> x = [%extension_constructor X]
<span class="ocamlkeyword">let</span> y = [%extension_constructor Y]</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span>  x &lt;&gt; y;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div>
<!--TOC section id="s:extensible-variants" 12.14â€ƒExtensible variant types-->
<h2 class="section" id="s:extensible-variants"><a class="section-anchor" href="#s:extensible-variants" aria-hidden="true">ï»¿</a>12.14â€ƒExtensible variant types</h2><!--SEC END --><!--NAME extensiblevariants.html-->
<p>(Introduced in OCaml 4.02)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-representation"><span class="nonterminal">type-representation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">..</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">type</span>â€„[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>â€„<a class="syntax" href="#type-extension-spec"><span class="nonterminal">type-extension-spec</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">type</span>â€„[<a class="syntax" href="#type-params"><span class="nonterminal">type-params</span></a>]â€„<a class="syntax" href="#typeconstr"><span class="nonterminal">typeconstr</span></a>â€„<a class="syntax" href="#type-extension-def"><span class="nonterminal">type-extension-def</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-extension-spec"><span class="nonterminal">type-extension-spec</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">+=</span>â€„[<span class="syntax-token">private</span>]â€„[<span class="syntax-token">|</span>]â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="type-extension-def"><span class="nonterminal">type-extension-def</span></a></td><td class="c005">::=</td><td class="c007">â€„<span class="syntax-token">+=</span>â€„[<span class="syntax-token">private</span>]â€„[<span class="syntax-token">|</span>]â€„<a class="syntax" href="#constr-def"><span class="nonterminal">constr-def</span></a>â€„{â€„<span class="syntax-token">|</span>â€„<a class="syntax" href="#constr-def"><span class="nonterminal">constr-def</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="constr-def"><span class="nonterminal">constr-def</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#constr-decl"><span class="nonterminal">constr-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#constr-name"><span class="nonterminal">constr-name</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Extensible variant types are variant types which can be extended with
new variant constructors. Extensible variant types are defined using
<span class="machine"><span class="font-tt">..</span></span>. New variant constructors are added using <span class="machine"><span class="font-tt">+=</span></span>.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Expr = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> attr = ..

  <span class="ocamlkeyword">type</span> attr += Str <span class="ocamlkeyword">of</span> string

  <span class="ocamlkeyword">type</span> attr +=
    | Int <span class="ocamlkeyword">of</span> int
    | Float <span class="ocamlkeyword">of</span> float
<span class="ocamlkeyword">end</span></div></div>

</div><p>Pattern matching on an extensible variant type requires a default case
to handle unknown variant constructors:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> to_string = <span class="ocamlkeyword">function</span>
  | Expr.Str s -&gt; s
  | Expr.Int i -&gt; Int.to_string i
  | Expr.Float f -&gt; string_of_float f
  | _ -&gt; <span class="ocamlstring">"?"</span></div></div>

</div><p>A preexisting example of an extensible variant type is the built-in
<span class="machine"><span class="font-tt">exn</span></span> type used for exceptions. Indeed, exception constructors can be
declared using the type extension syntax:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> exn += Exc <span class="ocamlkeyword">of</span> int</div></div>

</div><p>Extensible variant constructors can be rebound to a different name. This
allows exporting variants from another module.

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> not_in_scope = <span class="ocamlhighlight">Str</span> <span class="ocamlstring">"Foo"</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Unbound constructor Str</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> Expr.attr += Str = Expr.Str</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> now_works = Str <span class="ocamlstring">"foo"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> now_works : Expr.attr = Expr.Str <span class="ocamlstring">"foo"</span></div></div>

</div><p>Extensible variant constructors can be declared <span class="machine"><span class="font-tt">private</span></span>. As with
regular variants, this prevents them from being constructed directly by
constructor application while still allowing them to be de-structured in
pattern-matching.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> B : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> Expr.attr += <span class="ocamlkeyword">private</span> Bool <span class="ocamlkeyword">of</span> int
  <span class="ocamlkeyword">val</span> bool : bool -&gt; Expr.attr
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> Expr.attr += Bool <span class="ocamlkeyword">of</span> int
  <span class="ocamlkeyword">let</span> bool p = <span class="ocamlkeyword">if</span> p <span class="ocamlkeyword">then</span> Bool 1 <span class="ocamlkeyword">else</span> Bool 0
<span class="ocamlkeyword">end</span></div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> inspection_works = <span class="ocamlkeyword">function</span>
    | B.Bool p -&gt; (p = 1)
    | _ -&gt; <span class="ocamlkeyword">true</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> inspection_works : Expr.attr -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> construction_is_forbidden = <span class="ocamlhighlight">B.Bool 1</span>;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Cannot use private constructor Bool to create values of type Expr.attr</div></div>

</div>
<!--TOC subsection id="ss:private-extensible" 12.14.1â€ƒPrivate extensible variant types-->
<h3 class="subsection" id="ss:private-extensible"><a class="section-anchor" href="#ss:private-extensible" aria-hidden="true">ï»¿</a>12.14.1â€ƒPrivate extensible variant types</h3><!--SEC END --><p>(Introduced in OCaml 4.06)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-representation"><span class="nonterminal">type-representation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">private</span>â€„<span class="syntax-token">..</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Extensible variant types can be declared <span class="machine"><span class="font-tt">private</span></span>. This prevents new
constructors from being declared directly, but allows extension
constructors to be referred to in interfaces.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Msg : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> t = <span class="ocamlkeyword">private</span> ..
  <span class="ocamlkeyword">module</span> MkConstr (X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">end</span>) : <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> t += C <span class="ocamlkeyword">of</span> X.t
  <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = ..
  <span class="ocamlkeyword">module</span> MkConstr (X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">end</span>) = <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">type</span> t += C <span class="ocamlkeyword">of</span> X.t
  <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC section id="s:generative-functors" 12.15â€ƒGenerative functors-->
<h2 class="section" id="s:generative-functors"><a class="section-anchor" href="#s:generative-functors" aria-hidden="true">ï»¿</a>12.15â€ƒGenerative functors</h2><!--SEC END --><!--NAME generativefunctors.html-->
<p>(Introduced in OCaml 4.02)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">functor</span>â€„<span class="syntax-token">()</span>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">()</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„âˆ£â€„<span class="syntax-token">()</span>â€„}
[â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„]â€„â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">functor</span>â€„<span class="syntax-token">()</span>â€„<span class="syntax-token">-&gt;</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">module</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„{â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#module-name"><span class="nonterminal">module-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>â€„<span class="syntax-token">)</span>â€„âˆ£â€„<span class="syntax-token">()</span>â€„}
<span class="syntax-token">:</span>â€„<a class="syntax" href="#module-type"><span class="nonterminal">module-type</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>A generative functor takes a unit <span class="machine"><span class="font-tt">()</span></span> argument.
In order to use it, one must necessarily apply it to this unit argument,
ensuring that all type components in the result of the functor behave
in a generative way, <em>i.e.</em> they are different from types obtained
by other applications of the same functor.
This is equivalent to taking an argument of signature <span class="machine"><span class="font-tt">sig end</span></span>, and always
applying to <span class="machine"><span class="font-tt">struct end</span></span>, but not to some defined module (in the
latter case, applying twice to the same module would return identical
types).</p><p>As a side-effect of this generativity, one is allowed to unpack
first-class modules in the body of generative functors.</p>
<!--TOC section id="s:extension-syntax" 12.16â€ƒExtension-only syntax-->
<h2 class="section" id="s:extension-syntax"><a class="section-anchor" href="#s:extension-syntax" aria-hidden="true">ï»¿</a>12.16â€ƒExtension-only syntax</h2><!--SEC END --><!--NAME extensionsyntax.html-->
<p>(Introduced in OCaml 4.02.2, extended in 4.03)</p><p>Some syntactic constructions are accepted during parsing and rejected
during type checking. These syntactic constructions can therefore not
be used directly in vanilla OCaml. However, <span class="machine"><span class="font-tt">-ppx</span></span> rewriters and other
external tools can exploit this parser leniency to extend the language
with these new syntactic constructions by rewriting them to
vanilla constructions.
</p>
<!--TOC subsection id="ss:extension-operators" 12.16.1â€ƒExtension operators-->
<h3 class="subsection" id="ss:extension-operators"><a class="section-anchor" href="#ss:extension-operators" aria-hidden="true">ï»¿</a>12.16.1â€ƒExtension operators</h3><!--SEC END --><p> <a id="s:ext-ops"></a>
(Introduced in OCaml 4.02.2, extended to unary operators in OCaml 4.12.0)
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="nonterminal">infix-symbol</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">#</span>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}â€„<span class="syntax-token">#</span>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">#</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">prefix-symbol</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„(<span class="syntax-token">?</span>â€„âˆ£â€„<span class="syntax-token">~</span>â€„âˆ£â€„<span class="syntax-token">!</span>)â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}â€„<span class="syntax-token">#</span>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">#</span>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>There are two classes of operators available for extensions:
infix operators with a name starting with a <span class="machine"><span class="font-tt">#</span></span> character and containing more
than one <span class="machine"><span class="font-tt">#</span></span> character, and unary operators with a name (starting with a <span class="machine"><span class="font-tt">?</span></span>,
<span class="machine"><span class="font-tt">~</span></span>, or <span class="machine"><span class="font-tt">!</span></span> character) containing at least one <span class="machine"><span class="font-tt">#</span></span> character.</p><p>For instance:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> infix x y = x<span class="ocamlhighlight">##</span>y;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: '##' is not a valid value identifier.</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> prefix x = <span class="ocamlhighlight">!#</span>x;;</div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: '!#' is not a valid value identifier.</div></div>

</div><p>

Note that both <span class="machine"><span class="font-tt">##</span></span> and <span class="machine"><span class="font-tt">!#</span></span> must be eliminated by a ppx rewriter to make
this example valid.</p>
<!--TOC subsection id="ss:extension-literals" 12.16.2â€ƒExtension literals-->
<h3 class="subsection" id="ss:extension-literals"><a class="section-anchor" href="#ss:extension-literals" aria-hidden="true">ï»¿</a>12.16.2â€ƒExtension literals</h3><!--SEC END --><p>
(Introduced in OCaml 4.03)
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><span class="nonterminal">float-literal</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}â€„[<span class="syntax-token">.</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[(<span class="syntax-token">e</span>â€„âˆ£â€„<span class="syntax-token">E</span>)â€„[<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0x</span>â€„âˆ£â€„<span class="syntax-token">0X</span>)
(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
[<span class="syntax-token">.</span>â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[(<span class="syntax-token">p</span>â€„âˆ£â€„<span class="syntax-token">P</span>)â€„[<span class="syntax-token">+</span>â€„âˆ£â€„<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}]
[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="int-literal"><span class="nonterminal">int-literal</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0x</span>â€„âˆ£â€„<span class="syntax-token">0X</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>)
{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">9</span>â€„âˆ£â€„<span class="syntax-token">A</span>â€¦<span class="syntax-token">F</span>â€„âˆ£â€„<span class="syntax-token">a</span>â€¦<span class="syntax-token">f</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0o</span>â€„âˆ£â€„<span class="syntax-token">0O</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">7</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„[<span class="syntax-token">-</span>]â€„(<span class="syntax-token">0b</span>â€„âˆ£â€„<span class="syntax-token">0B</span>)â€„(<span class="syntax-token">0</span>â€¦<span class="syntax-token">1</span>)â€„{â€„<span class="syntax-token">0</span>â€¦<span class="syntax-token">1</span>â€„âˆ£â€„<span class="syntax-token">_</span>â€„}
[<span class="syntax-token">g</span>â€¦<span class="syntax-token">z</span>â€„âˆ£â€„<span class="syntax-token">G</span>â€¦<span class="syntax-token">Z</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>
Int and float literals followed by an one-letter identifier in the
range [<span class="syntax-token">g</span>..<span class="syntax-token">z</span>âˆ£<span class="syntax-token">G</span>..<span class="syntax-token">Z</span>] are extension-only literals.
</p>
<!--TOC section id="s:inline-records" 12.17â€ƒInline records-->
<h2 class="section" id="s:inline-records"><a class="section-anchor" href="#s:inline-records" aria-hidden="true">ï»¿</a>12.17â€ƒInline records</h2><!--SEC END --><!--NAME inlinerecords.html-->
<p>(Introduced in OCaml 4.03)
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008">â€„â€„<span class="nonterminal">constr-args</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#record-decl"><span class="nonterminal">record-decl</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>The arguments of sum-type constructors can now be defined using the
same syntax as records. Mutable and polymorphic fields are allowed.
GADT syntax is supported. Attributes can be specified on individual
fields.</p><p>Syntactically, building or matching constructors with such an inline
record argument is similar to working with a unary constructor whose
unique argument is a declared record type. A pattern can bind
the inline record as a pseudo-value, but the record cannot escape the
scope of the binding and can only be used with the dot-notation to
extract or modify fields or to build new constructor values.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t =
  | Point <span class="ocamlkeyword">of</span> {width: int; <span class="ocamlkeyword">mutable</span> x: float; <span class="ocamlkeyword">mutable</span> y: float}
  | Other

<span class="ocamlkeyword">let</span> v = Point {width = 10; x = 0.; y = 0.}

<span class="ocamlkeyword">let</span> scale l = <span class="ocamlkeyword">function</span>
  | Point p -&gt; Point {p <span class="ocamlkeyword">with</span> x = l *. p.x; y = l *. p.y}
  | Other -&gt; Other

<span class="ocamlkeyword">let</span> print = <span class="ocamlkeyword">function</span>
  | Point {x; y; _} -&gt; Printf.printf <span class="ocamlstring">"%f/%f"</span> x y
  | Other -&gt; ()

<span class="ocamlkeyword">let</span> reset = <span class="ocamlkeyword">function</span>
  | Point p -&gt; p.x &lt;- 0.; p.y &lt;- 0.
  | Other -&gt; ()</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> invalid = <span class="ocamlkeyword">function</span>
  | Point p -&gt; <span class="ocamlhighlight">p</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: This form is not allowed as the type of the inlined record could escape.</div></div>

</div>
<!--TOC section id="s:doc-comments" 12.18â€ƒDocumentation comments-->
<h2 class="section" id="s:doc-comments"><a class="section-anchor" href="#s:doc-comments" aria-hidden="true">ï»¿</a>12.18â€ƒDocumentation comments</h2><!--SEC END --><!--NAME doccomments.html-->
<p>(Introduced in OCaml 4.03)</p><p>Comments which start with <span class="machine"><span class="font-tt">**</span></span> are treated specially by the
compiler. They are automatically converted during parsing into
attributes (see <a href="#s%3Aattributes">12.12</a>) to allow tools to process them as
documentation.</p><p>Such comments can take three forms: <em>floating comments</em>, <em>item
comments</em> and <em>label comments</em>. Any comment starting with <span class="machine"><span class="font-tt">**</span></span> which
does not match one of these forms will cause the compiler to emit
warning 50.</p><p>Comments which start with <span class="machine"><span class="font-tt">**</span></span> are also used by the ocamldoc
documentation generator (see <a href="#c%3Aocamldoc">19</a>). The three comment forms
recognised by the compiler are a subset of the forms accepted by
ocamldoc (see <a href="#s%3Aocamldoc-comments">19.2</a>).</p>
<!--TOC subsection id="ss:floating-comments" 12.18.1â€ƒFloating comments-->
<h3 class="subsection" id="ss:floating-comments"><a class="section-anchor" href="#ss:floating-comments" aria-hidden="true">ï»¿</a>12.18.1â€ƒFloating comments</h3><!--SEC END --><p>Comments surrounded by blank lines that appear within structures,
signatures, classes or class types are converted into
<a class="syntax" href="#floating-attribute"><span class="nonterminal">floating-attribute</span></a>s. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T

<span class="ocamlcomment">(** Now some definitions for [t] *)</span>

<span class="ocamlkeyword">let</span> mkT = T</div></div>

</div><p>will be converted to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T

[@@@ocaml.text <span class="ocamlstring">" Now some definitions for [t] "</span>]

<span class="ocamlkeyword">let</span> mkT = T</div></div>

</div>
<!--TOC subsection id="ss:item-comments" 12.18.2â€ƒItem comments-->
<h3 class="subsection" id="ss:item-comments"><a class="section-anchor" href="#ss:item-comments" aria-hidden="true">ï»¿</a>12.18.2â€ƒItem comments</h3><!--SEC END --><p>Comments which appear <em>immediately before</em> or <em>immediately
after</em> a structure item, signature item, class item or class type item
are converted into <a class="syntax" href="#item-attribute"><span class="nonterminal">item-attribute</span></a>s. Immediately before or immediately
after means that there must be no blank lines, <span class="machine"><span class="font-tt">;;</span></span>, or other
documentation comments between them. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T
<span class="ocamlcomment">(** A description of [t] *)</span></div></div>

</div><p>or</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(** A description of [t] *)</span>
<span class="ocamlkeyword">type</span> t = T</div></div>

</div><p>will be converted to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T
[@@ocaml.doc <span class="ocamlstring">" A description of [t] "</span>]</div></div>

</div><p>Note that, if a comment appears immediately next to multiple items,
as in:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T
<span class="ocamlcomment">(** An ambiguous comment *)</span>
<span class="ocamlkeyword">type</span> s = S</div></div>

</div><p>then it will be attached to both items:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T
[@@ocaml.doc <span class="ocamlstring">" An ambiguous comment "</span>]
<span class="ocamlkeyword">type</span> s = S
[@@ocaml.doc <span class="ocamlstring">" An ambiguous comment "</span>]</div></div>

</div><p>and the compiler will emit warning 50.</p>
<!--TOC subsection id="ss:label-comments" 12.18.3â€ƒLabel comments-->
<h3 class="subsection" id="ss:label-comments"><a class="section-anchor" href="#ss:label-comments" aria-hidden="true">ï»¿</a>12.18.3â€ƒLabel comments</h3><!--SEC END --><p>Comments which appear <em>immediately after</em> a labelled argument,
record field, variant constructor, object method or polymorphic variant
constructor are are converted into <a class="syntax" href="#attribute"><span class="nonterminal">attribute</span></a>s. Immediately
after means that there must be no blank lines or other documentation
comments between them. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t1 = lbl:int <span class="ocamlcomment">(** Labelled argument *)</span> -&gt; unit

<span class="ocamlkeyword">type</span> t2 = {
  fld: int; <span class="ocamlcomment">(** Record field *)</span>
  fld2: float;
}

<span class="ocamlkeyword">type</span> t3 =
  | Cstr <span class="ocamlkeyword">of</span> string <span class="ocamlcomment">(** Variant constructor *)</span>
  | Cstr2 <span class="ocamlkeyword">of</span> string

<span class="ocamlkeyword">type</span> t4 = &lt; meth: int * int; <span class="ocamlcomment">(** Object method *)</span> &gt;

<span class="ocamlkeyword">type</span> t5 = [
  `PCstr <span class="ocamlcomment">(** Polymorphic variant constructor *)</span>
]</div></div>

</div><p>will be converted to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t1 = lbl:(int [@ocaml.doc <span class="ocamlstring">" Labelled argument "</span>]) -&gt; unit

<span class="ocamlkeyword">type</span> t2 = {
  fld: int [@ocaml.doc <span class="ocamlstring">" Record field "</span>];
  fld2: float;
}

<span class="ocamlkeyword">type</span> t3 =
  | Cstr <span class="ocamlkeyword">of</span> string [@ocaml.doc <span class="ocamlstring">" Variant constructor "</span>]
  | Cstr2 <span class="ocamlkeyword">of</span> string

<span class="ocamlkeyword">type</span> t4 = &lt; meth : int * int [@ocaml.doc <span class="ocamlstring">" Object method "</span>] &gt;

<span class="ocamlkeyword">type</span> t5 = [
  `PCstr [@ocaml.doc <span class="ocamlstring">" Polymorphic variant constructor "</span>]
]</div></div>

</div><p>Note that label comments take precedence over item comments, so:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T <span class="ocamlkeyword">of</span> string
<span class="ocamlcomment">(** Attaches to T not t *)</span></div></div>

</div><p>will be converted to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t =  T <span class="ocamlkeyword">of</span> string [@ocaml.doc <span class="ocamlstring">" Attaches to T not t "</span>]</div></div>

</div><p>whilst:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T <span class="ocamlkeyword">of</span> string
<span class="ocamlcomment">(** Attaches to T not t *)</span>
<span class="ocamlcomment">(** Attaches to t *)</span></div></div>

</div><p>will be converted to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t =  T <span class="ocamlkeyword">of</span> string [@ocaml.doc <span class="ocamlstring">" Attaches to T not t "</span>]
[@@ocaml.doc <span class="ocamlstring">" Attaches to t "</span>]</div></div>

</div><p>In the absence of meaningful comment on the last constructor of
a type, an empty commentÂ <span class="machine"><span class="font-tt">(**)</span></span> can be used instead:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = T <span class="ocamlkeyword">of</span> string
<span class="ocamlcomment">(**)</span>
<span class="ocamlcomment">(** Attaches to t *)</span></div></div>

</div><p>will be converted directly to</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t =  T <span class="ocamlkeyword">of</span> string
[@@ocaml.doc <span class="ocamlstring">" Attaches to t "</span>]</div></div>

</div>
<!--TOC section id="s:index-operators" 12.19â€ƒExtended indexing operators -->
<h2 class="section" id="s:index-operators"><a class="section-anchor" href="#s:index-operators" aria-hidden="true">ï»¿</a>12.19â€ƒExtended indexing operators </h2><!--SEC END --><!--NAME indexops.html-->
<p>(Introduced in 4.06)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008">
<a class="syntax" id="dot-ext"><span class="nonterminal">dot-ext</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#dot-operator-char"><span class="nonterminal">dot-operator-char</span></a>â€„{â€„<a class="syntax" href="#operator-char"><span class="nonterminal">operator-char</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="dot-operator-char"><span class="nonterminal">dot-operator-char</span></a></td><td class="c005">::=</td><td class="c007">
<span class="syntax-token">!</span>â€„âˆ£â€„<span class="syntax-token">?</span>â€„âˆ£â€„<a class="syntax" href="#core-operator-char"><span class="nonterminal">core-operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">%</span>â€„âˆ£â€„<span class="syntax-token">:</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„[<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>]â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„(â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">)</span>â€„âˆ£â€„<span class="syntax-token">[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">]</span>â€„âˆ£â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">}</span>â€„)â€„[â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">operator-name</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„(<span class="syntax-token">()</span>â€„âˆ£â€„<span class="syntax-token">[]</span>â€„âˆ£â€„<span class="syntax-token">{}</span>)â€„[<span class="syntax-token">&lt;-</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>This extension provides syntactic sugar for getting and setting elements
for user-defined indexed types. For instance, we can define python-like
dictionaries with

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Dict = <span class="ocamlkeyword">struct</span>
<span class="ocamlkeyword">include</span> Hashtbl
<span class="ocamlkeyword">let</span> ( .%{} ) tabl index = find tabl index
<span class="ocamlkeyword">let</span> ( .%{}&lt;- ) tabl index value = add tabl index value
<span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">let</span> dict =
  <span class="ocamlkeyword">let</span> dict = Dict.create 10 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> () =
    dict.Dict.%{<span class="ocamlstring">"one"</span>} &lt;- 1;
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> Dict <span class="ocamlkeyword">in</span>
    dict.%{<span class="ocamlstring">"two"</span>} &lt;- 2 <span class="ocamlkeyword">in</span>
  dict</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> dict.Dict.%{<span class="ocamlstring">"one"</span>};;</div>



<div class="pre caml-output ok">- : int = 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> Dict <span class="ocamlkeyword">in</span> dict.%{<span class="ocamlstring">"two"</span>};;</div>



<div class="pre caml-output ok">- : int = 2</div></div>

</div>
<!--TOC subsection id="ss:multiindexing" 12.19.1â€ƒMulti-index notation-->
<h3 class="subsection" id="ss:multiindexing"><a class="section-anchor" href="#ss:multiindexing" aria-hidden="true">ï»¿</a>12.19.1â€ƒMulti-index notation</h3><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„[<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>]â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">)</span>â€„[â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„[<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>]â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„<span class="syntax-token">[</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">]</span>â€„[â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">.</span>â€„[<a class="syntax" href="#module-path"><span class="nonterminal">module-path</span></a>â€„<span class="syntax-token">.</span>]â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„<span class="syntax-token">{</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„{â€„<span class="syntax-token">;</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">}</span>â€„[â€„<span class="syntax-token">&lt;-</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">operator-name</span></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#dot-ext"><span class="nonterminal">dot-ext</span></a>â€„(<span class="syntax-token">(;..)</span>â€„âˆ£â€„<span class="syntax-token">[;..]</span>â€„âˆ£â€„<span class="syntax-token">{;..}</span>)â€„[<span class="syntax-token">&lt;-</span>]
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Multi-index are also supported through a second variant of indexing operators</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> (.%[;..]) = Bigarray.Genarray.get
<span class="ocamlkeyword">let</span> (.%{;..}) = Bigarray.Genarray.get
<span class="ocamlkeyword">let</span> (.%(;..)) = Bigarray.Genarray.get</div></div>

</div><p>which is called when an index literals contain a semicolon separated list
of expressions with two and more elements:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> sum x y = x.%[1;2;3] + y.%[1;2]
<span class="ocamlcomment">(* is equivalent to *)</span>
<span class="ocamlkeyword">let</span> sum x y = (.%[;..]) x [|1;2;3|] + (.%[;..]) y [|1;2|]</div></div>

</div><p>In particular this multi-index notation makes it possible to uniformly handle
indexing Genarray and other implementations of multidimensional arrays.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> A = Bigarray.Genarray
<span class="ocamlkeyword">let</span> (.%{;..}) = A.get
<span class="ocamlkeyword">let</span> (.%{;..}&lt;- ) = A.set
<span class="ocamlkeyword">let</span> (.%{ }) a k = A.get a [|k|]
<span class="ocamlkeyword">let</span> (.%{ }&lt;-) a k x = A.set a [|k|] x
<span class="ocamlkeyword">let</span> syntax_compare vec mat t3 t4 =
          vec.%{0} = A.get vec [|0|]
   &amp;&amp;   mat.%{0;0} = A.get mat [|0;0|]
   &amp;&amp;   t3.%{0;0;0} = A.get t3 [|0;0;0|]
   &amp;&amp; t4.%{0;0;0;0} = t4.{0,0,0,0}</div></div>

</div><p>Beware that the differentiation between the multi-index and single index
operators is purely syntactic: multi-index operators are restricted to
index expressions that contain one or more semicolons <span class="machine"><span class="font-tt">;</span></span>. For instance,

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">  <span class="ocamlkeyword">let</span> pair vec mat = vec.%{0}, mat.%{0;0}</div></div>

</div><p>

is equivalent to

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">  <span class="ocamlkeyword">let</span> pair vec mat = (.%{ }) vec 0, (.%{;..}) mat [|0;0|]</div></div>

</div><p>

Notice that in the <span class="machine"><span class="font-tt">vec</span></span> case, we are calling the single index operator, <span class="machine"><span class="font-tt">(.%{})</span></span>, and
not the multi-index variant, <span class="machine"><span class="font-tt">(.{;..})</span></span>.
For this reason, it is expected that most users of multi-index operators will need
to define conjointly a single index variant

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> (.%{;..}) = A.get
<span class="ocamlkeyword">let</span> (.%{ }) a k = A.get a [|k|]</div></div>

</div><p>

to handle both cases uniformly.
</p>
<!--TOC section id="s:empty-variants" 12.20â€ƒEmpty variant types-->
<h2 class="section" id="s:empty-variants"><a class="section-anchor" href="#s:empty-variants" aria-hidden="true">ï»¿</a>12.20â€ƒEmpty variant types</h2><!--SEC END --><!--NAME emptyvariants.html-->
<p>
(Introduced in 4.07.0)
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#type-representation"><span class="nonterminal">type-representation</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">=</span>â€„<span class="syntax-token">|</span>
</td></tr>
</table></td></tr>
</table></div><p>
This extension allows user to define empty variants.
Empty variant type can be eliminated by refutation case of pattern matching.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t = |
<span class="ocamlkeyword">let</span> f (x: t) = <span class="ocamlkeyword">match</span> x <span class="ocamlkeyword">with</span> _ -&gt; .</div></div>

</div>
<!--TOC section id="s:alerts" 12.21â€ƒAlerts-->
<h2 class="section" id="s:alerts"><a class="section-anchor" href="#s:alerts" aria-hidden="true">ï»¿</a>12.21â€ƒAlerts</h2><!--SEC END --><!--NAME alerts.html-->
<p>(Introduced in 4.08)</p><p>Since OCaml 4.08, it is possible to mark components (such as value or
type declarations) in signatures with â€œalertsâ€ that will be reported
when those components are referenced. This generalizes the notion of
â€œdeprecatedâ€ components which were previously reported as warning 3.
Those alerts can be used for instance to report usage of unsafe
features, or of features which are only available on some platforms,
etc.</p><p>Alert categories are identified by a symbolic identifier (a lowercase
identifier, following the usual lexical rules) and an optional
message. The identifier is used to control which alerts are enabled,
and which ones are turned into fatal errors. The message is reported
to the user when the alert is triggered (i.e. when the marked
component is referenced).</p><p>The <span class="machine"><span class="font-tt">ocaml.alert</span></span> or <span class="machine"><span class="font-tt">alert</span></span> attribute serves two purposes: (i) to
mark component with an alert to be triggered when the component is
referenced, and (ii) to control which alert names are enabled. In the
first form, the attribute takes an identifier possibly
followed by a message. Here is an example of a value declaration marked
with an alert:</p><pre>module U: sig
  val fork: unit -&gt; bool
    [@@alert unix "This function is only available under Unix."]
end
</pre><p>
Here <span class="machine"><span class="font-tt">unix</span></span> is the identifier for the alert. If this alert category
is enabled, any reference to <span class="machine"><span class="font-tt">U.fork</span></span> will produce a message at
compile time, which can be turned or not into a fatal error.</p><p>And here is another example as a floating attribute on top
of an â€œ.mliâ€ file (i.e. before any other non-attribute item)
or on top of an â€œ.mlâ€ file without a corresponding interface file,
so that any reference to that unit will trigger the alert:</p><pre>[@@@alert unsafe "This module is unsafe!"]
</pre><p>Controlling which alerts are enabled and whether they are turned into
fatal errors is done either through the compilerâ€™s command-line option
<span class="machine"><span class="font-tt">-alert &lt;spec&gt;</span></span> or locally in the code through the <span class="machine"><span class="font-tt">alert</span></span> or
<span class="machine"><span class="font-tt">ocaml.alert</span></span> attribute taking a single string payload <span class="machine"><span class="font-tt">&lt;spec&gt;</span></span>. In
both cases, the syntax for <span class="machine"><span class="font-tt">&lt;spec&gt;</span></span> is a concatenation of items of the
form:</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">+id</span></span> enables alert <span class="machine"><span class="font-tt">id</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">-id</span></span> disables alert <span class="machine"><span class="font-tt">id</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">++id</span></span> turns alert <span class="machine"><span class="font-tt">id</span></span> into a fatal error.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">--id</span></span> turns alert <span class="machine"><span class="font-tt">id</span></span> into non-fatal mode.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">@id</span></span> equivalent to <span class="machine"><span class="font-tt">++id+id</span></span> (enables <span class="machine"><span class="font-tt">id</span></span> and turns it into a fatal-error)
</li></ul><p>As a special case, if <span class="machine"><span class="font-tt">id</span></span> is <span class="machine"><span class="font-tt">all</span></span>, it stands for all alerts.</p><p>Here are some examples:</p><pre>
(* Disable all alerts, reenables just unix (as a soft alert) and window
   (as a fatal-error), for the rest of the current structure *)

[@@@alert "-all--all+unix@window"]
 ...

let x =
  (* Locally disable the window alert *)
  begin[@alert "-window"]
      ...
  end
</pre><p>
Before OCaml 4.08, there was support for a single kind of deprecation
alert. It is now known as the <span class="machine"><span class="font-tt">deprecated</span></span> alert, but legacy
attributes to trigger it and the legacy ways to control it as warning
3 are still supported. For instance, passing <span class="machine"><span class="font-tt">-w +3</span></span> on the
command-line is equivant to <span class="machine"><span class="font-tt">-alert +deprecated</span></span>, and:</p><pre>val x: int
  [@@@ocaml.deprecated "Please do something else"]
</pre><p>
is equivalent to:</p><pre>val x: int
  [@@@ocaml.alert deprecated "Please do something else"]
</pre>
<!--TOC section id="s:generalized-open" 12.22â€ƒGeneralized open statements-->
<h2 class="section" id="s:generalized-open"><a class="section-anchor" href="#s:generalized-open" aria-hidden="true">ï»¿</a>12.22â€ƒGeneralized open statements</h2><!--SEC END --><!--NAME generalizedopens.html-->
<p>(Introduced in 4.08)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open</span>â€„â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#specification"><span class="nonterminal">specification</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open</span>â€„â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#extended-module-path"><span class="nonterminal">extended-module-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open</span>â€„â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„<span class="syntax-token">open!</span>â€„<a class="syntax" href="#module-expr"><span class="nonterminal">module-expr</span></a>â€„<span class="syntax-token">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>This extension makes it possible to open any module expression in
module structures and expressions. A similar mechanism is also available
inside module types, but only for extended module paths (e.g. <span class="machine"><span class="font-tt">F(X).G(Y)</span></span>).</p><p>For instance, a module can be constrained when opened with</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">let</span> x = 0 <span class="ocamlkeyword">let</span> hidden = 1 <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">open</span> (M:<span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> x: int <span class="ocamlkeyword">end</span>)
<span class="ocamlkeyword">let</span> y = <span class="ocamlhighlight">hidden</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: Unbound value hidden</div></div>

</div><p>Another possibility is to immediately open the result of a functor application</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">  <span class="ocamlkeyword">let</span> sort (<span class="ocamlkeyword">type</span> x) (x:x list) =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> Set.Make(<span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = x <span class="ocamlkeyword">let</span> compare=compare <span class="ocamlkeyword">end</span>) <span class="ocamlkeyword">in</span>
    elements (of_list x)</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sort : 'x list -&gt; 'x list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Going further, this construction can introduce local components inside a
structure,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">let</span> x = 0
  <span class="ocamlkeyword">open</span>! <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">let</span> x = 0
    <span class="ocamlkeyword">let</span> y = 1
  <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">let</span> w = x + y
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> x : int <span class="ocamlkeyword">val</span> w : int <span class="ocamlkeyword">end</span></div></div>

</div><p>One important restriction is that types introduced by <span class="syntax-token">open</span> <span class="syntax-token">struct</span> ...
<span class="syntax-token">end</span> cannot appear in the signature of the enclosing structure, unless they
are defined equal to some non-local type.
So:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">open</span> <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> 'a t = 'a option = None | Some <span class="ocamlkeyword">of</span> 'a <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">let</span> x : int t = Some 1
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">val</span> x : int option <span class="ocamlkeyword">end</span></div></div>

</div><p>

is OK, but:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span>
  <span class="ocamlhighlight">open struct type t = A end</span>
  <span class="ocamlkeyword">let</span> x = A
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: The type t/568 introduced by this open appears in the signature
       File "extensions/generalizedopens.etex", line 3, characters 6-7:
         The value x has no valid type if t/568 is hidden</div></div>

</div><p>

is not because <span class="machine"><span class="font-tt">x</span></span> cannot be given any type other than <span class="machine"><span class="font-tt">t</span></span>, which only exists
locally. Although the above would be OK if <span class="machine"><span class="font-tt">x</span></span> too was local:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> M: <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">open</span> <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> t = A
  <span class="ocamlkeyword">end</span>
  â€¦
  <span class="ocamlkeyword">open</span> <span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">let</span> x = A <span class="ocamlkeyword">end</span>
  â€¦
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> M : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span></div></div>

</div><p>Inside signatures, extended opens are limited to extended module paths,

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">module</span> F: <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span> -&gt; <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">module</span> X: <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">open</span> F(X)
  <span class="ocamlkeyword">val</span> f: t
<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> S =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">module</span> F : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span> -&gt; <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">type</span> t <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">module</span> X : <span class="ocamlkeyword">sig</span> <span class="ocamlkeyword">end</span>
    <span class="ocamlkeyword">val</span> f : F(X).t
  <span class="ocamlkeyword">end</span></div></div>

</div><p>and not</p><pre>  open struct type t = int end
</pre><p>
In those situations, local substitutions(see <a href="#ss%3Alocal-substitution">12.7.2</a>)
can be used instead.</p><p>Beware that this extension is not available inside class definitions:</p><pre>class c =
  let open Set.Make(Int) in
  ...
</pre>
<!--TOC section id="s:binding-operators" 12.23â€ƒBinding operators-->
<h2 class="section" id="s:binding-operators"><a class="section-anchor" href="#s:binding-operators" aria-hidden="true">ï»¿</a>12.23â€ƒBinding operators</h2><!--SEC END --><!--NAME bindingops.html-->
<p>(Introduced in 4.08.0)</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="let-operator"><span class="nonterminal">let-operator</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">let</span>â€„(<a class="syntax" href="#core-operator-char"><span class="nonterminal">core-operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">&lt;</span>)â€„{â€„<a class="syntax" href="#dot-operator-char"><span class="nonterminal">dot-operator-char</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="and-operator"><span class="nonterminal">and-operator</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">and</span>â€„(<a class="syntax" href="#core-operator-char"><span class="nonterminal">core-operator-char</span></a>â€„âˆ£â€„<span class="syntax-token">&lt;</span>)â€„{â€„<a class="syntax" href="#dot-operator-char"><span class="nonterminal">dot-operator-char</span></a>â€„}
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<span class="nonterminal">operator-name</span>â€„</td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#let-operator"><span class="nonterminal">let-operator</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#and-operator"><span class="nonterminal">and-operator</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="letop-binding"><span class="nonterminal">letop-binding</span></a>â€„</td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#let-operator"><span class="nonterminal">let-operator</span></a>â€„<a class="syntax" href="#letop-binding"><span class="nonterminal">letop-binding</span></a>â€„{â€„<a class="syntax" href="#and-operator"><span class="nonterminal">and-operator</span></a>â€„<a class="syntax" href="#letop-binding"><span class="nonterminal">letop-binding</span></a>â€„}â€„<span class="nonterminal">in</span>â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><p>Users can define <em>let operators</em>:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> ( <span class="ocamlkeyword">let</span>* ) o f =
  <span class="ocamlkeyword">match</span> o <span class="ocamlkeyword">with</span>
  | None -&gt; None
  | Some x -&gt; f x

<span class="ocamlkeyword">let</span> return x = Some x</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">let</span>* ) : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> return : 'a -&gt; 'a option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>and then apply them using this convenient syntax:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> find_and_sum tbl k1 k2 =
  <span class="ocamlkeyword">let</span>* x1 = Hashtbl.find_opt tbl k1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span>* x2 = Hashtbl.find_opt tbl k2 <span class="ocamlkeyword">in</span>
    return (x1 + x2)</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> find_and_sum : ('a, int) Hashtbl.t -&gt; 'a -&gt; 'a -&gt; int option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>which is equivalent to this expanded form:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> find_and_sum tbl k1 k2 =
  ( <span class="ocamlkeyword">let</span>* ) (Hashtbl.find_opt tbl k1)
    (<span class="ocamlkeyword">fun</span> x1 -&gt;
       ( <span class="ocamlkeyword">let</span>* ) (Hashtbl.find_opt tbl k2)
         (<span class="ocamlkeyword">fun</span> x2 -&gt; return (x1 + x2)))</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> find_and_sum : ('a, int) Hashtbl.t -&gt; 'a -&gt; 'a -&gt; int option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Users can also define <em>and operators</em>:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> ZipSeq = <span class="ocamlkeyword">struct</span>

  <span class="ocamlkeyword">type</span> 'a t = 'a Seq.t

  <span class="ocamlkeyword">open</span> Seq

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> return x =
    <span class="ocamlkeyword">fun</span> () -&gt; Cons(x, return x)

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> prod a b =
    <span class="ocamlkeyword">fun</span> () -&gt;
      <span class="ocamlkeyword">match</span> a (), b () <span class="ocamlkeyword">with</span>
      | Nil, _ | _, Nil -&gt; Nil
      | Cons(x, a), Cons(y, b) -&gt; Cons((x, y), prod a b)

  <span class="ocamlkeyword">let</span> ( <span class="ocamlkeyword">let</span>+ ) f s = map s f
  <span class="ocamlkeyword">let</span> ( <span class="ocamlkeyword">and</span>+ ) a b = prod a b

<span class="ocamlkeyword">end</span></div>



<div class="pre caml-output ok"><span class="ocamlkeyword">module</span> ZipSeq :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlkeyword">type</span> 'a t = 'a Seq.t
    <span class="ocamlkeyword">val</span> return : 'a -&gt; 'a Seq.t
    <span class="ocamlkeyword">val</span> prod : 'a Seq.t -&gt; 'b Seq.t -&gt; ('a * 'b) Seq.t
    <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">let</span>+ ) : 'a Seq.t -&gt; ('a -&gt; 'b) -&gt; 'b Seq.t
    <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">and</span>+ ) : 'a Seq.t -&gt; 'b Seq.t -&gt; ('a * 'b) Seq.t
  <span class="ocamlkeyword">end</span></div></div>

</div><p>to support the syntax:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> ZipSeq
<span class="ocamlkeyword">let</span> sum3 z1 z2 z3 =
  <span class="ocamlkeyword">let</span>+ x1 = z1
  <span class="ocamlkeyword">and</span>+ x2 = z2
  <span class="ocamlkeyword">and</span>+ x3 = z3 <span class="ocamlkeyword">in</span>
    x1 + x2 + x3</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum3 : int Seq.t -&gt; int Seq.t -&gt; int Seq.t -&gt; int Seq.t = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>which is equivalent to this expanded form:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> ZipSeq
<span class="ocamlkeyword">let</span> sum3 z1 z2 z3 =
  ( <span class="ocamlkeyword">let</span>+ ) (( <span class="ocamlkeyword">and</span>+ ) (( <span class="ocamlkeyword">and</span>+ ) z1 z2) z3)
    (<span class="ocamlkeyword">fun</span> ((x1, x2), x3) -&gt; x1 + x2 + x3)</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum3 : int Seq.t -&gt; int Seq.t -&gt; int Seq.t -&gt; int Seq.t = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<!--TOC subsection id="ss:letops-punning" 12.23.1â€ƒShort notation for variable bindings (let-punning)-->
<h3 class="subsection" id="ss:letops-punning"><a class="section-anchor" href="#ss:letops-punning" aria-hidden="true">ï»¿</a>12.23.1â€ƒShort notation for variable bindings (let-punning)</h3><!--SEC END --><p>(Introduced in 4.13.0)</p><p>When the expression being bound is a variable, it can be convenient to
use the shorthand notation <span class="machine"><span class="font-tt">let+ x in ...</span></span>, which expands to <span class="machine"><span class="font-tt">let+ x = x in ...</span></span>. This notation, also known as let-punning, allows the
<span class="machine"><span class="font-tt">sum3</span></span> function above can be written more concisely as:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> ZipSeq
<span class="ocamlkeyword">let</span> sum3 z1 z2 z3 =
  <span class="ocamlkeyword">let</span>+ z1 <span class="ocamlkeyword">and</span>+ z2 <span class="ocamlkeyword">and</span>+ z3 <span class="ocamlkeyword">in</span>
  z1 + z2 + z3</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum3 : int Seq.t -&gt; int Seq.t -&gt; int Seq.t -&gt; int Seq.t = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>This notation is also supported for extension nodes, expanding
<span class="machine"><span class="font-tt">let%foo x in ...</span></span> to <span class="machine"><span class="font-tt">let%foo x = x in ...</span></span>. However, to avoid
confusion, this notation is not supported for plain <span class="machine"><span class="font-tt">let</span></span> bindings.</p>
<!--TOC subsection id="ss:letops-rationale" 12.23.2â€ƒRationale-->
<h3 class="subsection" id="ss:letops-rationale"><a class="section-anchor" href="#ss:letops-rationale" aria-hidden="true">ï»¿</a>12.23.2â€ƒRationale</h3><!--SEC END --><p>This extension is intended to provide a convenient syntax for working
with monads and applicatives.</p><p>An applicative should provide a module implementing the following
interface:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> Applicative_syntax = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">let</span>+ ) : 'a t -&gt; ('a -&gt; 'b) -&gt; 'b t
  <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">and</span>+ ): 'a t -&gt; 'b t -&gt; ('a * 'b) t
<span class="ocamlkeyword">end</span></div></div>

</div><p>where <span class="machine"><span class="font-tt">(let+)</span></span> is bound to the <span class="machine"><span class="font-tt">map</span></span> operation and <span class="machine"><span class="font-tt">(and+)</span></span> is bound to
the monoidal product operation.</p><p>A monad should provide a module implementing the following interface:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> Monad_syntax = <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">include</span> Applicative_syntax
  <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">let</span>* ) : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t
  <span class="ocamlkeyword">val</span> ( <span class="ocamlkeyword">and</span>* ): 'a t -&gt; 'b t -&gt; ('a * 'b) t
<span class="ocamlkeyword">end</span></div></div>

</div><p>where <span class="machine"><span class="font-tt">(let*)</span></span> is bound to the <span class="machine"><span class="font-tt">bind</span></span> operation, and <span class="machine"><span class="font-tt">(and*)</span></span> is also
bound to the monoidal product operation.
</p>
<!--TOC section id="s:effect-handlers" 12.24â€ƒEffect handlers-->
<h2 class="section" id="s:effect-handlers"><a class="section-anchor" href="#s:effect-handlers" aria-hidden="true">ï»¿</a>12.24â€ƒEffect handlers</h2><!--SEC END --><!--NAME effects.html-->
<p>(Introduced in 5.0)</p><p><span class="font-it">Note: Effect handlers in OCaml 5.0 should be considered experimental.
Effect handlers are exposed in the standard library as a thin wrapper
around their implementations in the runtime. They are not supported as a
language feature with new syntax. You can rely on them to build non-local
control-flow abstractions such as user-level threading that do not expose
the effect handler primitives to the user. Expect breaking changes in the
future.</span></p><p>Effect handlers are a mechanism for modular programming with user-defined
effects. Effect handlers allow the programmers to describe
<span class="font-it">computations</span> that <span class="font-it">perform</span> effectful <span class="font-it">operations</span>,
whose meaning is described by <span class="font-it">handlers</span> that enclose the computations.
Effect handlers are a generalization of exception handlers and enable non-local
control-flow mechanisms such as resumable exceptions, lightweight threads,
coroutines, generators and asynchronous I/O to be composably expressed. In this
tutorial, we shall see how some of these mechanisms can be built using effect
handlers.</p>
<!--TOC subsection id="s:effects-basics" 12.24.1â€ƒBasics-->
<h3 class="subsection" id="s:effects-basics"><a class="section-anchor" href="#s:effects-basics" aria-hidden="true">ï»¿</a>12.24.1â€ƒBasics</h3><!--SEC END --><p>To understand the basics, let us define an effect (that is, an operation) that
takes an integer argument and returns an integer result. We name this effect
<span class="machine"><span class="font-tt">Xchg</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Effect
<span class="ocamlkeyword">open</span> Effect.Deep

<span class="ocamlkeyword">type</span> _ Effect.t += Xchg: int -&gt; int t
<span class="ocamlkeyword">let</span> comp1 () = perform (Xchg 0) + perform (Xchg 1)</div></div>

</div><p>We declare the exchange effect <span class="machine"><span class="font-tt">Xchg</span></span> by extending the pre-defined extensible
variant type <span class="machine"><span class="font-tt">Effect.t</span></span> with a new constructor <span class="machine"><span class="font-tt">Xchg: int -&gt; int t</span></span>. The
declaration may be intuitively read as â€œthe <span class="machine"><span class="font-tt">Xchg</span></span> effect takes an integer
parameter, and when this effect is performed, it returns an integerâ€. The
computation <span class="machine"><span class="font-tt">comp1</span></span> performs the effect twice using the <span class="machine"><span class="font-tt">perform</span></span> primitive and
returns their sum.</p><p>We can handle the <span class="machine"><span class="font-tt">Xchg</span></span> effect by implementing a handler that always returns
the successor of the offered value:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">try_with comp1 ()
{ effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
    <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
    | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a, _) continuation) -&gt;
        continue k (n+1))
    | _ -&gt; None }</div>



<div class="pre caml-output ok">- : int = 3</div></div>

</div><p><span class="machine"><span class="font-tt">try_with</span></span> runs the computation <span class="machine"><span class="font-tt">comp1 ()</span></span> under an effect handler that handles
the <span class="machine"><span class="font-tt">Xchg</span></span> effect. As mentioned earlier, effect handlers are a generalization
of exception handlers. Similar to exception handlers, when the computation
performs the <span class="machine"><span class="font-tt">Xchg</span></span> effect, the control jumps to the corresponding handler.
However, unlike exception handlers, the handler is also provided with the
delimited continuation <span class="machine"><span class="font-tt">k</span></span>, which represents the suspended computation between
the point of <span class="machine"><span class="font-tt">perform</span></span> and this handler.</p><p>The handler uses the <span class="machine"><span class="font-tt">continue</span></span> primitive to resume the suspended computation
with the successor of the offered value. In this example, the computation
<span class="machine"><span class="font-tt">comp1</span></span> performs <span class="machine"><span class="font-tt">Xchg 0</span></span> and <span class="machine"><span class="font-tt">Xchg 1</span></span> and receives the values <span class="machine"><span class="font-tt">1</span></span> and <span class="machine"><span class="font-tt">2</span></span>
from the handler respectively. Hence, the whole expression evaluates to <span class="machine"><span class="font-tt">3</span></span>.</p><p>It is useful to note that the we must use locally abstract type <span class="machine"><span class="font-tt">(type a)</span></span> in
the effect handler. The type <span class="machine"><span class="font-tt">Effect.t</span></span> is a GADT, and the effect declarations
may have different type parameters for different effects. The type parameter
<span class="machine"><span class="font-tt">a</span></span> in the type <span class="machine"><span class="font-tt">a Effect.t</span></span> represents the type of the value returned when
performing the effect. From the fact that <span class="machine"><span class="font-tt">eff</span></span> has type <span class="machine"><span class="font-tt">a Effect.t</span></span> and from
the fact that <span class="machine"><span class="font-tt">Xchg n</span></span> has type <span class="machine"><span class="font-tt">int Effect.t</span></span>, the type-checker deduces that
<span class="machine"><span class="font-tt">a</span></span> must be <span class="machine"><span class="font-tt">int</span></span>, which is why we are allowed to pass the integer value <span class="machine"><span class="font-tt">n+1</span></span>
as an argument to <span class="machine"><span class="font-tt">continue k</span></span>.</p><p>Another point to note is that the catch-all case â€œ<span class="machine"><span class="font-tt">| _ -&gt; None</span></span>â€ is necessary
when handling effects. This case may be intuitively read as â€œforward the
unhandled effects to the outer handlerâ€.</p><p>In this example, we use the <em>deep</em> version of the effect handlers here as
opposed to the <em>shallow</em> version. A deep handler monitors a computation
until the computation terminates (either normally or via an exception), and
handles all of the effects performed (in sequence) by the computation. In
contrast, a shallow handler monitors a computation until either the computation
terminates or the computation performs one effect, and it handles this single
effect only. In situations where they are applicable, deep handlers are usually
preferred. An example that utilises shallow handlers is discussed later
inÂ <a href="#s%3Aeffects-shallow">12.24.6</a>.</p>
<!--TOC subsection id="s:effects-concurrency" 12.24.2â€ƒConcurrency-->
<h3 class="subsection" id="s:effects-concurrency"><a class="section-anchor" href="#s:effects-concurrency" aria-hidden="true">ï»¿</a>12.24.2â€ƒConcurrency</h3><!--SEC END --><p>The expressive power of effect handlers comes from the delimited continuation.
While the previous example immediately resumed the computation, the computation
may be resumed later, running some other computation in the interim. Let us
extend the previous example and implement message-passing concurrency between
two concurrent computations using the <span class="machine"><span class="font-tt">Xchg</span></span> effect. We call these concurrent
computations <span class="font-it">tasks</span>.</p><p>A task either is in a suspended state or is completed. We represent the task
status as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> 'a status =
  Complete <span class="ocamlkeyword">of</span> 'a
| Suspended <span class="ocamlkeyword">of</span> {msg: int; cont: (int, 'a status) continuation}</div></div>

</div><p>A task either is complete, with a result of type <span class="machine"><span class="font-tt">'a</span></span>, or is suspended with the
message <span class="machine"><span class="font-tt">msg</span></span> to send and the continuation <span class="machine"><span class="font-tt">cont</span></span>. The type <span class="machine"><span class="font-tt">(int,'a status) continuation</span></span> says that the suspended computation expects an <span class="machine"><span class="font-tt">int</span></span> value to
resume and returns a <span class="machine"><span class="font-tt">'a status</span></span> value when resumed.</p><p>Next, we define a <span class="machine"><span class="font-tt">step</span></span> function that executes one step of computation until
it completes or suspends:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> step (f : unit -&gt; 'a) () : 'a status =
  match_with f ()
  { retc = (<span class="ocamlkeyword">fun</span> v -&gt; Complete v);
    exnc = raise;
    effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | Xchg msg -&gt; Some (<span class="ocamlkeyword">fun</span> (cont: (a, _) continuation) -&gt;
          Suspended {msg; cont})
      | _ -&gt; None }</div></div>

</div><p>The argument to the <span class="machine"><span class="font-tt">step</span></span> function, <span class="machine"><span class="font-tt">f</span></span>, is a computation that can perform an
<span class="machine"><span class="font-tt">Xchg</span></span> effect and returns a result of type <span class="machine"><span class="font-tt">'a</span></span>. The <span class="machine"><span class="font-tt">step</span></span> function itself
returns a <span class="machine"><span class="font-tt">'a status</span></span> value.</p><p>In the <span class="machine"><span class="font-tt">step</span></span> function, we use the <span class="machine"><span class="font-tt">match_with</span></span> primitive. Like <span class="machine"><span class="font-tt">try_with</span></span>,
<span class="machine"><span class="font-tt">match_with</span></span> primitive installs an effect handler. However, unlike <span class="machine"><span class="font-tt">try_with</span></span>,
where only the effect case <span class="machine"><span class="font-tt">effc</span></span> is provided, <span class="machine"><span class="font-tt">match_with</span></span> expects the
handlers for the value (<span class="machine"><span class="font-tt">retc</span></span>) and exceptional (<span class="machine"><span class="font-tt">exnc</span></span>) return cases. In fact,
<span class="machine"><span class="font-tt">try_with</span></span> can be defined using <span class="machine"><span class="font-tt">match_with</span></span> as follows: <span class="machine"><span class="font-tt">let try_with f v {effc} = match_with f v {retc = Fun.id; exnc = raise; effc}</span></span>.</p><p>In the <span class="machine"><span class="font-tt">step</span></span> function,</p><ul class="itemize"><li class="li-itemize">Case <span class="machine"><span class="font-tt">retc</span></span>: If the computation returns with a value <span class="machine"><span class="font-tt">v</span></span>, we return
<span class="machine"><span class="font-tt">Complete v</span></span>.
</li><li class="li-itemize">Case <span class="machine"><span class="font-tt">exnc</span></span>: If the computation raises an exception, then the handler
raises the same exception.
</li><li class="li-itemize">Case <span class="machine"><span class="font-tt">effc</span></span>: If the computation performs the effect <span class="machine"><span class="font-tt">Xchg msg</span></span> with the
continuation <span class="machine"><span class="font-tt">cont</span></span>, then we return <span class="machine"><span class="font-tt">Suspended{msg;cont}</span></span>. Thus, in this
case, the continuation cont is not immediately invoked by the handler;
instead, it is stored in a data structure for later use.
</li></ul><p>Since the <span class="machine"><span class="font-tt">step</span></span> function handles the <span class="machine"><span class="font-tt">Xchg</span></span> effect, <span class="machine"><span class="font-tt">step f</span></span> is a computation
that does not perform the <span class="machine"><span class="font-tt">Xchg</span></span> effect. It may however perform other effects.
Moreover, since we are using deep handlers, the continuation <span class="machine"><span class="font-tt">cont</span></span> stored in
the status does not perform the <span class="machine"><span class="font-tt">Xchg</span></span> effect.</p><p>We can now write a simple scheduler that runs a pair of tasks to completion:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> run_both a b =
  <span class="ocamlkeyword">match</span> a (), b () <span class="ocamlkeyword">with</span>
  | Complete va, Complete vb -&gt; (va, vb)
  | Suspended {msg = m1; cont = k1},
    Suspended {msg = m2; cont = k2} -&gt;
      run_both (<span class="ocamlkeyword">fun</span> () -&gt; continue k1 m2)
               (<span class="ocamlkeyword">fun</span> () -&gt; continue k2 m1)
  | _ -&gt; failwith <span class="ocamlstring">"Improper synchronization"</span></div></div>

</div><p>Both of the tasks may run to completion, or both may offer to exchange a
message. In the latter case, each computation receives the value offered by the
other computation. The situation where one computation offers an exchange while
the other computation terminates is regarded as a programmer error, and causes
the handler to raise an exception</p><p>We can now define a second computation that also exchanges two messages:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> comp2 () = perform (Xchg 21) * perform (Xchg 21)</div></div>

</div><p>Finally, we can run the two computations together:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run_both (step comp1) (step comp2)</div>



<div class="pre caml-output ok">- : int * int = (42, 0)</div></div>

</div><p>The computation <span class="machine"><span class="font-tt">comp1</span></span> offers the values <span class="machine"><span class="font-tt">0</span></span> and <span class="machine"><span class="font-tt">1</span></span> and in exchange receives
the values <span class="machine"><span class="font-tt">21</span></span> and <span class="machine"><span class="font-tt">21</span></span>, which it adds, producing <span class="machine"><span class="font-tt">42</span></span>. The computation
<span class="machine"><span class="font-tt">comp2</span></span> offers the values <span class="machine"><span class="font-tt">21</span></span> and <span class="machine"><span class="font-tt">21</span></span> and in exchange receives the values <span class="machine"><span class="font-tt">0</span></span>
and <span class="machine"><span class="font-tt">1</span></span>, which it multiplies, producing <span class="machine"><span class="font-tt">0</span></span>. The communication between the two
computations is programmed entirely inside <span class="machine"><span class="font-tt">run_both</span></span>. Indeed, the definitions
of <span class="machine"><span class="font-tt">comp1</span></span> and <span class="machine"><span class="font-tt">comp2</span></span>, alone, do not assign any meaning to the <span class="machine"><span class="font-tt">Xchg</span></span> effect.</p>
<!--TOC subsection id="s:effects-user-threads" 12.24.3â€ƒUser-level threads-->
<h3 class="subsection" id="s:effects-user-threads"><a class="section-anchor" href="#s:effects-user-threads" aria-hidden="true">ï»¿</a>12.24.3â€ƒUser-level threads</h3><!--SEC END --><p>Let us extend the previous example for an arbitrary number of tasks. Many
languages such as GHC Haskell and Go provide user-level threads as a primitive
feature implemented in the runtime system. With effect handlers, user-level
threads and their schedulers can be implemented in OCaml itself. Typically,
user-level threading systems provide a <span class="machine"><span class="font-tt">fork</span></span> primitive to spawn off a new
concurrent task and a <span class="machine"><span class="font-tt">yield</span></span> primitive to yield control to some other task.
Correspondingly, we shall declare two effects as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ Effect.t += Fork : (unit -&gt; unit) -&gt; unit t
                 | Yield : unit t</div></div>

</div><p>The <span class="machine"><span class="font-tt">Fork</span></span> effect takes a thunk (a suspended computation, represented as a
function of type <span class="machine"><span class="font-tt">unit -&gt; unit</span></span>) and returns a unit to the performer. The
<span class="machine"><span class="font-tt">Yield</span></span> effect is unparameterized and returns a unit when performed. Let us
consider that a task performing an <span class="machine"><span class="font-tt">Xchg</span></span> effect may match with any other task
also offering to exchange a value.</p><p>We shall also define helper functions that simply perform these effects:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> fork f = perform (Fork f)
<span class="ocamlkeyword">let</span> yield () = perform Yield
<span class="ocamlkeyword">let</span> xchg v = perform (Xchg v)</div></div>

</div><p>A top-level <span class="machine"><span class="font-tt">run</span></span> function defines the scheduler:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* A concurrent round-robin scheduler *)</span>
<span class="ocamlkeyword">let</span> run (main : unit -&gt; unit) : unit =
  <span class="ocamlkeyword">let</span> exchanger = <span class="ocamlkeyword">ref</span> None <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* waiting exchanger *)</span>
  <span class="ocamlkeyword">let</span> run_q = Queue.create () <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* scheduler queue *)</span>
  <span class="ocamlkeyword">let</span> enqueue k v =
    <span class="ocamlkeyword">let</span> task () = continue k v <span class="ocamlkeyword">in</span>
    Queue.push task run_q
  <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> dequeue () =
    <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> () <span class="ocamlcomment">(* done *)</span>
    <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">begin</span>
      <span class="ocamlkeyword">let</span> task = Queue.pop run_q <span class="ocamlkeyword">in</span>
      task ()
    <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> spawn (f : unit -&gt; unit) : unit =
    match_with f () {
      retc = dequeue;
      exnc = (<span class="ocamlkeyword">fun</span> e -&gt;
        print_endline (Printexc.to_string e);
        dequeue ());
      effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff : a t) -&gt;
        <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
        | Yield -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (a, unit) continuation) -&gt;
            enqueue k (); dequeue ())
        | Fork f -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (a, unit) continuation) -&gt;
            enqueue k (); spawn f)
        | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (int, unit) continuation) -&gt;
            <span class="ocamlkeyword">begin</span> <span class="ocamlkeyword">match</span> !exchanger <span class="ocamlkeyword">with</span>
            | Some (n', k') -&gt;
                exchanger := None; enqueue k' n; continue k n'
            | None -&gt; exchanger := Some (n, k); dequeue ()
            <span class="ocamlkeyword">end</span>)
        | _ -&gt; None
    }
  <span class="ocamlkeyword">in</span>
  spawn main</div></div>

</div><p>We use a mutable queue <span class="machine"><span class="font-tt">run_q</span></span> to hold the scheduler queue. The FIFO queue
enables round-robin scheduling of tasks in the scheduler. <span class="machine"><span class="font-tt">enqueue</span></span> inserts
tasks into the queue, and <span class="machine"><span class="font-tt">dequeue</span></span> extracts tasks from the queue and runs
them. The reference cell <span class="machine"><span class="font-tt">exchanger</span></span> holds a (suspended) task offering to
exchange a value. At any time, there is either zero or one suspended task that
is offering an exchange.</p><p>The heavy lifting is done by the <span class="machine"><span class="font-tt">spawn</span></span> function. The <span class="machine"><span class="font-tt">spawn</span></span> function runs
the given computation <span class="machine"><span class="font-tt">f</span></span> in an effect handler. If <span class="machine"><span class="font-tt">f</span></span> returns with a value
(case <span class="machine"><span class="font-tt">retc</span></span>), we dequeue and run the next task from the scheduler queue. If
the computation <span class="machine"><span class="font-tt">f</span></span> raises an exception (case <span class="machine"><span class="font-tt">exnc</span></span>), we print the exception
and run the next task from the scheduler.</p><p>The computation <span class="machine"><span class="font-tt">f</span></span> may also perform effects. If <span class="machine"><span class="font-tt">f</span></span> performs the <span class="machine"><span class="font-tt">Yield</span></span>
effect, the current task is suspended (inserted into the queue of ready tasks),
and the next task from the scheduler queue is run. If the effect is <span class="machine"><span class="font-tt">Fork f</span></span>,
then the current task is suspended, and the new task <span class="machine"><span class="font-tt">f</span></span> is executed
immediately via a tail call to <span class="machine"><span class="font-tt">spawn f</span></span>. Note that this choice to run the new
task first is arbitrary. We could very well have chosen instead to insert the
task for <span class="machine"><span class="font-tt">f</span></span> into the ready queue and resumed <span class="machine"><span class="font-tt">k</span></span> immediately.</p><p>If the effect is <span class="machine"><span class="font-tt">Xchg</span></span>, then we first check whether there is a task waiting to
exchange. If so, we enqueue the waiting task with the current value being
offered and immediately resume the current task with the value being offered.
If not, we make the current task the waiting exchanger, and run the next task
from the scheduler queue.</p><p>Note that this scheduler code is not perfect â€“ it can leak resources. We shall
explain and fix this in the next sectionÂ <a href="#s%3Aeffects-discontinue">12.24.3</a>.</p><p>Now we can write a concurrent program that utilises the newly defined
operations:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Printf

<span class="ocamlkeyword">let</span> _ = run (<span class="ocamlkeyword">fun</span> _ -&gt;
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    printf <span class="ocamlstring">"[t1] Sending 0\n"</span>;
    <span class="ocamlkeyword">let</span> v = xchg 0 <span class="ocamlkeyword">in</span>
    printf <span class="ocamlstring">"[t1] received %d\n"</span> v);
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    printf <span class="ocamlstring">"[t2] Sending 1\n"</span>;
    <span class="ocamlkeyword">let</span> v = xchg 1 <span class="ocamlkeyword">in</span>
    printf <span class="ocamlstring">"[t2] received %d\n"</span> v))</div>



<div class="pre caml-output ok">[t1] Sending 0
[t2] Sending 1
[t2] received 0
[t1] received 1</div></div>

</div><p>Observe that the messages from the two tasks are interleaved. Notice also that
the snippet above makes no reference to the effect handlers and is in direct
style (no monadic operations). This example illustrates that, with effect
handlers, the user code in a concurrent program can remain in simple direct
style, and the use of effect handlers can be fully contained within the
concurrency library implementation.</p>
<!--TOC subsubsection id="s:effects-discontinue" Resuming with an exception-->
<h4 class="subsubsection" id="s:effects-discontinue"><a class="section-anchor" href="#s:effects-discontinue" aria-hidden="true">ï»¿</a>Resuming with an exception</h4><!--SEC END --><p>In addition to resuming a continuation with a value, effect handlers also
permit resuming by raising an effect at the point of perform. This is done with
the help of the <span class="machine"><span class="font-tt">discontinue</span></span> primitive. The <span class="machine"><span class="font-tt">discontinue</span></span> primitive helps
ensure that resources are always eventually deallocated, even in the presence
of effects.</p><p>For example, consider the dequeue operation in the previous example reproduced
below:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">â€¦
<span class="ocamlkeyword">let</span> dequeue () =
  <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> () <span class="ocamlcomment">(* done *)</span>
  <span class="ocamlkeyword">else</span> (Queue.pop run_q) ()</div></div>

</div><p>If the scheduler queue is empty, dequeue considers that the scheduler is done
and returns to the caller. However, there may still be a task waiting to
exchange a value (stored in the reference cell <span class="machine"><span class="font-tt">exchanger</span></span>), which remains
blocked forever! If the blocked task holds onto resources, these resources are
leaked. For example, consider the following task:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> leaky_task () =
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> oc = open_out <span class="ocamlstring">"secret.txt"</span> <span class="ocamlkeyword">in</span>
    Fun.protect ~finally:(<span class="ocamlkeyword">fun</span> _ -&gt; close_out oc) (<span class="ocamlkeyword">fun</span> _ -&gt;
      output_value oc (xchg 0)))</div></div>

</div><p>The task writes the received message to the file <span class="machine"><span class="font-tt">secret.txt</span></span>. It uses
<span class="machine"><span class="font-tt">Fun.protect</span></span> to ensure that the output channel <span class="machine"><span class="font-tt">oc</span></span> is closed on both normal
and exceptional return cases. Unfortunately, this is not sufficient. If the
exchange effect <span class="machine"><span class="font-tt">xchg 0</span></span> cannot be matched with an exchange effect performed by
some other thread, then this task remains blocked forever. Thus, the output
channel <span class="machine"><span class="font-tt">oc</span></span> is never closed.</p><p>To avoid this problem, one must adhere to a simple discipline:
<em><span class="font-bold">every continuation must be eventually either continued or
discontinued</span></em>. Here, we use <span class="machine"><span class="font-tt">discontinue</span></span> to ensure that the blocked task does
not remain blocked forever. By discontinuing this task, we force it to
terminate (with an exception):</p><div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">exception</span> Improper_synchronization

<span class="ocamlkeyword">let</span> dequeue () =
  <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> <span class="ocamlkeyword">begin</span>
    <span class="ocamlkeyword">match</span> !exchanger <span class="ocamlkeyword">with</span>
    | None -&gt; () <span class="ocamlcomment">(* done *)</span>
    | Some (n, k) -&gt;
        exchanger := None;
        discontinue k Improper_synchronization
  <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">else</span> (Queue.pop run_q) ()</div></div><p>When the scheduler queue is empty and there is a blocked exchanger thread, the
dequeue function discontinues the blocked thread with an
<span class="machine"><span class="font-tt">Improper_synchronization</span></span> exception. This exception is raised at the blocked
<span class="machine"><span class="font-tt">xchg</span></span> function call, which causes the <span class="machine"><span class="font-tt">finally</span></span> block to be run and closes the
output channel <span class="machine"><span class="font-tt">oc</span></span>. From the point of view of the user, it seems as though the
function call <span class="machine"><span class="font-tt">xchg 0</span></span> raises the exception <span class="machine"><span class="font-tt">Improper_synchronization</span></span>.</p>
<!--TOC subsection id="s:effects-sequence" 12.24.4â€ƒControl inversion-->
<h3 class="subsection" id="s:effects-sequence"><a class="section-anchor" href="#s:effects-sequence" aria-hidden="true">ï»¿</a>12.24.4â€ƒControl inversion</h3><!--SEC END --><p>When it comes to performing traversals on a data structure, there are two
fundamental ways depending on whether the producer or the consumer has the
control over the traversal. For example, in <span class="machine"><span class="font-tt">List.iter f l</span></span>, the producer
<span class="machine"><span class="font-tt">List.iter</span></span> has the control and pushes the element to the consumer <span class="machine"><span class="font-tt">f</span></span> who
processes them. On the other hand, the <a href="libref/Seq.html"><span class="font-tt">Seq</span></a> module provides a
mechanism similar to delayed lists where the consumer controls the traversal.
For example, <span class="machine"><span class="font-tt">Seq.forever Random.bool</span></span> returns an infinite sequence of random
bits where every bit is produced (on demand) when queried by the consumer.</p><p>Naturally, producers such as <span class="machine"><span class="font-tt">List.iter</span></span> are easier to write in the former
style. The latter style is ergonomically better for the consumer since it is
preferable and more natural to be in control. To have the best of both worlds,
we would like to write a producer in the former style and automatically convert
it to the latter style. The conversion can be written <em>once and for all</em>
as a library function, thanks to effect handlers. Let us name this function
<span class="machine"><span class="font-tt">invert</span></span>. We will first look at how to use the <span class="machine"><span class="font-tt">invert</span></span> function before looking
at its implementation details. The type of this function is given below:</p><div class="caml-example signature">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">val</span> invert : iter:(('a -&gt; unit) -&gt; unit) -&gt; 'a Seq.t</div></div>

</div><p>The <span class="machine"><span class="font-tt">invert</span></span> function takes an <span class="machine"><span class="font-tt">iter</span></span> function (a producer that pushes elements
to the consumer) and returns a sequence (where the consumer has the control).
For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> lst_iter = Fun.flip List.iter [1;2;3]</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lst_iter : (int -&gt; unit) -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>is an <span class="machine"><span class="font-tt">iter</span></span> function with type <span class="machine"><span class="font-tt">(int -&gt; unit) -&gt; unit</span></span>. The expression
<span class="machine"><span class="font-tt">lst_iter f</span></span> pushes the elements 1, 2 and 3 to the consumer <span class="machine"><span class="font-tt">f</span></span>. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">lst_iter (<span class="ocamlkeyword">fun</span> i -&gt; Printf.printf <span class="ocamlstring">"%d\n"</span> i)</div>



<div class="pre caml-output ok">1
2
3
- : unit = ()</div></div>

</div><p>The expression <span class="machine"><span class="font-tt">invert lst_iter</span></span> returns a sequence that allows the consumer to
traverse the list on demand. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> s = invert ~iter:lst_iter
<span class="ocamlkeyword">let</span> next = Seq.to_dispenser s;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> s : int Seq.t = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> next : unit -&gt; int option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : int option = Some 1</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : int option = Some 2</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : int option = Some 3</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : int option = None</div></div>

</div><p>We can use the same <span class="machine"><span class="font-tt">invert</span></span> function on any <span class="machine"><span class="font-tt">iter</span></span> function. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> s = invert ~iter:(Fun.flip String.iter <span class="ocamlstring">"OCaml"</span>)
<span class="ocamlkeyword">let</span> next = Seq.to_dispenser s;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> s : char Seq.t = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> next : unit -&gt; char option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = Some 'O'</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = Some 'C'</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = Some 'a'</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = Some 'm'</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = Some 'l'</div></div>
<div class="ocaml">



<div class="pre caml-input">next();;</div>



<div class="pre caml-output ok">- : char option = None</div></div>

</div>
<!--TOC subsubsection id="s:effects-sequence-implementation" Implementing control inversion-->
<h4 class="subsubsection" id="s:effects-sequence-implementation"><a class="section-anchor" href="#s:effects-sequence-implementation" aria-hidden="true">ï»¿</a>Implementing control inversion</h4><!--SEC END --><p>The implementation of the <span class="machine"><span class="font-tt">invert</span></span> function is given below:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> invert (<span class="ocamlkeyword">type</span> a) ~(iter : (a -&gt; unit) -&gt; unit) : a Seq.t =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">type</span> _ Effect.t += Yield : a -&gt; unit t
  <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> yield v = perform (M.Yield v) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">fun</span> () -&gt; match_with iter yield
  { retc = (<span class="ocamlkeyword">fun</span> _ -&gt; Seq.Nil);
    exnc = raise;
    effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (eff : b Effect.t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | M.Yield v -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (b,_) continuation) -&gt;
          Seq.Cons (v, continue k))
      | _ -&gt; None }</div></div>

</div><p>The <span class="machine"><span class="font-tt">invert</span></span> function declares an effect <span class="machine"><span class="font-tt">Yield</span></span> that takes the element to be
yielded as a parameter. The <span class="machine"><span class="font-tt">yield</span></span> function performs the <span class="machine"><span class="font-tt">Yield</span></span> effect. The
lambda abstraction <span class="machine"><span class="font-tt">fun () -&gt; ...</span></span> delays all action until the first element of
the sequence is demanded. Once this happens, the computation <span class="machine"><span class="font-tt">iter yield</span></span> is
executed under an effect handler. Every time the <span class="machine"><span class="font-tt">iter</span></span> function pushes an
element to the <span class="machine"><span class="font-tt">yield</span></span> function, the computation is interrupted by the <span class="machine"><span class="font-tt">Yield</span></span>
effect. The <span class="machine"><span class="font-tt">Yield</span></span> effect is handled by returning the value
<span class="machine"><span class="font-tt">Seq.Cons(v,continue k)</span></span> to the consumer. The consumer gets the element <span class="machine"><span class="font-tt">v</span></span> as
well as the suspended computation, which in the consumerâ€™s eyes is just the
tail of sequence.</p><p>When the consumer demands the next element from the sequence (by applying it to
<span class="machine"><span class="font-tt">()</span></span>), the continuation <span class="machine"><span class="font-tt">k</span></span> is resumed. This allows the computation <span class="machine"><span class="font-tt">iter yield</span></span> to make progress, until it either yields another element or terminates
normally. In the latter case, the value <span class="machine"><span class="font-tt">Seq.Nil</span></span> is returned, indicating to
the consumer that the iteration is over.</p><p>It is important to note that the sequence returned by the <span class="machine"><span class="font-tt">invert</span></span> function is
<em>ephemeral</em> (as defined by the <a href="libref/Seq.html"><span class="font-tt">Seq</span></a> module) i.e., the
sequence must be used at most once. Additionally, the sequence must be fully
consumed (i.e., used at least once) so as to ensure that the captured
continuation is used linearly.</p>
<!--TOC subsection id="s:effects-semantics" 12.24.5â€ƒSemantics-->
<h3 class="subsection" id="s:effects-semantics"><a class="section-anchor" href="#s:effects-semantics" aria-hidden="true">ï»¿</a>12.24.5â€ƒSemantics</h3><!--SEC END --><p>In this section, we shall see the semantics of effect handlers with the help of
examples.</p>
<!--TOC subsubsection id="s:effects-nesting" Nesting handlers-->
<h4 class="subsubsection" id="s:effects-nesting"><a class="section-anchor" href="#s:effects-nesting" aria-hidden="true">ï»¿</a>Nesting handlers</h4><!--SEC END --><p>Like exception handlers, effect handlers can be nested.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ Effect.t += E : int t
                 | F : string t

<span class="ocamlkeyword">let</span> foo () = perform F

<span class="ocamlkeyword">let</span> bar () =
  try_with foo ()
  { effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | E -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a,_) continuation) -&gt;
          failwith <span class="ocamlstring">"impossible"</span>)
      | _ -&gt; None }

<span class="ocamlkeyword">let</span> baz () =
  try_with bar ()
  { effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | F -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a,_) continuation) -&gt;
          continue k <span class="ocamlstring">"Hello, world!"</span>)
      | _ -&gt; None }</div></div>

</div><p>In this example, the computation <span class="machine"><span class="font-tt">foo</span></span> performs <span class="machine"><span class="font-tt">F</span></span>, the inner handler handles
only <span class="machine"><span class="font-tt">E</span></span> and the outer handler handles <span class="machine"><span class="font-tt">F</span></span>. The call to <span class="machine"><span class="font-tt">baz</span></span> returns <span class="machine"><span class="font-tt">Hello, world!</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">baz ()</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"Hello, world!"</span></div></div>

</div>
<!--TOC subsubsection id="s:effects-fibers" Fibers-->
<h4 class="subsubsection" id="s:effects-fibers"><a class="section-anchor" href="#s:effects-fibers" aria-hidden="true">ï»¿</a>Fibers</h4><!--SEC END --><p>It is useful to know a little bit about the implementation of effect handlers
to appreciate the design choices and their performance characteristics. Effect
handlers are implemented with the help of runtime-managed, dynamically growing
segments of stack called <span class="font-it">fibers</span>. The program stack in OCaml is a
linked list of such fibers.</p><p>A new fiber is allocated for evaluating the computation enclosed by an effect
handler. The fiber is freed when the computation returns to the caller either
normally by returning a value or by raising an exception.</p><p>At the point of <span class="machine"><span class="font-tt">perform</span></span> in <span class="machine"><span class="font-tt">foo</span></span> in the previous example, the program stack
looks like this:</p><div class="ocaml">



<div class="pre caml-input">+-----+   +-----+   +-----+
|     |   |     |   |     |
| baz |&lt;--| bar |&lt;--| foo |
|     |   |     |   |     |
|     |   |     |   |     |
+-----+   +-----+   +-----+ &lt;- stack_pointer</div></div><p>The two links correspond to the two effect handlers in the program. When the
effect <span class="machine"><span class="font-tt">F</span></span> is handled in <span class="machine"><span class="font-tt">baz</span></span>, the program state looks as follows:</p><div class="ocaml">



<div class="pre caml-input">+-----+                   +-----+   +-----+
|     |                   |     |   |     |   +-+
| baz |                   | bar |&lt;--| foo |&lt;--|k|
|     |                   |     |   |     |   +-+
+-----+ &lt;- stack_pointer  +-----+   +-----+</div></div><p>The delimited continuation <span class="machine"><span class="font-tt">k</span></span> is an object on the heap that refers to the
segment of the stack that corresponds to the suspended computation. Capturing a
continuation does not involve copying stack frames. When the continuation is
resumed, the stack is restored to the previous state by linking together the
segment pointed to by <span class="machine"><span class="font-tt">k</span></span> to the current stack. Since neither continuation
capture nor resumption requires copying stack frames, suspending the execution
using <span class="machine"><span class="font-tt">perform</span></span> and resuming it using either <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> are
fast.</p>
<!--TOC subsubsection id="s:effects-unhandled" Unhandled effects-->
<h4 class="subsubsection" id="s:effects-unhandled"><a class="section-anchor" href="#s:effects-unhandled" aria-hidden="true">ï»¿</a>Unhandled effects</h4><!--SEC END --><p>Unlike languages such as Eff and Koka, effect handlers in OCaml do not provide
<span class="font-it">effect safety</span>; the compiler does not statically ensure that all the
effects performed by the program are handled. If effects do not have a matching
handler, then an <span class="machine"><span class="font-tt">Effect.Unhandled</span></span> exception is raised at the point of the
corresponding <span class="machine"><span class="font-tt">perform</span></span>. For example, in the previous example, <span class="machine"><span class="font-tt">bar</span></span> does not
handle the effect <span class="machine"><span class="font-tt">F</span></span>. Hence, we will get an <span class="machine"><span class="font-tt">Effect.Unhandled F</span></span> exception
when we run <span class="machine"><span class="font-tt">bar</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">try</span> bar () <span class="ocamlkeyword">with</span> Effect.Unhandled F -&gt; <span class="ocamlstring">"Saw Effect.Unhandled exception"</span></div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"Saw Effect.Unhandled exception"</span></div></div>

</div>
<!--TOC subsubsection id="s:effects-linearity" Linear continuations-->
<h4 class="subsubsection" id="s:effects-linearity"><a class="section-anchor" href="#s:effects-linearity" aria-hidden="true">ï»¿</a>Linear continuations</h4><!--SEC END --><p>As discussed earlierÂ <a href="#s%3Aeffects-discontinue">12.24.3</a>, the delimited continuations
in OCaml must be used linearly â€“ <em><span class="font-bold">every captured continuation
must be resumed either with a <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> exactly once</span></em>.
Attempting to use a continuation more than once raises a
<span class="machine"><span class="font-tt">Continuation_already_resumed</span></span> exception. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">try_with perform (Xchg 0)
{ effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff : a t) -&gt;
    <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
    | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a, _) continuation) -&gt;
        continue k 21 + continue k 21)
    | _ -&gt; None }</div>



<div class="pre caml-output ok">Exception: Stdlib.Effect.Continuation_already_resumed.</div></div>

</div><p>The primary motivation for adding effect handlers to OCaml is to enable
concurrent programming. One-shot continuations are sufficient for almost all
concurrent programming needs. They are also much cheaper to implement
compared to multi-shot continuations since they do not require stack frames to
be copied. Moreover, OCaml programs may also manipulate linear resources such
as sockets and file descriptors. The linearity discipline is easily broken if
the continuations are allowed to resume more than once. It would be quite hard
to debug such linearity violations on resources due to the lack of static
checks for linearity and the non-local nature of control flow. Hence, OCaml
does not support multi-shot continuations.</p><p>While the â€œat most once resumptionâ€ property of continuations is ensured with
a dynamic check, there is no check to ensure that the continuations are resumed
â€œat least onceâ€. It is left to the user to ensure that the captured
continuations are resumed at least once. Not resuming continuations will leak
the memory allocated for the fibers as well as any resources that the suspended
computation may hold.</p><p>One may install a finaliser on the captured continuation to ensure that the
resources are freed:</p><div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">exception</span> Unwind
Gc.finalise (<span class="ocamlkeyword">fun</span> k -&gt;
  <span class="ocamlkeyword">try</span> ignore (discontinue k Unwind) <span class="ocamlkeyword">with</span> _ -&gt; ()) k</div></div><p>In this case, if <span class="machine"><span class="font-tt">k</span></span> becomes unreachable, then the finaliser ensures that the
continuation stack is unwound by discontinuing with an <span class="machine"><span class="font-tt">Unwind</span></span> exception,
allowing the computation to free up resources. However, the runtime cost of
finalisers is much more than the cost of capturing a continuation. Hence, it is
recommended that the user take care of resuming the continuation exactly once
rather than relying on the finaliser.</p>
<!--TOC subsection id="s:effects-shallow" 12.24.6â€ƒShallow handlers-->
<h3 class="subsection" id="s:effects-shallow"><a class="section-anchor" href="#s:effects-shallow" aria-hidden="true">ï»¿</a>12.24.6â€ƒShallow handlers</h3><!--SEC END --><p>The examples that we have seen so far have used <span class="font-it">deep</span> handlers. A deep
handler handles all the effects performed (in sequence) by the computation.
Whenever a continuation is captured in a deep handler, the captured continuation
also includes the handler. This means that, when the continuation is resumed,
the effect handler is automatically re-installed, and will handle the effect(s)
that the computation may perform in the future.</p><p>OCaml also provides <span class="font-it">shallow</span> handlers. Compared to deep handlers, a
shallow handler handles only the first effect performed by the computation. The
continuation captured in a shallow handler does not include the handler. This
means that, when the continuation is resumed, the handler is no longer present.
For this reason, when the continuation is resumed, the user is expected to
provide a new effect handler (possibly a different one) to handle the next
effect that the computation may perform.</p><p>Shallow handlers make it easier to express certain kinds of programs. Let us
implement a shallow handler that enforces a particular sequence of effects (a
protocol) on a computation. For this example, let us consider that the
computation may perform the following effects:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ Effect.t += Send : int -&gt; unit Effect.t
                 | Recv : int Effect.t</div></div>

</div><p>Let us assume that we want to enforce a protocol that only permits an
alternating sequence of <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span> effects that conform to the regular
expression <span class="machine"><span class="font-tt">(Send;Recv)*;Send?</span></span>. Hence, the sequence of effects <span class="machine"><span class="font-tt">[]</span></span> (the empty
sequence), <span class="machine"><span class="font-tt">[Send]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv;Send]</span></span>, etc., are allowed, but
not <span class="machine"><span class="font-tt">[Recv]</span></span>, <span class="machine"><span class="font-tt">[Send;Send]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv;Recv]</span></span>, etc. The key observation here
is that the set of effects handled evolves over time. We can enforce this
protocol quite naturally using shallow handlers as shown below:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Effect.Shallow

<span class="ocamlkeyword">let</span> run (comp: unit -&gt; unit) : unit =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> loop_send : <span class="ocamlkeyword">type</span> a. (a,unit) continuation -&gt; a -&gt; unit = <span class="ocamlkeyword">fun</span> k v -&gt;
    continue_with k v
      { retc = Fun.id;
        exnc = raise;
        effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (eff : b Effect.t) -&gt;
          <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
          | Send n -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (b,_) continuation) -&gt;
              loop_recv n k ())
          | Recv -&gt; failwith <span class="ocamlstring">"protocol violation"</span>
          | _ -&gt; None }
  <span class="ocamlkeyword">and</span> loop_recv : <span class="ocamlkeyword">type</span> a. int -&gt; (a,unit) continuation -&gt; a -&gt; unit = <span class="ocamlkeyword">fun</span> n k v -&gt;
    continue_with k v
      { retc = Fun.id;
        exnc = raise;
        effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (eff : b Effect.t) -&gt;
          <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
          | Recv -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (b,_) continuation) -&gt;
              loop_send k n)
          | Send v -&gt; failwith <span class="ocamlstring">"protocol violation"</span>
          | _ -&gt; None }
  <span class="ocamlkeyword">in</span>
  loop_send (fiber comp) ()</div></div>

</div><p>The <span class="machine"><span class="font-tt">run</span></span> function executes the computation <span class="machine"><span class="font-tt">comp</span></span> ensuring that it can only
perform an alternating sequence of <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span> effects. The shallow
handler uses a different set of primitives compared to the deep handler. The
primitive <span class="machine"><span class="font-tt">fiber</span></span> (on the last line) takes an <span class="machine"><span class="font-tt">'a -&gt; 'b</span></span> function and returns a
<span class="machine"><span class="font-tt">('a,'b) Effects.Shallow.continuation</span></span>. The expression <span class="machine"><span class="font-tt">continue_with k v h</span></span>
resumes the continuation <span class="machine"><span class="font-tt">k</span></span> with value <span class="machine"><span class="font-tt">v</span></span> under the handler <span class="machine"><span class="font-tt">h</span></span>.</p><p>The mutually recursive functions <span class="machine"><span class="font-tt">loop_send</span></span> and <span class="machine"><span class="font-tt">loop_recv</span></span> resume the given
continuation <span class="machine"><span class="font-tt">k</span></span> with value <span class="machine"><span class="font-tt">v</span></span> under different handlers. The <span class="machine"><span class="font-tt">loop_send</span></span>
function handles the <span class="machine"><span class="font-tt">Send</span></span> effect and tail calls the <span class="machine"><span class="font-tt">loop_recv</span></span> function. If
the computation performs the <span class="machine"><span class="font-tt">Recv</span></span> effect, then <span class="machine"><span class="font-tt">loop_send</span></span> aborts the
computation by raising an exception. Similarly, the <span class="machine"><span class="font-tt">loop_recv</span></span> function
handles the <span class="machine"><span class="font-tt">Recv</span></span> effect and tail calls the <span class="machine"><span class="font-tt">loop_send</span></span> function. If the
computation performs the <span class="machine"><span class="font-tt">Send</span></span> effect, then <span class="machine"><span class="font-tt">loop_recv</span></span> aborts the
computation. Given that the continuation captured in the shallow handler do not
include the handler, there is only ever one handler installed in the dynamic
scope of the computation <span class="machine"><span class="font-tt">comp</span></span>.</p><p>The computation is initially executed by the <span class="machine"><span class="font-tt">loop_send</span></span> function (see last
line in the code above) which ensures that the first effect that the
computation is allowed to perform is the <span class="machine"><span class="font-tt">Send</span></span> effect. Note that the
computation is free to perform effects other than <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span>, which may
be handled by an outer handler.</p><p>We can see that the <span class="machine"><span class="font-tt">run</span></span> function will permit a computation that follows the
protocol:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run (<span class="ocamlkeyword">fun</span> () -&gt;
  printf <span class="ocamlstring">"Send 42\n"</span>;
  perform (Send 42);
  printf <span class="ocamlstring">"Recv: %d\n"</span> (perform Recv);
  printf <span class="ocamlstring">"Send 43\n"</span>;
  perform (Send 43);
  printf <span class="ocamlstring">"Recv: %d\n"</span> (perform Recv))</div>



<div class="pre caml-output ok">Send 42
Recv: 42
Send 43
Recv: 43
- : unit = ()</div></div>

</div><p>and aborts those that do not:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run (<span class="ocamlkeyword">fun</span> () -&gt;
  Printf.printf <span class="ocamlstring">"Send 0\n"</span>;
  perform (Send 0);
  Printf.printf <span class="ocamlstring">"Send 1\n"</span>;
  perform (Send 1) <span class="ocamlcomment">(* protocol violation *)</span>)</div>



<div class="pre caml-output ok">Send 0
Send 1
Exception: Failure <span class="ocamlstring">"protocol violation"</span>.</div></div>

</div><p>We may implement the same example using deep handlers using reference cells
(easy, but unsatisfying) or without them (harder). We leave this as an exercise
to the reader.
</p><!--CUT END -->

<!--TOC part id="sec335" PartÂ IIIâ€ƒThe OCaml tools-->
<table class="center"><tr><td><h1 class="part" id="sec335">PartÂ III<br>
The OCaml tools</h1></td></tr>
</table><!--SEC END --><p>
<a id="p:commands"></a></p>
<!--TOC chapter id="sec336" ChapterÂ 13â€ƒBatch compilation (ocamlc)-->
<h1 class="chapter" id="sec336">ChapterÂ 13â€ƒBatch compilation (ocamlc)</h1><!--SEC END --><p> <a id="c:camlc"></a>
</p><!--NAME comp.html-->
<p>This chapter describes the OCaml batch compiler <span class="machine"><span class="font-tt">ocamlc</span></span>,
which compiles OCaml source files to bytecode object files and links
these object files to produce standalone bytecode executable files.
These executable files are then run by the bytecode interpreter
<span class="machine"><span class="font-tt">ocamlrun</span></span>.</p>
<!--TOC section id="s:comp-overview" 13.1â€ƒOverview of the compiler-->
<h2 class="section" id="s:comp-overview"><a class="section-anchor" href="#s:comp-overview" aria-hidden="true">ï»¿</a>13.1â€ƒOverview of the compiler</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlc</span></span> command has a command-line interface similar to the one of
most C compilers. It accepts several types of arguments and processes them
sequentially, after all options have been processed:</p><ul class="itemize"><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.mli</span></span> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <span class="font-it">x</span><span class="machine"><span class="font-tt">.mli</span></span>, the <span class="machine"><span class="font-tt">ocamlc</span></span> compiler produces a compiled interface
in the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmi</span></span>.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.ml</span></span> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span>, the <span class="machine"><span class="font-tt">ocamlc</span></span>
compiler produces compiled object bytecode in the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmo</span></span>.<p>If the interface file <span class="font-it">x</span><span class="machine"><span class="font-tt">.mli</span></span> exists, the implementation
<span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span> is checked against the corresponding compiled interface
<span class="font-it">x</span><span class="machine"><span class="font-tt">.cmi</span></span>, which is assumed to exist. If no interface
<span class="font-it">x</span><span class="machine"><span class="font-tt">.mli</span></span> is provided, the compilation of <span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span> produces a
compiled interface file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmi</span></span> in addition to the compiled
object code file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmo</span></span>. The file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmi</span></span> produced
corresponds to an interface that exports everything that is defined in
the implementation <span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span>.</p></li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.cmo</span></span> are taken to be compiled object bytecode. These
files are linked together, along with the object files obtained
by compiling <span class="machine"><span class="font-tt">.ml</span></span> arguments (if any), and the OCaml standard
library, to produce a standalone executable program. The order in
which <span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.ml</span></span> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmo</span></span> file must come
before all <span class="machine"><span class="font-tt">.cmo</span></span> files that refer to the unit <span class="font-it">x</span>.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.cma</span></span> are taken to be libraries of object bytecode.
A library of object bytecode packs in a single file a set of object
bytecode files (<span class="machine"><span class="font-tt">.cmo</span></span> files). Libraries are built with <span class="machine"><span class="font-tt">ocamlc -a</span></span>
(see the description of the <span class="machine"><span class="font-tt">-a</span></span> option below). The object files
contained in the library are linked as regular <span class="machine"><span class="font-tt">.cmo</span></span> files (see
above), in the order specified when the <span class="machine"><span class="font-tt">.cma</span></span> file was built. The
only difference is that if an object file contained in a library is
not referenced anywhere in the program, then it is not linked in.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.c</span></span> are passed to the C compiler, which generates
a <span class="machine"><span class="font-tt">.o</span></span> object file (<span class="machine"><span class="font-tt">.obj</span></span> under Windows). This object file is linked
with the program if the <span class="machine"><span class="font-tt">-custom</span></span> flag is set (see the description of
<span class="machine"><span class="font-tt">-custom</span></span> below).</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.o</span></span> or <span class="machine"><span class="font-tt">.a</span></span> (<span class="machine"><span class="font-tt">.obj</span></span> or <span class="machine"><span class="font-tt">.lib</span></span> under Windows)
are assumed to be C object files and libraries. They are passed to the
C linker when linking in <span class="machine"><span class="font-tt">-custom</span></span> mode (see the description of
<span class="machine"><span class="font-tt">-custom</span></span> below).</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.so</span></span> (<span class="machine"><span class="font-tt">.dll</span></span> under Windows)
are assumed to be C shared libraries (DLLs). During linking, they are
searched for external C functions referenced from the OCaml code,
and their names are written in the generated bytecode executable.
The run-time system <span class="machine"><span class="font-tt">ocamlrun</span></span> then loads them dynamically at program
start-up time.</li></ul><p>The output of the linking phase is a file containing compiled bytecode
that can be executed by the OCaml bytecode interpreter:
the command named <span class="machine"><span class="font-tt">ocamlrun</span></span>. If <span class="machine"><span class="font-tt">a.out</span></span> is the name of the file
produced by the linking phase, the command
</p><pre>
        ocamlrun a.out <span class="font-it">arg</span><sub>1</sub> <span class="font-it">arg</span><sub>2</sub> â€¦ <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>
</pre><p>
executes the compiled code contained in <span class="machine"><span class="font-tt">a.out</span></span>, passing it as
arguments the character strings <span class="font-it">arg</span><sub>1</sub> to <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>.
(See chapterÂ <a href="#c%3Aruntime">15</a> for more details.)</p><p>On most systems, the file produced by the linking
phase can be run directly, as in:
</p><pre>
        ./a.out <span class="font-it">arg</span><sub>1</sub> <span class="font-it">arg</span><sub>2</sub> â€¦ <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>
</pre><p>
The produced file has the executable bit set, and it manages to launch
the bytecode interpreter by itself.</p><p>The compiler is able to emit some information on its internal stages.
It can output <span class="machine"><span class="font-tt">.cmt</span></span> files for the implementation of the compilation unit
and <span class="machine"><span class="font-tt">.cmti</span></span> for signatures if the option <span class="machine"><span class="font-tt">-bin-annot</span></span> is passed to it (see the
description of <span class="machine"><span class="font-tt">-bin-annot</span></span> below).
Each such file contains a typed abstract syntax tree (AST), that is produced
during the type checking procedure. This tree contains all available information
about the location and the specific type of each term in the source file.
The AST is partial if type checking was unsuccessful.</p><p>These <span class="machine"><span class="font-tt">.cmt</span></span> and <span class="machine"><span class="font-tt">.cmti</span></span> files are typically useful for code inspection tools.</p>
<!--TOC section id="s:comp-options" 13.2â€ƒOptions-->
<h2 class="section" id="s:comp-options"><a class="section-anchor" href="#s:comp-options" aria-hidden="true">ï»¿</a>13.2â€ƒOptions</h2><!--SEC END --><p>The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamlc</span></span>.
The options <span class="machine"><span class="font-tt">-pack</span></span>, <span class="machine"><span class="font-tt">-a</span></span>, <span class="machine"><span class="font-tt">-c</span></span>, <span class="machine"><span class="font-tt">-output-obj</span></span> and <span class="machine"><span class="font-tt">-output-complete-obj</span></span> are mutually exclusive.
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-a</span></span></span></dt><dd class="dd-description">
Build a library(<span class="machine"><span class="font-tt">.cma</span></span> file)
with the object files ( <span class="machine"><span class="font-tt">.cmo</span></span> files)
given on the command line, instead of linking them into an executable file.
The name of the library must be set with the <span class="machine"><span class="font-tt">-o</span></span> option.<p>If <span class="machine"><span class="font-tt">-custom</span></span>, <span class="machine"><span class="font-tt">-cclib</span></span> or <span class="machine"><span class="font-tt">-ccopt</span></span> options are passed on the command
line, these options are stored in the resulting <span class="machine"><span class="font-tt">.cma</span></span>library. Then,
linking with this library automatically adds back the <span class="machine"><span class="font-tt">-custom</span></span>, 
<span class="machine"><span class="font-tt">-cclib</span></span> and <span class="machine"><span class="font-tt">-ccopt</span></span> options as if they had been provided on the
command line, unless the <span class="machine"><span class="font-tt">-noautolink</span></span> option is given.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-absname</span></span></span></dt><dd class="dd-description">
Force error messages to show absolute paths for file names.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-annot</span></span></span></dt><dd class="dd-description">
Deprecated since OCaml 4.11. Please use <span class="machine"><span class="font-tt">-bin-annot</span></span> instead.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional newline-terminated command line arguments from <span class="font-it">filename</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args0</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional null character terminated command line arguments from
<span class="font-it">filename</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-bin-annot</span></span></span></dt><dd class="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc) in binary format. The information for file <span class="font-it">src</span><span class="machine"><span class="font-tt">.ml</span></span>
(resp. <span class="font-it">src</span><span class="machine"><span class="font-tt">.mli</span></span>) is put into file <span class="font-it">src</span><span class="machine"><span class="font-tt">.cmt</span></span>
(resp. <span class="font-it">src</span><span class="machine"><span class="font-tt">.cmti</span></span>). In case of a type error, dump
all the information inferred by the type-checker before the error.
The <span class="machine"><span class="font-tt">*.cmt</span></span> and <span class="machine"><span class="font-tt">*.cmti</span></span> files produced by <span class="machine"><span class="font-tt">-bin-annot</span></span> contain
more information and are much more compact than the files produced by
<span class="machine"><span class="font-tt">-annot</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-c</span></span></span></dt><dd class="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cc</span></span> <span class="font-it">ccomp</span></span></dt><dd class="dd-description">
Use <span class="font-it">ccomp</span> as the C linker 
when linking in â€œcustom runtimeâ€ mode (see the <span class="machine"><span class="font-tt">-custom</span></span> option)
and as the C compiler for compiling <span class="machine"><span class="font-tt">.c</span></span> source files.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cclib</span></span> <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span></span></dt><dd class="dd-description">
Pass the <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span> option to the C linker
when linking in â€œcustom runtimeâ€ mode (see the <span class="machine"><span class="font-tt">-custom</span></span> option).
This causes the given C library to be linked with the program.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ccopt</span></span> <span class="font-it">option</span></span></dt><dd class="dd-description">
Pass the given option to the C compiler and linker.
When linking in â€œcustom runtimeâ€ mode, for instance <span class="machine"><span class="font-tt">-ccopt -L</span></span><span class="font-it">dir</span> causes the C linker to search for C libraries in
directory <span class="font-it">dir</span>. (See the <span class="machine"><span class="font-tt">-custom</span></span> option.)
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cmi-file</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Use the given interface file to type-check the ML source file to compile.
When this option is not specified, the compiler looks for a <span class="font-it">.mli</span> file
with the same base name than the implementation it is compiling and in the
same directory. If such a file is found, the compiler looks for a
corresponding <span class="font-it">.cmi</span> file in the included directories and reports an
error if it fails to find one.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-color</span></span> <span class="font-it">mode</span></span></dt><dd class="dd-description">
Enable or disable colors in compiler messages (especially warnings and errors).
The following modes are supported:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">auto</span></span></span></dt><dd class="dd-description"> use heuristics to enable colors only if the output supports them
(an ANSI-compatible tty terminal);
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">always</span></span></span></dt><dd class="dd-description"> enable colors unconditionally;
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">never</span></span></span></dt><dd class="dd-description"> disable color output.
</dd></dl><p>The environment variable <span class="machine"><span class="font-tt">OCAML_COLOR</span></span> is considered if <span class="machine"><span class="font-tt">-color</span></span> is not
provided. Its values are auto/always/never as above.</p><p>If <span class="machine"><span class="font-tt">-color</span></span> is not provided, <span class="machine"><span class="font-tt">OCAML_COLOR</span></span> is not set and the environment
variable <span class="machine"><span class="font-tt">NO_COLOR</span></span> is set, then color output is disabled. Otherwise,
the default setting is â€™autoâ€™, and the current heuristic
checks that the <span class="machine"><span class="font-tt">TERM</span></span> environment variable exists and is
not empty or <span class="machine"><span class="font-tt">dumb</span></span>, and that â€™isatty(stderr)â€™ holds.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-error-style</span></span> <span class="font-it">mode</span></span></dt><dd class="dd-description">
Control the way error messages and warnings are printed.
The following modes are supported:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">short</span></span></span></dt><dd class="dd-description"> only print the error and its location;
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">contextual</span></span></span></dt><dd class="dd-description"> like <span class="machine"><span class="font-tt">short</span></span>, but also display the source code snippet
corresponding to the location of the error.
</dd></dl>
The default setting is <span class="machine"><span class="font-tt">contextual</span></span>.<p>The environment variable <span class="machine"><span class="font-tt">OCAML_ERROR_STYLE</span></span> is considered if <span class="machine"><span class="font-tt">-error-style</span></span> is
not provided. Its values are short/contextual as above.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-compat-32</span></span></span></dt><dd class="dd-description">
Check that the generated bytecode executable can run on 32-bit
platforms and signal an error if it cannot. This is useful when
compiling bytecode on a 64-bit machine.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-config</span></span></span></dt><dd class="dd-description">
Print the version number of <span class="machine"><span class="font-tt">ocamlc</span></span> and a detailed
summary of its configuration, then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-config-var</span></span> <span class="font-it">var</span></span></dt><dd class="dd-description">
Print the value of a specific configuration variable from the
<span class="machine"><span class="font-tt">-config</span></span> output, then exit. If the variable does not exist, the exit
code is non-zero. This option is only available since OCaml 4.08,
so script authors should have a fallback for older versions.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-custom</span></span></span></dt><dd class="dd-description">
Link in â€œcustom runtimeâ€ mode. In the default linking mode, the
linker produces bytecode that is intended to be executed with the
shared runtime system, <span class="machine"><span class="font-tt">ocamlrun</span></span>. In the custom runtime mode, the
linker produces an output file that contains both the runtime system
and the bytecode for the program. The resulting file is larger, but it
can be executed directly, even if the <span class="machine"><span class="font-tt">ocamlrun</span></span> command is not
installed. Moreover, the â€œcustom runtimeâ€ mode enables static
linking of OCaml code with user-defined C functions, as described in
chapterÂ <a href="#c%3Aintf-c">22</a>.
<blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ
Never use the <span class="machine"><span class="font-tt">strip</span></span> command on executables produced by <span class="machine"><span class="font-tt">ocamlc -custom</span></span>,
this would remove the bytecode part of the executable.
</blockquote>
<blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ
Security warning: never set the â€œsetuidâ€ or â€œsetgidâ€ bits on executables
produced by <span class="machine"><span class="font-tt">ocamlc -custom</span></span>, this would make them vulnerable to attacks.
</blockquote>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-depend</span></span> <span class="font-it">ocamldep-args</span></span></dt><dd class="dd-description">
Compute dependencies, as the <span class="machine"><span class="font-tt">ocamldep</span></span> command would do. The remaining
arguments are interpreted as if they were given to the <span class="machine"><span class="font-tt">ocamldep</span></span> command.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dllib</span></span> <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span></span></dt><dd class="dd-description">
Arrange for the C shared library <span class="machine"><span class="font-tt">dll</span></span><span class="font-it">libname</span><span class="machine"><span class="font-tt">.so</span></span>
(<span class="machine"><span class="font-tt">dll</span></span><span class="font-it">libname</span><span class="machine"><span class="font-tt">.dll</span></span> under Windows) to be loaded dynamically
by the run-time system <span class="machine"><span class="font-tt">ocamlrun</span></span> at program start-up time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dllpath</span></span> <span class="font-it">dir</span></span></dt><dd class="dd-description">
Adds the directory <span class="font-it">dir</span> to the run-time search path for shared
C libraries. At link-time, shared libraries are searched in the
standard search path (the one corresponding to the <span class="machine"><span class="font-tt">-I</span></span> option).
The <span class="machine"><span class="font-tt">-dllpath</span></span> option simply stores <span class="font-it">dir</span> in the produced
executable file, where <span class="machine"><span class="font-tt">ocamlrun</span></span> can find it and use it as
described in sectionÂ <a href="#s%3Aocamlrun-dllpath">15.3</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-for-pack</span></span> <span class="font-it">module-path</span></span></dt><dd class="dd-description">
Generate an object file (<span class="machine"><span class="font-tt">.cmo</span></span>)
that can later be included
as a sub-module (with the given access path) of a compilation unit
constructed with <span class="machine"><span class="font-tt">-pack</span></span>. For instance,
<span class="machine"><span class="font-tt">ocamlc -for-pack P -c A.ml</span></span>
will generate <span class="machine"><span class="font-tt">a..cmo</span></span> that can
later be used with <span class="machine"><span class="font-tt">ocamlc -pack -o P.cmo a.cmo</span></span>.
Note: you can still pack a module that was compiled without
<span class="machine"><span class="font-tt">-for-pack</span></span> but in this case exceptions will be printed with the wrong
names.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-g</span></span></span></dt><dd class="dd-description">
Add debugging information while compiling and linking. This option is
required in order to be able to debug the program with <span class="machine"><span class="font-tt">ocamldebug</span></span>
(see chapterÂ <a href="#c%3Adebugger">20</a>), and to produce stack backtraces when
the program terminates on an uncaught exception (see
sectionÂ <a href="#s%3Aocamlrun-options">15.2</a>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-i</span></span></span></dt><dd class="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<span class="machine"><span class="font-tt">.ml</span></span>
file). No compiled files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cmi</span></span> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<span class="machine"><span class="font-tt">.mli</span></span> file) for a file:
just redirect the standard output of the compiler to a <span class="machine"><span class="font-tt">.mli</span></span> file,
and edit that file to remove all declarations of unexported names.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for

compiled interface files (<span class="machine"><span class="font-tt">.cmi</span></span>), compiled object code files <span class="machine"><span class="font-tt">.cmo</span></span>,
libraries (<span class="machine"><span class="font-tt">.cma</span></span>) and C libraries specified with <span class="machine"><span class="font-tt">-cclib -lxxx</span></span>.

By default, the current directory is searched first, then the standard
library directory. Directories added with <span class="machine"><span class="font-tt">-I</span></span> are searched after the
current directory, in the order in which they were given on the command line,
but before the standard library directory. See also option <span class="machine"><span class="font-tt">-nostdlib</span></span>.<p>If the given directory starts with <span class="machine"><span class="font-tt">+</span></span>, it is taken relative to the
standard library directory. For instance, <span class="machine"><span class="font-tt">-I +unix</span></span> adds the
subdirectory <span class="machine"><span class="font-tt">unix</span></span> of the standard library to the search path.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-impl</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Compile the file <span class="font-it">filename</span> as an implementation file, even if its
extension is not <span class="machine"><span class="font-tt">.ml</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Compile the file <span class="font-it">filename</span> as an interface file, even if its
extension is not <span class="machine"><span class="font-tt">.mli</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf-suffix</span></span> <span class="font-it">string</span></span></dt><dd class="dd-description">
Recognize file names ending with <span class="font-it">string</span> as interface files
(instead of the default <span class="machine"><span class="font-tt">.mli</span></span>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-labels</span></span></span></dt><dd class="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-linkall</span></span></span></dt><dd class="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (option <span class="machine"><span class="font-tt">-a</span></span>), setting the <span class="machine"><span class="font-tt">-linkall</span></span> option forces all
subsequent links of programs involving that library to link all the
modules contained in the library. When compiling a module (option
<span class="machine"><span class="font-tt">-c</span></span>), setting the <span class="machine"><span class="font-tt">-linkall</span></span> option ensures that this module will
always be linked if it is put in a library and this library is linked.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-make-runtime</span></span></span></dt><dd class="dd-description">
Build a custom runtime system (in the file specified by option <span class="machine"><span class="font-tt">-o</span></span>)
incorporating the C object files and libraries given on the command
line. This custom runtime system can be used later to execute
bytecode executables produced with the
<span class="machine"><span class="font-tt">ocamlc -use-runtime</span></span> <span class="font-it">runtime-name</span> option.
See sectionÂ <a href="#ss%3Acustom-runtime">22.1.6</a> for more information.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-match-context-rows</span></span></span></dt><dd class="dd-description">
Set the number of rows of context used for optimization during
pattern matching compilation. The default value is 32. Lower values
cause faster compilation, but less optimized code. This advanced
option is meant for use in the event that a pattern-match-heavy
program leads to significant increases in compilation time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-alias-deps</span></span></span></dt><dd class="dd-description">
Do not record dependencies for module aliases. See
sectionÂ <a href="#s%3Amodule-alias">12.8</a> for more information.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-app-funct</span></span></span></dt><dd class="dd-description">
Deactivates the applicative behaviour of functors. With this option,
each functor application generates new types in its result and
applying the same functor twice to the same argument yields two
incompatible structures.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noassert</span></span></span></dt><dd class="dd-description">
Do not compile assertion checks. Note that the special form
<span class="machine"><span class="font-tt">assert false</span></span> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noautolink</span></span></span></dt><dd class="dd-description">
When linking <span class="machine"><span class="font-tt">.cma</span></span>libraries, ignore <span class="machine"><span class="font-tt">-custom</span></span>, <span class="machine"><span class="font-tt">-cclib</span></span> and <span class="machine"><span class="font-tt">-ccopt</span></span>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <span class="machine"><span class="font-tt">-noautolink</span></span> and pass the correct C
libraries and options on the command line.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nolabels</span></span></span></dt><dd class="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nostdlib</span></span></span></dt><dd class="dd-description">
Do not include the standard library directory in the list of
directories searched for
compiled interface files (<span class="machine"><span class="font-tt">.cmi</span></span>), compiled object code files
(<span class="machine"><span class="font-tt">.cmo</span></span>), libraries (<span class="machine"><span class="font-tt">.cma</span></span>), and C libraries specified with
<span class="machine"><span class="font-tt">-cclib -lxxx</span></span>. See also option <span class="machine"><span class="font-tt">-I</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">output-file</span></span></dt><dd class="dd-description">
Specify the name of the output file to produce. For executable files, the
default output name is <span class="machine"><span class="font-tt">a.out</span></span> under Unix and <span class="machine"><span class="font-tt">camlprog.exe</span></span> under
Windows. If the <span class="machine"><span class="font-tt">-a</span></span> option is given, specify the name of the library
produced. If the <span class="machine"><span class="font-tt">-pack</span></span> option is given, specify the name of the
packed object file produced. If the <span class="machine"><span class="font-tt">-output-obj</span></span> or <span class="machine"><span class="font-tt">-output-complete-obj</span></span>
options are given, specify the name of the produced object file.

If the <span class="machine"><span class="font-tt">-c</span></span> option is given, specify the name of the object
file produced for the <em>next</em> source file that appears on the
command line.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-opaque</span></span></span></dt><dd class="dd-description">
When the native compiler compiles an implementation, by default it
produces a <span class="machine"><span class="font-tt">.cmx</span></span> file containing information for cross-module
optimization. It also expects <span class="machine"><span class="font-tt">.cmx</span></span> files to be present for the
dependencies of the currently compiled source, and uses them for
optimization. Since OCaml 4.03, the compiler will emit a warning if it
is unable to locate the <span class="machine"><span class="font-tt">.cmx</span></span> file of one of those dependencies.<p>The <span class="machine"><span class="font-tt">-opaque</span></span> option, available since 4.04, disables cross-module
optimization information for the currently compiled unit. When
compiling <span class="machine"><span class="font-tt">.mli</span></span> interface, using <span class="machine"><span class="font-tt">-opaque</span></span> marks the compiled <span class="machine"><span class="font-tt">.cmi</span></span>
interface so that subsequent compilations of modules that depend on it
will not rely on the corresponding <span class="machine"><span class="font-tt">.cmx</span></span> file, nor warn if it is
absent. When the native compiler compiles a <span class="machine"><span class="font-tt">.ml</span></span> implementation,
using <span class="machine"><span class="font-tt">-opaque</span></span> generates a <span class="machine"><span class="font-tt">.cmx</span></span> that does not contain any
cross-module optimization information.</p><p>Using this option may degrade the quality of generated code, but it
reduces compilation time, both on clean and incremental
builds. Indeed, with the native compiler, when the implementation of
a compilation unit changes, all the units that depend on it may need
to be recompiled â€“ because the cross-module information may have
changed. If the compilation unit whose implementation changed was
compiled with <span class="machine"><span class="font-tt">-opaque</span></span>, no such recompilation needs to occur. This
option can thus be used, for example, to get faster edit-compile-test
feedback loops.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-open</span></span> <span class="font-it">Module</span></span></dt><dd class="dd-description">
Opens the given module before processing the interface or
implementation files. If several <span class="machine"><span class="font-tt">-open</span></span> options are given,
they are processed in order, just as if
the statements <span class="machine"><span class="font-tt">open!</span></span> <span class="font-it">Module1</span><span class="machine"><span class="font-tt">;;</span></span> <span class="machine"><span class="font-tt">...</span></span> <span class="machine"><span class="font-tt">open!</span></span> <span class="font-it">ModuleN</span><span class="machine"><span class="font-tt">;;</span></span>
were added at the top of each file.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-output-obj</span></span></span></dt><dd class="dd-description">
Cause the linker to produce a C object file instead of
a bytecode executable file.
This is useful to wrap OCaml code as a C library,
callable from any C program. See chapterÂ <a href="#c%3Aintf-c">22</a>,
sectionÂ <a href="#ss%3Ac-embedded-code">22.7.5</a>. The name of the output object file
must be set with the <span class="machine"><span class="font-tt">-o</span></span> option.
This option can also be used to produce a C source file (<span class="machine"><span class="font-tt">.c</span></span> extension)
or a compiled shared/dynamic library (<span class="machine"><span class="font-tt">.so</span></span> extension, <span class="machine"><span class="font-tt">.dll</span></span> under Windows).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-output-complete-exe</span></span></span></dt><dd class="dd-description">
Build a self-contained executable by linking a C object file containing the
bytecode program, the OCaml runtime system and any other static C code given to
<span class="machine"><span class="font-tt">ocamlc</span></span>. The resulting effect is similar to <span class="machine"><span class="font-tt">-custom</span></span>, except that the bytecode
is embedded in the C code so it is no longer accessible to tools such as
<span class="machine"><span class="font-tt">ocamldebug</span></span>. On the other hand, the resulting binary is resistant to <span class="machine"><span class="font-tt">strip</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-output-complete-obj</span></span></span></dt><dd class="dd-description">
Same as <span class="machine"><span class="font-tt">-output-obj</span></span> options except the object file produced includes the
runtime and autolink libraries.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pack</span></span></span></dt><dd class="dd-description">
Build a bytecode object file (<span class="machine"><span class="font-tt">.cmo</span></span> file) and its associated compiled
interface (<span class="machine"><span class="font-tt">.cmi</span></span>) that combines the object
files given on the command line, making them appear as sub-modules of
the output <span class="machine"><span class="font-tt">.cmo</span></span> file. The name of the output <span class="machine"><span class="font-tt">.cmo</span></span> file must be
given with the <span class="machine"><span class="font-tt">-o</span></span> option. For instance,
<pre>        ocamlc -pack -o p.cmo a.cmo b.cmo c.cmo
</pre>generates compiled files <span class="machine"><span class="font-tt">p.cmo</span></span> and <span class="machine"><span class="font-tt">p.cmi</span></span> describing a compilation
unit having three sub-modules <span class="machine"><span class="font-tt">A</span></span>, <span class="machine"><span class="font-tt">B</span></span> and <span class="machine"><span class="font-tt">C</span></span>, corresponding to the
contents of the object files <span class="machine"><span class="font-tt">a.cmo</span></span>, <span class="machine"><span class="font-tt">b.cmo</span></span> and <span class="machine"><span class="font-tt">c.cmo</span></span>. These
contents can be referenced as <span class="machine"><span class="font-tt">P.A</span></span>, <span class="machine"><span class="font-tt">P.B</span></span> and <span class="machine"><span class="font-tt">P.C</span></span> in the remainder
of the program.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pp</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
Cause the compiler to call the given <span class="font-it">command</span> as a preprocessor
for each source file. The output of <span class="font-it">command</span> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ppx</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
After parsing, pipe the abstract syntax tree through the preprocessor
<span class="font-it">command</span>. The module <span class="machine"><span class="font-tt">Ast_mapper</span></span>, described in
chapterÂ <a href="#c%3Aparsinglib">29</a>:
<a href="compilerlibref/Ast_mapper.html"> <span class="font-tt">Ast_mapper</span> </a>
,
implements the external interface of a preprocessor.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-principal</span></span></span></dt><dd class="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <span class="machine"><span class="font-tt">-principal</span></span> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rectypes</span></span></span></dt><dd class="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-runtime-variant</span></span> <span class="font-it">suffix</span></span></dt><dd class="dd-description">
Add the <span class="font-it">suffix</span> string to the name of the runtime library used by
the program. Currently, only one such suffix is supported: <span class="machine"><span class="font-tt">d</span></span>, and
only if the OCaml compiler was configured with option
<span class="machine"><span class="font-tt">-with-debug-runtime</span></span>. This suffix gives the debug version of the
runtime, which is useful for debugging pointer problems in low-level
code such as C stubs.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-stop-after</span></span> <span class="font-it">pass</span></span></dt><dd class="dd-description">
Stop compilation after the given compilation pass. The currently
supported passes are:
<span class="machine"><span class="font-tt">parsing</span></span>, <span class="machine"><span class="font-tt">typing</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-safe-string</span></span></span></dt><dd class="dd-description">
Enforce the separation between types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>,
thereby making strings read-only. This is the default, and enforced
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-short-paths</span></span></span></dt><dd class="dd-description">
When a type is visible under several module-paths, use the shortest
one when printing the typeâ€™s name in inferred interfaces and error and
warning messages. Identifier names starting with an underscore <span class="machine"><span class="font-tt">_</span></span> or
containing double underscores <span class="machine"><span class="font-tt">__</span></span> incur a penalty of +10 when computing
their length.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-sequence</span></span></span></dt><dd class="dd-description">
Force the left-hand part of each sequence to have type unit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-formats</span></span></span></dt><dd class="dd-description">
Reject invalid formats that were accepted in legacy format
implementations. You should use this flag to detect and fix such
invalid formats, as they will be rejected by future OCaml versions.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unboxed-types</span></span></span></dt><dd class="dd-description">
When a type is unboxable (i.e. a record with a single argument or a
concrete datatype with a single constructor of one argument) it will
be unboxed unless annotated with <span class="machine"><span class="font-tt">[@@ocaml.boxed]</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-unboxed-types</span></span></span></dt><dd class="dd-description">
When a type is unboxable it will be boxed unless annotated with
<span class="machine"><span class="font-tt">[@@ocaml.unboxed]</span></span>. This is the default.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe</span></span></span></dt><dd class="dd-description">
Turn bound checking off for array and string accesses (the <span class="machine"><span class="font-tt">v.(i)</span></span> and
<span class="machine"><span class="font-tt">s.[i]</span></span> constructs). Programs compiled with <span class="machine"><span class="font-tt">-unsafe</span></span> are therefore
slightly faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.
Additionally, turn off the check for zero divisor in integer division
and modulus operations. With <span class="machine"><span class="font-tt">-unsafe</span></span>, an integer division
(or modulus) by zero can halt the program or continue with an
unspecified result instead of raising a <span class="machine"><span class="font-tt">Division_by_zero</span></span> exception.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe-string</span></span></span></dt><dd class="dd-description">
Identify the types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>, thereby making strings writable.
This is intended for compatibility with old source code and should not
be used with new software. This option raises an error unconditionally
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-use-runtime</span></span> <span class="font-it">runtime-name</span></span></dt><dd class="dd-description">
Generate a bytecode executable file that can be executed on the custom
runtime system <span class="font-it">runtime-name</span>, built earlier with
<span class="machine"><span class="font-tt">ocamlc -make-runtime</span></span> <span class="font-it">runtime-name</span>.
See sectionÂ <a href="#ss%3Acustom-runtime">22.1.6</a> for more information.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-verbose</span></span></span></dt><dd class="dd-description">
Print all external commands before they are executed,

in particular invocations of the C compiler and linker in <span class="machine"><span class="font-tt">-custom</span></span> mode.
Useful to debug C library problems.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span> or <span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print the version number of the compiler in short form (e.g. <span class="machine"><span class="font-tt">3.11.0</span></span>),
then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-w</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Enable, disable, or mark as fatal the warnings specified by the argument
<span class="font-it">warning-list</span>.
Each warning can be <em>enabled</em> or <em>disabled</em>, and each warning
can be <em>fatal</em> or <em>non-fatal</em>.
If a warning is disabled, it isnâ€™t displayed and doesnâ€™t affect
compilation in any way (even if it is fatal). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and fatal, the compiler will also
stop with an error after displaying it.<p>The <span class="font-it">warning-list</span> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Disable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Disable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable and mark as fatal warnings in
the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable and mark as fatal the set of warnings
corresponding to <span class="font-it">letter</span>. The letter may be uppercase or
lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">uppercase-letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding
to <span class="font-it">uppercase-letter</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">lowercase-letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding
to <span class="font-it">lowercase-letter</span>.
</dd></dl><p>Alternatively, <span class="font-it">warning-list</span> can specify a single warning using its
mnemonic name (see below), as follows:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Disable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning <span class="font-it">name</span>.
</dd></dl><p>Warning numbers, letters and names which are not currently defined are
ignored. The warnings are as follows (the name following each number specifies
the mnemonic for that warning).
</p><dl class="description"><dt class="dt-description"><span class="font-bold">1 <span class="machine"><span class="font-tt">comment-start</span></span></span></dt><dd class="dd-description"> Suspicious-looking start-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">2 <span class="machine"><span class="font-tt">comment-not-end</span></span></span></dt><dd class="dd-description"> Suspicious-looking end-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">3</span></dt><dd class="dd-description"> Deprecated synonym for the â€™deprecatedâ€™ alert.
</dd><dt class="dt-description"><span class="font-bold">4 <span class="machine"><span class="font-tt">fragile-match</span></span></span></dt><dd class="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</dd><dt class="dt-description"><span class="font-bold">5 <span class="machine"><span class="font-tt">ignored-partial-application</span></span></span></dt><dd class="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</dd><dt class="dt-description"><span class="font-bold">6 <span class="machine"><span class="font-tt">labels-omitted</span></span></span></dt><dd class="dd-description"> Label omitted in function application.
</dd><dt class="dt-description"><span class="font-bold">7 <span class="machine"><span class="font-tt">method-override</span></span></span></dt><dd class="dd-description"> Method overridden.
</dd><dt class="dt-description"><span class="font-bold">8 <span class="machine"><span class="font-tt">partial-match</span></span></span></dt><dd class="dd-description"> Partial match: missing cases in pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">9 <span class="machine"><span class="font-tt">missing-record-field-pattern</span></span></span></dt><dd class="dd-description"> Missing fields in a record pattern.
</dd><dt class="dt-description"><span class="font-bold">10 <span class="machine"><span class="font-tt">non-unit-statement</span></span></span></dt><dd class="dd-description"> Expression on the left-hand side of a sequence that doesnâ€™t have type
<span class="machine"><span class="font-tt">unit</span></span> (and that is not a function, see warning number 5).
</dd><dt class="dt-description"><span class="font-bold">11 <span class="machine"><span class="font-tt">redundant-case</span></span></span></dt><dd class="dd-description"> Redundant case in a pattern matching (unused match case).
</dd><dt class="dt-description"><span class="font-bold">12 <span class="machine"><span class="font-tt">redundant-subpat</span></span></span></dt><dd class="dd-description"> Redundant sub-pattern in a pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">13 <span class="machine"><span class="font-tt">instance-variable-override</span></span></span></dt><dd class="dd-description"> Instance variable overridden.
</dd><dt class="dt-description"><span class="font-bold">14 <span class="machine"><span class="font-tt">illegal-backslash</span></span></span></dt><dd class="dd-description"> Illegal backslash escape in a string constant.
</dd><dt class="dt-description"><span class="font-bold">15 <span class="machine"><span class="font-tt">implicit-public-methods</span></span></span></dt><dd class="dd-description"> Private method made public implicitly.
</dd><dt class="dt-description"><span class="font-bold">16 <span class="machine"><span class="font-tt">unerasable-optional-argument</span></span></span></dt><dd class="dd-description"> Unerasable optional argument.
</dd><dt class="dt-description"><span class="font-bold">17 <span class="machine"><span class="font-tt">undeclared-virtual-method</span></span></span></dt><dd class="dd-description"> Undeclared virtual method.
</dd><dt class="dt-description"><span class="font-bold">18 <span class="machine"><span class="font-tt">not-principal</span></span></span></dt><dd class="dd-description"> Non-principal type.
</dd><dt class="dt-description"><span class="font-bold">19 <span class="machine"><span class="font-tt">non-principal-labels</span></span></span></dt><dd class="dd-description"> Type without principality.
</dd><dt class="dt-description"><span class="font-bold">20 <span class="machine"><span class="font-tt">ignored-extra-argument</span></span></span></dt><dd class="dd-description"> Unused function argument.
</dd><dt class="dt-description"><span class="font-bold">21 <span class="machine"><span class="font-tt">nonreturning-statement</span></span></span></dt><dd class="dd-description"> Non-returning statement.
</dd><dt class="dt-description"><span class="font-bold">22 <span class="machine"><span class="font-tt">preprocessor</span></span></span></dt><dd class="dd-description"> Preprocessor warning.
</dd><dt class="dt-description"><span class="font-bold">23 <span class="machine"><span class="font-tt">useless-record-with</span></span></span></dt><dd class="dd-description"> Useless record <span class="machine"><span class="font-tt">with</span></span> clause.
</dd><dt class="dt-description"><span class="font-bold">24 <span class="machine"><span class="font-tt">bad-module-name</span></span></span></dt><dd class="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</dd><dt class="dt-description"><span class="font-bold">25</span></dt><dd class="dd-description"> Ignored: now part of warning 8.
</dd><dt class="dt-description"><span class="font-bold">26 <span class="machine"><span class="font-tt">unused-var</span></span></span></dt><dd class="dd-description"> Suspicious unused variable: unused variable that is bound
with <span class="machine"><span class="font-tt">let</span></span> or <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">27 <span class="machine"><span class="font-tt">unused-var-strict</span></span></span></dt><dd class="dd-description"> Innocuous unused variable: unused variable that is not bound with
<span class="machine"><span class="font-tt">let</span></span> nor <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">28 <span class="machine"><span class="font-tt">wildcard-arg-to-constant-constr</span></span></span></dt><dd class="dd-description"> Wildcard pattern given as argument to a constant constructor.
</dd><dt class="dt-description"><span class="font-bold">29 <span class="machine"><span class="font-tt">eol-in-string</span></span></span></dt><dd class="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</dd><dt class="dt-description"><span class="font-bold">30 <span class="machine"><span class="font-tt">duplicate-definitions</span></span></span></dt><dd class="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.
</dd><dt class="dt-description"><span class="font-bold">31 <span class="machine"><span class="font-tt">module-linked-twice</span></span></span></dt><dd class="dd-description"> A module is linked twice in the same executable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">32 <span class="machine"><span class="font-tt">unused-value-declaration</span></span></span></dt><dd class="dd-description"> Unused value declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">33 <span class="machine"><span class="font-tt">unused-open</span></span></span></dt><dd class="dd-description"> Unused open statement. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">34 <span class="machine"><span class="font-tt">unused-type-declaration</span></span></span></dt><dd class="dd-description"> Unused type declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">35 <span class="machine"><span class="font-tt">unused-for-index</span></span></span></dt><dd class="dd-description"> Unused for-loop index. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">36 <span class="machine"><span class="font-tt">unused-ancestor</span></span></span></dt><dd class="dd-description"> Unused ancestor variable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">37 <span class="machine"><span class="font-tt">unused-constructor</span></span></span></dt><dd class="dd-description"> Unused constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">38 <span class="machine"><span class="font-tt">unused-extension</span></span></span></dt><dd class="dd-description"> Unused extension constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">39 <span class="machine"><span class="font-tt">unused-rec-flag</span></span></span></dt><dd class="dd-description"> Unused rec flag. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">40 <span class="machine"><span class="font-tt">name-out-of-scope</span></span></span></dt><dd class="dd-description"> Constructor or label name used out of scope. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">41 <span class="machine"><span class="font-tt">ambiguous-name</span></span></span></dt><dd class="dd-description"> Ambiguous constructor or label name. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">42 <span class="machine"><span class="font-tt">disambiguated-name</span></span></span></dt><dd class="dd-description"> Disambiguated constructor or label name (compatibility warning). (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">43 <span class="machine"><span class="font-tt">nonoptional-label</span></span></span></dt><dd class="dd-description"> Nonoptional label applied as optional. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">44 <span class="machine"><span class="font-tt">open-shadow-identifier</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined identifier. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">45 <span class="machine"><span class="font-tt">open-shadow-label-constructor</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined label or constructor. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">46 <span class="machine"><span class="font-tt">bad-env-variable</span></span></span></dt><dd class="dd-description"> Error in environment variable. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">47 <span class="machine"><span class="font-tt">attribute-payload</span></span></span></dt><dd class="dd-description"> Illegal attribute payload. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">48 <span class="machine"><span class="font-tt">eliminated-optional-arguments</span></span></span></dt><dd class="dd-description"> Implicit elimination of optional arguments. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">49 <span class="machine"><span class="font-tt">no-cmi-file</span></span></span></dt><dd class="dd-description"> Absent cmi file when looking up module alias. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">50 <span class="machine"><span class="font-tt">unexpected-docstring</span></span></span></dt><dd class="dd-description"> Unexpected documentation comment. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">51 <span class="machine"><span class="font-tt">wrong-tailcall-expectation</span></span></span></dt><dd class="dd-description"> Function call annotated with an incorrect @tailcall attribute. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">52 <span class="machine"><span class="font-tt">fragile-literal-pattern</span></span> (see </span><a href="#ss%3Awarn52"><span class="font-bold">13.5.3</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Fragile constant pattern. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">53 <span class="machine"><span class="font-tt">misplaced-attribute</span></span></span></dt><dd class="dd-description"> Attribute cannot appear in this context. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">54 <span class="machine"><span class="font-tt">duplicated-attribute</span></span></span></dt><dd class="dd-description"> Attribute used more than once on an expression. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">55 <span class="machine"><span class="font-tt">inlining-impossible</span></span></span></dt><dd class="dd-description"> Inlining impossible. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">56 <span class="machine"><span class="font-tt">unreachable-case</span></span></span></dt><dd class="dd-description"> Unreachable case in a pattern-matching (based on type information). (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">57 <span class="machine"><span class="font-tt">ambiguous-var-in-pattern-guard</span></span> (see </span><a href="#ss%3Awarn57"><span class="font-bold">13.5.4</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Ambiguous or-pattern variables under guard. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">58 <span class="machine"><span class="font-tt">no-cmx-file</span></span></span></dt><dd class="dd-description"> Missing cmx file. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">59 <span class="machine"><span class="font-tt">flambda-assignment-to-non-mutable-value</span></span></span></dt><dd class="dd-description"> Assignment to non-mutable value. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">60 <span class="machine"><span class="font-tt">unused-module</span></span></span></dt><dd class="dd-description"> Unused module declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">61 <span class="machine"><span class="font-tt">unboxable-type-in-prim-decl</span></span></span></dt><dd class="dd-description"> Unboxable type in primitive declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">62 <span class="machine"><span class="font-tt">constraint-on-gadt</span></span></span></dt><dd class="dd-description"> Type constraint on GADT type declaration. (since 4.06)
</dd><dt class="dt-description"><span class="font-bold">63 <span class="machine"><span class="font-tt">erroneous-printed-signature</span></span></span></dt><dd class="dd-description"> Erroneous printed signature. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">64 <span class="machine"><span class="font-tt">unsafe-array-syntax-without-parsing</span></span></span></dt><dd class="dd-description"> -unsafe used with a preprocessor returning a syntax tree. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">65 <span class="machine"><span class="font-tt">redefining-unit</span></span></span></dt><dd class="dd-description"> Type declaration defining a new â€™()â€™ constructor. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">66 <span class="machine"><span class="font-tt">unused-open-bang</span></span></span></dt><dd class="dd-description"> Unused open! statement. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">67 <span class="machine"><span class="font-tt">unused-functor-parameter</span></span></span></dt><dd class="dd-description"> Unused functor parameter. (since 4.10)
</dd><dt class="dt-description"><span class="font-bold">68 <span class="machine"><span class="font-tt">match-on-mutable-state-prevent-uncurry</span></span></span></dt><dd class="dd-description"> Pattern-matching depending on mutable state prevents the remaining 
arguments from being uncurried. (since 4.12)
</dd><dt class="dt-description"><span class="font-bold">69 <span class="machine"><span class="font-tt">unused-field</span></span></span></dt><dd class="dd-description"> Unused record field. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">70 <span class="machine"><span class="font-tt">missing-mli</span></span></span></dt><dd class="dd-description"> Missing interface file. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">71 <span class="machine"><span class="font-tt">unused-tmc-attribute</span></span></span></dt><dd class="dd-description"> Unused @tail_mod_cons attribute. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">72 <span class="machine"><span class="font-tt">tmc-breaks-tailcall</span></span></span></dt><dd class="dd-description"> A tail call is turned into a non-tail call by the @tail_mod_cons transformation. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">A</span></dt><dd class="dd-description"> all warnings
</dd><dt class="dt-description"><span class="font-bold">C</span></dt><dd class="dd-description"> warnings 1, 2.
</dd><dt class="dt-description"><span class="font-bold">D</span></dt><dd class="dd-description"> Alias for warning 3.
</dd><dt class="dt-description"><span class="font-bold">E</span></dt><dd class="dd-description"> Alias for warning 4.
</dd><dt class="dt-description"><span class="font-bold">F</span></dt><dd class="dd-description"> Alias for warning 5.
</dd><dt class="dt-description"><span class="font-bold">K</span></dt><dd class="dd-description"> warnings 32, 33, 34, 35, 36, 37, 38, 39.
</dd><dt class="dt-description"><span class="font-bold">L</span></dt><dd class="dd-description"> Alias for warning 6.
</dd><dt class="dt-description"><span class="font-bold">M</span></dt><dd class="dd-description"> Alias for warning 7.
</dd><dt class="dt-description"><span class="font-bold">P</span></dt><dd class="dd-description"> Alias for warning 8.
</dd><dt class="dt-description"><span class="font-bold">R</span></dt><dd class="dd-description"> Alias for warning 9.
</dd><dt class="dt-description"><span class="font-bold">S</span></dt><dd class="dd-description"> Alias for warning 10.
</dd><dt class="dt-description"><span class="font-bold">U</span></dt><dd class="dd-description"> warnings 11, 12.
</dd><dt class="dt-description"><span class="font-bold">V</span></dt><dd class="dd-description"> Alias for warning 13.
</dd><dt class="dt-description"><span class="font-bold">X</span></dt><dd class="dd-description"> warnings 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 30.
</dd><dt class="dt-description"><span class="font-bold">Y</span></dt><dd class="dd-description"> Alias for warning 26.
</dd><dt class="dt-description"><span class="font-bold">Z</span></dt><dd class="dd-description"> Alias for warning 27.

</dd></dl><p>The default setting is <span class="machine"><span class="font-tt">-w +a-4-6-7-9-27-29-32..42-44-45-48-50-60</span></span>.
It is displayed by <span class="machine"><span class="font-tt">ocamlc -help</span></span>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-error</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Mark as fatal the warnings specified in the argument <span class="font-it">warning-list</span>.
The compiler will stop with an error when one of these warnings is
emitted. The <span class="font-it">warning-list</span> has the same meaning as for
the <span class="machine"><span class="font-tt">-w</span></span> option: a <span class="machine"><span class="font-tt">+</span></span> sign (or an uppercase letter) marks the
corresponding warnings as fatal, a <span class="machine"><span class="font-tt">-</span></span>
sign (or a lowercase letter) turns them back into non-fatal warnings,
and a <span class="machine"><span class="font-tt">@</span></span> sign both enables and marks as fatal the corresponding
warnings.<p>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <span class="machine"><span class="font-tt">-warn-error</span></span>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</p><p>The default setting is <span class="machine"><span class="font-tt">-warn-error -a+31</span></span> (only warning 31 is fatal).</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-help</span></span></span></dt><dd class="dd-description">
Show the description of all available warning numbers.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-where</span></span></span></dt><dd class="dd-description">
Print the location of the standard library, then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-with-runtime</span></span></span></dt><dd class="dd-description">
Include the runtime system in the generated program. This is the default.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-without-runtime</span></span></span></dt><dd class="dd-description">
The compiler does not include the runtime system (nor a reference to it) in the
generated program; it must be supplied separately.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Process <span class="font-it">file</span> as a file name, even if it starts with a dash (<span class="machine"><span class="font-tt">-</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.</dd></dl>
<!--TOC paragraph id="sec339" contextual-cli-control-->
<h5 class="paragraph" id="sec339"><a class="section-anchor" href="#sec339" aria-hidden="true">ï»¿</a>contextual-cli-control</h5><!--SEC END --><p>Contextual control of command-line options</p><p>The compiler command line can be modified â€œfrom the outsideâ€
with the following mechanisms. These are experimental
and subject to change. They should be used only for experimental and
development work, not in released packages.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLPARAM</span></span> </span>(environment variable)</dt><dd class="dd-description">
A set of arguments that will be inserted before or after the arguments from
the command line. Arguments are specified in a comma-separated list
of <span class="machine"><span class="font-tt">name=value</span></span> pairs. A <span class="machine"><span class="font-tt">_</span></span> is used to specify the position of
the command line arguments, i.e. <span class="machine"><span class="font-tt">a=x,_,b=y</span></span> means that <span class="machine"><span class="font-tt">a=x</span></span> should be
executed before parsing the arguments, and <span class="machine"><span class="font-tt">b=y</span></span> after. Finally,
an alternative separator can be specified as the
first character of the string, within the set <span class="machine"><span class="font-tt">:|; ,</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">ocaml_compiler_internal_params</span></span> </span>(file in the stdlib directory)</dt><dd class="dd-description">
A mapping of file names to lists of arguments that
will be added to the command line (and <span class="machine"><span class="font-tt">OCAMLPARAM</span></span>) arguments.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAML_FLEXLINK</span></span> </span>(environment variable)</dt><dd class="dd-description">
Alternative executable to use on native
Windows for <span class="machine"><span class="font-tt">flexlink</span></span> instead of the
configured value. Primarily used for bootstrapping.
</dd></dl>
<!--TOC section id="s:modules-file-system" 13.3â€ƒModules and the file system-->
<h2 class="section" id="s:modules-file-system"><a class="section-anchor" href="#s:modules-file-system" aria-hidden="true">ï»¿</a>13.3â€ƒModules and the file system</h2><!--SEC END --><p>This short section is intended to clarify the relationship between the
names of the modules corresponding to compilation units and the names
of the files that contain their compiled interface and compiled
implementation.</p><p>The compiler always derives the module name by taking the capitalized
base name of the source file (<span class="machine"><span class="font-tt">.ml</span></span> or <span class="machine"><span class="font-tt">.mli</span></span> file). That is, it
strips the leading directory name, if any, as well as the <span class="machine"><span class="font-tt">.ml</span></span> or
<span class="machine"><span class="font-tt">.mli</span></span> suffix; then, it set the first letter to uppercase, in order to
comply with the requirement that module names must be capitalized.
For instance, compiling the file <span class="machine"><span class="font-tt">mylib/misc.ml</span></span> provides an
implementation for the module named <span class="machine"><span class="font-tt">Misc</span></span>. Other compilation units
may refer to components defined in <span class="machine"><span class="font-tt">mylib/misc.ml</span></span> under the names
<span class="machine"><span class="font-tt">Misc.</span></span><span class="font-it">name</span>; they can also do <span class="machine"><span class="font-tt">open Misc</span></span>, then use unqualified
names <span class="font-it">name</span>.</p><p>The <span class="machine"><span class="font-tt">.cmi</span></span> and <span class="machine"><span class="font-tt">.cmo</span></span> files produced by the compiler have the same
base name as the source file. Hence, the compiled files always have
their base name equal (modulo capitalization of the first letter) to
the name of the module they describe (for <span class="machine"><span class="font-tt">.cmi</span></span> files) or implement
(for <span class="machine"><span class="font-tt">.cmo</span></span> files).</p><p>When the compiler encounters a reference to a free module identifier
<span class="machine"><span class="font-tt">Mod</span></span>, it looks in the search path for a file named <span class="machine"><span class="font-tt">Mod.cmi</span></span> or <span class="machine"><span class="font-tt">mod.cmi</span></span>
and loads the compiled interface
contained in that file. As a consequence, renaming <span class="machine"><span class="font-tt">.cmi</span></span> files is not
advised: the name of a <span class="machine"><span class="font-tt">.cmi</span></span> file must always correspond to the name
of the compilation unit it implements. It is admissible to move them
to another directory, if their base name is preserved, and the correct
<span class="machine"><span class="font-tt">-I</span></span> options are given to the compiler. The compiler will flag an
error if it loads a <span class="machine"><span class="font-tt">.cmi</span></span> file that has been renamed.</p><p>Compiled bytecode files (<span class="machine"><span class="font-tt">.cmo</span></span> files), on the other hand, can be
freely renamed once created. Thatâ€™s because the linker never attempts
to find by itself the <span class="machine"><span class="font-tt">.cmo</span></span> file that implements a module with a
given name: it relies instead on the user providing the list of <span class="machine"><span class="font-tt">.cmo</span></span>
files by hand.</p>
<!--TOC section id="s:comp-errors" 13.4â€ƒCommon errors-->
<h2 class="section" id="s:comp-errors"><a class="section-anchor" href="#s:comp-errors" aria-hidden="true">ï»¿</a>13.4â€ƒCommon errors</h2><!--SEC END --><p>This section describes and explains the most frequently encountered
error messages.</p><dl class="description"><dt class="dt-description"><span class="font-bold">Cannot find file <span class="font-it">filename</span></span></dt><dd class="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path. The <span class="font-it">filename</span> is either a
compiled interface file (<span class="machine"><span class="font-tt">.cmi</span></span> file), or a compiled bytecode file
(<span class="machine"><span class="font-tt">.cmo</span></span> file). If <span class="font-it">filename</span> has the format <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmi</span></span>, this
means you are trying to compile a file that references identifiers
from module <span class="font-it">mod</span>, but you have not yet compiled an interface for
module <span class="font-it">mod</span>. Fix: compile <span class="font-it">mod</span><span class="machine"><span class="font-tt">.mli</span></span> or <span class="font-it">mod</span><span class="machine"><span class="font-tt">.ml</span></span>
first, to create the compiled interface <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmi</span></span>.<p>If <span class="font-it">filename</span> has the format <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmo</span></span>, this
means you are trying to link a bytecode object file that does not
exist yet. Fix: compile <span class="font-it">mod</span><span class="machine"><span class="font-tt">.ml</span></span> first.</p><p>If your program spans several directories, this error can also appear
because you havenâ€™t specified the directories to look into. Fix: add
the correct <span class="machine"><span class="font-tt">-I</span></span> options to the command line.</p></dd><dt class="dt-description"><span class="font-bold">Corrupted compiled interface <span class="font-it">filename</span></span></dt><dd class="dd-description">
The compiler produces this error when it tries to read a compiled
interface file (<span class="machine"><span class="font-tt">.cmi</span></span> file) that has the wrong structure. This means
something went wrong when this <span class="machine"><span class="font-tt">.cmi</span></span> file was written: the disk was
full, the compiler was interrupted in the middle of the file creation,
and so on. This error can also appear if a <span class="machine"><span class="font-tt">.cmi</span></span> file is modified after
its creation by the compiler. Fix: remove the corrupted <span class="machine"><span class="font-tt">.cmi</span></span> file,
and rebuild it.</dd><dt class="dt-description"><span class="font-bold">This expression has type </span><span class="font-it">t</span><sub>1</sub><span class="font-bold">, but is used with type </span><span class="font-it">t</span><sub>2</sub></dt><dd class="dd-description">
This is by far the most common type error in programs. Type <span class="font-it">t</span><sub>1</sub> is
the type inferred for the expression (the part of the program that is
displayed in the error message), by looking at the expression itself.
Type <span class="font-it">t</span><sub>2</sub> is the type expected by the context of the expression; it
is deduced by looking at how the value of this expression is used in
the rest of the program. If the two types <span class="font-it">t</span><sub>1</sub> and <span class="font-it">t</span><sub>2</sub> are not
compatible, then the error above is produced.<p>In some cases, it is hard to understand why the two types <span class="font-it">t</span><sub>1</sub> and
<span class="font-it">t</span><sub>2</sub> are incompatible. For instance, the compiler can report that
â€œexpression of type <span class="machine"><span class="font-tt">foo</span></span> cannot be used with type <span class="machine"><span class="font-tt">foo</span></span>â€, and it
really seems that the two types <span class="machine"><span class="font-tt">foo</span></span> are compatible. This is not
always true. Two type constructors can have the same name, but
actually represent different types. This can happen if a type
constructor is redefined. Example:
</p><pre>        type foo = A | B
        let f = function A -&gt; 0 | B -&gt; 1
        type foo = C | D
        f C
</pre><p>This result in the error message â€œexpression <span class="machine"><span class="font-tt">C</span></span> of type <span class="machine"><span class="font-tt">foo</span></span> cannot
be used with type <span class="machine"><span class="font-tt">foo</span></span>â€.</p></dd><dt class="dt-description"><span class="font-bold">The type of this expression, <span class="font-it">t</span>, contains type variables
that cannot be generalized</span></dt><dd class="dd-description">
Type variables (<span class="machine"><span class="font-tt">'a</span></span>, <span class="machine"><span class="font-tt">'b</span></span>, â€¦) in a type <span class="font-it">t</span> can be in either
of two states: generalized (which means that the type <span class="font-it">t</span> is valid
for all possible instantiations of the variables) and not generalized
(which means that the type <span class="font-it">t</span> is valid only for one instantiation
of the variables). In a <span class="machine"><span class="font-tt">let</span></span> binding <span class="machine"><span class="font-tt">let </span></span><span class="font-it">name</span><span class="machine"><span class="font-tt"> = </span></span><span class="font-it">expr</span>,
the type-checker normally generalizes as many type variables as
possible in the type of <span class="font-it">expr</span>. However, this leads to unsoundness
(a well-typed program can crash) in conjunction with polymorphic
mutable data structures. To avoid this, generalization is performed at
<span class="machine"><span class="font-tt">let</span></span> bindings only if the bound expression <span class="font-it">expr</span> belongs to the
class of â€œsyntactic valuesâ€, which includes constants, identifiers,
functions, tuples of syntactic values, etc. In all other cases (for
instance, <span class="font-it">expr</span> is a function application), a polymorphic mutable
could have been created and generalization is therefore turned off for
all variables occurring in contravariant or non-variant branches of the
type. For instance, if the type of a non-value is <span class="machine"><span class="font-tt">'a list</span></span> the
variable is generalizable (<span class="machine"><span class="font-tt">list</span></span> is a covariant type constructor),
but not in <span class="machine"><span class="font-tt">'a list -&gt; 'a list</span></span> (the left branch of <span class="machine"><span class="font-tt">-&gt;</span></span> is
contravariant) or <span class="machine"><span class="font-tt">'a ref</span></span> (<span class="machine"><span class="font-tt">ref</span></span> is non-variant).<p>Non-generalized type variables in a type cause no difficulties inside
a given structure or compilation unit (the contents of a <span class="machine"><span class="font-tt">.ml</span></span> file,
or an interactive session), but they cannot be allowed inside
signatures nor in compiled interfaces (<span class="machine"><span class="font-tt">.cmi</span></span> file), because they
could be used inconsistently later. Therefore, the compiler
flags an error when a structure or compilation unit defines a value
<span class="font-it">name</span> whose type contains non-generalized type variables. There
are two ways to fix this error:
</p><ul class="itemize"><li class="li-itemize">Add a type constraint or a <span class="machine"><span class="font-tt">.mli</span></span> file to give a monomorphic
type (without type variables) to <span class="font-it">name</span>. For instance, instead of
writing
<pre>    let sort_int_list = List.sort Stdlib.compare
    (* inferred type 'a list -&gt; 'a list, with 'a not generalized *)
</pre>write
<pre>    let sort_int_list = (List.sort Stdlib.compare : int list -&gt; int list);;
</pre></li><li class="li-itemize">If you really need <span class="font-it">name</span> to have a polymorphic type, turn
its defining expression into a function by adding an extra parameter.
For instance, instead of writing
<pre>    let map_length = List.map Array.length
    (* inferred type 'a array list -&gt; int list, with 'a not generalized *)
</pre>write
<pre>    let map_length lv = List.map Array.length lv
</pre></li></ul></dd><dt class="dt-description"><span class="font-bold">Reference to undefined global <span class="font-it">mod</span></span></dt><dd class="dd-description">
This error appears when trying to link an incomplete or incorrectly
ordered set of files. Either you have forgotten to provide an
implementation for the compilation unit named <span class="font-it">mod</span> on the command line
(typically, the file named <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmo</span></span>, or a library containing
that file). Fix: add the missing <span class="machine"><span class="font-tt">.ml</span></span> or <span class="machine"><span class="font-tt">.cmo</span></span> file to the command
line. Or, you have provided an implementation for the module named
<span class="font-it">mod</span>, but it comes too late on the command line: the
implementation of <span class="font-it">mod</span> must come before all bytecode object files
that reference <span class="font-it">mod</span>. Fix: change the order of <span class="machine"><span class="font-tt">.ml</span></span> and <span class="machine"><span class="font-tt">.cmo</span></span>
files on the command line.<p>Of course, you will always encounter this error if you have mutually
recursive functions across modules. That is, function <span class="machine"><span class="font-tt">Mod1.f</span></span> calls
function <span class="machine"><span class="font-tt">Mod2.g</span></span>, and function <span class="machine"><span class="font-tt">Mod2.g</span></span> calls function <span class="machine"><span class="font-tt">Mod1.f</span></span>.
In this case, no matter what permutations you perform on the command
line, the program will be rejected at link-time. Fixes:
</p><ul class="itemize"><li class="li-itemize">Put <span class="machine"><span class="font-tt">f</span></span> and <span class="machine"><span class="font-tt">g</span></span> in the same module.
</li><li class="li-itemize">Parameterize one function by the other.
That is, instead of having
<pre>mod1.ml:    let f x = ... Mod2.g ...
mod2.ml:    let g y = ... Mod1.f ...
</pre>define
<pre>mod1.ml:    let f g x = ... g ...
mod2.ml:    let rec g y = ... Mod1.f g ...
</pre>and link <span class="machine"><span class="font-tt">mod1.cmo</span></span> before <span class="machine"><span class="font-tt">mod2.cmo</span></span>.
</li><li class="li-itemize">Use a reference to hold one of the two functions, as in :
<pre>mod1.ml:    let forward_g =
                ref((fun x -&gt; failwith "forward_g") : &lt;type&gt;)
            let f x = ... !forward_g ...
mod2.ml:    let g y = ... Mod1.f ...
            let _ = Mod1.forward_g := g
</pre></li></ul></dd><dt class="dt-description"><span class="font-bold">The external function <span class="font-it">f</span> is not available</span></dt><dd class="dd-description">
This error appears when trying to link code that calls external
functions written in C. As explained in
chapterÂ <a href="#c%3Aintf-c">22</a>, such code must be linked with C libraries that
implement the required <span class="font-it">f</span> C function. If the C libraries in
question are not shared libraries (DLLs), the code must be linked in
â€œcustom runtimeâ€ mode. Fix: add the required C libraries to the
command line, and possibly the <span class="machine"><span class="font-tt">-custom</span></span> option.</dd></dl>
<!--TOC section id="s:comp-warnings" 13.5â€ƒWarning reference-->
<h2 class="section" id="s:comp-warnings"><a class="section-anchor" href="#s:comp-warnings" aria-hidden="true">ï»¿</a>13.5â€ƒWarning reference</h2><!--SEC END --><p>This section describes and explains in detail some warnings:</p>
<!--TOC subsection id="ss:warn6" 13.5.1â€ƒWarning 6: Label omitted in function application-->
<h3 class="subsection" id="ss:warn6"><a class="section-anchor" href="#ss:warn6" aria-hidden="true">ï»¿</a>13.5.1â€ƒWarning 6: Label omitted in function application</h3><!--SEC END --><p>OCaml supports <span class="machine"><span class="font-tt">labels-omitted</span></span> full applications: if the function has
a known arity, all the arguments are unlabeled, and their number
matches the number of non-optional parameters, then labels are ignored
and non-optional parameters are matched in their definition
order. Optional arguments are defaulted.</p><pre>let f ~x ~y = x + y
let test = f 2 3

&gt; let test = f 2 3
&gt;            ^
&gt; Warning 6 [labels-omitted]: labels x, y were omitted in the application of this function.
</pre><p>
This support for <span class="machine"><span class="font-tt">labels-omitted</span></span> application was introduced when
labels were added to OCaml, to ease the progressive introduction of
labels in a codebase. However, it has the downside of weakening the
labeling discipline: if you use labels to prevent callers from
mistakenly reordering two parameters of the same type, labels-omitted
make this mistake possible again.</p><p>Warning 6 warns when labels-omitted applications are used, to
discourage their use. When labels were introduced, this warning was
not enabled by default, so users would use labels-omitted
applications, often without noticing.</p><p>Over time, it has become idiomatic to enable this warning to avoid
argument-order mistakes. The warning is now on by default, since OCaml
4.13. Labels-omitted applications are not recommended anymore, but
users wishing to preserve this transitory style can disable the
warning explicitly.</p>
<!--TOC subsection id="ss:warn9" 13.5.2â€ƒWarning 9: missing fields in a record pattern-->
<h3 class="subsection" id="ss:warn9"><a class="section-anchor" href="#ss:warn9" aria-hidden="true">ï»¿</a>13.5.2â€ƒWarning 9: missing fields in a record pattern</h3><!--SEC END --><p>When pattern matching on records, it can be useful to match only few
fields of a record. Eliding fields can be done either implicitly
or explicitly by ending the record pattern with <span class="machine"><span class="font-tt">; _</span></span>.
However, implicit field elision is at odd with pattern matching
exhaustiveness checks.
Enabling warning 9 prioritizes exhaustiveness checks over the
convenience of implicit field elision and will warn on implicit
field elision in record patterns. In particular, this warning can
help to spot exhaustive record pattern that may need to be updated
after the addition of new fields to a record type.</p><pre>type 'a point = {x : 'a; y : 'a}
let dx { x } = x (* implicit field elision: trigger warning 9 *)
let dy { y; _ } = y (* explicit field elision: do not trigger warning 9 *)
</pre>
<!--TOC subsection id="ss:warn52" 13.5.3â€ƒWarning 52: fragile constant pattern-->
<h3 class="subsection" id="ss:warn52"><a class="section-anchor" href="#ss:warn52" aria-hidden="true">ï»¿</a>13.5.3â€ƒWarning 52: fragile constant pattern</h3><!--SEC END --><p>Some constructors, such as the exception constructors <span class="machine"><span class="font-tt">Failure</span></span> and
<span class="machine"><span class="font-tt">Invalid_argument</span></span>, take as parameter a <span class="machine"><span class="font-tt">string</span></span> value holding
a text message intended for the user.</p><p>These text messages are usually not stable over time: call sites
building these constructors may refine the message in a future
version to make it more explicit, etc. Therefore, it is dangerous to
match over the precise value of the message. For example, until
OCaml 4.02, <span class="machine"><span class="font-tt">Array.iter2</span></span> would raise the exception
</p><pre>  Invalid_argument "arrays must have the same length"
</pre><p> Since 4.03 it raises the more helpful message
</p><pre>  Invalid_argument "Array.iter2: arrays must have the same length"
</pre><p> but this means that any code of the form
</p><pre>  try ...
  with Invalid_argument "arrays must have the same length" -&gt; ...
</pre><p> is now broken and may suffer from uncaught exceptions.</p><p>Warning 52 is there to prevent users from writing such fragile code
in the first place. It does not occur on every matching on a literal
string, but only in the case in which library authors expressed
their intent to possibly change the constructor parameter value in
the future, by using the attribute <span class="machine"><span class="font-tt">ocaml.warn_on_literal_pattern</span></span>
(see the manual section on builtin attributes in
<a href="#ss%3Abuiltin-attributes">12.12.1</a>):

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> t =
  | Foo <span class="ocamlkeyword">of</span> string [@ocaml.warn_on_literal_pattern]
  | Bar <span class="ocamlkeyword">of</span> string

<span class="ocamlkeyword">let</span> no_warning = <span class="ocamlkeyword">function</span>
  | Bar <span class="ocamlstring">"specific value"</span> -&gt; 0
  | _ -&gt; 1

<span class="ocamlkeyword">let</span> warning = <span class="ocamlkeyword">function</span>
  | Foo <span class="ocamlhighlight">"specific value"</span> -&gt; 0
  | _ -&gt; 1</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 52 [fragile-literal-pattern]: Code should not depend on the actual values of
this constructor's arguments. They are only for information
and may change in future versions. (See manual section 13.5)</div></div>

</div><p>In particular, all built-in exceptions with a string argument have
this attribute set: <span class="machine"><span class="font-tt">Invalid_argument</span></span>, <span class="machine"><span class="font-tt">Failure</span></span>, <span class="machine"><span class="font-tt">Sys_error</span></span> will
all raise this warning if you match for a specific string argument.</p><p>Additionally, built-in exceptions with a structured argument that
includes a string also have the attribute set: <span class="machine"><span class="font-tt">Assert_failure</span></span> and
<span class="machine"><span class="font-tt">Match_failure</span></span> will raise the warning for a pattern that uses a
literal string to match the first element of their tuple argument.</p><p>If your code raises this warning, you should <em>not</em> change the
way you test for the specific string to avoid the warning (for
example using a string equality inside the right-hand-side instead
of a literal pattern), as your code would remain fragile. You should
instead enlarge the scope of the pattern by matching on all possible
values.</p><pre>
let warning = function
  | Foo _ -&gt; 0
  | _ -&gt; 1
</pre><p>
This may require some care: if the scrutinee may return several
different cases of the same pattern, or raise distinct instances of
the same exception, you may need to modify your code to separate
those several cases.</p><p>For example,
</p><pre>try (int_of_string count_str, bool_of_string choice_str) with
  | Failure "int_of_string" -&gt; (0, true)
  | Failure "bool_of_string" -&gt; (-1, false)
</pre><p> should be rewritten into more atomic tests. For example,
using the <span class="machine"><span class="font-tt">exception</span></span> patterns documented in SectionÂ <a href="#sss%3Aexception-match">11.6</a>,
one can write:
</p><pre>match int_of_string count_str with
  | exception (Failure _) -&gt; (0, true)
  | count -&gt;
    begin match bool_of_string choice_str with
    | exception (Failure _) -&gt; (-1, false)
    | choice -&gt; (count, choice)
    end
</pre><p>
The only case where that transformation is not possible is if a given
function call may raise distinct exceptions with the same constructor
but different string values. In this case, you will have to check for
specific string values. This is dangerous API design and it should be
discouraged: itâ€™s better to define more precise exception constructors
than store useful information in strings.</p>
<!--TOC subsection id="ss:warn57" 13.5.4â€ƒWarning 57: Ambiguous or-pattern variables under guard-->
<h3 class="subsection" id="ss:warn57"><a class="section-anchor" href="#ss:warn57" aria-hidden="true">ï»¿</a>13.5.4â€ƒWarning 57: Ambiguous or-pattern variables under guard</h3><!--SEC END --><p>The semantics of or-patterns in OCaml is specified with
a left-to-right bias: a value <span class="font-it">v</span> matches the pattern <span class="font-it">p</span> <span class="machine"><span class="font-tt">|</span></span> <span class="font-it">q</span>
if it matches <span class="font-it">p</span> or <span class="font-it">q</span>, but if it matches both,
the environment captured by the match is the environment captured by
<span class="font-it">p</span>, never the one captured by <span class="font-it">q</span>.</p><p>While this property is generally intuitive, there is at least one specific
case where a different semantics might be expected.
Consider a pattern followed by a when-guard:
<span class="machine"><span class="font-tt">|</span></span>Â <span class="font-it">p</span>Â <span class="machine"><span class="font-tt">when</span></span>Â <span class="font-it">g</span>Â <span class="machine"><span class="font-tt">-&gt;</span></span>Â <span class="font-it">e</span>, for example:
</p><pre>     | ((Const x, _) | (_, Const x)) when is_neutral x -&gt; branch
</pre><p> The semantics is clear:
match the scrutinee against the pattern, if it matches, test the guard,
and if the guard passes, take the branch.
In particular, consider the input <span class="machine"><span class="font-tt">(Const</span></span>Â <span class="font-it">a</span><span class="machine"><span class="font-tt">, Const</span></span>Â <span class="font-it">b</span><span class="machine"><span class="font-tt">)</span></span>, where
<span class="font-it">a</span> fails the test <span class="machine"><span class="font-tt">is_neutral</span></span>Â <span class="font-it">a</span>, while <span class="font-it">b</span> passes the test
<span class="machine"><span class="font-tt">is_neutral</span></span>Â <span class="font-it">b</span>. With the left-to-right semantics, the clause above is
<em>not</em> taken by its input: matching <span class="machine"><span class="font-tt">(Const</span></span>Â <span class="font-it">a</span><span class="machine"><span class="font-tt">, Const</span></span>Â <span class="font-it">b</span><span class="machine"><span class="font-tt">)</span></span>
against the or-pattern succeeds in the left branch, it returns the
environment <span class="font-it">x</span>Â <span class="machine"><span class="font-tt">-&gt;</span></span>Â <span class="font-it">a</span>, and then the guard
<span class="machine"><span class="font-tt">is_neutral</span></span>Â <span class="font-it">a</span> is tested and fails, the branch is not taken.</p><p>However, another semantics may be considered more natural here:
any pair that has one side passing the test will take the branch. With this
semantics the previous code fragment would be equivalent to
</p><pre>     | (Const x, _) when is_neutral x -&gt; branch
     | (_, Const x) when is_neutral x -&gt; branch
</pre><p> This is <em>not</em> the semantics adopted by OCaml.</p><p>Warning 57 is dedicated to these confusing cases where the
specified left-to-right semantics is not equivalent to a non-deterministic
semantics (any branch can be taken) relatively to a specific guard.
More precisely, it warns when guard uses â€œambiguousâ€ variables, that are bound
to different parts of the scrutinees by different sides of a or-pattern.

</p>
<!--TOC chapter id="sec347" ChapterÂ 14â€ƒThe toplevel system or REPL (ocaml)-->
<h1 class="chapter" id="sec347">ChapterÂ 14â€ƒThe toplevel system or REPL (ocaml)</h1><!--SEC END --><p> <a id="c:camllight"></a>
</p><!--NAME toplevel.html-->
<p>This chapter describes the toplevel system for OCaml, that permits
interactive use of the OCaml system
through a read-eval-print loop (REPL). In this mode, the system repeatedly
reads OCaml phrases from the input, then typechecks, compile and
evaluate them, then prints the inferred type and result value, if
any. The system prints a <span class="machine"><span class="font-tt">#</span></span> (sharp) prompt before reading each
phrase.</p><p>Input to the toplevel can span several lines. It is terminated by <span class="syntax-token">;;</span> (a
double-semicolon). The toplevel input consists in one or several
toplevel phrases, with the following syntax:</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="toplevel-input"><span class="nonterminal">toplevel-input</span></a></td><td class="c005">::=</td><td class="c007">
{â€„<a class="syntax" href="#definition"><span class="nonterminal">definition</span></a>â€„}<sup>+</sup>â€„<span class="syntax-token">;;</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>â€„<span class="syntax-token">;;</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">#</span>â€„<a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>â€„[â€„<a class="syntax" href="#directive-argument"><span class="nonterminal">directive-argument</span></a>â€„]â€„<span class="syntax-token">;;</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="directive-argument"><span class="nonterminal">directive-argument</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#string-literal"><span class="nonterminal">string-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#integer-literal"><span class="nonterminal">integer-literal</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#value-path"><span class="nonterminal">value-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">true</span>â€„âˆ£â€„<span class="syntax-token">false</span>
</td></tr>
</table></td></tr>
</table></div><p>A phrase can consist of a definition, like those found in
implementations of compilation units or in <span class="syntax-token">struct</span> â€¦ <span class="syntax-token">end</span>
module expressions. The definition can bind value names, type names,
an exception, a module name, or a module type name. The toplevel
system performs the bindings, then prints the types and values (if
any) for the names thus defined.</p><p>A phrase may also consist in a value expression
(sectionÂ <a href="#s%3Avalue-expr">11.7</a>). It is simply evaluated
without performing any bindings, and its value is
printed.</p><p>Finally, a phrase can also consist in a toplevel directive,
starting with <span class="syntax-token">#</span> (the sharp sign). These directives control the
behavior of the toplevel; they are listed below in
sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>.</p><blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ
The toplevel system is started by the command <span class="machine"><span class="font-tt">ocaml</span></span>, as follows:
<pre>
        ocaml <span class="font-it">options</span> <span class="font-it">objects</span>                # interactive mode
        ocaml <span class="font-it">options</span> <span class="font-it">objects</span> <span class="font-it">scriptfile</span>        # script mode
</pre>
<span class="font-it">options</span> are described below.
<span class="font-it">objects</span> are filenames ending in <span class="machine"><span class="font-tt">.cmo</span></span> or <span class="machine"><span class="font-tt">.cma</span></span>; they are
loaded into the interpreter immediately after <span class="font-it">options</span> are set.
<span class="font-it">scriptfile</span> is any file name not ending in <span class="machine"><span class="font-tt">.cmo</span></span> or <span class="machine"><span class="font-tt">.cma</span></span>.<p>If no <span class="font-it">scriptfile</span> is given on the command line, the toplevel system
enters interactive mode: phrases are read on standard input, results
are printed on standard output, errors on standard error. End-of-file
on standard input terminates <span class="machine"><span class="font-tt">ocaml</span></span> (see also the <span class="machine"><span class="font-tt">#quit</span></span> directive
in sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>).</p><p>On start-up (before the first phrase is read), if the file
<span class="machine"><span class="font-tt">.ocamlinit</span></span> exists in the current directory,
its contents are read as a sequence of OCaml phrases
and executed as per the <span class="machine"><span class="font-tt">#use</span></span> directive
described in sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>.
The evaluation outcode for each phrase are not displayed.
If the current directory does not contain an <span class="machine"><span class="font-tt">.ocamlinit</span></span> file,
the file <span class="machine"><span class="font-tt">XDG_CONFIG_HOME/ocaml/init.ml</span></span> is looked up according
to the XDG base directory specification and used instead (on Windows
this is skipped). If that file doesnâ€™t exist then an [.ocamlinit] file
in the usersâ€™ home directory (determined via environment variable <span class="machine"><span class="font-tt">HOME</span></span>) is
used if existing.</p><p>The toplevel system does not perform line editing, but it can
easily be used in conjunction with an external line editor such as
<span class="machine"><span class="font-tt">ledit</span></span>, or <span class="machine"><span class="font-tt">rlwrap</span></span>. An improved toplevel, <span class="machine"><span class="font-tt">utop</span></span>, is also available.
Another option is to use <span class="machine"><span class="font-tt">ocaml</span></span> under Gnu Emacs, which gives the
full editing power of Emacs (command <span class="machine"><span class="font-tt">run-caml</span></span> from library <span class="machine"><span class="font-tt">inf-caml</span></span>).</p><p>At any point, the parsing, compilation or evaluation of the current
phrase can be interrupted by pressing <span class="machine"><span class="font-tt">ctrl-C</span></span> (or, more precisely,
by sending the <span class="machine"><span class="font-tt">INTR</span></span> signal to the <span class="machine"><span class="font-tt">ocaml</span></span> process). The toplevel
then immediately returns to the <span class="machine"><span class="font-tt">#</span></span> prompt.</p><p>If <span class="font-it">scriptfile</span> is given on the command-line to <span class="machine"><span class="font-tt">ocaml</span></span>, the toplevel
system enters script mode: the contents of the file are read as a
sequence of OCaml phrases and executed, as per the <span class="machine"><span class="font-tt">#use</span></span>
directive (sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>). The outcome of the
evaluation is not printed. On reaching the end of file, the <span class="machine"><span class="font-tt">ocaml</span></span>
command exits immediately. No commands are read from standard input.
<span class="machine"><span class="font-tt">Sys.argv</span></span> is transformed, ignoring all OCaml parameters, and
starting with the script file name in <span class="machine"><span class="font-tt">Sys.argv.(0)</span></span>.</p><p>In script mode, the first line of the script is ignored if it starts
with <span class="machine"><span class="font-tt">#!</span></span>. Thus, it should be possible to make the script
itself executable and put as first line <span class="machine"><span class="font-tt">#!/usr/local/bin/ocaml</span></span>,
thus calling the toplevel system automatically when the script is
run. However, <span class="machine"><span class="font-tt">ocaml</span></span> itself is a <span class="machine"><span class="font-tt">#!</span></span> script on most installations
of OCaml, and Unix kernels usually do not handle nested <span class="machine"><span class="font-tt">#!</span></span>
scripts. A better solution is to put the following as the first line
of the script:
</p><pre>        #!/usr/local/bin/ocamlrun /usr/local/bin/ocaml
</pre></blockquote>
<!--TOC section id="s:toplevel-options" 14.1â€ƒOptions-->
<h2 class="section" id="s:toplevel-options"><a class="section-anchor" href="#s:toplevel-options" aria-hidden="true">ï»¿</a>14.1â€ƒOptions</h2><!--SEC END --><p>The following command-line options are recognized by the <span class="machine"><span class="font-tt">ocaml</span></span> command.
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-absname</span></span></span></dt><dd class="dd-description">
Force error messages to show absolute paths for file names.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional newline-terminated command line arguments from <span class="font-it">filename</span>.
It is not possible to pass a <span class="font-it">scriptfile</span> via file to the toplevel.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args0</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional null character terminated command line arguments from
<span class="font-it">filename</span>.
It is not possible to pass a <span class="font-it">scriptfile</span> via file to the toplevel.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for


source and compiled files.
By default, the current directory is searched first, then the standard
library directory. Directories added with <span class="machine"><span class="font-tt">-I</span></span> are searched after the
current directory, in the order in which they were given on the command line,
but before the standard library directory. See also option <span class="machine"><span class="font-tt">-nostdlib</span></span>.<p>If the given directory starts with <span class="machine"><span class="font-tt">+</span></span>, it is taken relative to the
standard library directory. For instance, <span class="machine"><span class="font-tt">-I +unix</span></span> adds the
subdirectory <span class="machine"><span class="font-tt">unix</span></span> of the standard library to the search path.</p><p>Directories can also be added to the list once
the toplevel is running with the <span class="machine"><span class="font-tt">#directory</span></span> directive
(sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>).
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-init</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Load the given file instead of the default initialization file.
The default file is <span class="machine"><span class="font-tt">.ocamlinit</span></span> in the current directory if it
exists, otherwise <span class="machine"><span class="font-tt">XDG_CONFIG_HOME/ocaml/init.ml</span></span> or
<span class="machine"><span class="font-tt">.ocamlinit</span></span> in the userâ€™s home directory.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-labels</span></span></span></dt><dd class="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-app-funct</span></span></span></dt><dd class="dd-description">
Deactivates the applicative behaviour of functors. With this option,
each functor application generates new types in its result and
applying the same functor twice to the same argument yields two
incompatible structures.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noassert</span></span></span></dt><dd class="dd-description">
Do not compile assertion checks. Note that the special form
<span class="machine"><span class="font-tt">assert false</span></span> is always compiled because it is typed specially.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nolabels</span></span></span></dt><dd class="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noprompt</span></span></span></dt><dd class="dd-description">
Do not display any prompt when waiting for input.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nopromptcont</span></span></span></dt><dd class="dd-description">
Do not display the secondary prompt when waiting for continuation
lines in multi-line inputs. This should be used e.g. when running
<span class="machine"><span class="font-tt">ocaml</span></span> in an <span class="machine"><span class="font-tt">emacs</span></span> window.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nostdlib</span></span></span></dt><dd class="dd-description">
Do not include the standard library directory in the list of
directories searched for source and compiled files.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ppx</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
After parsing, pipe the abstract syntax tree through the preprocessor
<span class="font-it">command</span>. The module <span class="machine"><span class="font-tt">Ast_mapper</span></span>, described in
chapterÂ <a href="#c%3Aparsinglib">29</a>:
<a href="compilerlibref/Ast_mapper.html"> <span class="font-tt">Ast_mapper</span> </a>
,
implements the external interface of a preprocessor.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-principal</span></span></span></dt><dd class="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <span class="machine"><span class="font-tt">-principal</span></span> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rectypes</span></span></span></dt><dd class="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. </dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-safe-string</span></span></span></dt><dd class="dd-description">
Enforce the separation between types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>,
thereby making strings read-only. This is the default, and enforced
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-short-paths</span></span></span></dt><dd class="dd-description">
When a type is visible under several module-paths, use the shortest
one when printing the typeâ€™s name in inferred interfaces and error and
warning messages. Identifier names starting with an underscore <span class="machine"><span class="font-tt">_</span></span> or
containing double underscores <span class="machine"><span class="font-tt">__</span></span> incur a penalty of +10 when computing
their length.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-stdin</span></span></span></dt><dd class="dd-description">
Read the standard input as a script file rather than starting an
interactive session.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-sequence</span></span></span></dt><dd class="dd-description">
Force the left-hand part of each sequence to have type unit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-formats</span></span></span></dt><dd class="dd-description">
Reject invalid formats that were accepted in legacy format
implementations. You should use this flag to detect and fix such
invalid formats, as they will be rejected by future OCaml versions.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe</span></span></span></dt><dd class="dd-description">
Turn bound checking off for array and string accesses (the <span class="machine"><span class="font-tt">v.(i)</span></span> and
<span class="machine"><span class="font-tt">s.[i]</span></span> constructs). Programs compiled with <span class="machine"><span class="font-tt">-unsafe</span></span> are therefore
 faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe-string</span></span></span></dt><dd class="dd-description">
Identify the types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>, thereby making strings writable.
This is intended for compatibility with old source code and should not
be used with new software. This option raises an error unconditionally
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-verbose</span></span></span></dt><dd class="dd-description">
Print all external commands before they are executed,


Useful to debug C library problems.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-version</span></span></span></dt><dd class="dd-description">
Do not print the version banner at startup.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-w</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Enable, disable, or mark as fatal the warnings specified by the argument
<span class="font-it">warning-list</span>.
Each warning can be <em>enabled</em> or <em>disabled</em>, and each warning
can be <em>fatal</em> or <em>non-fatal</em>.
If a warning is disabled, it isnâ€™t displayed and doesnâ€™t affect
compilation in any way (even if it is fatal). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and fatal, the compiler will also
stop with an error after displaying it.<p>The <span class="font-it">warning-list</span> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Disable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Disable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable and mark as fatal warnings in
the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable and mark as fatal the set of warnings
corresponding to <span class="font-it">letter</span>. The letter may be uppercase or
lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">uppercase-letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding
to <span class="font-it">uppercase-letter</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">lowercase-letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding
to <span class="font-it">lowercase-letter</span>.
</dd></dl><p>Alternatively, <span class="font-it">warning-list</span> can specify a single warning using its
mnemonic name (see below), as follows:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Disable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning <span class="font-it">name</span>.
</dd></dl><p>Warning numbers, letters and names which are not currently defined are
ignored. The warnings are as follows (the name following each number specifies
the mnemonic for that warning).
</p><dl class="description"><dt class="dt-description"><span class="font-bold">1 <span class="machine"><span class="font-tt">comment-start</span></span></span></dt><dd class="dd-description"> Suspicious-looking start-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">2 <span class="machine"><span class="font-tt">comment-not-end</span></span></span></dt><dd class="dd-description"> Suspicious-looking end-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">3</span></dt><dd class="dd-description"> Deprecated synonym for the â€™deprecatedâ€™ alert.
</dd><dt class="dt-description"><span class="font-bold">4 <span class="machine"><span class="font-tt">fragile-match</span></span></span></dt><dd class="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</dd><dt class="dt-description"><span class="font-bold">5 <span class="machine"><span class="font-tt">ignored-partial-application</span></span></span></dt><dd class="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</dd><dt class="dt-description"><span class="font-bold">6 <span class="machine"><span class="font-tt">labels-omitted</span></span></span></dt><dd class="dd-description"> Label omitted in function application.
</dd><dt class="dt-description"><span class="font-bold">7 <span class="machine"><span class="font-tt">method-override</span></span></span></dt><dd class="dd-description"> Method overridden.
</dd><dt class="dt-description"><span class="font-bold">8 <span class="machine"><span class="font-tt">partial-match</span></span></span></dt><dd class="dd-description"> Partial match: missing cases in pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">9 <span class="machine"><span class="font-tt">missing-record-field-pattern</span></span></span></dt><dd class="dd-description"> Missing fields in a record pattern.
</dd><dt class="dt-description"><span class="font-bold">10 <span class="machine"><span class="font-tt">non-unit-statement</span></span></span></dt><dd class="dd-description"> Expression on the left-hand side of a sequence that doesnâ€™t have type
<span class="machine"><span class="font-tt">unit</span></span> (and that is not a function, see warning number 5).
</dd><dt class="dt-description"><span class="font-bold">11 <span class="machine"><span class="font-tt">redundant-case</span></span></span></dt><dd class="dd-description"> Redundant case in a pattern matching (unused match case).
</dd><dt class="dt-description"><span class="font-bold">12 <span class="machine"><span class="font-tt">redundant-subpat</span></span></span></dt><dd class="dd-description"> Redundant sub-pattern in a pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">13 <span class="machine"><span class="font-tt">instance-variable-override</span></span></span></dt><dd class="dd-description"> Instance variable overridden.
</dd><dt class="dt-description"><span class="font-bold">14 <span class="machine"><span class="font-tt">illegal-backslash</span></span></span></dt><dd class="dd-description"> Illegal backslash escape in a string constant.
</dd><dt class="dt-description"><span class="font-bold">15 <span class="machine"><span class="font-tt">implicit-public-methods</span></span></span></dt><dd class="dd-description"> Private method made public implicitly.
</dd><dt class="dt-description"><span class="font-bold">16 <span class="machine"><span class="font-tt">unerasable-optional-argument</span></span></span></dt><dd class="dd-description"> Unerasable optional argument.
</dd><dt class="dt-description"><span class="font-bold">17 <span class="machine"><span class="font-tt">undeclared-virtual-method</span></span></span></dt><dd class="dd-description"> Undeclared virtual method.
</dd><dt class="dt-description"><span class="font-bold">18 <span class="machine"><span class="font-tt">not-principal</span></span></span></dt><dd class="dd-description"> Non-principal type.
</dd><dt class="dt-description"><span class="font-bold">19 <span class="machine"><span class="font-tt">non-principal-labels</span></span></span></dt><dd class="dd-description"> Type without principality.
</dd><dt class="dt-description"><span class="font-bold">20 <span class="machine"><span class="font-tt">ignored-extra-argument</span></span></span></dt><dd class="dd-description"> Unused function argument.
</dd><dt class="dt-description"><span class="font-bold">21 <span class="machine"><span class="font-tt">nonreturning-statement</span></span></span></dt><dd class="dd-description"> Non-returning statement.
</dd><dt class="dt-description"><span class="font-bold">22 <span class="machine"><span class="font-tt">preprocessor</span></span></span></dt><dd class="dd-description"> Preprocessor warning.
</dd><dt class="dt-description"><span class="font-bold">23 <span class="machine"><span class="font-tt">useless-record-with</span></span></span></dt><dd class="dd-description"> Useless record <span class="machine"><span class="font-tt">with</span></span> clause.
</dd><dt class="dt-description"><span class="font-bold">24 <span class="machine"><span class="font-tt">bad-module-name</span></span></span></dt><dd class="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</dd><dt class="dt-description"><span class="font-bold">25</span></dt><dd class="dd-description"> Ignored: now part of warning 8.
</dd><dt class="dt-description"><span class="font-bold">26 <span class="machine"><span class="font-tt">unused-var</span></span></span></dt><dd class="dd-description"> Suspicious unused variable: unused variable that is bound
with <span class="machine"><span class="font-tt">let</span></span> or <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">27 <span class="machine"><span class="font-tt">unused-var-strict</span></span></span></dt><dd class="dd-description"> Innocuous unused variable: unused variable that is not bound with
<span class="machine"><span class="font-tt">let</span></span> nor <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">28 <span class="machine"><span class="font-tt">wildcard-arg-to-constant-constr</span></span></span></dt><dd class="dd-description"> Wildcard pattern given as argument to a constant constructor.
</dd><dt class="dt-description"><span class="font-bold">29 <span class="machine"><span class="font-tt">eol-in-string</span></span></span></dt><dd class="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</dd><dt class="dt-description"><span class="font-bold">30 <span class="machine"><span class="font-tt">duplicate-definitions</span></span></span></dt><dd class="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.
</dd><dt class="dt-description"><span class="font-bold">31 <span class="machine"><span class="font-tt">module-linked-twice</span></span></span></dt><dd class="dd-description"> A module is linked twice in the same executable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">32 <span class="machine"><span class="font-tt">unused-value-declaration</span></span></span></dt><dd class="dd-description"> Unused value declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">33 <span class="machine"><span class="font-tt">unused-open</span></span></span></dt><dd class="dd-description"> Unused open statement. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">34 <span class="machine"><span class="font-tt">unused-type-declaration</span></span></span></dt><dd class="dd-description"> Unused type declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">35 <span class="machine"><span class="font-tt">unused-for-index</span></span></span></dt><dd class="dd-description"> Unused for-loop index. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">36 <span class="machine"><span class="font-tt">unused-ancestor</span></span></span></dt><dd class="dd-description"> Unused ancestor variable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">37 <span class="machine"><span class="font-tt">unused-constructor</span></span></span></dt><dd class="dd-description"> Unused constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">38 <span class="machine"><span class="font-tt">unused-extension</span></span></span></dt><dd class="dd-description"> Unused extension constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">39 <span class="machine"><span class="font-tt">unused-rec-flag</span></span></span></dt><dd class="dd-description"> Unused rec flag. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">40 <span class="machine"><span class="font-tt">name-out-of-scope</span></span></span></dt><dd class="dd-description"> Constructor or label name used out of scope. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">41 <span class="machine"><span class="font-tt">ambiguous-name</span></span></span></dt><dd class="dd-description"> Ambiguous constructor or label name. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">42 <span class="machine"><span class="font-tt">disambiguated-name</span></span></span></dt><dd class="dd-description"> Disambiguated constructor or label name (compatibility warning). (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">43 <span class="machine"><span class="font-tt">nonoptional-label</span></span></span></dt><dd class="dd-description"> Nonoptional label applied as optional. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">44 <span class="machine"><span class="font-tt">open-shadow-identifier</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined identifier. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">45 <span class="machine"><span class="font-tt">open-shadow-label-constructor</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined label or constructor. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">46 <span class="machine"><span class="font-tt">bad-env-variable</span></span></span></dt><dd class="dd-description"> Error in environment variable. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">47 <span class="machine"><span class="font-tt">attribute-payload</span></span></span></dt><dd class="dd-description"> Illegal attribute payload. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">48 <span class="machine"><span class="font-tt">eliminated-optional-arguments</span></span></span></dt><dd class="dd-description"> Implicit elimination of optional arguments. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">49 <span class="machine"><span class="font-tt">no-cmi-file</span></span></span></dt><dd class="dd-description"> Absent cmi file when looking up module alias. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">50 <span class="machine"><span class="font-tt">unexpected-docstring</span></span></span></dt><dd class="dd-description"> Unexpected documentation comment. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">51 <span class="machine"><span class="font-tt">wrong-tailcall-expectation</span></span></span></dt><dd class="dd-description"> Function call annotated with an incorrect @tailcall attribute. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">52 <span class="machine"><span class="font-tt">fragile-literal-pattern</span></span> (see </span><a href="#ss%3Awarn52"><span class="font-bold">13.5.3</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Fragile constant pattern. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">53 <span class="machine"><span class="font-tt">misplaced-attribute</span></span></span></dt><dd class="dd-description"> Attribute cannot appear in this context. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">54 <span class="machine"><span class="font-tt">duplicated-attribute</span></span></span></dt><dd class="dd-description"> Attribute used more than once on an expression. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">55 <span class="machine"><span class="font-tt">inlining-impossible</span></span></span></dt><dd class="dd-description"> Inlining impossible. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">56 <span class="machine"><span class="font-tt">unreachable-case</span></span></span></dt><dd class="dd-description"> Unreachable case in a pattern-matching (based on type information). (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">57 <span class="machine"><span class="font-tt">ambiguous-var-in-pattern-guard</span></span> (see </span><a href="#ss%3Awarn57"><span class="font-bold">13.5.4</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Ambiguous or-pattern variables under guard. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">58 <span class="machine"><span class="font-tt">no-cmx-file</span></span></span></dt><dd class="dd-description"> Missing cmx file. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">59 <span class="machine"><span class="font-tt">flambda-assignment-to-non-mutable-value</span></span></span></dt><dd class="dd-description"> Assignment to non-mutable value. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">60 <span class="machine"><span class="font-tt">unused-module</span></span></span></dt><dd class="dd-description"> Unused module declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">61 <span class="machine"><span class="font-tt">unboxable-type-in-prim-decl</span></span></span></dt><dd class="dd-description"> Unboxable type in primitive declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">62 <span class="machine"><span class="font-tt">constraint-on-gadt</span></span></span></dt><dd class="dd-description"> Type constraint on GADT type declaration. (since 4.06)
</dd><dt class="dt-description"><span class="font-bold">63 <span class="machine"><span class="font-tt">erroneous-printed-signature</span></span></span></dt><dd class="dd-description"> Erroneous printed signature. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">64 <span class="machine"><span class="font-tt">unsafe-array-syntax-without-parsing</span></span></span></dt><dd class="dd-description"> -unsafe used with a preprocessor returning a syntax tree. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">65 <span class="machine"><span class="font-tt">redefining-unit</span></span></span></dt><dd class="dd-description"> Type declaration defining a new â€™()â€™ constructor. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">66 <span class="machine"><span class="font-tt">unused-open-bang</span></span></span></dt><dd class="dd-description"> Unused open! statement. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">67 <span class="machine"><span class="font-tt">unused-functor-parameter</span></span></span></dt><dd class="dd-description"> Unused functor parameter. (since 4.10)
</dd><dt class="dt-description"><span class="font-bold">68 <span class="machine"><span class="font-tt">match-on-mutable-state-prevent-uncurry</span></span></span></dt><dd class="dd-description"> Pattern-matching depending on mutable state prevents the remaining 
arguments from being uncurried. (since 4.12)
</dd><dt class="dt-description"><span class="font-bold">69 <span class="machine"><span class="font-tt">unused-field</span></span></span></dt><dd class="dd-description"> Unused record field. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">70 <span class="machine"><span class="font-tt">missing-mli</span></span></span></dt><dd class="dd-description"> Missing interface file. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">71 <span class="machine"><span class="font-tt">unused-tmc-attribute</span></span></span></dt><dd class="dd-description"> Unused @tail_mod_cons attribute. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">72 <span class="machine"><span class="font-tt">tmc-breaks-tailcall</span></span></span></dt><dd class="dd-description"> A tail call is turned into a non-tail call by the @tail_mod_cons transformation. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">A</span></dt><dd class="dd-description"> all warnings
</dd><dt class="dt-description"><span class="font-bold">C</span></dt><dd class="dd-description"> warnings 1, 2.
</dd><dt class="dt-description"><span class="font-bold">D</span></dt><dd class="dd-description"> Alias for warning 3.
</dd><dt class="dt-description"><span class="font-bold">E</span></dt><dd class="dd-description"> Alias for warning 4.
</dd><dt class="dt-description"><span class="font-bold">F</span></dt><dd class="dd-description"> Alias for warning 5.
</dd><dt class="dt-description"><span class="font-bold">K</span></dt><dd class="dd-description"> warnings 32, 33, 34, 35, 36, 37, 38, 39.
</dd><dt class="dt-description"><span class="font-bold">L</span></dt><dd class="dd-description"> Alias for warning 6.
</dd><dt class="dt-description"><span class="font-bold">M</span></dt><dd class="dd-description"> Alias for warning 7.
</dd><dt class="dt-description"><span class="font-bold">P</span></dt><dd class="dd-description"> Alias for warning 8.
</dd><dt class="dt-description"><span class="font-bold">R</span></dt><dd class="dd-description"> Alias for warning 9.
</dd><dt class="dt-description"><span class="font-bold">S</span></dt><dd class="dd-description"> Alias for warning 10.
</dd><dt class="dt-description"><span class="font-bold">U</span></dt><dd class="dd-description"> warnings 11, 12.
</dd><dt class="dt-description"><span class="font-bold">V</span></dt><dd class="dd-description"> Alias for warning 13.
</dd><dt class="dt-description"><span class="font-bold">X</span></dt><dd class="dd-description"> warnings 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 30.
</dd><dt class="dt-description"><span class="font-bold">Y</span></dt><dd class="dd-description"> Alias for warning 26.
</dd><dt class="dt-description"><span class="font-bold">Z</span></dt><dd class="dd-description"> Alias for warning 27.

</dd></dl><p>The default setting is <span class="machine"><span class="font-tt">-w +a-4-6-7-9-27-29-32..42-44-45-48-50-60</span></span>.
It is displayed by <span class="machine"><span class="font-tt"> -help</span></span>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-error</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Mark as fatal the warnings specified in the argument <span class="font-it">warning-list</span>.
The compiler will stop with an error when one of these warnings is
emitted. The <span class="font-it">warning-list</span> has the same meaning as for
the <span class="machine"><span class="font-tt">-w</span></span> option: a <span class="machine"><span class="font-tt">+</span></span> sign (or an uppercase letter) marks the
corresponding warnings as fatal, a <span class="machine"><span class="font-tt">-</span></span>
sign (or a lowercase letter) turns them back into non-fatal warnings,
and a <span class="machine"><span class="font-tt">@</span></span> sign both enables and marks as fatal the corresponding
warnings.<p>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <span class="machine"><span class="font-tt">-warn-error</span></span>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</p><p>The default setting is <span class="machine"><span class="font-tt">-warn-error -a+31</span></span> (only warning 31 is fatal).</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-help</span></span></span></dt><dd class="dd-description">
Show the description of all available warning numbers.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">

Use <span class="font-it">file</span> as a script file name, even when it starts with a
hyphen (-).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.</dd></dl><blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ
The following environment variables are also consulted:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLTOP_INCLUDE_PATH</span></span></span></dt><dd class="dd-description"> Additional directories to search for compiled
object code files (<span class="machine"><span class="font-tt">.cmi</span></span>, <span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span>). The specified directories are
considered from left to right, after the include directories specified on the
command line via <span class="machine"><span class="font-tt">-I</span></span> have been searched. Available since OCaml 4.08.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLTOP_UTF_8</span></span></span></dt><dd class="dd-description"> When printing string values, non-ascii bytes
(  &gt; <span class="machine"><span class="font-tt">\0<span class="font-it">x</span>7<span class="font-it">E</span></span></span> ) are printed as decimal escape sequence if <span class="machine"><span class="font-tt">OCAMLTOP_UTF_8</span></span> is
set to false. Otherwise, they are printed unescaped.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">TERM</span></span></span></dt><dd class="dd-description"> When printing error messages, the toplevel system
attempts to underline visually the location of the error. It
consults the <span class="machine"><span class="font-tt">TERM</span></span> variable to determines the type of output terminal
and look up its capabilities in the terminal database.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">XDG_CONFIG_HOME</span></span>, <span class="machine"><span class="font-tt">HOME</span></span></span></dt><dd class="dd-description">
<span class="machine"><span class="font-tt">.ocamlinit</span></span> lookup procedure (see above).
</dd></dl>
</blockquote>
<!--TOC section id="s:toplevel-directives" 14.2â€ƒToplevel directives-->
<h2 class="section" id="s:toplevel-directives"><a class="section-anchor" href="#s:toplevel-directives" aria-hidden="true">ï»¿</a>14.2â€ƒToplevel directives</h2><!--SEC END --><p>The following directives control the toplevel behavior, load files in
memory, and trace program execution.</p><p><span class="font-bold">Note:</span> all directives start with a <span class="machine"><span class="font-tt">#</span></span> (sharp) symbol. This <span class="machine"><span class="font-tt">#</span></span>
must be typed before the directive, and must not be confused with the
<span class="machine"><span class="font-tt">#</span></span> prompt displayed by the interactive loop. For instance,
typing <span class="machine"><span class="font-tt">#quit;;</span></span> will exit the toplevel loop, but typing <span class="machine"><span class="font-tt">quit;;</span></span>
will result in an â€œunbound value <span class="machine"><span class="font-tt">quit</span></span>â€ error.</p><dl class="description"><dt class="dt-description"><span class="font-bold">General</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#help;;</span></span></span></dt><dd class="dd-description">
Prints a list of all available directives, with corresponding argument type
if appropriate.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#quit;;</span></span></span></dt><dd class="dd-description">
Exit the toplevel loop and terminate the <span class="machine"><span class="font-tt">ocaml</span></span> command.
</dd></dl></dd><dt class="dt-description"><span class="font-bold">Loading codes</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#cd "</span></span><span class="font-it">dir-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Change the current working directory.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#directory "</span></span><span class="font-it">dir-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for
source and compiled files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#remove_directory "</span></span><span class="font-it">dir-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Remove the given directory from the list of directories searched for
source and compiled files. Do nothing if the list does not contain
the given directory.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#load "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Load in memory a bytecode object file (<span class="machine"><span class="font-tt">.cmo</span></span> file) or library file
(<span class="machine"><span class="font-tt">.cma</span></span> file) produced by the batch compiler <span class="machine"><span class="font-tt">ocamlc</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#load_rec "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Load in memory a bytecode object file (<span class="machine"><span class="font-tt">.cmo</span></span> file) or library file
(<span class="machine"><span class="font-tt">.cma</span></span> file) produced by the batch compiler <span class="machine"><span class="font-tt">ocamlc</span></span>.
When loading an object file that depends on other modules
which have not been loaded yet, the .cmo files for these modules
are searched and loaded as well, recursively. The loading order
is not specified.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#use "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Read, compile and execute source phrases from the given file.
This is textual inclusion: phrases are processed just as if
they were typed on standard input. The reading of the file stops at
the first error encountered.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#use_output "</span></span><span class="font-it">command</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Execute a command and evaluate its output as if it had been captured
to a file and passed to <span class="machine"><span class="font-tt">#use</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#mod_use "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Similar to <span class="machine"><span class="font-tt">#use</span></span> but also wrap the code into a top-level module of the
same name as capitalized file name without extensions, following
semantics of the compiler.
</dd></dl><p>For directives that take file names as arguments, if the given file
name specifies no directory, the file is searched in the following
directories:
</p><ol class="enumerate" type=1><li class="li-enumerate">In script mode, the directory containing the script currently
executing; in interactive mode, the current working directory.
</li><li class="li-enumerate">Directories added with the <span class="machine"><span class="font-tt">#directory</span></span> directive.
</li><li class="li-enumerate">Directories given on the command line with <span class="machine"><span class="font-tt">-I</span></span> options.
</li><li class="li-enumerate">The standard library directory.
</li></ol></dd><dt class="dt-description"><span class="font-bold">Environment queries</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_class </span></span><span class="font-it">class-path</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_class_type </span></span><span class="font-it">class-path</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_exception </span></span><span class="font-it">ident</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_module </span></span><span class="font-it">module-path</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_module_type </span></span><span class="font-it">modtype-path</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_type </span></span><span class="font-it">typeconstr</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show_val </span></span><span class="font-it">value-path</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Print the signature of the corresponding component.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#show </span></span><span class="font-it">ident</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Print the signatures of components with name <span class="font-it">ident</span> in all the
above categories.
</dd></dl></dd><dt class="dt-description"><span class="font-bold">Pretty-printing</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#install_printer </span></span><span class="font-it">printer-name</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
This directive registers the function named <span class="font-it">printer-name</span> (a
value path) as a printer for values whose types match the argument
type of the function. That is, the toplevel loop will call
<span class="font-it">printer-name</span> when it has such a value to print.<p>The printing function <span class="font-it">printer-name</span> should have type
<span class="syntax-token">Format.formatter</span> <span class="syntax-token">-&gt;</span> <span class="nonterminal">t</span> <span class="syntax-token">-&gt;</span> <span class="syntax-token">unit</span>, where <span class="nonterminal">t</span> is the
type for the values to be printed, and should output its textual
representation for the value of type <span class="nonterminal">t</span> on the given formatter,
using the functions provided by the <span class="machine"><span class="font-tt">Format</span></span> library. For backward
compatibility, <span class="font-it">printer-name</span> can also have type
<span class="nonterminal">t</span> <span class="syntax-token">-&gt;</span> <span class="syntax-token">unit</span> and should then output on the standard
formatter, but this usage is deprecated.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#print_depth </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Limit the printing of values to a maximal depth of <span class="font-it">n</span>.
The parts of values whose depth exceeds <span class="font-it">n</span> are printed as <span class="machine"><span class="font-tt">...</span></span>
(ellipsis).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#print_length </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Limit the number of value nodes printed to at most <span class="font-it">n</span>.
Remaining parts of values are printed as <span class="machine"><span class="font-tt">...</span></span> (ellipsis).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#remove_printer </span></span><span class="font-it">printer-name</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Remove the named function from the table of toplevel printers.
</dd></dl></dd><dt class="dt-description"><span class="font-bold">Tracing</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#trace </span></span><span class="font-it">function-name</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
After executing this directive, all calls to the function named
<span class="font-it">function-name</span> will be â€œtracedâ€. That is, the argument and the
result are displayed for each call, as well as the exceptions escaping
out of the function, raised either by the function itself or by
another function it calls. If the function is curried, each argument
is printed as it is passed to the function.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#untrace </span></span><span class="font-it">function-name</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Stop tracing the given function.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#untrace_all;;</span></span></span></dt><dd class="dd-description">
Stop tracing all functions traced so far.
</dd></dl></dd><dt class="dt-description"><span class="font-bold">Compiler options</span></dt><dd class="dd-description">
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#labels </span></span><span class="font-it">bool</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
Ignore labels in function types if argument is <span class="machine"><span class="font-tt">false</span></span>, or switch back
to default behaviour (commuting style) if argument is <span class="machine"><span class="font-tt">true</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#ppx  "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
After parsing, pipe the abstract syntax tree through the preprocessor
command.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#principal </span></span><span class="font-it">bool</span><span class="machine"><span class="font-tt">;;</span></span></span></dt><dd class="dd-description">
If the argument is <span class="machine"><span class="font-tt">true</span></span>, check information paths during
type-checking, to make sure that all types are derived in a principal
way. If the argument is <span class="machine"><span class="font-tt">false</span></span>, do not check information paths.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#rectypes;;</span></span></span></dt><dd class="dd-description">
Allow arbitrary recursive types during type-checking. Note: once
enabled, this option cannot be disabled because that would lead to
unsoundness of the type system.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#warn_error "</span></span><span class="font-it">warning-list</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Treat as errors the warnings enabled by the argument and as normal
warnings the warnings disabled by the argument.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">#warnings "</span></span><span class="font-it">warning-list</span><span class="machine"><span class="font-tt">";;</span></span></span></dt><dd class="dd-description">
Enable or disable warnings according to the argument.</dd></dl></dd></dl>
<!--TOC section id="s:toplevel-modules" 14.3â€ƒThe toplevel and the module system-->
<h2 class="section" id="s:toplevel-modules"><a class="section-anchor" href="#s:toplevel-modules" aria-hidden="true">ï»¿</a>14.3â€ƒThe toplevel and the module system</h2><!--SEC END --><p>Toplevel phrases can refer to identifiers defined in compilation units
with the same mechanisms as for separately compiled units: either by
using qualified names (<span class="machine"><span class="font-tt">Modulename.localname</span></span>), or by using
the <span class="machine"><span class="font-tt">open</span></span> construct and unqualified names (see sectionÂ <a href="#s%3Anames">11.3</a>).</p><p>However, before referencing another compilation unit, an
implementation of that unit must be present in memory.
At start-up, the toplevel system contains implementations for all the
modules in the the standard library. Implementations for user modules
can be entered with the <span class="machine"><span class="font-tt">#load</span></span> directive described above. Referencing
a unit for which no implementation has been provided
results in the error <span class="machine"><span class="font-tt">Reference to undefined global `...'</span></span>.</p><p>Note that entering <span class="machine"><span class="font-tt">open </span></span><span class="font-it">Mod</span> merely accesses the compiled
interface (<span class="machine"><span class="font-tt">.cmi</span></span> file) for <span class="font-it">Mod</span>, but does not load the
implementation of <span class="font-it">Mod</span>, and does not cause any error if no
implementation of <span class="font-it">Mod</span> has been loaded. The error
â€œreference to undefined global <span class="font-it">Mod</span>â€ will occur only when
executing a value or module definition that refers to <span class="font-it">Mod</span>.</p>
<!--TOC section id="s:toplevel-common-errors" 14.4â€ƒCommon errors-->
<h2 class="section" id="s:toplevel-common-errors"><a class="section-anchor" href="#s:toplevel-common-errors" aria-hidden="true">ï»¿</a>14.4â€ƒCommon errors</h2><!--SEC END --><p>This section describes and explains the most frequently encountered
error messages.</p><dl class="description"><dt class="dt-description"><span class="font-bold">Cannot find file <span class="font-it">filename</span></span></dt><dd class="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path.<p>If <span class="font-it">filename</span> has the format <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmi</span></span>, this
means you have referenced the compilation unit <span class="font-it">mod</span>, but its
compiled interface could not be found. Fix: compile <span class="font-it">mod</span><span class="machine"><span class="font-tt">.mli</span></span> or
<span class="font-it">mod</span><span class="machine"><span class="font-tt">.ml</span></span> first, to create the compiled interface <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmi</span></span>.</p><p>If <span class="font-it">filename</span> has the format <span class="font-it">mod</span><span class="machine"><span class="font-tt">.cmo</span></span>, this
means you are trying to load with <span class="machine"><span class="font-tt">#load</span></span> a bytecode object file that
does not exist yet. Fix: compile <span class="font-it">mod</span><span class="machine"><span class="font-tt">.ml</span></span> first.</p><p>If your program spans several directories, this error can also appear
because you havenâ€™t specified the directories to look into. Fix: use
the <span class="machine"><span class="font-tt">#directory</span></span> directive to add the correct directories to the
search path.</p></dd><dt class="dt-description"><span class="font-bold">This expression has type </span><span class="font-it">t</span><sub>1</sub><span class="font-bold">, but is used with type </span><span class="font-it">t</span><sub>2</sub></dt><dd class="dd-description">
See sectionÂ <a href="#s%3Acomp-errors">13.4</a>.</dd><dt class="dt-description"><span class="font-bold">Reference to undefined global <span class="font-it">mod</span></span></dt><dd class="dd-description">
You have neglected to load in memory an implementation for a module
with <span class="machine"><span class="font-tt">#load</span></span>. See sectionÂ <a href="#s%3Atoplevel-modules">14.3</a> above.</dd></dl>
<!--TOC section id="s:custom-toplevel" 14.5â€ƒBuilding custom toplevel systems: <span class="font-tt">ocamlmktop</span>-->
<h2 class="section" id="s:custom-toplevel"><a class="section-anchor" href="#s:custom-toplevel" aria-hidden="true">ï»¿</a>14.5â€ƒBuilding custom toplevel systems: <span class="font-tt">ocamlmktop</span></h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlmktop</span></span> command builds OCaml toplevels that
contain user code preloaded at start-up.</p><p>The <span class="machine"><span class="font-tt">ocamlmktop</span></span> command takes as argument a set of <span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span>
files, and links them with the object files that implement the OCaml toplevel.
The typical use is:
</p><pre>        ocamlmktop -o mytoplevel foo.cmo bar.cmo gee.cmo
</pre><p>This creates the bytecode file <span class="machine"><span class="font-tt">mytoplevel</span></span>, containing the OCaml toplevel
system, plus the code from the three <span class="machine"><span class="font-tt">.cmo</span></span>
files. This toplevel is directly executable and is started by:
</p><pre>        ./mytoplevel
</pre><p>This enters a regular toplevel loop, except that the code from
<span class="machine"><span class="font-tt">foo.cmo</span></span>, <span class="machine"><span class="font-tt">bar.cmo</span></span> and <span class="machine"><span class="font-tt">gee.cmo</span></span> is already loaded in memory, just as
if you had typed:
</p><pre>        #load "foo.cmo";;
        #load "bar.cmo";;
        #load "gee.cmo";;
</pre><p>on entrance to the toplevel. The modules <span class="machine"><span class="font-tt">Foo</span></span>, <span class="machine"><span class="font-tt">Bar</span></span> and <span class="machine"><span class="font-tt">Gee</span></span> are
not opened, though; you still have to do
</p><pre>        open Foo;;
</pre><p>yourself, if this is what you wish.</p>
<!--TOC subsection id="ss:ocamlmktop-options" 14.5.1â€ƒOptions-->
<h3 class="subsection" id="ss:ocamlmktop-options"><a class="section-anchor" href="#ss:ocamlmktop-options" aria-hidden="true">ï»¿</a>14.5.1â€ƒOptions</h3><!--SEC END --><p>The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamlmktop</span></span>.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cclib</span></span> <span class="font-it">libname</span></span></dt><dd class="dd-description">
Pass the <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span> option to the C linker when linking in
â€œcustom runtimeâ€ mode. See the corresponding option for
<span class="machine"><span class="font-tt">ocamlc</span></span>, in chapterÂ <a href="#c%3Acamlc">13</a>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ccopt</span></span> <span class="font-it">option</span></span></dt><dd class="dd-description">
Pass the given option to the C compiler and linker, when linking in
â€œcustom runtimeâ€ mode. See the corresponding option for
<span class="machine"><span class="font-tt">ocamlc</span></span>, in chapterÂ <a href="#c%3Acamlc">13</a>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-custom</span></span></span></dt><dd class="dd-description">
Link in â€œcustom runtimeâ€ mode. See the corresponding option for
<span class="machine"><span class="font-tt">ocamlc</span></span>, in chapterÂ <a href="#c%3Acamlc">13</a>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for
compiled object code files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span>).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">exec-file</span></span></dt><dd class="dd-description">
Specify the name of the toplevel file produced by the linker.
The default is <span class="machine"><span class="font-tt">a.out</span></span>.</dd></dl>
<!--TOC section id="s:ocamlnat" 14.6â€ƒThe native toplevel: <span class="font-tt">ocamlnat</span> (experimental)-->
<h2 class="section" id="s:ocamlnat"><a class="section-anchor" href="#s:ocamlnat" aria-hidden="true">ï»¿</a>14.6â€ƒThe native toplevel: <span class="font-tt">ocamlnat</span> (experimental)</h2><!--SEC END --><p><span class="font-bold">This section describes a tool that is not yet officially supported but may be found useful.</span></p><p>OCaml code executing in the traditional toplevel system uses the bytecode
interpreter. When increased performance is required, or for testing
programs that will only execute correctly when compiled to native code,
the <em>native toplevel</em> may be used instead.</p><p>For the majority of installations the native toplevel will not have been
installed along with the rest of the OCaml toolchain. In such circumstances
it will be necessary to build the OCaml distribution from source.
From the built source tree of the distribution you may use
<span class="font-tt">make natruntop</span> to build and execute a native toplevel. (Alternatively
<span class="font-tt">make ocamlnat</span> can be used, which just performs the build step.)</p><p>If the <span class="font-tt">make install</span> command is run after having built the native
toplevel then the <span class="font-tt">ocamlnat</span> program (either from the source or the
installation directory) may be invoked directly rather than using
<span class="font-tt">make natruntop</span>.

</p>
<!--TOC chapter id="sec355" ChapterÂ 15â€ƒThe runtime system (ocamlrun)-->
<h1 class="chapter" id="sec355">ChapterÂ 15â€ƒThe runtime system (ocamlrun)</h1><!--SEC END --><p> <a id="c:runtime"></a>
</p><!--NAME runtime.html-->
<p>The <span class="machine"><span class="font-tt">ocamlrun</span></span> command executes bytecode files produced by the
linking phase of the <span class="machine"><span class="font-tt">ocamlc</span></span> command.</p>
<!--TOC section id="s:ocamlrun-overview" 15.1â€ƒOverview-->
<h2 class="section" id="s:ocamlrun-overview"><a class="section-anchor" href="#s:ocamlrun-overview" aria-hidden="true">ï»¿</a>15.1â€ƒOverview</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlrun</span></span> command comprises three main parts: the bytecode
interpreter, that actually executes bytecode files; the memory
allocator and garbage collector; and a set of C functions that
implement primitive operations such as input/output.</p><p>The usage for <span class="machine"><span class="font-tt">ocamlrun</span></span> is:
</p><pre>
        ocamlrun <span class="font-it">options</span> <span class="font-it">bytecode-executable</span> <span class="font-it">arg</span><sub>1</sub> ... <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>
</pre><p>
The first non-option argument is taken to be the name of the file
containing the executable bytecode. (That file is searched in the
executable path as well as in the current directory.) The remaining
arguments are passed to the OCaml program, in the string array
<span class="machine"><span class="font-tt">Sys.argv</span></span>. Element 0 of this array is the name of the
bytecode executable file; elements 1 to <span class="font-it">n</span> are the remaining
arguments <span class="font-it">arg</span><sub>1</sub> to <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>.</p><p>As mentioned in chapterÂ <a href="#c%3Acamlc">13</a>, the bytecode executable files
produced by the <span class="machine"><span class="font-tt">ocamlc</span></span> command are self-executable, and manage to
launch the <span class="machine"><span class="font-tt">ocamlrun</span></span> command on themselves automatically. That is,
assuming <span class="machine"><span class="font-tt">a.out</span></span> is a bytecode executable file,
</p><pre>
        a.out <span class="font-it">arg</span><sub>1</sub> ... <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>
</pre><p>
works exactly as
</p><pre>
        ocamlrun a.out <span class="font-it">arg</span><sub>1</sub> ... <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>
</pre><p>
Notice that it is not possible to pass options to <span class="machine"><span class="font-tt">ocamlrun</span></span> when
invoking <span class="machine"><span class="font-tt">a.out</span></span> directly.</p><blockquote class="quote"><span class="osvariant">Windows:</span>â€ƒ
Under several versions of Windows, bytecode executable files are
self-executable only if their name ends in <span class="machine"><span class="font-tt">.exe</span></span>. It is recommended
to always give <span class="machine"><span class="font-tt">.exe</span></span> names to bytecode executables, e.g. compile
with <span class="machine"><span class="font-tt">ocamlc -o myprog.exe ...</span></span> rather than <span class="machine"><span class="font-tt">ocamlc -o myprog ...</span></span>.
</blockquote>
<!--TOC section id="s:ocamlrun-options" 15.2â€ƒOptions-->
<h2 class="section" id="s:ocamlrun-options"><a class="section-anchor" href="#s:ocamlrun-options" aria-hidden="true">ï»¿</a>15.2â€ƒOptions</h2><!--SEC END --><p>
The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamlrun</span></span>.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-b</span></span></span></dt><dd class="dd-description">
When the program aborts due to an uncaught exception, print a detailed
â€œback traceâ€ of the execution, showing where the exception was
raised and which function calls were outstanding at this point. The
back trace is printed only if the bytecode executable contains
debugging information, i.e. was compiled and linked with the <span class="machine"><span class="font-tt">-g</span></span>
option to <span class="machine"><span class="font-tt">ocamlc</span></span> set. This is equivalent to setting the <span class="machine"><span class="font-tt">b</span></span> flag
in the <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> environment variable (see below).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-config</span></span></span></dt><dd class="dd-description">
Print the version number of <span class="machine"><span class="font-tt">ocamlrun</span></span> and a detailed summary of its
configuration, then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">dir</span></span></dt><dd class="dd-description">
Search the directory <span class="font-it">dir</span> for dynamically-loaded libraries,
in addition to the standard search path (see
sectionÂ <a href="#s%3Aocamlrun-dllpath">15.3</a>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-m</span></span></span></dt><dd class="dd-description">
Print the magic number of the bytecode executable given as argument
and exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-M</span></span></span></dt><dd class="dd-description">
Print the magic number expected for bytecode executables by this version
of the runtime and exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-p</span></span></span></dt><dd class="dd-description">
Print the names of the primitives known to this version of
<span class="machine"><span class="font-tt">ocamlrun</span></span> and exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-t</span></span></span></dt><dd class="dd-description">
Increments the trace level for the debug runtime (ignored otherwise).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Direct the memory manager to print some progress messages on
standard error. This is equivalent to setting <span class="machine"><span class="font-tt">v=61</span></span> in the
<span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> environment variable (see below).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd></dl><p>The following environment variables are also consulted:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">CAML_LD_LIBRARY_PATH</span></span></span></dt><dd class="dd-description"> Additional directories to search for
dynamically-loaded libraries (see sectionÂ <a href="#s%3Aocamlrun-dllpath">15.3</a>).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLLIB</span></span></span></dt><dd class="dd-description"> The directory containing the OCaml standard
library. (If <span class="machine"><span class="font-tt">OCAMLLIB</span></span> is not set, <span class="machine"><span class="font-tt">CAMLLIB</span></span> will be used instead.)
Used to locate the <span class="machine"><span class="font-tt">ld.conf</span></span> configuration file for
dynamic loading (see sectionÂ <a href="#s%3Aocamlrun-dllpath">15.3</a>). If not set,
default to the library directory specified when compiling OCaml.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span></span></dt><dd class="dd-description"> Set the runtime system options
and garbage collection parameters.
(If <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> is not set, <span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span> will be used instead.)
This variable must be a sequence of parameter specifications separated
by commas.
For convenience, commas at the beginning of the variable are ignored,
and multiple runs of commas are interpreted as a single one.
A parameter specification is an option letter followed by an <span class="machine"><span class="font-tt">=</span></span>
sign, a decimal number (or an hexadecimal number prefixed by <span class="machine"><span class="font-tt">0x</span></span>),
and an optional multiplier. The options are documented below;
the options <span class="machine"><span class="font-tt">a, i, l, m, M, n, o, O, s, v, w</span></span> correspond to
the fields of the <span class="machine"><span class="font-tt">control</span></span> record documented in
<a href="libref/Gc.html">Module <span class="font-tt">Gc</span></a>.
<dl class="description"><dt class="dt-description"><span class="font-bold">b</span></dt><dd class="dd-description"> (backtrace) Trigger the printing of a stack backtrace
when an uncaught exception aborts the program. An optional argument can
be provided: <span class="machine"><span class="font-tt">b=0</span></span> turns backtrace printing off; <span class="machine"><span class="font-tt">b=1</span></span> is equivalent to
<span class="machine"><span class="font-tt">b</span></span> and turns backtrace printing on; <span class="machine"><span class="font-tt">b=2</span></span> turns backtrace printing on
and forces the runtime system to load debugging information at program
startup time instead of at backtrace printing time. <span class="machine"><span class="font-tt">b=2</span></span> can be used if
the runtime is unable to load debugging information at backtrace
printing time, for example if there are no file descriptors available.
</dd><dt class="dt-description"><span class="font-bold">c</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">cleanup_on_exit</span></span>) Shut the runtime down gracefully on exit (see
<span class="machine"><span class="font-tt">caml_shutdown</span></span> in sectionÂ <a href="#ss%3Ac-embedded-code">22.7.5</a>). The option also enables
pooling (as in <span class="machine"><span class="font-tt">caml_startup_pooled</span></span>). This mode can be used to detect
leaks with a third-party memory debugger.
</dd><dt class="dt-description"><span class="font-bold">e</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">runtime_events_log_wsize</span></span>) Size of the per-domain runtime events ring
buffers in log powers of two words. Defaults to 16, giving 64k word or
512kb buffers on 64-bit systems.
</dd><dt class="dt-description"><span class="font-bold">l</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">stack_limit</span></span>) The limit (in words) of the stack size. This is only
relevant to the byte-code runtime, as the native code runtime uses the
operating systemâ€™s stack.
</dd><dt class="dt-description"><span class="font-bold">m</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">custom_minor_ratio</span></span>) Bound on floating garbage for
out-of-heap memory
held by custom values in the minor heap. A minor GC is triggered
when this much memory is held by custom values located in the minor
heap. Expressed as a percentage of minor heap size. Default:
100. Note: this only applies to values allocated with
<span class="machine"><span class="font-tt">caml_alloc_custom_mem</span></span>.
</dd><dt class="dt-description"><span class="font-bold">M</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">custom_major_ratio</span></span>) Target ratio of floating garbage to
major heap size for out-of-heap memory held by custom values
(e.g. bigarrays) located in the major heap. The GC speed is adjusted
to try to use this much memory for dead values that are not yet
collected. Expressed as a percentage of major heap size. Default:
44. Note: this only applies to values allocated with
<span class="machine"><span class="font-tt">caml_alloc_custom_mem</span></span>.
</dd><dt class="dt-description"><span class="font-bold">n</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">custom_minor_max_size</span></span>) Maximum amount of out-of-heap
memory for each custom value allocated in the minor heap. When a custom
value is allocated on the minor heap and holds more than this many
bytes, only this value is counted against <span class="machine"><span class="font-tt">custom_minor_ratio</span></span> and
the rest is directly counted against <span class="machine"><span class="font-tt">custom_major_ratio</span></span>.
Default: 8192 bytes. Note:
this only applies to values allocated with <span class="machine"><span class="font-tt">caml_alloc_custom_mem</span></span>.
</dd></dl>
The multiplier is <span class="machine"><span class="font-tt">k</span></span>, <span class="machine"><span class="font-tt">M</span></span>, or <span class="machine"><span class="font-tt">G</span></span>, for multiplication by 2<sup>10</sup>,
2<sup>20</sup>, and 2<sup>30</sup> respectively.
</dd><dt class="dt-description"><span class="font-bold">o</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">space_overhead</span></span>) The major GC speed setting.
See the Gc module documentation for details.
</dd><dt class="dt-description"><span class="font-bold">p</span></dt><dd class="dd-description"> (parser trace) Turn on debugging support for
<span class="machine"><span class="font-tt">ocamlyacc</span></span>-generated parsers. When this option is on,
the pushdown automaton that executes the parsers prints a
trace of its actions. This option takes no argument.
</dd><dt class="dt-description"><span class="font-bold">R</span></dt><dd class="dd-description"> (randomize) Turn on randomization of all hash tables by default
(see
<a href="libref/Hashtbl.html">Module <span class="font-tt">Hashtbl</span></a>).
This option takes no argument.
</dd><dt class="dt-description"><span class="font-bold">s</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">minor_heap_size</span></span>) Size of the minor heap. (in words)
</dd><dt class="dt-description"><span class="font-bold">t</span></dt><dd class="dd-description"> Set the trace level for the debug runtime (ignored by the standard runtime).
</dd><dt class="dt-description"><span class="font-bold">v</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">verbose</span></span>) What GC messages to print to stderr. This
is a sum of values selected from the following:
<dl class="description"><dt class="dt-description"><span class="font-bold">1 (= 0x001)</span></dt><dd class="dd-description"> Start and end of major GC cycle.
</dd><dt class="dt-description"><span class="font-bold">2 (= 0x002)</span></dt><dd class="dd-description"> Minor collection and major GC slice.
</dd><dt class="dt-description"><span class="font-bold">4 (= 0x004)</span></dt><dd class="dd-description"> Growing and shrinking of the heap.
</dd><dt class="dt-description"><span class="font-bold">8 (= 0x008)</span></dt><dd class="dd-description"> Resizing of stacks and memory manager tables.
</dd><dt class="dt-description"><span class="font-bold">16 (= 0x010)</span></dt><dd class="dd-description"> Heap compaction.
</dd><dt class="dt-description"><span class="font-bold">32 (= 0x020)</span></dt><dd class="dd-description"> Change of GC parameters.
</dd><dt class="dt-description"><span class="font-bold">64 (= 0x040)</span></dt><dd class="dd-description"> Computation of major GC slice size.
</dd><dt class="dt-description"><span class="font-bold">128 (= 0x080)</span></dt><dd class="dd-description"> Calling of finalization functions
</dd><dt class="dt-description"><span class="font-bold">256 (= 0x100)</span></dt><dd class="dd-description"> Startup messages (loading the bytecode
executable file, resolving shared libraries).
</dd><dt class="dt-description"><span class="font-bold">512 (= 0x200)</span></dt><dd class="dd-description"> Computation of compaction-triggering condition.
</dd><dt class="dt-description"><span class="font-bold">1024 (= 0x400)</span></dt><dd class="dd-description"> Output GC statistics at program exit.
</dd><dt class="dt-description"><span class="font-bold">2048 (= 0x800)</span></dt><dd class="dd-description"> GC debugging messages.
</dd></dl>
</dd><dt class="dt-description"><span class="font-bold">V</span></dt><dd class="dd-description"> (<span class="machine"><span class="font-tt">verify_heap</span></span>) runs an integrity check on the heap just after
the completion of a major GC cycle
</dd><dt class="dt-description"><span class="font-bold">W</span></dt><dd class="dd-description"> Print runtime warnings to stderr (such as Channel opened on file
dies without being closed, unflushed data, etc.)<p>If the option letter is not recognized, the whole parameter is ignored;
if the equal sign or the number is missing, the value is taken as 1;
if the multiplier is not recognized, it is ignored.</p><p>For example, on a 32-bit machine, under <span class="machine"><span class="font-tt">bash</span></span> the command
</p><pre>        export OCAMLRUNPARAM='b,s=256k,v=0x015'
</pre><p> tells a subsequent <span class="machine"><span class="font-tt">ocamlrun</span></span> to print backtraces for uncaught exceptions,
set its initial minor heap size to 1Â megabyte and
print a message at the start of each major GC cycle, when the heap
size changes, and when compaction is triggered.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span></span></dt><dd class="dd-description"> If <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> is not found in the
environment, then <span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span> will be used instead. If
<span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span> is also not found, then the default values will be used.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">PATH</span></span></span></dt><dd class="dd-description"> List of directories searched to find the bytecode
executable file.
</dd></dl>
<!--TOC section id="s:ocamlrun-dllpath" 15.3â€ƒDynamic loading of shared libraries-->
<h2 class="section" id="s:ocamlrun-dllpath"><a class="section-anchor" href="#s:ocamlrun-dllpath" aria-hidden="true">ï»¿</a>15.3â€ƒDynamic loading of shared libraries</h2><!--SEC END --><p>On platforms that support dynamic loading, <span class="machine"><span class="font-tt">ocamlrun</span></span> can link
dynamically with C shared libraries (DLLs) providing additional C primitives
beyond those provided by the standard runtime system. The names for
these libraries are provided at link time as described in
sectionÂ <a href="#ss%3Adynlink-c-code">22.1.4</a>), and recorded in the bytecode executable
file; <span class="machine"><span class="font-tt">ocamlrun</span></span>, then, locates these libraries and resolves references
to their primitives when the bytecode executable program starts.</p><p>The <span class="machine"><span class="font-tt">ocamlrun</span></span> command searches shared libraries in the following
directories, in the order indicated:
</p><ol class="enumerate" type=1><li class="li-enumerate">Directories specified on the <span class="machine"><span class="font-tt">ocamlrun</span></span> command line with the
<span class="machine"><span class="font-tt">-I</span></span> option.
</li><li class="li-enumerate">Directories specified in the <span class="machine"><span class="font-tt">CAML_LD_LIBRARY_PATH</span></span> environment
variable.
</li><li class="li-enumerate">Directories specified at link-time via the <span class="machine"><span class="font-tt">-dllpath</span></span> option to
<span class="machine"><span class="font-tt">ocamlc</span></span>. (These directories are recorded in the bytecode executable
file.)
</li><li class="li-enumerate">Directories specified in the file <span class="machine"><span class="font-tt">ld.conf</span></span>. This file resides
in the OCaml standard library directory, and lists directory
names (one per line) to be searched. Typically, it contains only one
line naming the <span class="machine"><span class="font-tt">stublibs</span></span> subdirectory of the OCaml standard
library directory. Users can add there the names of other directories
containing frequently-used shared libraries; however, for consistency
of installation, we recommend that shared libraries are installed
directly in the system <span class="machine"><span class="font-tt">stublibs</span></span> directory, rather than adding lines
to the <span class="machine"><span class="font-tt">ld.conf</span></span> file.
</li><li class="li-enumerate">Default directories searched by the system dynamic loader.
Under Unix, these generally include <span class="machine"><span class="font-tt">/lib</span></span> and <span class="machine"><span class="font-tt">/usr/lib</span></span>, plus the
directories listed in the file <span class="machine"><span class="font-tt">/etc/ld.so.conf</span></span> and the environment
variable <span class="machine"><span class="font-tt">LD_LIBRARY_PATH</span></span>. Under Windows, these include the Windows
system directories, plus the directories listed in the <span class="machine"><span class="font-tt">PATH</span></span>
environment variable.
</li></ol>
<!--TOC section id="s:ocamlrun-common-errors" 15.4â€ƒCommon errors-->
<h2 class="section" id="s:ocamlrun-common-errors"><a class="section-anchor" href="#s:ocamlrun-common-errors" aria-hidden="true">ï»¿</a>15.4â€ƒCommon errors</h2><!--SEC END --><p>This section describes and explains the most frequently encountered
error messages.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="font-it">filename</span><span class="machine"><span class="font-tt">: no such file or directory</span></span></span></dt><dd class="dd-description">
If <span class="font-it">filename</span> is the name of a self-executable bytecode file, this
means that either that file does not exist, or that it failed to run
the <span class="machine"><span class="font-tt">ocamlrun</span></span> bytecode interpreter on itself. The second possibility
indicates that OCaml has not been properly installed on your
system.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Cannot exec ocamlrun</span></span></span></dt><dd class="dd-description">
(When launching a self-executable bytecode file.) The <span class="machine"><span class="font-tt">ocamlrun</span></span>
could not be found in the executable path. Check that OCaml
has been properly installed on your system.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Cannot find the bytecode file</span></span></span></dt><dd class="dd-description">
The file that <span class="machine"><span class="font-tt">ocamlrun</span></span> is trying to execute (e.g. the file given as
first non-option argument to <span class="machine"><span class="font-tt">ocamlrun</span></span>) either does not exist, or is
not a valid executable bytecode file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Truncated bytecode file</span></span></span></dt><dd class="dd-description">
The file that <span class="machine"><span class="font-tt">ocamlrun</span></span> is trying to execute is not a valid executable
bytecode file. Probably it has been truncated or mangled since
created. Erase and rebuild it.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Uncaught exception</span></span></span></dt><dd class="dd-description">
The program being executed contains a â€œstrayâ€ exception. That is,
it raises an exception at some point, and this exception is never
caught. This causes immediate termination of the program. The name of
the exception is printed, along with its string, byte sequence, and
integer arguments
(arguments of more complex types are not correctly printed).
To locate the context of the uncaught exception, compile the program
with the <span class="machine"><span class="font-tt">-g</span></span> option and either run it again under the <span class="machine"><span class="font-tt">ocamldebug</span></span>
debugger (see chapterÂ <a href="#c%3Adebugger">20</a>), or run it with <span class="machine"><span class="font-tt">ocamlrun -b</span></span>
or with the <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> environment variable set to <span class="machine"><span class="font-tt">b=1</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Out of memory</span></span></span></dt><dd class="dd-description">
The program being executed requires more memory than available. Either
the program builds excessively large data structures; or the program
contains too many nested function calls, and the stack overflows. In
some cases, your program is perfectly correct, it just requires more
memory than your machine provides. In other cases, the â€œout of
memoryâ€ message reveals an error in your program: non-terminating
recursive function, allocation of an excessively large array,
string or byte sequence, attempts to build an infinite list or other
data structure, â€¦<p>To help you diagnose this error, run your program with the <span class="machine"><span class="font-tt">-v</span></span> option
to <span class="machine"><span class="font-tt">ocamlrun</span></span>, or with the <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> environment variable set to
<span class="machine"><span class="font-tt">v=63</span></span>. If it displays lots of â€œ<span class="machine"><span class="font-tt">Growing stack</span></span>â€¦â€
messages, this is probably a looping recursive function. If it
displays lots of â€œ<span class="machine"><span class="font-tt">Growing heap</span></span>â€¦â€ messages, with the heap size
growing slowly, this is probably an attempt to construct a data
structure with too many (infinitely many?) cells. If it displays few
â€œ<span class="machine"><span class="font-tt">Growing heap</span></span>â€¦â€ messages, but with a huge increment in the
heap size, this is probably an attempt to build an excessively large
array, string or byte sequence.</p></dd></dl>
<!--TOC chapter id="sec360" ChapterÂ 16â€ƒNative-code compilation (ocamlopt)-->
<h1 class="chapter" id="sec360">ChapterÂ 16â€ƒNative-code compilation (ocamlopt)</h1><!--SEC END --><p> <a id="c:nativecomp"></a>
</p><!--NAME native.html-->
<p>This chapter describes the OCaml high-performance
native-code compiler <span class="machine"><span class="font-tt">ocamlopt</span></span>, which compiles OCaml source files to
native code object files and links these object files to produce
standalone executables.</p><p>The native-code compiler is only available on certain platforms.
It produces code that runs faster than the bytecode produced by
<span class="machine"><span class="font-tt">ocamlc</span></span>, at the cost of increased compilation time and executable code
size. Compatibility with the bytecode compiler is extremely high: the
same source code should run identically when compiled with <span class="machine"><span class="font-tt">ocamlc</span></span> and
<span class="machine"><span class="font-tt">ocamlopt</span></span>.</p><p>It is not possible to mix native-code object files produced by <span class="machine"><span class="font-tt">ocamlopt</span></span>
with bytecode object files produced by <span class="machine"><span class="font-tt">ocamlc</span></span>: a program must be
compiled entirely with <span class="machine"><span class="font-tt">ocamlopt</span></span> or entirely with <span class="machine"><span class="font-tt">ocamlc</span></span>. Native-code
object files produced by <span class="machine"><span class="font-tt">ocamlopt</span></span> cannot be loaded in the toplevel
system <span class="machine"><span class="font-tt">ocaml</span></span>.</p>
<!--TOC section id="s:native-overview" 16.1â€ƒOverview of the compiler-->
<h2 class="section" id="s:native-overview"><a class="section-anchor" href="#s:native-overview" aria-hidden="true">ï»¿</a>16.1â€ƒOverview of the compiler</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlopt</span></span> command has a command-line interface very close to that
of <span class="machine"><span class="font-tt">ocamlc</span></span>. It accepts the same types of arguments, and processes them
sequentially, after all options have been processed:</p><ul class="itemize"><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.mli</span></span> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <span class="font-it">x</span><span class="machine"><span class="font-tt">.mli</span></span>, the <span class="machine"><span class="font-tt">ocamlopt</span></span> compiler produces a compiled interface
in the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmi</span></span>. The interface produced is identical to that
produced by the bytecode compiler <span class="machine"><span class="font-tt">ocamlc</span></span>.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.ml</span></span> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span>, the <span class="machine"><span class="font-tt">ocamlopt</span></span>
compiler produces two files: <span class="font-it">x</span><span class="machine"><span class="font-tt">.o</span></span>, containing native object code,
and <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmx</span></span>, containing extra information for linking and
optimization of the clients of the unit. The compiled implementation
should always be referred to under the name <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmx</span></span> (when given
a <span class="machine"><span class="font-tt">.o</span></span> or <span class="machine"><span class="font-tt">.obj</span></span> file, <span class="machine"><span class="font-tt">ocamlopt</span></span> assumes that it contains code compiled from C,
not from OCaml).<p>The implementation is checked against the interface file <span class="font-it">x</span><span class="machine"><span class="font-tt">.mli</span></span>
(if it exists) as described in the manual for <span class="machine"><span class="font-tt">ocamlc</span></span>
(chapterÂ <a href="#c%3Acamlc">13</a>).</p></li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.cmx</span></span> are taken to be compiled object code. These
files are linked together, along with the object files obtained
by compiling <span class="machine"><span class="font-tt">.ml</span></span> arguments (if any), and the OCaml standard
library, to produce a native-code executable program. The order in
which <span class="machine"><span class="font-tt">.cmx</span></span> and <span class="machine"><span class="font-tt">.ml</span></span> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <span class="font-it">x</span><span class="machine"><span class="font-tt">.cmx</span></span> file must come
before all <span class="machine"><span class="font-tt">.cmx</span></span> files that refer to the unit <span class="font-it">x</span>.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.cmxa</span></span> are taken to be libraries of object code.
Such a library packs in two files (<span class="font-it">lib</span><span class="machine"><span class="font-tt">.cmxa</span></span> and <span class="font-it">lib</span><span class="machine"><span class="font-tt">.a</span></span>/<span class="machine"><span class="font-tt">.lib</span></span>)
a set of object files (<span class="machine"><span class="font-tt">.cmx</span></span> and <span class="machine"><span class="font-tt">.o</span></span>/<span class="machine"><span class="font-tt">.obj</span></span> files). Libraries are build with
<span class="machine"><span class="font-tt">ocamlopt -a</span></span> (see the description of the <span class="machine"><span class="font-tt">-a</span></span> option below). The object
files contained in the library are linked as regular <span class="machine"><span class="font-tt">.cmx</span></span> files (see
above), in the order specified when the library was built. The only
difference is that if an object file contained in a library is not
referenced anywhere in the program, then it is not linked in.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.c</span></span> are passed to the C compiler, which generates
a <span class="machine"><span class="font-tt">.o</span></span>/<span class="machine"><span class="font-tt">.obj</span></span> object file. This object file is linked with the program.</li><li class="li-itemize">Arguments ending in <span class="machine"><span class="font-tt">.o</span></span>, <span class="machine"><span class="font-tt">.a</span></span> or <span class="machine"><span class="font-tt">.so</span></span> (<span class="machine"><span class="font-tt">.obj</span></span>, <span class="machine"><span class="font-tt">.lib</span></span> and <span class="machine"><span class="font-tt">.dll</span></span>
under Windows) are assumed to be C object files and
libraries. They are linked with the program.</li></ul><p>The output of the linking phase is a regular Unix or Windows
executable file. It does not need <span class="machine"><span class="font-tt">ocamlrun</span></span> to run.</p><p>The compiler is able to emit some information on its internal stages:</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">.cmt</span></span> files for the implementation of the compilation unit
and <span class="machine"><span class="font-tt">.cmti</span></span> for signatures if the option <span class="machine"><span class="font-tt">-bin-annot</span></span> is passed to it (see the
description of <span class="machine"><span class="font-tt">-bin-annot</span></span> below).
Each such file contains a typed abstract syntax tree (AST), that is produced
during the type checking procedure. This tree contains all available information
about the location and the specific type of each term in the source file.
The AST is partial if type checking was unsuccessful.<p>These <span class="machine"><span class="font-tt">.cmt</span></span> and <span class="machine"><span class="font-tt">.cmti</span></span> files are typically useful for code inspection tools.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">.cmir-linear</span></span> files for the implementation of the compilation unit
if the option <span class="machine"><span class="font-tt">-save-ir-after scheduling</span></span> is passed to it.
Each such file contains a low-level intermediate representation,
produced by the instruction scheduling pass.<p>An external tool can perform low-level optimisations,
such as code layout, by transforming a <span class="machine"><span class="font-tt">.cmir-linear</span></span> file.
To continue compilation, the compiler can be invoked with (a possibly modified)
<span class="machine"><span class="font-tt">.cmir-linear</span></span> file as an argument, instead of the corresponding source file.
</p></li></ul>
<!--TOC section id="s:native-options" 16.2â€ƒOptions-->
<h2 class="section" id="s:native-options"><a class="section-anchor" href="#s:native-options" aria-hidden="true">ï»¿</a>16.2â€ƒOptions</h2><!--SEC END --><p>The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamlopt</span></span>.
The options <span class="machine"><span class="font-tt">-pack</span></span>, <span class="machine"><span class="font-tt">-a</span></span>, <span class="machine"><span class="font-tt">-shared</span></span>, <span class="machine"><span class="font-tt">-c</span></span>, <span class="machine"><span class="font-tt">-output-obj</span></span> and
<span class="machine"><span class="font-tt">-output-complete-obj</span></span> are mutually exclusive.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-a</span></span></span></dt><dd class="dd-description">
Build a library(<span class="machine"><span class="font-tt">.cmxa</span></span> and <span class="machine"><span class="font-tt">.a</span></span>/<span class="machine"><span class="font-tt">.lib</span></span> files)
with the object files (<span class="machine"><span class="font-tt">.cmx</span></span> and <span class="machine"><span class="font-tt">.o</span></span>/<span class="machine"><span class="font-tt">.obj</span></span> files)
given on the command line, instead of linking them into an executable file.
The name of the library must be set with the <span class="machine"><span class="font-tt">-o</span></span> option.<p>If <span class="machine"><span class="font-tt">-cclib</span></span> or <span class="machine"><span class="font-tt">-ccopt</span></span> options are passed on the command
line, these options are stored in the resulting <span class="machine"><span class="font-tt">.cmxa</span></span>library. Then,
linking with this library automatically adds back the 
<span class="machine"><span class="font-tt">-cclib</span></span> and <span class="machine"><span class="font-tt">-ccopt</span></span> options as if they had been provided on the
command line, unless the <span class="machine"><span class="font-tt">-noautolink</span></span> option is given.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-absname</span></span></span></dt><dd class="dd-description">
Force error messages to show absolute paths for file names.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-annot</span></span></span></dt><dd class="dd-description">
Deprecated since OCaml 4.11. Please use <span class="machine"><span class="font-tt">-bin-annot</span></span> instead.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional newline-terminated command line arguments from <span class="font-it">filename</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args0</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional null character terminated command line arguments from
<span class="font-it">filename</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-bin-annot</span></span></span></dt><dd class="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc) in binary format. The information for file <span class="font-it">src</span><span class="machine"><span class="font-tt">.ml</span></span>
(resp. <span class="font-it">src</span><span class="machine"><span class="font-tt">.mli</span></span>) is put into file <span class="font-it">src</span><span class="machine"><span class="font-tt">.cmt</span></span>
(resp. <span class="font-it">src</span><span class="machine"><span class="font-tt">.cmti</span></span>). In case of a type error, dump
all the information inferred by the type-checker before the error.
The <span class="machine"><span class="font-tt">*.cmt</span></span> and <span class="machine"><span class="font-tt">*.cmti</span></span> files produced by <span class="machine"><span class="font-tt">-bin-annot</span></span> contain
more information and are much more compact than the files produced by
<span class="machine"><span class="font-tt">-annot</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-c</span></span></span></dt><dd class="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cc</span></span> <span class="font-it">ccomp</span></span></dt><dd class="dd-description">
Use <span class="font-it">ccomp</span> as the C linker called to build the final executable 

and as the C compiler for compiling <span class="machine"><span class="font-tt">.c</span></span> source files.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cclib</span></span> <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span></span></dt><dd class="dd-description">
Pass the <span class="machine"><span class="font-tt">-l</span></span><span class="font-it">libname</span> option to the  linker
.
This causes the given C library to be linked with the program.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ccopt</span></span> <span class="font-it">option</span></span></dt><dd class="dd-description">
Pass the given option to the C compiler and linker.
For instance, <span class="machine"><span class="font-tt">-ccopt -L</span></span><span class="font-it">dir</span> causes the C linker to search for C libraries in
directory <span class="font-it">dir</span>. 
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cmi-file</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Use the given interface file to type-check the ML source file to compile.
When this option is not specified, the compiler looks for a <span class="font-it">.mli</span> file
with the same base name than the implementation it is compiling and in the
same directory. If such a file is found, the compiler looks for a
corresponding <span class="font-it">.cmi</span> file in the included directories and reports an
error if it fails to find one.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-color</span></span> <span class="font-it">mode</span></span></dt><dd class="dd-description">
Enable or disable colors in compiler messages (especially warnings and errors).
The following modes are supported:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">auto</span></span></span></dt><dd class="dd-description"> use heuristics to enable colors only if the output supports them
(an ANSI-compatible tty terminal);
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">always</span></span></span></dt><dd class="dd-description"> enable colors unconditionally;
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">never</span></span></span></dt><dd class="dd-description"> disable color output.
</dd></dl><p>The environment variable <span class="machine"><span class="font-tt">OCAML_COLOR</span></span> is considered if <span class="machine"><span class="font-tt">-color</span></span> is not
provided. Its values are auto/always/never as above.</p><p>If <span class="machine"><span class="font-tt">-color</span></span> is not provided, <span class="machine"><span class="font-tt">OCAML_COLOR</span></span> is not set and the environment
variable <span class="machine"><span class="font-tt">NO_COLOR</span></span> is set, then color output is disabled. Otherwise,
the default setting is â€™autoâ€™, and the current heuristic
checks that the <span class="machine"><span class="font-tt">TERM</span></span> environment variable exists and is
not empty or <span class="machine"><span class="font-tt">dumb</span></span>, and that â€™isatty(stderr)â€™ holds.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-error-style</span></span> <span class="font-it">mode</span></span></dt><dd class="dd-description">
Control the way error messages and warnings are printed.
The following modes are supported:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">short</span></span></span></dt><dd class="dd-description"> only print the error and its location;
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">contextual</span></span></span></dt><dd class="dd-description"> like <span class="machine"><span class="font-tt">short</span></span>, but also display the source code snippet
corresponding to the location of the error.
</dd></dl>
The default setting is <span class="machine"><span class="font-tt">contextual</span></span>.<p>The environment variable <span class="machine"><span class="font-tt">OCAML_ERROR_STYLE</span></span> is considered if <span class="machine"><span class="font-tt">-error-style</span></span> is
not provided. Its values are short/contextual as above.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-compact</span></span></span></dt><dd class="dd-description">
Optimize the produced code for space rather than for time. This
results in slightly smaller but slightly slower programs. The default is to
optimize for speed.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-config</span></span></span></dt><dd class="dd-description">
Print the version number of <span class="machine"><span class="font-tt">ocamlopt</span></span> and a detailed
summary of its configuration, then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-config-var</span></span> <span class="font-it">var</span></span></dt><dd class="dd-description">
Print the value of a specific configuration variable from the
<span class="machine"><span class="font-tt">-config</span></span> output, then exit. If the variable does not exist, the exit
code is non-zero. This option is only available since OCaml 4.08,
so script authors should have a fallback for older versions.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-depend</span></span> <span class="font-it">ocamldep-args</span></span></dt><dd class="dd-description">
Compute dependencies, as the <span class="machine"><span class="font-tt">ocamldep</span></span> command would do. The remaining
arguments are interpreted as if they were given to the <span class="machine"><span class="font-tt">ocamldep</span></span> command.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-for-pack</span></span> <span class="font-it">module-path</span></span></dt><dd class="dd-description">
Generate an object file (<span class="machine"><span class="font-tt">.cmx</span></span> and <span class="machine"><span class="font-tt">.o</span></span>/<span class="machine"><span class="font-tt">.obj</span></span> files)
that can later be included
as a sub-module (with the given access path) of a compilation unit
constructed with <span class="machine"><span class="font-tt">-pack</span></span>. For instance,
<span class="machine"><span class="font-tt">ocamlopt -for-pack P -c A.ml</span></span>
will generate <span class="machine"><span class="font-tt">a..cmx</span></span> and <span class="machine"><span class="font-tt">a.o</span></span> files that can
later be used with <span class="machine"><span class="font-tt">ocamlopt -pack -o P.cmx a.cmx</span></span>.
Note: you can still pack a module that was compiled without
<span class="machine"><span class="font-tt">-for-pack</span></span> but in this case exceptions will be printed with the wrong
names.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-g</span></span></span></dt><dd class="dd-description">
Add debugging information while compiling and linking. This option is
required in order to  produce stack backtraces when
the program terminates on an uncaught exception (see
sectionÂ <a href="#s%3Aocamlrun-options">15.2</a>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-i</span></span></span></dt><dd class="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<span class="machine"><span class="font-tt">.ml</span></span>
file). No compiled files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cmi</span></span> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<span class="machine"><span class="font-tt">.mli</span></span> file) for a file:
just redirect the standard output of the compiler to a <span class="machine"><span class="font-tt">.mli</span></span> file,
and edit that file to remove all declarations of unexported names.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for
compiled interface files (<span class="machine"><span class="font-tt">.cmi</span></span>), compiled object code files (<span class="machine"><span class="font-tt">.cmx</span></span>),
and libraries (<span class="machine"><span class="font-tt">.cmxa</span></span>).


By default, the current directory is searched first, then the standard
library directory. Directories added with <span class="machine"><span class="font-tt">-I</span></span> are searched after the
current directory, in the order in which they were given on the command line,
but before the standard library directory. See also option <span class="machine"><span class="font-tt">-nostdlib</span></span>.<p>If the given directory starts with <span class="machine"><span class="font-tt">+</span></span>, it is taken relative to the
standard library directory. For instance, <span class="machine"><span class="font-tt">-I +unix</span></span> adds the
subdirectory <span class="machine"><span class="font-tt">unix</span></span> of the standard library to the search path.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-impl</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Compile the file <span class="font-it">filename</span> as an implementation file, even if its
extension is not <span class="machine"><span class="font-tt">.ml</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline</span></span> <span class="font-it">n</span></span></dt><dd class="dd-description">
Set aggressiveness of inlining to <span class="font-it">n</span>, where <span class="font-it">n</span> is a positive
integer. Specifying <span class="machine"><span class="font-tt">-inline 0</span></span> prevents all functions from being
inlined, except those whose body is smaller than the call site. Thus,
inlining causes no expansion in code size. The default aggressiveness,
<span class="machine"><span class="font-tt">-inline 1</span></span>, allows slightly larger functions to be inlined, resulting
in a slight expansion in code size. Higher values for the <span class="machine"><span class="font-tt">-inline</span></span>
option cause larger and larger functions to become candidate for
inlining, but can result in a serious increase in code size.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Compile the file <span class="font-it">filename</span> as an interface file, even if its
extension is not <span class="machine"><span class="font-tt">.mli</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf-suffix</span></span> <span class="font-it">string</span></span></dt><dd class="dd-description">
Recognize file names ending with <span class="font-it">string</span> as interface files
(instead of the default <span class="machine"><span class="font-tt">.mli</span></span>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-labels</span></span></span></dt><dd class="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-linkall</span></span></span></dt><dd class="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (option <span class="machine"><span class="font-tt">-a</span></span>), setting the <span class="machine"><span class="font-tt">-linkall</span></span> option forces all
subsequent links of programs involving that library to link all the
modules contained in the library. When compiling a module (option
<span class="machine"><span class="font-tt">-c</span></span>), setting the <span class="machine"><span class="font-tt">-linkall</span></span> option ensures that this module will
always be linked if it is put in a library and this library is linked.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-linscan</span></span></span></dt><dd class="dd-description">
Use linear scan register allocation. Compiling with this allocator is faster
than with the usual graph coloring allocator, sometimes quite drastically so for
long functions and modules. On the other hand, the generated code can be a bit
slower.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-match-context-rows</span></span></span></dt><dd class="dd-description">
Set the number of rows of context used for optimization during
pattern matching compilation. The default value is 32. Lower values
cause faster compilation, but less optimized code. This advanced
option is meant for use in the event that a pattern-match-heavy
program leads to significant increases in compilation time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-alias-deps</span></span></span></dt><dd class="dd-description">
Do not record dependencies for module aliases. See
sectionÂ <a href="#s%3Amodule-alias">12.8</a> for more information.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-app-funct</span></span></span></dt><dd class="dd-description">
Deactivates the applicative behaviour of functors. With this option,
each functor application generates new types in its result and
applying the same functor twice to the same argument yields two
incompatible structures.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-float-const-prop</span></span></span></dt><dd class="dd-description">
Deactivates the constant propagation for floating-point operations.
This option should be given if the program changes the float rounding
mode during its execution.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noassert</span></span></span></dt><dd class="dd-description">
Do not compile assertion checks. Note that the special form
<span class="machine"><span class="font-tt">assert false</span></span> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noautolink</span></span></span></dt><dd class="dd-description">
When linking <span class="machine"><span class="font-tt">.cmxa</span></span>libraries, ignore  <span class="machine"><span class="font-tt">-cclib</span></span> and <span class="machine"><span class="font-tt">-ccopt</span></span>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <span class="machine"><span class="font-tt">-noautolink</span></span> and pass the correct C
libraries and options on the command line.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nodynlink</span></span></span></dt><dd class="dd-description">
Allow the compiler to use some optimizations that are valid only for
code that is statically linked to produce a non-relocatable
executable. The generated code cannot be linked to produce a shared
library nor a position-independent executable (PIE). Many operating
systems produce PIEs by default, causing errors when linking code
compiled with <span class="machine"><span class="font-tt">-nodynlink</span></span>. Either do not use <span class="machine"><span class="font-tt">-nodynlink</span></span> or pass
the option <span class="machine"><span class="font-tt">-ccopt -no-pie</span></span> at link-time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nolabels</span></span></span></dt><dd class="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nostdlib</span></span></span></dt><dd class="dd-description">
Do not automatically add the standard library directory to the list of
directories searched for compiled interface files (<span class="machine"><span class="font-tt">.cmi</span></span>), compiled
object code files (<span class="machine"><span class="font-tt">.cmx</span></span>), and libraries (<span class="machine"><span class="font-tt">.cmxa</span></span>). See also option
<span class="machine"><span class="font-tt">-I</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">output-file</span></span></dt><dd class="dd-description">
Specify the name of the output file to produce. For executable files, the
default output name is <span class="machine"><span class="font-tt">a.out</span></span> under Unix and <span class="machine"><span class="font-tt">camlprog.exe</span></span> under
Windows. If the <span class="machine"><span class="font-tt">-a</span></span> option is given, specify the name of the library
produced. If the <span class="machine"><span class="font-tt">-pack</span></span> option is given, specify the name of the
packed object file produced. If the <span class="machine"><span class="font-tt">-output-obj</span></span> or <span class="machine"><span class="font-tt">-output-complete-obj</span></span>
options are given, specify the name of the produced object file.
If the <span class="machine"><span class="font-tt">-shared</span></span> option is given, specify the name of plugin
file produced.

</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-opaque</span></span></span></dt><dd class="dd-description">
When the native compiler compiles an implementation, by default it
produces a <span class="machine"><span class="font-tt">.cmx</span></span> file containing information for cross-module
optimization. It also expects <span class="machine"><span class="font-tt">.cmx</span></span> files to be present for the
dependencies of the currently compiled source, and uses them for
optimization. Since OCaml 4.03, the compiler will emit a warning if it
is unable to locate the <span class="machine"><span class="font-tt">.cmx</span></span> file of one of those dependencies.<p>The <span class="machine"><span class="font-tt">-opaque</span></span> option, available since 4.04, disables cross-module
optimization information for the currently compiled unit. When
compiling <span class="machine"><span class="font-tt">.mli</span></span> interface, using <span class="machine"><span class="font-tt">-opaque</span></span> marks the compiled <span class="machine"><span class="font-tt">.cmi</span></span>
interface so that subsequent compilations of modules that depend on it
will not rely on the corresponding <span class="machine"><span class="font-tt">.cmx</span></span> file, nor warn if it is
absent. When the native compiler compiles a <span class="machine"><span class="font-tt">.ml</span></span> implementation,
using <span class="machine"><span class="font-tt">-opaque</span></span> generates a <span class="machine"><span class="font-tt">.cmx</span></span> that does not contain any
cross-module optimization information.</p><p>Using this option may degrade the quality of generated code, but it
reduces compilation time, both on clean and incremental
builds. Indeed, with the native compiler, when the implementation of
a compilation unit changes, all the units that depend on it may need
to be recompiled â€“ because the cross-module information may have
changed. If the compilation unit whose implementation changed was
compiled with <span class="machine"><span class="font-tt">-opaque</span></span>, no such recompilation needs to occur. This
option can thus be used, for example, to get faster edit-compile-test
feedback loops.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-open</span></span> <span class="font-it">Module</span></span></dt><dd class="dd-description">
Opens the given module before processing the interface or
implementation files. If several <span class="machine"><span class="font-tt">-open</span></span> options are given,
they are processed in order, just as if
the statements <span class="machine"><span class="font-tt">open!</span></span> <span class="font-it">Module1</span><span class="machine"><span class="font-tt">;;</span></span> <span class="machine"><span class="font-tt">...</span></span> <span class="machine"><span class="font-tt">open!</span></span> <span class="font-it">ModuleN</span><span class="machine"><span class="font-tt">;;</span></span>
were added at the top of each file.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-output-obj</span></span></span></dt><dd class="dd-description">
Cause the linker to produce a C object file instead of
an executable file.
This is useful to wrap OCaml code as a C library,
callable from any C program. See chapterÂ <a href="#c%3Aintf-c">22</a>,
sectionÂ <a href="#ss%3Ac-embedded-code">22.7.5</a>. The name of the output object file
must be set with the <span class="machine"><span class="font-tt">-o</span></span> option.
This option can also be used to produce a  compiled shared/dynamic library (<span class="machine"><span class="font-tt">.so</span></span> extension, <span class="machine"><span class="font-tt">.dll</span></span> under Windows).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-output-complete-obj</span></span></span></dt><dd class="dd-description">
Same as <span class="machine"><span class="font-tt">-output-obj</span></span> options except the object file produced includes the
runtime and autolink libraries.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pack</span></span></span></dt><dd class="dd-description">
Build an object file (<span class="machine"><span class="font-tt">.cmx</span></span> and <span class="machine"><span class="font-tt">.o</span></span>/<span class="machine"><span class="font-tt">.obj</span></span> files) and its associated compiled
interface (<span class="machine"><span class="font-tt">.cmi</span></span>) that combines the <span class="machine"><span class="font-tt">.cmx</span></span> object
files given on the command line, making them appear as sub-modules of
the output <span class="machine"><span class="font-tt">.cmx</span></span> file. The name of the output <span class="machine"><span class="font-tt">.cmx</span></span> file must be
given with the <span class="machine"><span class="font-tt">-o</span></span> option. For instance,
<pre>        ocamlopt -pack -o P.cmx A.cmx B.cmx C.cmx
</pre>generates compiled files <span class="machine"><span class="font-tt">P.cmx</span></span>, <span class="machine"><span class="font-tt">P.o</span></span> and <span class="machine"><span class="font-tt">P.cmi</span></span> describing a
compilation unit having three sub-modules <span class="machine"><span class="font-tt">A</span></span>, <span class="machine"><span class="font-tt">B</span></span> and <span class="machine"><span class="font-tt">C</span></span>,
corresponding to the contents of the object files <span class="machine"><span class="font-tt">A.cmx</span></span>, <span class="machine"><span class="font-tt">B.cmx</span></span> and
<span class="machine"><span class="font-tt">C.cmx</span></span>. These contents can be referenced as <span class="machine"><span class="font-tt">P.A</span></span>, <span class="machine"><span class="font-tt">P.B</span></span> and <span class="machine"><span class="font-tt">P.C</span></span>
in the remainder of the program.<p>The <span class="machine"><span class="font-tt">.cmx</span></span> object files being combined must have been compiled with
the appropriate <span class="machine"><span class="font-tt">-for-pack</span></span> option. In the example above,
<span class="machine"><span class="font-tt">A.cmx</span></span>, <span class="machine"><span class="font-tt">B.cmx</span></span> and <span class="machine"><span class="font-tt">C.cmx</span></span> must have been compiled with
<span class="machine"><span class="font-tt">ocamlopt -for-pack P</span></span>.</p><p>Multiple levels of packing can be achieved by combining <span class="machine"><span class="font-tt">-pack</span></span> with
<span class="machine"><span class="font-tt">-for-pack</span></span>. Consider the following example:
</p><pre>        ocamlopt -for-pack P.Q -c A.ml
        ocamlopt -pack -o Q.cmx -for-pack P A.cmx
        ocamlopt -for-pack P -c B.ml
        ocamlopt -pack -o P.cmx Q.cmx B.cmx
</pre><p>The resulting <span class="machine"><span class="font-tt">P.cmx</span></span> object file has sub-modules <span class="machine"><span class="font-tt">P.Q</span></span>, <span class="machine"><span class="font-tt">P.Q.A</span></span>
and <span class="machine"><span class="font-tt">P.B</span></span>.
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pp</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
Cause the compiler to call the given <span class="font-it">command</span> as a preprocessor
for each source file. The output of <span class="font-it">command</span> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ppx</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
After parsing, pipe the abstract syntax tree through the preprocessor
<span class="font-it">command</span>. The module <span class="machine"><span class="font-tt">Ast_mapper</span></span>, described in
chapterÂ <a href="#c%3Aparsinglib">29</a>:
<a href="compilerlibref/Ast_mapper.html"> <span class="font-tt">Ast_mapper</span> </a>
,
implements the external interface of a preprocessor.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-principal</span></span></span></dt><dd class="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <span class="machine"><span class="font-tt">-principal</span></span> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rectypes</span></span></span></dt><dd class="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-runtime-variant</span></span> <span class="font-it">suffix</span></span></dt><dd class="dd-description">
Add the <span class="font-it">suffix</span> string to the name of the runtime library used by
the program. Currently, only one such suffix is supported: <span class="machine"><span class="font-tt">d</span></span>, and
only if the OCaml compiler was configured with option
<span class="machine"><span class="font-tt">-with-debug-runtime</span></span>. This suffix gives the debug version of the
runtime, which is useful for debugging pointer problems in low-level
code such as C stubs.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-stop-after</span></span> <span class="font-it">pass</span></span></dt><dd class="dd-description">
Stop compilation after the given compilation pass. The currently
supported passes are:
<span class="machine"><span class="font-tt">parsing</span></span>, <span class="machine"><span class="font-tt">typing</span></span>, <span class="machine"><span class="font-tt">scheduling</span></span>, <span class="machine"><span class="font-tt">emit</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-save-ir-after</span></span> <span class="font-it">pass</span></span></dt><dd class="dd-description">
Save intermediate representation after the given compilation pass
to a file.
The currently supported passes and the corresponding file extensions are:
<span class="machine"><span class="font-tt">scheduling</span></span> (<span class="machine"><span class="font-tt">.cmir-linear</span></span>).<p>This experimental feature enables external tools to inspect and manipulate
compilerâ€™s intermediate representation of the program
using <span class="machine"><span class="font-tt">compiler-libs</span></span> library (see
chapterÂ <a href="#c%3Aparsinglib">29</a> and
<a href="compilerlibref/Compiler_libs.html"> <span class="font-tt">Compiler_libs</span> </a>
).
</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-S</span></span></span></dt><dd class="dd-description">
Keep the assembly code produced during the compilation. The assembly
code for the source file <span class="font-it">x</span><span class="machine"><span class="font-tt">.ml</span></span> is saved in the file <span class="font-it">x</span><span class="machine"><span class="font-tt">.s</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-shared</span></span></span></dt><dd class="dd-description">
Build a plugin (usually <span class="machine"><span class="font-tt">.cmxs</span></span>) that can be dynamically loaded with
the <span class="machine"><span class="font-tt">Dynlink</span></span> module. The name of the plugin must be
set with the <span class="machine"><span class="font-tt">-o</span></span> option. A plugin can include a number of OCaml
modules and libraries, and extra native objects (<span class="machine"><span class="font-tt">.o</span></span>, <span class="machine"><span class="font-tt">.obj</span></span>, <span class="machine"><span class="font-tt">.a</span></span>,
<span class="machine"><span class="font-tt">.lib</span></span> files). Building native plugins is only supported for some
operating system. Under some systems (currently,
only Linux AMD 64), all the OCaml code linked in a plugin must have
been compiled without the <span class="machine"><span class="font-tt">-nodynlink</span></span> flag. Some constraints might also
apply to the way the extra native objects have been compiled (under
Linux AMD 64, they must contain only position-independent code).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-safe-string</span></span></span></dt><dd class="dd-description">
Enforce the separation between types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>,
thereby making strings read-only. This is the default, and enforced
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-short-paths</span></span></span></dt><dd class="dd-description">
When a type is visible under several module-paths, use the shortest
one when printing the typeâ€™s name in inferred interfaces and error and
warning messages. Identifier names starting with an underscore <span class="machine"><span class="font-tt">_</span></span> or
containing double underscores <span class="machine"><span class="font-tt">__</span></span> incur a penalty of +10 when computing
their length.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-sequence</span></span></span></dt><dd class="dd-description">
Force the left-hand part of each sequence to have type unit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-strict-formats</span></span></span></dt><dd class="dd-description">
Reject invalid formats that were accepted in legacy format
implementations. You should use this flag to detect and fix such
invalid formats, as they will be rejected by future OCaml versions.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unboxed-types</span></span></span></dt><dd class="dd-description">
When a type is unboxable (i.e. a record with a single argument or a
concrete datatype with a single constructor of one argument) it will
be unboxed unless annotated with <span class="machine"><span class="font-tt">[@@ocaml.boxed]</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-unboxed-types</span></span></span></dt><dd class="dd-description">
When a type is unboxable it will be boxed unless annotated with
<span class="machine"><span class="font-tt">[@@ocaml.unboxed]</span></span>. This is the default.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe</span></span></span></dt><dd class="dd-description">
Turn bound checking off for array and string accesses (the <span class="machine"><span class="font-tt">v.(i)</span></span> and
<span class="machine"><span class="font-tt">s.[i]</span></span> constructs). Programs compiled with <span class="machine"><span class="font-tt">-unsafe</span></span> are therefore
 faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.
Additionally, turn off the check for zero divisor in integer division
and modulus operations. With <span class="machine"><span class="font-tt">-unsafe</span></span>, an integer division
(or modulus) by zero can halt the program or continue with an
unspecified result instead of raising a <span class="machine"><span class="font-tt">Division_by_zero</span></span> exception.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unsafe-string</span></span></span></dt><dd class="dd-description">
Identify the types <span class="machine"><span class="font-tt">string</span></span> and <span class="machine"><span class="font-tt">bytes</span></span>, thereby making strings writable.
This is intended for compatibility with old source code and should not
be used with new software. This option raises an error unconditionally
since OCaml 5.0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-verbose</span></span></span></dt><dd class="dd-description">
Print all external commands before they are executed,
in particular invocations of the assembler, C compiler, and linker.

Useful to debug C library problems.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span> or <span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print the version number of the compiler in short form (e.g. <span class="machine"><span class="font-tt">3.11.0</span></span>),
then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-w</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Enable, disable, or mark as fatal the warnings specified by the argument
<span class="font-it">warning-list</span>.
Each warning can be <em>enabled</em> or <em>disabled</em>, and each warning
can be <em>fatal</em> or <em>non-fatal</em>.
If a warning is disabled, it isnâ€™t displayed and doesnâ€™t affect
compilation in any way (even if it is fatal). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and fatal, the compiler will also
stop with an error after displaying it.<p>The <span class="font-it">warning-list</span> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Disable warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning number <span class="font-it">num</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Disable warnings in the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">num1</span>..<span class="font-it">num2</span></span></dt><dd class="dd-description"> Enable and mark as fatal warnings in
the given range.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding to
<span class="font-it">letter</span>. The letter may be uppercase or lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">letter</span></span></dt><dd class="dd-description"> Enable and mark as fatal the set of warnings
corresponding to <span class="font-it">letter</span>. The letter may be uppercase or
lowercase.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">uppercase-letter</span></span></dt><dd class="dd-description"> Enable the set of warnings corresponding
to <span class="font-it">uppercase-letter</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">lowercase-letter</span></span></dt><dd class="dd-description"> Disable the set of warnings corresponding
to <span class="font-it">lowercase-letter</span>.
</dd></dl><p>Alternatively, <span class="font-it">warning-list</span> can specify a single warning using its
mnemonic name (see below), as follows:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">+</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Disable warning <span class="font-it">name</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@</span></span><span class="font-it">name</span></span></dt><dd class="dd-description"> Enable and mark as fatal warning <span class="font-it">name</span>.
</dd></dl><p>Warning numbers, letters and names which are not currently defined are
ignored. The warnings are as follows (the name following each number specifies
the mnemonic for that warning).
</p><dl class="description"><dt class="dt-description"><span class="font-bold">1 <span class="machine"><span class="font-tt">comment-start</span></span></span></dt><dd class="dd-description"> Suspicious-looking start-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">2 <span class="machine"><span class="font-tt">comment-not-end</span></span></span></dt><dd class="dd-description"> Suspicious-looking end-of-comment mark.
</dd><dt class="dt-description"><span class="font-bold">3</span></dt><dd class="dd-description"> Deprecated synonym for the â€™deprecatedâ€™ alert.
</dd><dt class="dt-description"><span class="font-bold">4 <span class="machine"><span class="font-tt">fragile-match</span></span></span></dt><dd class="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</dd><dt class="dt-description"><span class="font-bold">5 <span class="machine"><span class="font-tt">ignored-partial-application</span></span></span></dt><dd class="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</dd><dt class="dt-description"><span class="font-bold">6 <span class="machine"><span class="font-tt">labels-omitted</span></span></span></dt><dd class="dd-description"> Label omitted in function application.
</dd><dt class="dt-description"><span class="font-bold">7 <span class="machine"><span class="font-tt">method-override</span></span></span></dt><dd class="dd-description"> Method overridden.
</dd><dt class="dt-description"><span class="font-bold">8 <span class="machine"><span class="font-tt">partial-match</span></span></span></dt><dd class="dd-description"> Partial match: missing cases in pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">9 <span class="machine"><span class="font-tt">missing-record-field-pattern</span></span></span></dt><dd class="dd-description"> Missing fields in a record pattern.
</dd><dt class="dt-description"><span class="font-bold">10 <span class="machine"><span class="font-tt">non-unit-statement</span></span></span></dt><dd class="dd-description"> Expression on the left-hand side of a sequence that doesnâ€™t have type
<span class="machine"><span class="font-tt">unit</span></span> (and that is not a function, see warning number 5).
</dd><dt class="dt-description"><span class="font-bold">11 <span class="machine"><span class="font-tt">redundant-case</span></span></span></dt><dd class="dd-description"> Redundant case in a pattern matching (unused match case).
</dd><dt class="dt-description"><span class="font-bold">12 <span class="machine"><span class="font-tt">redundant-subpat</span></span></span></dt><dd class="dd-description"> Redundant sub-pattern in a pattern-matching.
</dd><dt class="dt-description"><span class="font-bold">13 <span class="machine"><span class="font-tt">instance-variable-override</span></span></span></dt><dd class="dd-description"> Instance variable overridden.
</dd><dt class="dt-description"><span class="font-bold">14 <span class="machine"><span class="font-tt">illegal-backslash</span></span></span></dt><dd class="dd-description"> Illegal backslash escape in a string constant.
</dd><dt class="dt-description"><span class="font-bold">15 <span class="machine"><span class="font-tt">implicit-public-methods</span></span></span></dt><dd class="dd-description"> Private method made public implicitly.
</dd><dt class="dt-description"><span class="font-bold">16 <span class="machine"><span class="font-tt">unerasable-optional-argument</span></span></span></dt><dd class="dd-description"> Unerasable optional argument.
</dd><dt class="dt-description"><span class="font-bold">17 <span class="machine"><span class="font-tt">undeclared-virtual-method</span></span></span></dt><dd class="dd-description"> Undeclared virtual method.
</dd><dt class="dt-description"><span class="font-bold">18 <span class="machine"><span class="font-tt">not-principal</span></span></span></dt><dd class="dd-description"> Non-principal type.
</dd><dt class="dt-description"><span class="font-bold">19 <span class="machine"><span class="font-tt">non-principal-labels</span></span></span></dt><dd class="dd-description"> Type without principality.
</dd><dt class="dt-description"><span class="font-bold">20 <span class="machine"><span class="font-tt">ignored-extra-argument</span></span></span></dt><dd class="dd-description"> Unused function argument.
</dd><dt class="dt-description"><span class="font-bold">21 <span class="machine"><span class="font-tt">nonreturning-statement</span></span></span></dt><dd class="dd-description"> Non-returning statement.
</dd><dt class="dt-description"><span class="font-bold">22 <span class="machine"><span class="font-tt">preprocessor</span></span></span></dt><dd class="dd-description"> Preprocessor warning.
</dd><dt class="dt-description"><span class="font-bold">23 <span class="machine"><span class="font-tt">useless-record-with</span></span></span></dt><dd class="dd-description"> Useless record <span class="machine"><span class="font-tt">with</span></span> clause.
</dd><dt class="dt-description"><span class="font-bold">24 <span class="machine"><span class="font-tt">bad-module-name</span></span></span></dt><dd class="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</dd><dt class="dt-description"><span class="font-bold">25</span></dt><dd class="dd-description"> Ignored: now part of warning 8.
</dd><dt class="dt-description"><span class="font-bold">26 <span class="machine"><span class="font-tt">unused-var</span></span></span></dt><dd class="dd-description"> Suspicious unused variable: unused variable that is bound
with <span class="machine"><span class="font-tt">let</span></span> or <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">27 <span class="machine"><span class="font-tt">unused-var-strict</span></span></span></dt><dd class="dd-description"> Innocuous unused variable: unused variable that is not bound with
<span class="machine"><span class="font-tt">let</span></span> nor <span class="machine"><span class="font-tt">as</span></span>, and doesnâ€™t start with an underscore (<span class="machine"><span class="font-tt">_</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold">28 <span class="machine"><span class="font-tt">wildcard-arg-to-constant-constr</span></span></span></dt><dd class="dd-description"> Wildcard pattern given as argument to a constant constructor.
</dd><dt class="dt-description"><span class="font-bold">29 <span class="machine"><span class="font-tt">eol-in-string</span></span></span></dt><dd class="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</dd><dt class="dt-description"><span class="font-bold">30 <span class="machine"><span class="font-tt">duplicate-definitions</span></span></span></dt><dd class="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.
</dd><dt class="dt-description"><span class="font-bold">31 <span class="machine"><span class="font-tt">module-linked-twice</span></span></span></dt><dd class="dd-description"> A module is linked twice in the same executable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">32 <span class="machine"><span class="font-tt">unused-value-declaration</span></span></span></dt><dd class="dd-description"> Unused value declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">33 <span class="machine"><span class="font-tt">unused-open</span></span></span></dt><dd class="dd-description"> Unused open statement. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">34 <span class="machine"><span class="font-tt">unused-type-declaration</span></span></span></dt><dd class="dd-description"> Unused type declaration. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">35 <span class="machine"><span class="font-tt">unused-for-index</span></span></span></dt><dd class="dd-description"> Unused for-loop index. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">36 <span class="machine"><span class="font-tt">unused-ancestor</span></span></span></dt><dd class="dd-description"> Unused ancestor variable. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">37 <span class="machine"><span class="font-tt">unused-constructor</span></span></span></dt><dd class="dd-description"> Unused constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">38 <span class="machine"><span class="font-tt">unused-extension</span></span></span></dt><dd class="dd-description"> Unused extension constructor. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">39 <span class="machine"><span class="font-tt">unused-rec-flag</span></span></span></dt><dd class="dd-description"> Unused rec flag. (since 4.00)
</dd><dt class="dt-description"><span class="font-bold">40 <span class="machine"><span class="font-tt">name-out-of-scope</span></span></span></dt><dd class="dd-description"> Constructor or label name used out of scope. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">41 <span class="machine"><span class="font-tt">ambiguous-name</span></span></span></dt><dd class="dd-description"> Ambiguous constructor or label name. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">42 <span class="machine"><span class="font-tt">disambiguated-name</span></span></span></dt><dd class="dd-description"> Disambiguated constructor or label name (compatibility warning). (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">43 <span class="machine"><span class="font-tt">nonoptional-label</span></span></span></dt><dd class="dd-description"> Nonoptional label applied as optional. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">44 <span class="machine"><span class="font-tt">open-shadow-identifier</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined identifier. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">45 <span class="machine"><span class="font-tt">open-shadow-label-constructor</span></span></span></dt><dd class="dd-description"> Open statement shadows an already defined label or constructor. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">46 <span class="machine"><span class="font-tt">bad-env-variable</span></span></span></dt><dd class="dd-description"> Error in environment variable. (since 4.01)
</dd><dt class="dt-description"><span class="font-bold">47 <span class="machine"><span class="font-tt">attribute-payload</span></span></span></dt><dd class="dd-description"> Illegal attribute payload. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">48 <span class="machine"><span class="font-tt">eliminated-optional-arguments</span></span></span></dt><dd class="dd-description"> Implicit elimination of optional arguments. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">49 <span class="machine"><span class="font-tt">no-cmi-file</span></span></span></dt><dd class="dd-description"> Absent cmi file when looking up module alias. (since 4.02)
</dd><dt class="dt-description"><span class="font-bold">50 <span class="machine"><span class="font-tt">unexpected-docstring</span></span></span></dt><dd class="dd-description"> Unexpected documentation comment. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">51 <span class="machine"><span class="font-tt">wrong-tailcall-expectation</span></span></span></dt><dd class="dd-description"> Function call annotated with an incorrect @tailcall attribute. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">52 <span class="machine"><span class="font-tt">fragile-literal-pattern</span></span> (see </span><a href="#ss%3Awarn52"><span class="font-bold">13.5.3</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Fragile constant pattern. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">53 <span class="machine"><span class="font-tt">misplaced-attribute</span></span></span></dt><dd class="dd-description"> Attribute cannot appear in this context. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">54 <span class="machine"><span class="font-tt">duplicated-attribute</span></span></span></dt><dd class="dd-description"> Attribute used more than once on an expression. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">55 <span class="machine"><span class="font-tt">inlining-impossible</span></span></span></dt><dd class="dd-description"> Inlining impossible. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">56 <span class="machine"><span class="font-tt">unreachable-case</span></span></span></dt><dd class="dd-description"> Unreachable case in a pattern-matching (based on type information). (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">57 <span class="machine"><span class="font-tt">ambiguous-var-in-pattern-guard</span></span> (see </span><a href="#ss%3Awarn57"><span class="font-bold">13.5.4</span></a><span class="font-bold">)</span></dt><dd class="dd-description"> Ambiguous or-pattern variables under guard. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">58 <span class="machine"><span class="font-tt">no-cmx-file</span></span></span></dt><dd class="dd-description"> Missing cmx file. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">59 <span class="machine"><span class="font-tt">flambda-assignment-to-non-mutable-value</span></span></span></dt><dd class="dd-description"> Assignment to non-mutable value. (since 4.03)
</dd><dt class="dt-description"><span class="font-bold">60 <span class="machine"><span class="font-tt">unused-module</span></span></span></dt><dd class="dd-description"> Unused module declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">61 <span class="machine"><span class="font-tt">unboxable-type-in-prim-decl</span></span></span></dt><dd class="dd-description"> Unboxable type in primitive declaration. (since 4.04)
</dd><dt class="dt-description"><span class="font-bold">62 <span class="machine"><span class="font-tt">constraint-on-gadt</span></span></span></dt><dd class="dd-description"> Type constraint on GADT type declaration. (since 4.06)
</dd><dt class="dt-description"><span class="font-bold">63 <span class="machine"><span class="font-tt">erroneous-printed-signature</span></span></span></dt><dd class="dd-description"> Erroneous printed signature. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">64 <span class="machine"><span class="font-tt">unsafe-array-syntax-without-parsing</span></span></span></dt><dd class="dd-description"> -unsafe used with a preprocessor returning a syntax tree. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">65 <span class="machine"><span class="font-tt">redefining-unit</span></span></span></dt><dd class="dd-description"> Type declaration defining a new â€™()â€™ constructor. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">66 <span class="machine"><span class="font-tt">unused-open-bang</span></span></span></dt><dd class="dd-description"> Unused open! statement. (since 4.08)
</dd><dt class="dt-description"><span class="font-bold">67 <span class="machine"><span class="font-tt">unused-functor-parameter</span></span></span></dt><dd class="dd-description"> Unused functor parameter. (since 4.10)
</dd><dt class="dt-description"><span class="font-bold">68 <span class="machine"><span class="font-tt">match-on-mutable-state-prevent-uncurry</span></span></span></dt><dd class="dd-description"> Pattern-matching depending on mutable state prevents the remaining 
arguments from being uncurried. (since 4.12)
</dd><dt class="dt-description"><span class="font-bold">69 <span class="machine"><span class="font-tt">unused-field</span></span></span></dt><dd class="dd-description"> Unused record field. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">70 <span class="machine"><span class="font-tt">missing-mli</span></span></span></dt><dd class="dd-description"> Missing interface file. (since 4.13)
</dd><dt class="dt-description"><span class="font-bold">71 <span class="machine"><span class="font-tt">unused-tmc-attribute</span></span></span></dt><dd class="dd-description"> Unused @tail_mod_cons attribute. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">72 <span class="machine"><span class="font-tt">tmc-breaks-tailcall</span></span></span></dt><dd class="dd-description"> A tail call is turned into a non-tail call by the @tail_mod_cons transformation. (since 4.14)
</dd><dt class="dt-description"><span class="font-bold">A</span></dt><dd class="dd-description"> all warnings
</dd><dt class="dt-description"><span class="font-bold">C</span></dt><dd class="dd-description"> warnings 1, 2.
</dd><dt class="dt-description"><span class="font-bold">D</span></dt><dd class="dd-description"> Alias for warning 3.
</dd><dt class="dt-description"><span class="font-bold">E</span></dt><dd class="dd-description"> Alias for warning 4.
</dd><dt class="dt-description"><span class="font-bold">F</span></dt><dd class="dd-description"> Alias for warning 5.
</dd><dt class="dt-description"><span class="font-bold">K</span></dt><dd class="dd-description"> warnings 32, 33, 34, 35, 36, 37, 38, 39.
</dd><dt class="dt-description"><span class="font-bold">L</span></dt><dd class="dd-description"> Alias for warning 6.
</dd><dt class="dt-description"><span class="font-bold">M</span></dt><dd class="dd-description"> Alias for warning 7.
</dd><dt class="dt-description"><span class="font-bold">P</span></dt><dd class="dd-description"> Alias for warning 8.
</dd><dt class="dt-description"><span class="font-bold">R</span></dt><dd class="dd-description"> Alias for warning 9.
</dd><dt class="dt-description"><span class="font-bold">S</span></dt><dd class="dd-description"> Alias for warning 10.
</dd><dt class="dt-description"><span class="font-bold">U</span></dt><dd class="dd-description"> warnings 11, 12.
</dd><dt class="dt-description"><span class="font-bold">V</span></dt><dd class="dd-description"> Alias for warning 13.
</dd><dt class="dt-description"><span class="font-bold">X</span></dt><dd class="dd-description"> warnings 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 30.
</dd><dt class="dt-description"><span class="font-bold">Y</span></dt><dd class="dd-description"> Alias for warning 26.
</dd><dt class="dt-description"><span class="font-bold">Z</span></dt><dd class="dd-description"> Alias for warning 27.

</dd></dl><p>The default setting is <span class="machine"><span class="font-tt">-w +a-4-6-7-9-27-29-32..42-44-45-48-50-60</span></span>.
It is displayed by <span class="machine"><span class="font-tt">ocamlopt -help</span></span>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-error</span></span> <span class="font-it">warning-list</span></span></dt><dd class="dd-description">
Mark as fatal the warnings specified in the argument <span class="font-it">warning-list</span>.
The compiler will stop with an error when one of these warnings is
emitted. The <span class="font-it">warning-list</span> has the same meaning as for
the <span class="machine"><span class="font-tt">-w</span></span> option: a <span class="machine"><span class="font-tt">+</span></span> sign (or an uppercase letter) marks the
corresponding warnings as fatal, a <span class="machine"><span class="font-tt">-</span></span>
sign (or a lowercase letter) turns them back into non-fatal warnings,
and a <span class="machine"><span class="font-tt">@</span></span> sign both enables and marks as fatal the corresponding
warnings.<p>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <span class="machine"><span class="font-tt">-warn-error</span></span>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</p><p>The default setting is <span class="machine"><span class="font-tt">-warn-error -a+31</span></span> (only warning 31 is fatal).</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-help</span></span></span></dt><dd class="dd-description">
Show the description of all available warning numbers.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-where</span></span></span></dt><dd class="dd-description">
Print the location of the standard library, then exit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-with-runtime</span></span></span></dt><dd class="dd-description">
Include the runtime system in the generated program. This is the default.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-without-runtime</span></span></span></dt><dd class="dd-description">
The compiler does not include the runtime system (nor a reference to it) in the
generated program; it must be supplied separately.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Process <span class="font-it">file</span> as a file name, even if it starts with a dash (<span class="machine"><span class="font-tt">-</span></span>)
character.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.</dd></dl>
<!--TOC paragraph id="sec363" Options for the 32-bit x86 architecture-->
<h5 class="paragraph" id="sec363"><a class="section-anchor" href="#sec363" aria-hidden="true">ï»¿</a>Options for the 32-bit x86 architecture</h5><!--SEC END --><p>
The 32-bit code generator for Intel/AMD x86 processors (<span class="machine"><span class="font-tt">i386</span></span>
architecture) supports the
following additional option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ffast-math</span></span></span></dt><dd class="dd-description"> Use the processor instructions to compute
trigonometric and exponential functions, instead of calling the
corresponding library routines. The functions affected are:
<span class="machine"><span class="font-tt">atan</span></span>, <span class="machine"><span class="font-tt">atan2</span></span>, <span class="machine"><span class="font-tt">cos</span></span>, <span class="machine"><span class="font-tt">log</span></span>, <span class="machine"><span class="font-tt">log10</span></span>, <span class="machine"><span class="font-tt">sin</span></span>, <span class="machine"><span class="font-tt">sqrt</span></span> and <span class="machine"><span class="font-tt">tan</span></span>.
The resulting code runs faster, but the range of supported arguments
and the precision of the result can be reduced. In particular,
trigonometric operations <span class="machine"><span class="font-tt">cos</span></span>, <span class="machine"><span class="font-tt">sin</span></span>, <span class="machine"><span class="font-tt">tan</span></span> have their range reduced to
[âˆ’2<sup>64</sup>, 2<sup>64</sup>].
</dd></dl>
<!--TOC paragraph id="sec364" Options for the 64-bit x86 architecture-->
<h5 class="paragraph" id="sec364"><a class="section-anchor" href="#sec364" aria-hidden="true">ï»¿</a>Options for the 64-bit x86 architecture</h5><!--SEC END --><p>
The 64-bit code generator for Intel/AMD x86 processors (<span class="machine"><span class="font-tt">amd64</span></span>
architecture) supports the following additional options:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-fPIC</span></span></span></dt><dd class="dd-description"> Generate position-independent machine code. This is
the default.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-fno-PIC</span></span></span></dt><dd class="dd-description"> Generate position-dependent machine code.
</dd></dl>
<!--TOC paragraph id="sec365" Options for the PowerPC architecture-->
<h5 class="paragraph" id="sec365"><a class="section-anchor" href="#sec365" aria-hidden="true">ï»¿</a>Options for the PowerPC architecture</h5><!--SEC END --><p>
The PowerPC code generator supports the following additional options:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-flarge-toc</span></span></span></dt><dd class="dd-description"> Enables the PowerPC large model allowing the TOC (table of
contents) to be arbitrarily large. This is the default since 4.11.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-fsmall-toc</span></span></span></dt><dd class="dd-description"> Enables the PowerPC small model allowing the TOC to be up
to 64 kbytes per compilation unit. Prior to 4.11 this was the default
behaviour.
</dd></dl>
<!--TOC paragraph id="sec366" Contextual control of command-line options-->
<h5 class="paragraph" id="sec366"><a class="section-anchor" href="#sec366" aria-hidden="true">ï»¿</a>Contextual control of command-line options</h5><!--SEC END --><p>The compiler command line can be modified â€œfrom the outsideâ€
with the following mechanisms. These are experimental
and subject to change. They should be used only for experimental and
development work, not in released packages.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLPARAM</span></span> </span>(environment variable)</dt><dd class="dd-description">
A set of arguments that will be inserted before or after the arguments from
the command line. Arguments are specified in a comma-separated list
of <span class="machine"><span class="font-tt">name=value</span></span> pairs. A <span class="machine"><span class="font-tt">_</span></span> is used to specify the position of
the command line arguments, i.e. <span class="machine"><span class="font-tt">a=x,_,b=y</span></span> means that <span class="machine"><span class="font-tt">a=x</span></span> should be
executed before parsing the arguments, and <span class="machine"><span class="font-tt">b=y</span></span> after. Finally,
an alternative separator can be specified as the
first character of the string, within the set <span class="machine"><span class="font-tt">:|; ,</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">ocaml_compiler_internal_params</span></span> </span>(file in the stdlib directory)</dt><dd class="dd-description">
A mapping of file names to lists of arguments that
will be added to the command line (and <span class="machine"><span class="font-tt">OCAMLPARAM</span></span>) arguments.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAML_FLEXLINK</span></span> </span>(environment variable)</dt><dd class="dd-description">
Alternative executable to use on native
Windows for <span class="machine"><span class="font-tt">flexlink</span></span> instead of the
configured value. Primarily used for bootstrapping.
</dd></dl>
<!--TOC section id="s:native-common-errors" 16.3â€ƒCommon errors-->
<h2 class="section" id="s:native-common-errors"><a class="section-anchor" href="#s:native-common-errors" aria-hidden="true">ï»¿</a>16.3â€ƒCommon errors</h2><!--SEC END --><p>The error messages are almost identical to those of <span class="machine"><span class="font-tt">ocamlc</span></span>.
See sectionÂ <a href="#s%3Acomp-errors">13.4</a>.</p>
<!--TOC section id="s:native:running-executable" 16.4â€ƒRunning executables produced by ocamlopt-->
<h2 class="section" id="s:native:running-executable"><a class="section-anchor" href="#s:native:running-executable" aria-hidden="true">ï»¿</a>16.4â€ƒRunning executables produced by ocamlopt</h2><!--SEC END --><p>Executables generated by <span class="machine"><span class="font-tt">ocamlopt</span></span> are native, stand-alone executable
files that can be invoked directly. They do
not depend on the <span class="machine"><span class="font-tt">ocamlrun</span></span> bytecode runtime system nor on
dynamically-loaded C/OCaml stub libraries.</p><p>During execution of an <span class="machine"><span class="font-tt">ocamlopt</span></span>-generated executable,
the following environment variables are also consulted:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span></span></dt><dd class="dd-description"> Same usage as in <span class="machine"><span class="font-tt">ocamlrun</span></span>
(see sectionÂ <a href="#s%3Aocamlrun-options">15.2</a>), except that option <span class="machine"><span class="font-tt">l</span></span>
is ignored (the operating systemâ€™s stack size limit
is used instead).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span></span></dt><dd class="dd-description"> If <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> is not found in the
environment, then <span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span> will be used instead. If
<span class="machine"><span class="font-tt">CAMLRUNPARAM</span></span> is not found, then the default values will be used.
</dd></dl>
<!--TOC section id="s:compat-native-bytecode" 16.5â€ƒCompatibility with the bytecode compiler-->
<h2 class="section" id="s:compat-native-bytecode"><a class="section-anchor" href="#s:compat-native-bytecode" aria-hidden="true">ï»¿</a>16.5â€ƒCompatibility with the bytecode compiler</h2><!--SEC END --><p>This section lists the known incompatibilities between the bytecode
compiler and the native-code compiler. Except on those points, the two
compilers should generate code that behave identically.</p><ul class="itemize"><li class="li-itemize">Signals are detected only when the program performs an
allocation in the heap. That is, if a signal is delivered while in a
piece of code that does not allocate, its handler will not be called
until the next heap allocation.</li><li class="li-itemize">On ARM and PowerPC processors (32 and 64 bits), fused
multiply-add (FMA) instructions can be generated for a
floating-point multiplication followed by a floating-point addition
or subtraction, as in <span class="machine"><span class="font-tt">x *. y +. z</span></span>. The FMA instruction avoids
rounding the intermediate result <span class="machine"><span class="font-tt">x *. y</span></span>, which is generally
beneficial, but produces floating-point results that differ slightly
from those produced by the bytecode interpreter.</li><li class="li-itemize">On Intel/AMD x86 processors in 32-bit mode,
some intermediate results in floating-point computations are
kept in extended precision rather than being rounded to double
precision like the bytecode compiler always does. Floating-point
results can therefore differ slightly between bytecode and native code.</li><li class="li-itemize">The native-code compiler performs a number of optimizations that
the bytecode compiler does not perform, especially when the Flambda
optimizer is active. In particular, the native-code compiler
identifies and eliminates â€œdead codeâ€, i.e. computations that do
not contribute to the results of the program. For example,
<pre>        let _ = ignore M.f
</pre>contains a reference to compilation unit <span class="machine"><span class="font-tt">M</span></span> when compiled to
bytecode. This reference forces <span class="machine"><span class="font-tt">M</span></span> to be linked and its
initialization code to be executed. The native-code compiler
eliminates the reference to <span class="machine"><span class="font-tt">M</span></span>, hence the compilation unit <span class="machine"><span class="font-tt">M</span></span> may
not be linked and executed. A workaround is to compile <span class="machine"><span class="font-tt">M</span></span> with the
<span class="machine"><span class="font-tt">-linkall</span></span> flag so that it will always be linked and executed, even if
not referenced. See also the <span class="machine"><span class="font-tt">Sys.opaque_identity</span></span> function from the
<span class="machine"><span class="font-tt">Sys</span></span> standard library module.</li><li class="li-itemize">Before 4.10, stack overflows, typically caused by excessively
deep recursion, are not always turned into a <span class="machine"><span class="font-tt">Stack_overflow</span></span>
exception like with the bytecode compiler. The runtime system makes
a best effort to trap stack overflows and raise the <span class="machine"><span class="font-tt">Stack_overflow</span></span>
exception, but sometimes it fails and a â€œsegmentation faultâ€ or
another system fault occurs instead.</li></ul>
<!--TOC chapter id="sec370" ChapterÂ 17â€ƒLexer and parser generators (ocamllex, ocamlyacc)-->
<h1 class="chapter" id="sec370">ChapterÂ 17â€ƒLexer and parser generators (ocamllex, ocamlyacc)</h1><!--SEC END --><p>
<a id="c:ocamlyacc"></a>
</p><!--NAME lexyacc.html-->
<p>This chapter describes two program generators: <span class="machine"><span class="font-tt">ocamllex</span></span>, that
produces a lexical analyzer from a set of regular expressions with
associated semantic actions, and <span class="machine"><span class="font-tt">ocamlyacc</span></span>, that produces a parser
from a grammar with associated semantic actions.</p><p>These program generators are very close to the well-known <span class="machine"><span class="font-tt">lex</span></span> and
<span class="machine"><span class="font-tt">yacc</span></span> commands that can be found in most C programming environments.
This chapter assumes a working knowledge of <span class="machine"><span class="font-tt">lex</span></span> and <span class="machine"><span class="font-tt">yacc</span></span>: while
it describes the input syntax for <span class="machine"><span class="font-tt">ocamllex</span></span> and <span class="machine"><span class="font-tt">ocamlyacc</span></span> and the
main differences with <span class="machine"><span class="font-tt">lex</span></span> and <span class="machine"><span class="font-tt">yacc</span></span>, it does not explain the basics
of writing a lexer or parser description in <span class="machine"><span class="font-tt">lex</span></span> and <span class="machine"><span class="font-tt">yacc</span></span>. Readers
unfamiliar with <span class="machine"><span class="font-tt">lex</span></span> and <span class="machine"><span class="font-tt">yacc</span></span> are referred to â€œCompilers:
principles, techniques, and toolsâ€ by Aho, Lam, Sethi and Ullman
(Pearson, 2006), or â€œLex &amp; Yaccâ€, by Levine, Mason and
Brown (Oâ€™Reilly, 1992).</p>
<!--TOC section id="s:ocamllex-overview" 17.1â€ƒOverview of <span class="font-tt">ocamllex</span>-->
<h2 class="section" id="s:ocamllex-overview"><a class="section-anchor" href="#s:ocamllex-overview" aria-hidden="true">ï»¿</a>17.1â€ƒOverview of <span class="font-tt">ocamllex</span></h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamllex</span></span> command produces a lexical analyzer from a set of regular
expressions with attached semantic actions, in the style of
<span class="machine"><span class="font-tt">lex</span></span>. Assuming the input file is <span class="font-it">lexer</span><span class="machine"><span class="font-tt">.mll</span></span>, executing
</p><pre>
        ocamllex <span class="font-it">lexer</span>.mll
</pre><p>
produces OCaml code for a lexical analyzer in file <span class="font-it">lexer</span><span class="machine"><span class="font-tt">.ml</span></span>.
This file defines one lexing function per entry point in the lexer
definition. These functions have the same names as the entry
points. Lexing functions take as argument a lexer buffer, and return
the semantic attribute of the corresponding entry point.</p><p>Lexer buffers are an abstract data type implemented in the standard
library module <span class="machine"><span class="font-tt">Lexing</span></span>. The functions <span class="machine"><span class="font-tt">Lexing.from_channel</span></span>,
<span class="machine"><span class="font-tt">Lexing.from_string</span></span> and <span class="machine"><span class="font-tt">Lexing.from_function</span></span> create
lexer buffers that read from an input channel, a character string, or
any reading function, respectively. (See the description of module
<span class="machine"><span class="font-tt">Lexing</span></span> in chapterÂ <a href="#c%3Astdlib">28</a>.)</p><p>When used in conjunction with a parser generated by <span class="machine"><span class="font-tt">ocamlyacc</span></span>, the
semantic actions compute a value belonging to the type <span class="machine"><span class="font-tt">token</span></span> defined
by the generated parsing module. (See the description of <span class="machine"><span class="font-tt">ocamlyacc</span></span>
below.)</p>
<!--TOC subsection id="ss:ocamllex-options" 17.1.1â€ƒOptions-->
<h3 class="subsection" id="ss:ocamllex-options"><a class="section-anchor" href="#ss:ocamllex-options" aria-hidden="true">ï»¿</a>17.1.1â€ƒOptions</h3><!--SEC END --><p>
The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamllex</span></span>.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ml</span></span></span></dt><dd class="dd-description">
Output code that does not use OCamlâ€™s built-in automata
interpreter. Instead, the automaton is encoded by OCaml functions.
This option improves performance when using the native compiler, but
decreases it when using the bytecode compiler.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">output-file</span></span></dt><dd class="dd-description">
Specify the name of the output file produced by <span class="machine"><span class="font-tt">ocamllex</span></span>.
The default is the input file name with its extension replaced by <span class="machine"><span class="font-tt">.ml</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-q</span></span></span></dt><dd class="dd-description">
Quiet mode. <span class="machine"><span class="font-tt">ocamllex</span></span> normally outputs informational messages
to standard output. They are suppressed if option <span class="machine"><span class="font-tt">-q</span></span> is used.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span> or <span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.
</dd></dl>
<!--TOC section id="s:ocamllex-syntax" 17.2â€ƒSyntax of lexer definitions-->
<h2 class="section" id="s:ocamllex-syntax"><a class="section-anchor" href="#s:ocamllex-syntax" aria-hidden="true">ï»¿</a>17.2â€ƒSyntax of lexer definitions</h2><!--SEC END --><p>The format of lexer definitions is as follows:
</p><pre>
{ <span class="font-it">header</span> }
let <span class="font-it">ident</span> = <span class="font-it">regexp</span> â€¦
[refill { <span class="font-it">refill-handler</span> }]
rule <span class="font-it">entrypoint</span> [<span class="font-it">arg</span><sub>1</sub>â€¦ <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>] =
  parse <span class="font-it">regexp</span> { <span class="font-it">action</span> }
      | â€¦
      | <span class="font-it">regexp</span> { <span class="font-it">action</span> }
and <span class="font-it">entrypoint</span> [<span class="font-it">arg</span><sub>1</sub>â€¦ <span class="font-it">arg</span><sub><span class="font-it">n</span></sub>] =
  parse â€¦
and â€¦
{ <span class="font-it">trailer</span> }
</pre><p>
Comments are delimited by <span class="machine"><span class="font-tt">(*</span></span> and <span class="machine"><span class="font-tt">*)</span></span>, as in OCaml.
The <span class="machine"><span class="font-tt">parse</span></span> keyword, can be replaced by the <span class="machine"><span class="font-tt">shortest</span></span> keyword, with
the semantic consequences explained below.</p><p>Refill handlers are a recent (optional) feature introduced in 4.02,
documented below in subsectionÂ <a href="#ss%3Arefill-handlers">17.2.7</a>.</p>
<!--TOC subsection id="ss:ocamllex-header-trailer" 17.2.1â€ƒHeader and trailer-->
<h3 class="subsection" id="ss:ocamllex-header-trailer"><a class="section-anchor" href="#ss:ocamllex-header-trailer" aria-hidden="true">ï»¿</a>17.2.1â€ƒHeader and trailer</h3><!--SEC END --><p>
The <span class="font-it">header</span> and <span class="font-it">trailer</span> sections are arbitrary OCaml
text enclosed in curly braces. Either or both can be omitted. If
present, the header text is copied as is at the beginning of the
output file and the trailer text at the end. Typically, the
header section contains the <span class="machine"><span class="font-tt">open</span></span> directives required
by the actions, and possibly some auxiliary functions used in the
actions.</p>
<!--TOC subsection id="ss:ocamllex-named-regexp" 17.2.2â€ƒNaming regular expressions-->
<h3 class="subsection" id="ss:ocamllex-named-regexp"><a class="section-anchor" href="#ss:ocamllex-named-regexp" aria-hidden="true">ï»¿</a>17.2.2â€ƒNaming regular expressions</h3><!--SEC END --><p>Between the header and the entry points, one can give names to
frequently-occurring regular expressions. This is written
<span class="syntax-token">let</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a>.
In regular expressions that follow this declaration, the identifier
<span class="font-it">ident</span> can be used as shorthand for <span class="font-it">regexp</span>.</p>
<!--TOC subsection id="ss:ocamllex-entry-points" 17.2.3â€ƒEntry points-->
<h3 class="subsection" id="ss:ocamllex-entry-points"><a class="section-anchor" href="#ss:ocamllex-entry-points" aria-hidden="true">ï»¿</a>17.2.3â€ƒEntry points</h3><!--SEC END --><p>The names of the entry points must be valid identifiers for OCaml
values (starting with a lowercase letter).
Similarly, the arguments <span class="font-tt"><span class="font-it">arg</span></span><sub>1</sub><span class="font-tt">â€¦
<span class="font-it">arg</span></span><sub><span class="font-it">n</span></sub> must be valid identifiers for OCaml.
Each entry point becomes an
OCaml function that takes <span class="font-it">n</span>+1 arguments,
the extra implicit last argument being of type <span class="machine"><span class="font-tt">Lexing.lexbuf</span></span>.
Characters are read from the <span class="machine"><span class="font-tt">Lexing.lexbuf</span></span> argument and matched
against the regular expressions provided in the rule, until a prefix
of the input matches one of the rule. The corresponding action is
then evaluated and returned as the result of the function.</p><p>If several regular expressions match a prefix of the input, the
â€œlongest matchâ€ rule applies: the regular expression that matches
the longest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is selected.</p><p>However, if lexer rules are introduced with the <span class="machine"><span class="font-tt">shortest</span></span> keyword in
place of the <span class="machine"><span class="font-tt">parse</span></span> keyword, then the â€œshortest matchâ€ rule applies:
the shortest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is still selected.
This feature is not intended for use in ordinary lexical analyzers, it
may facilitate the use of <span class="machine"><span class="font-tt">ocamllex</span></span> as a simple text processing tool.</p>
<!--TOC subsection id="ss:ocamllex-regexp" 17.2.4â€ƒRegular expressions-->
<h3 class="subsection" id="ss:ocamllex-regexp"><a class="section-anchor" href="#ss:ocamllex-regexp" aria-hidden="true">ï»¿</a>17.2.4â€ƒRegular expressions</h3><!--SEC END --><p>The regular expressions are in the style of <span class="machine"><span class="font-tt">lex</span></span>, with a more
OCaml-like syntax.
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="regexp"><span class="nonterminal">regexp</span></a></td><td class="c005">::=</td><td class="c007">
â€¦
</td></tr>
</table></td></tr>
</table></div><dl class="description"><dt class="dt-description"><span class="syntax-token">'</span> <span class="nonterminal">regular-char</span> âˆ£ <a class="syntax" href="#escape-sequence"><span class="nonterminal">escape-sequence</span></a> <span class="syntax-token">'</span></dt><dd class="dd-description">
A character constant, with the same syntax as OCaml character
constants. Match the denoted character.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">_</span></span></span></dt><dd class="dd-description">
(underscore) Match any character.</dd><dt class="dt-description"><span class="syntax-token">eof</span></dt><dd class="dd-description">
Match the end of the lexer input.<br>
<span class="font-bold">Note:</span> On some systems, with interactive input, an end-of-file
may be followed by more characters. However, <span class="machine"><span class="font-tt">ocamllex</span></span> will not
correctly handle regular expressions that contain <span class="machine"><span class="font-tt">eof</span></span> followed by
something else.</dd><dt class="dt-description"><span class="syntax-token">"</span> { <a class="syntax" href="#string-character"><span class="nonterminal">string-character</span></a> } <span class="syntax-token">"</span></dt><dd class="dd-description">
A string constant, with the same syntax as OCaml string
constants. Match the corresponding sequence of characters.</dd><dt class="dt-description"><span class="syntax-token">[</span> <span class="nonterminal">character-set</span> <span class="syntax-token">]</span></dt><dd class="dd-description">
Match any single character belonging to the given
character set. Valid character sets are: single
character constants <span class="syntax-token">'</span> <span class="nonterminal">c</span> <span class="syntax-token">'</span>; ranges of characters
<span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>1</sub> <span class="syntax-token">'</span> <span class="syntax-token">-</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>2</sub> <span class="syntax-token">'</span> (all characters between <span class="font-it">c</span><sub>1</sub> and <span class="font-it">c</span><sub>2</sub>,
inclusive); and the union of two or more character sets, denoted by
concatenation.</dd><dt class="dt-description"><span class="syntax-token">[</span> <span class="syntax-token">^</span> <span class="nonterminal">character-set</span> <span class="syntax-token">]</span></dt><dd class="dd-description">
Match any single character not belonging to the given character set.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> <span class="syntax-token">#</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub></dt><dd class="dd-description">
(difference of character sets)
Regular expressions <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> and <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub> must be character sets
defined with <span class="syntax-token">[</span>â€¦ <span class="syntax-token">]</span> (or a single character expression or
underscore <span class="machine"><span class="font-tt">_</span></span>).
Match the difference of the two specified character sets.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">*</span></dt><dd class="dd-description">
(repetition) Match the concatenation of zero or more
strings that match <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a>.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">+</span></dt><dd class="dd-description">
(strict repetition) Match the concatenation of one or more
strings that match <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a>.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">?</span></dt><dd class="dd-description">
(option) Match the empty string, or a string matching <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a>.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub></dt><dd class="dd-description">
(alternative) Match any string that matches <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> or <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub></dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub></dt><dd class="dd-description">
(concatenation) Match the concatenation of two strings, the first
matching <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub>, the second matching <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub>.</dd><dt class="dt-description"><span class="syntax-token">(</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">)</span></dt><dd class="dd-description">
Match the same strings as <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a>.</dd><dt class="dt-description"><a class="syntax" href="#ident"><span class="nonterminal">ident</span></a></dt><dd class="dd-description">
Reference the regular expression bound to <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> by an earlier
<span class="syntax-token">let</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> definition.</dd><dt class="dt-description"><a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">as</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a></dt><dd class="dd-description">
Bind the substring matched by <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> to identifier <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>.
</dd></dl><p>Concerning the precedences of operators, <span class="machine"><span class="font-tt">#</span></span> has the highest precedence,
followed by <span class="machine"><span class="font-tt">*</span></span>, <span class="machine"><span class="font-tt">+</span></span> and <span class="machine"><span class="font-tt">?</span></span>,
then concatenation, then <span class="machine"><span class="font-tt">|</span></span> (alternation), then <span class="machine"><span class="font-tt">as</span></span>.</p>
<!--TOC subsection id="ss:ocamllex-actions" 17.2.5â€ƒActions-->
<h3 class="subsection" id="ss:ocamllex-actions"><a class="section-anchor" href="#ss:ocamllex-actions" aria-hidden="true">ï»¿</a>17.2.5â€ƒActions</h3><!--SEC END --><p>The actions are arbitrary OCaml expressions. They are evaluated in
a context where the identifiers defined by using the <span class="machine"><span class="font-tt">as</span></span> construct
are bound to subparts of the matched string.
Additionally, <span class="machine"><span class="font-tt">lexbuf</span></span> is bound to the current lexer
buffer. Some typical uses for <span class="machine"><span class="font-tt">lexbuf</span></span>, in conjunction with the
operations on lexer buffers provided by the <span class="machine"><span class="font-tt">Lexing</span></span> standard library
module, are listed below.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Lexing.lexeme lexbuf</span></span></span></dt><dd class="dd-description">
Return the matched string.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Lexing.lexeme_char lexbuf </span></span></span><span class="font-it">n</span></dt><dd class="dd-description">
Return the <span class="font-it">n</span><sup><span class="th">th</span></sup>
character in the matched string. The first character corresponds to <span class="font-it">n</span> = 0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Lexing.lexeme_start lexbuf</span></span></span></dt><dd class="dd-description">
Return the absolute position in the input text of the beginning of the
matched string (i.e. the offset of the first character of the matched
string). The first character read from the input text has offset 0.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">Lexing.lexeme_end lexbuf</span></span></span></dt><dd class="dd-description">
Return the absolute position in the input text of the end of the
matched string (i.e. the offset of the first character after the
matched string). The first character read from the input text has
offset 0.</dd><dt class="dt-description"><span class="font-bold"><span class="font-it">entrypoint</span> [<span class="font-it">exp</span></span><sub>1</sub><span class="font-bold">â€¦ <span class="font-it">exp</span></span><sub><span class="font-it">n</span></sub><span class="font-bold">] <span class="machine"><span class="font-tt">lexbuf</span></span></span></dt><dd class="dd-description">
(Where <span class="font-it">entrypoint</span> is the name of another entry point in the same
lexer definition.) Recursively call the lexer on the given entry point.
Notice that <span class="machine"><span class="font-tt">lexbuf</span></span> is the last argument.
Useful for lexing nested comments, for example.</dd></dl>
<!--TOC subsection id="ss:ocamllex-variables" 17.2.6â€ƒVariables in regular expressions-->
<h3 class="subsection" id="ss:ocamllex-variables"><a class="section-anchor" href="#ss:ocamllex-variables" aria-hidden="true">ï»¿</a>17.2.6â€ƒVariables in regular expressions</h3><!--SEC END --><p>
The <span class="machine"><span class="font-tt">as</span></span> construct is similar to â€œ<em>groups</em>â€ as provided by
numerous regular expression packages.
The type of these variables can be <span class="machine"><span class="font-tt">string</span></span>, <span class="machine"><span class="font-tt">char</span></span>, <span class="machine"><span class="font-tt">string option</span></span>
or <span class="machine"><span class="font-tt">char option</span></span>.</p><p>We first consider the case of linear patterns, that is the case when
all <span class="machine"><span class="font-tt">as</span></span> bound variables are distinct.
In <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">as</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a>, the type of <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> normally is <span class="machine"><span class="font-tt">string</span></span> (or
<span class="machine"><span class="font-tt">string option</span></span>) except
when <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> is a character constant, an underscore, a string
constant of length one, a character set specification, or an
alternation of those. Then, the type of <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> is <span class="machine"><span class="font-tt">char</span></span> (or <span class="machine"><span class="font-tt">char option</span></span>).
Option types are introduced when overall rule matching does not
imply matching of the bound sub-pattern. This is in particular the
case of <span class="syntax-token">(</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a> <span class="syntax-token">as</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">)</span> <span class="syntax-token">?</span> and of
<a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>1</sub> <span class="syntax-token">|</span> <span class="syntax-token">(</span> <a class="syntax" href="#regexp"><span class="nonterminal">regexp</span></a><sub>2</sub> <span class="syntax-token">as</span> <a class="syntax" href="#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">)</span>.</p><p>There is no linearity restriction over <span class="machine"><span class="font-tt">as</span></span> bound variables.
When a variable is bound more than once, the previous rules are to be
extended as follows:
</p><ul class="itemize"><li class="li-itemize">A variable is a <span class="machine"><span class="font-tt">char</span></span> variable when all its occurrences bind
<span class="machine"><span class="font-tt">char</span></span> occurrences in the previous sense.
</li><li class="li-itemize">A variable is an <span class="machine"><span class="font-tt">option</span></span> variable when the overall expression
can be matched without binding this variable.
</li></ul><p>
For instance, in
<span class="machine"><span class="font-tt">('a' as x) | ( 'a' (_ as x) )</span></span> the variable <span class="machine"><span class="font-tt">x</span></span> is of type
<span class="machine"><span class="font-tt">char</span></span>, whereas in
<span class="machine"><span class="font-tt">("ab" as x) | ( 'a' (_ as x) ? )</span></span> the variable <span class="machine"><span class="font-tt">x</span></span> is of type
<span class="machine"><span class="font-tt">string option</span></span>.</p><p>In some cases, a successful match may not yield a unique set of bindings.
For instance the matching of <code class="verb">aba</code> by the regular expression
<span class="machine"><span class="font-tt">(('a'|"ab") as x) (("ba"|'a') as y)</span></span> may result in binding
either
<code class="verb">x</code> to <code class="verb">"ab"</code> and <code class="verb">y</code> to <code class="verb">"a"</code>, or
<code class="verb">x</code> to <code class="verb">"a"</code> and <code class="verb">y</code> to <code class="verb">"ba"</code>.
The automata produced <span class="machine"><span class="font-tt">ocamllex</span></span> on such ambiguous regular
expressions will select one of the possible resulting sets of
bindings.
The selected set of bindings is purposely left unspecified.</p>
<!--TOC subsection id="ss:refill-handlers" 17.2.7â€ƒRefill handlers-->
<h3 class="subsection" id="ss:refill-handlers"><a class="section-anchor" href="#ss:refill-handlers" aria-hidden="true">ï»¿</a>17.2.7â€ƒRefill handlers</h3><!--SEC END --><p>By default, when ocamllex reaches the end of its lexing buffer, it
will silently call the <span class="machine"><span class="font-tt">refill_buff</span></span> function of <span class="machine"><span class="font-tt">lexbuf</span></span> structure
and continue lexing. It is sometimes useful to be able to take control
of refilling action; typically, if you use a library for asynchronous
computation, you may want to wrap the refilling action in a delaying
function to avoid blocking synchronous operations.</p><p>Since OCaml 4.02, it is possible to specify a <span class="font-it">refill-handler</span>,
a function that will be called when refill happens. It is passed the
continuation of the lexing, on which it has total control. The OCaml
expression used as refill action should have a type that is an
instance of
</p><pre>   (Lexing.lexbuf -&gt; 'a) -&gt; Lexing.lexbuf -&gt; 'a
</pre><p>where the first argument is the continuation which captures the
processing ocamllex would usually perform (refilling the buffer, then
calling the lexing function again), and the result type that
instantiates [â€™a] should unify with the result type of all lexing
rules.</p><p>As an example, consider the following lexer that is parametrized over
an arbitrary monad:
</p><pre>{
type token = EOL | INT of int | PLUS

module Make (M : sig
               type 'a t
               val return: 'a -&gt; 'a t
               val bind: 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t
               val fail : string -&gt; 'a t

               (* Set up lexbuf *)
               val on_refill : Lexing.lexbuf -&gt; unit t
             end)
= struct

let refill_handler k lexbuf =
    M.bind (M.on_refill lexbuf) (fun () -&gt; k lexbuf)

}

refill {refill_handler}

rule token = parse
| [' ' '\t']
    { token lexbuf }
| '\n'
    { M.return EOL }
| ['0'-'9']+ as i
    { M.return (INT (int_of_string i)) }
| '+'
    { M.return PLUS }
| _
    { M.fail "unexpected character" }
{
end
}
</pre>
<!--TOC subsection id="ss:ocamllex-reserved-ident" 17.2.8â€ƒReserved identifiers-->
<h3 class="subsection" id="ss:ocamllex-reserved-ident"><a class="section-anchor" href="#ss:ocamllex-reserved-ident" aria-hidden="true">ï»¿</a>17.2.8â€ƒReserved identifiers</h3><!--SEC END --><p>All identifiers starting with <span class="machine"><span class="font-tt">__ocaml_lex</span></span> are reserved for use by
<span class="machine"><span class="font-tt">ocamllex</span></span>; do not use any such identifier in your programs.</p>
<!--TOC section id="s:ocamlyacc-overview" 17.3â€ƒOverview of <span class="font-tt">ocamlyacc</span>-->
<h2 class="section" id="s:ocamlyacc-overview"><a class="section-anchor" href="#s:ocamlyacc-overview" aria-hidden="true">ï»¿</a>17.3â€ƒOverview of <span class="font-tt">ocamlyacc</span></h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlyacc</span></span> command produces a parser from a context-free grammar
specification with attached semantic actions, in the style of <span class="machine"><span class="font-tt">yacc</span></span>.
Assuming the input file is <span class="font-it">grammar</span><span class="machine"><span class="font-tt">.mly</span></span>, executing
</p><pre>
        ocamlyacc <span class="font-it">options</span> <span class="font-it">grammar</span>.mly
</pre><p>
produces OCaml code for a parser in the file <span class="font-it">grammar</span><span class="machine"><span class="font-tt">.ml</span></span>,
and its interface in file <span class="font-it">grammar</span><span class="machine"><span class="font-tt">.mli</span></span>.</p><p>The generated module defines one parsing function per entry point in
the grammar. These functions have the same names as the entry points.
Parsing functions take as arguments a lexical analyzer (a function
from lexer buffers to tokens) and a lexer buffer, and return the
semantic attribute of the corresponding entry point. Lexical analyzer
functions are usually generated from a lexer specification by the
<span class="machine"><span class="font-tt">ocamllex</span></span> program. Lexer buffers are an abstract data type
implemented in the standard library module <span class="machine"><span class="font-tt">Lexing</span></span>. Tokens are values from
the concrete type <span class="machine"><span class="font-tt">token</span></span>, defined in the interface file
<span class="font-it">grammar</span><span class="machine"><span class="font-tt">.mli</span></span> produced by <span class="machine"><span class="font-tt">ocamlyacc</span></span>.</p>
<!--TOC section id="s:ocamlyacc-syntax" 17.4â€ƒSyntax of grammar definitions-->
<h2 class="section" id="s:ocamlyacc-syntax"><a class="section-anchor" href="#s:ocamlyacc-syntax" aria-hidden="true">ï»¿</a>17.4â€ƒSyntax of grammar definitions</h2><!--SEC END --><p>Grammar definitions have the following format:
</p><pre>
%{
  <span class="font-it">header</span>
%}
  <span class="font-it">declarations</span>
%%
  <span class="font-it">rules</span>
%%
  <span class="font-it">trailer</span>
</pre><p>Comments are enclosed between <code class="verb">/*</code> and <code class="verb">*/</code> (as in C) in the
â€œdeclarationsâ€ and â€œrulesâ€ sections, and between <code class="verb">(*</code> and
<code class="verb">*)</code> (as in OCaml) in the â€œheaderâ€ and â€œtrailerâ€ sections.</p>
<!--TOC subsection id="ss:ocamlyacc-header-trailer" 17.4.1â€ƒHeader and trailer-->
<h3 class="subsection" id="ss:ocamlyacc-header-trailer"><a class="section-anchor" href="#ss:ocamlyacc-header-trailer" aria-hidden="true">ï»¿</a>17.4.1â€ƒHeader and trailer</h3><!--SEC END --><p>The header and the trailer sections are OCaml code that is copied
as is into file <span class="font-it">grammar</span><span class="machine"><span class="font-tt">.ml</span></span>. Both sections are optional. The header
goes at the beginning of the output file; it usually contains
<span class="machine"><span class="font-tt">open</span></span> directives and auxiliary functions required by the semantic
actions of the rules. The trailer goes at the end of the output file.</p>
<!--TOC subsection id="ss:ocamlyacc-declarations" 17.4.2â€ƒDeclarations-->
<h3 class="subsection" id="ss:ocamlyacc-declarations"><a class="section-anchor" href="#ss:ocamlyacc-declarations" aria-hidden="true">ï»¿</a>17.4.2â€ƒDeclarations</h3><!--SEC END --><p>Declarations are given one per line. They all start with a <code class="verb">%</code> sign.</p><dl class="description"><dt class="dt-description"><span class="syntax-token">%token</span> <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> â€¦ <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a></dt><dd class="dd-description">
Declare the given symbols <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> â€¦ <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a>
as tokens (terminal symbols). These symbols
are added as constant constructors for the <span class="machine"><span class="font-tt">token</span></span> concrete type.</dd><dt class="dt-description"><span class="syntax-token">%token</span> <span class="syntax-token">&lt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">&gt;</span> <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> â€¦ <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a></dt><dd class="dd-description">
Declare the given symbols <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> â€¦ <a class="syntax" href="#constr"><span class="nonterminal">constr</span></a> as tokens with an
attached attribute of the
given type. These symbols are added as constructors with arguments of
the given type for the <span class="machine"><span class="font-tt">token</span></span> concrete type. The <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> part is
an arbitrary OCaml type expression, except that all type
constructor names must be fully qualified (e.g. <span class="machine"><span class="font-tt">Modname.typename</span></span>)
for all types except standard built-in types, even if the proper
<code class="verb">open</code> directives (e.g. <code class="verb">open Modname</code>) were given in the
header section. Thatâ€™s because the header is copied only to the <span class="machine"><span class="font-tt">.ml</span></span>
output file, but not to the <span class="machine"><span class="font-tt">.mli</span></span> output file, while the <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> part
of a <code class="verb">%token</code> declaration is copied to both.</dd><dt class="dt-description"><span class="syntax-token">%start</span> <span class="nonterminal">symbol</span> â€¦ <span class="nonterminal">symbol</span></dt><dd class="dd-description">
Declare the given symbols as entry points for the grammar. For each
entry point, a parsing function with the same name is defined in the
output module. Non-terminals that are not declared as entry points
have no such parsing function. Start symbols must be given a type with
the <code class="verb">%type</code> directive below.</dd><dt class="dt-description"><span class="syntax-token">%type</span> <span class="syntax-token">&lt;</span> <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">&gt;</span> <span class="nonterminal">symbol</span> â€¦ <span class="nonterminal">symbol</span></dt><dd class="dd-description">
Specify the type of the semantic attributes for the given symbols.
This is mandatory for start symbols only. Other nonterminal symbols
need not be given types by hand: these types will be inferred when
running the output files through the OCaml compiler (unless the
<code class="verb">-s</code> option is in effect). The <a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a> part is an arbitrary OCaml
type expression, except that all type constructor names must be
fully qualified, as explained above for <span class="machine"><span class="font-tt">%token</span></span>.</dd><dt class="dt-description"><span class="syntax-token">%left</span> <span class="nonterminal">symbol</span> â€¦ <span class="nonterminal">symbol</span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="syntax-token">%right</span> <span class="nonterminal">symbol</span> â€¦ <span class="nonterminal">symbol</span></dt><dd class="dd-description">
</dd><dt class="dt-description"><span class="syntax-token">%nonassoc</span> <span class="nonterminal">symbol</span> â€¦ <span class="nonterminal">symbol</span></dt><dd class="dd-description"><p>Associate precedences and associativities to the given symbols. All
symbols on the same line are given the same precedence. They have
higher precedence than symbols declared before in a <code class="verb">%left</code>,
<code class="verb">%right</code> or <code class="verb">%nonassoc</code> line. They have lower precedence
than symbols declared after in a <code class="verb">%left</code>, <code class="verb">%right</code> or
<code class="verb">%nonassoc</code> line. The symbols are declared to associate to the
left (<code class="verb">%left</code>), to the right (<code class="verb">%right</code>), or to be
non-associative (<code class="verb">%nonassoc</code>). The symbols are usually tokens.
They can also be dummy nonterminals, for use with the <code class="verb">%prec</code>
directive inside the rules.</p><p>The precedence declarations are used in the following way to
resolve reduce/reduce and shift/reduce conflicts:
</p><ul class="itemize"><li class="li-itemize">Tokens and rules have precedences. By default, the precedence
of a rule is the precedence of its rightmost terminal. You
can override this default by using the <span class="syntax-token">%prec</span> directive in the rule.
</li><li class="li-itemize">A reduce/reduce conflict
is resolved in favor of the first rule (in the order given by the
source file), and <span class="machine"><span class="font-tt">ocamlyacc</span></span> outputs a warning.
</li><li class="li-itemize">A shift/reduce conflict
is resolved by comparing the precedence of the rule to be
reduced with the precedence of the token to be shifted. If the
precedence of the rule is higher, then the rule will be reduced;
if the precedence of the token is higher, then the token will
be shifted.
</li><li class="li-itemize">A shift/reduce conflict between a rule and a token with the
same precedence will be resolved using the associativity: if the
token is left-associative, then the parser will reduce; if the
token is right-associative, then the parser will shift. If the
token is non-associative, then the parser will declare a syntax
error.
</li><li class="li-itemize">When a shift/reduce conflict cannot be resolved using the above
method, then <span class="machine"><span class="font-tt">ocamlyacc</span></span> will output a warning and the parser will
always shift.
</li></ul></dd></dl>
<!--TOC subsection id="ss:ocamlyacc-rules" 17.4.3â€ƒRules-->
<h3 class="subsection" id="ss:ocamlyacc-rules"><a class="section-anchor" href="#ss:ocamlyacc-rules" aria-hidden="true">ï»¿</a>17.4.3â€ƒRules</h3><!--SEC END --><p>The syntax for rules is as usual:
</p><pre>
<span class="font-it">nonterminal</span> :
    <span class="font-it">symbol</span> â€¦ <span class="font-it">symbol</span> { <span class="font-it">semantic-action</span> }
  | â€¦
  | <span class="font-it">symbol</span> â€¦ <span class="font-it">symbol</span> { <span class="font-it">semantic-action</span> }
;
</pre><p>
Rules can also contain the <code class="verb">%prec </code><span class="font-it">symbol</span> directive in the
right-hand side part, to override the default precedence and
associativity of the rule with the precedence and associativity of the
given symbol.</p><p>Semantic actions are arbitrary OCaml expressions, that
are evaluated to produce the semantic attribute attached to
the defined nonterminal. The semantic actions can access the
semantic attributes of the symbols in the right-hand side of
the rule with the <code class="verb">$</code> notation: <code class="verb">$1</code> is the attribute for the
first (leftmost) symbol, <code class="verb">$2</code> is the attribute for the second
symbol, etc.</p><p>The rules may contain the special symbol <span class="machine"><span class="font-tt">error</span></span> to indicate
resynchronization points, as in <span class="machine"><span class="font-tt">yacc</span></span>.</p><p>Actions occurring in the middle of rules are not supported.</p><p>Nonterminal symbols are like regular OCaml symbols, except that they
cannot end with <span class="machine"><span class="font-tt">'</span></span> (single quote).</p>
<!--TOC subsection id="ss:ocamlyacc-error-handling" 17.4.4â€ƒError handling-->
<h3 class="subsection" id="ss:ocamlyacc-error-handling"><a class="section-anchor" href="#ss:ocamlyacc-error-handling" aria-hidden="true">ï»¿</a>17.4.4â€ƒError handling</h3><!--SEC END --><p>Error recovery is supported as follows: when the parser reaches an
error state (no grammar rules can apply), it calls a function named
<span class="machine"><span class="font-tt">parse_error</span></span> with the string <span class="machine"><span class="font-tt">"syntax error"</span></span> as argument. The default
<span class="machine"><span class="font-tt">parse_error</span></span> function does nothing and returns, thus initiating error
recovery (see below). The user can define a customized <span class="machine"><span class="font-tt">parse_error</span></span>
function in the header section of the grammar file.</p><p>The parser also enters error recovery mode if one of the grammar
actions raises the <span class="machine"><span class="font-tt">Parsing.Parse_error</span></span> exception.</p><p>In error recovery mode, the parser discards states from the
stack until it reaches a place where the error token can be shifted.
It then discards tokens from the input until it finds three successive
tokens that can be accepted, and starts processing with the first of
these. If no state can be uncovered where the error token can be
shifted, then the parser aborts by raising the <span class="machine"><span class="font-tt">Parsing.Parse_error</span></span>
exception.</p><p>Refer to documentation on <span class="machine"><span class="font-tt">yacc</span></span> for more details and guidance in how
to use error recovery.</p>
<!--TOC section id="s:ocamlyacc-options" 17.5â€ƒOptions-->
<h2 class="section" id="s:ocamlyacc-options"><a class="section-anchor" href="#s:ocamlyacc-options" aria-hidden="true">ï»¿</a>17.5â€ƒOptions</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlyacc</span></span> command recognizes the following options:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-b</span></span><span class="font-it">prefix</span></span></dt><dd class="dd-description">
Name the output files <span class="font-it">prefix</span><span class="machine"><span class="font-tt">.ml</span></span>, <span class="font-it">prefix</span><span class="machine"><span class="font-tt">.mli</span></span>,
<span class="font-it">prefix</span><span class="machine"><span class="font-tt">.output</span></span>, instead of the default naming convention.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-q</span></span></span></dt><dd class="dd-description">
This option has no effect.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Generate a description of the parsing tables and a report on conflicts
resulting from ambiguities in the grammar. The description is put in
file <span class="font-it">grammar</span><span class="machine"><span class="font-tt">.output</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-</span></span></span></dt><dd class="dd-description">
Read the grammar specification from standard input. The default
output file names are <span class="machine"><span class="font-tt">stdin.ml</span></span> and <span class="machine"><span class="font-tt">stdin.mli</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">--</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Process <span class="font-it">file</span> as the grammar specification, even if its name
starts with a dash (-) character. This option must be the last on the
command line.</dd></dl><p>At run-time, the <span class="machine"><span class="font-tt">ocamlyacc</span></span>-generated parser can be debugged by
setting the <span class="machine"><span class="font-tt">p</span></span> option in the <span class="machine"><span class="font-tt">OCAMLRUNPARAM</span></span> environment variable
(see sectionÂ <a href="#s%3Aocamlrun-options">15.2</a>). This causes the pushdown
automaton executing the parser to print a trace of its action (tokens
shifted, rules reduced, etc). The trace mentions rule numbers and
state numbers that can be interpreted by looking at the file
<span class="font-it">grammar</span><span class="machine"><span class="font-tt">.output</span></span> generated by <span class="machine"><span class="font-tt">ocamlyacc -v</span></span>.</p>
<!--TOC section id="s:lexyacc-example" 17.6â€ƒA complete example-->
<h2 class="section" id="s:lexyacc-example"><a class="section-anchor" href="#s:lexyacc-example" aria-hidden="true">ï»¿</a>17.6â€ƒA complete example</h2><!--SEC END --><p>The all-time favorite: a desk calculator. This program reads
arithmetic expressions on standard input, one per line, and prints
their values. Here is the grammar definition:
</p><pre>        /* File parser.mly */
        %token &lt;int&gt; INT
        %token PLUS MINUS TIMES DIV
        %token LPAREN RPAREN
        %token EOL
        %left PLUS MINUS        /* lowest precedence */
        %left TIMES DIV         /* medium precedence */
        %nonassoc UMINUS        /* highest precedence */
        %start main             /* the entry point */
        %type &lt;int&gt; main
        %%
        main:
            expr EOL                { $1 }
        ;
        expr:
            INT                     { $1 }
          | LPAREN expr RPAREN      { $2 }
          | expr PLUS expr          { $1 + $3 }
          | expr MINUS expr         { $1 - $3 }
          | expr TIMES expr         { $1 * $3 }
          | expr DIV expr           { $1 / $3 }
          | MINUS expr %prec UMINUS { - $2 }
        ;
</pre><p>Here is the definition for the corresponding lexer:
</p><pre>        (* File lexer.mll *)
        {
        open Parser        (* The type token is defined in parser.mli *)
        exception Eof
        }
        rule token = parse
            [' ' '\t']     { token lexbuf }     (* skip blanks *)
          | ['\n' ]        { EOL }
          | ['0'-'9']+ as lxm { INT(int_of_string lxm) }
          | '+'            { PLUS }
          | '-'            { MINUS }
          | '*'            { TIMES }
          | '/'            { DIV }
          | '('            { LPAREN }
          | ')'            { RPAREN }
          | eof            { raise Eof }
</pre><p>Here is the main program, that combines the parser with the lexer:
</p><pre>        (* File calc.ml *)
        let _ =
          try
            let lexbuf = Lexing.from_channel stdin in
            while true do
              let result = Parser.main Lexer.token lexbuf in
                print_int result; print_newline(); flush stdout
            done
          with Lexer.Eof -&gt;
            exit 0
</pre><p>To compile everything, execute:
</p><pre>        ocamllex lexer.mll       # generates lexer.ml
        ocamlyacc parser.mly     # generates parser.ml and parser.mli
        ocamlc -c parser.mli
        ocamlc -c lexer.ml
        ocamlc -c parser.ml
        ocamlc -c calc.ml
        ocamlc -o calc lexer.cmo parser.cmo calc.cmo
</pre>
<!--TOC section id="s:lexyacc-common-errors" 17.7â€ƒCommon errors-->
<h2 class="section" id="s:lexyacc-common-errors"><a class="section-anchor" href="#s:lexyacc-common-errors" aria-hidden="true">ï»¿</a>17.7â€ƒCommon errors</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold">ocamllex: transition table overflow, automaton is too big</span></dt><dd class="dd-description"><p>The deterministic automata generated by <span class="machine"><span class="font-tt">ocamllex</span></span> are limited to at
most 32767 transitions. The message above indicates that your lexer
definition is too complex and overflows this limit. This is commonly
caused by lexer definitions that have separate rules for each of the
alphabetic keywords of the language, as in the following example.
</p><pre>rule token = parse
  "keyword1"   { KWD1 }
| "keyword2"   { KWD2 }
| ...
| "keyword100" { KWD100 }
| ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { IDENT id}
</pre><p>To keep the generated automata small, rewrite those definitions with
only one general â€œidentifierâ€ rule, followed by a hashtable lookup
to separate keywords from identifiers:
</p><pre>{ let keyword_table = Hashtbl.create 53
  let _ =
    List.iter (fun (kwd, tok) -&gt; Hashtbl.add keyword_table kwd tok)
              [ "keyword1", KWD1;
                "keyword2", KWD2; ...
                "keyword100", KWD100 ]
}
rule token = parse
  ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { try
                   Hashtbl.find keyword_table id
                 with Not_found -&gt;
                   IDENT id }
</pre></dd><dt class="dt-description"><span class="font-bold">ocamllex: Position memory overflow, too many bindings</span></dt><dd class="dd-description">
The deterministic automata generated by <span class="machine"><span class="font-tt">ocamllex</span></span> maintain a table of
positions inside the scanned lexer buffer. The size of this table is
limited to at most 255 cells. This error should not show up in normal
situations.</dd><dt class="dt-description"><span class="font-bold">ocamlyacc: concurrency safety</span></dt><dd class="dd-description"><p>Parsers generated by ocamlyacc are not thread-safe.
Those parsers rely on an internal work state which is shared by all
ocamlyacc generated parsers.
The <a href="https://cambium.inria.fr/~fpottier/menhir/">menhir</a> parser generator
is a better option if you want thread-safe parsers.</p></dd></dl>
<!--TOC chapter id="sec391" ChapterÂ 18â€ƒDependency generator (ocamldep)-->
<h1 class="chapter" id="sec391">ChapterÂ 18â€ƒDependency generator (ocamldep)</h1><!--SEC END --><p> <a id="c:camldep"></a>
</p><!--NAME depend.html-->
<p>The <span class="machine"><span class="font-tt">ocamldep</span></span> command scans a set of OCaml source files
(<span class="machine"><span class="font-tt">.ml</span></span> and <span class="machine"><span class="font-tt">.mli</span></span> files) for references to external compilation units,
and outputs dependency lines in a format suitable for the <span class="machine"><span class="font-tt">make</span></span>
utility. This ensures that <span class="machine"><span class="font-tt">make</span></span> will compile the source files in the
correct order, and recompile those files that need to when a source
file is modified.</p><p>The typical usage is:
</p><pre>
        ocamldep <span class="font-it">options</span> *.mli *.ml &gt; .depend
</pre><p>
where <span class="machine"><span class="font-tt">*.mli *.ml</span></span> expands to all source files in the current
directory and <span class="machine"><span class="font-tt">.depend</span></span> is the file that should contain the
dependencies. (See below for a typical <span class="machine"><span class="font-tt">Makefile</span></span>.)</p><p>Dependencies are generated both for compiling with the bytecode
compiler <span class="machine"><span class="font-tt">ocamlc</span></span> and with the native-code compiler <span class="machine"><span class="font-tt">ocamlopt</span></span>.</p>
<!--TOC section id="s:ocamldep-options" 18.1â€ƒOptions-->
<h2 class="section" id="s:ocamldep-options"><a class="section-anchor" href="#s:ocamldep-options" aria-hidden="true">ï»¿</a>18.1â€ƒOptions</h2><!--SEC END --><p>The following command-line options are recognized by <span class="machine"><span class="font-tt">ocamldep</span></span>.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-absname</span></span></span></dt><dd class="dd-description">
Show absolute filenames in error messages.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-all</span></span></span></dt><dd class="dd-description">
Generate dependencies on all required files, rather than assuming
implicit dependencies.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-allow-approx</span></span></span></dt><dd class="dd-description">
Allow falling back on a lexer-based approximation when parsing fails.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional newline-terminated command line arguments from <span class="font-it">filename</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args0</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional null character terminated command line arguments from <span class="font-it">filename</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-as-map</span></span></span></dt><dd class="dd-description">
For the following files, do not include delayed dependencies for
module aliases.
This option assumes that they are compiled using options
<span class="machine"><span class="font-tt">-no-alias-deps -w -49</span></span>, and that those files or their interface are
passed with the <span class="machine"><span class="font-tt">-map</span></span> option when computing dependencies for other
files. Note also that for dependencies to be correct in the
implementation of a map file, its interface should not coerce any of
the aliases it contains.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-debug-map</span></span></span></dt><dd class="dd-description">
Dump the delayed dependency map for each map file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the list of directories searched for
source files. If a source file <span class="machine"><span class="font-tt">foo.ml</span></span> mentions an external
compilation unit <span class="machine"><span class="font-tt">Bar</span></span>, a dependency on that unitâ€™s interface
<span class="machine"><span class="font-tt">bar.cmi</span></span> is generated only if the source for <span class="machine"><span class="font-tt">bar</span></span> is found in the
current directory or in one of the directories specified with <span class="machine"><span class="font-tt">-I</span></span>.
Otherwise, <span class="machine"><span class="font-tt">Bar</span></span> is assumed to be a module from the standard library,
and no dependencies are generated. For programs that span multiple
directories, it is recommended to pass <span class="machine"><span class="font-tt">ocamldep</span></span> the same <span class="machine"><span class="font-tt">-I</span></span> options
that are passed to the compiler.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nocwd</span></span></span></dt><dd class="dd-description">
Do not add current working directory to the list of include directories.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-impl</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Process <span class="font-it">file</span> as a <span class="machine"><span class="font-tt">.ml</span></span> file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Process <span class="font-it">file</span> as a <span class="machine"><span class="font-tt">.mli</span></span> file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-map</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Read and propagate the delayed dependencies for module aliases in
<span class="font-it">file</span>, so that the following files will depend on the
exported aliased modules if they use them. See the example below.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ml-synonym</span></span> <span class="font-it">.ext</span></span></dt><dd class="dd-description">
Consider the given extension (with leading dot) to be a synonym for .ml.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-mli-synonym</span></span> <span class="font-it">.ext</span></span></dt><dd class="dd-description">
Consider the given extension (with leading dot) to be a synonym for .mli.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-modules</span></span></span></dt><dd class="dd-description">
Output raw dependencies of the form
<pre>      filename: Module1 Module2 ... ModuleN
</pre>where <span class="machine"><span class="font-tt">Module1</span></span>, â€¦, <span class="machine"><span class="font-tt">ModuleN</span></span> are the names of the compilation
units referenced within the file <span class="machine"><span class="font-tt">filename</span></span>, but these names are not
resolved to source file names. Such raw dependencies cannot be used
by <span class="machine"><span class="font-tt">make</span></span>, but can be post-processed by other tools such as <span class="machine"><span class="font-tt">Omake</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-native</span></span></span></dt><dd class="dd-description">
Generate dependencies for a pure native-code program (no bytecode
version). When an implementation file (<span class="machine"><span class="font-tt">.ml</span></span> file) has no explicit
interface file (<span class="machine"><span class="font-tt">.mli</span></span> file), <span class="machine"><span class="font-tt">ocamldep</span></span> generates dependencies on the
bytecode compiled file (<span class="machine"><span class="font-tt">.cmo</span></span> file) to reflect interface changes.
This can cause unnecessary bytecode recompilations for programs that
are compiled to native-code only. The flag <span class="machine"><span class="font-tt">-native</span></span> causes
dependencies on native compiled files (<span class="machine"><span class="font-tt">.cmx</span></span>) to be generated instead
of on <span class="machine"><span class="font-tt">.cmo</span></span> files. (This flag makes no difference if all source files
have explicit <span class="machine"><span class="font-tt">.mli</span></span> interface files.)</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-one-line</span></span></span></dt><dd class="dd-description">
Output one line per file, regardless of the length.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-open</span></span> <span class="font-it">module</span></span></dt><dd class="dd-description">
Assume that module <span class="font-it">module</span> is opened before parsing each of the
following files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pp</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
Cause <span class="machine"><span class="font-tt">ocamldep</span></span> to call the given <span class="font-it">command</span> as a preprocessor
for each source file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ppx</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
Pipe abstract syntax trees through preprocessor <span class="font-it">command</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-shared</span></span></span></dt><dd class="dd-description">
Generate dependencies for native plugin files (.cmxs) in addition to
native compiled files (.cmx).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-slash</span></span></span></dt><dd class="dd-description">
Under Windows, use a forward slash (/) as the path separator instead
of the usual backward slash (\). Under Unix, this option does
nothing.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-sort</span></span></span></dt><dd class="dd-description">
Sort files according to their dependencies.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.
</dd></dl>
<!--TOC section id="s:ocamldep-makefile" 18.2â€ƒA typical Makefile-->
<h2 class="section" id="s:ocamldep-makefile"><a class="section-anchor" href="#s:ocamldep-makefile" aria-hidden="true">ï»¿</a>18.2â€ƒA typical Makefile</h2><!--SEC END --><p>Here is a template <span class="machine"><span class="font-tt">Makefile</span></span> for a OCaml program.</p><pre>OCAMLC=ocamlc
OCAMLOPT=ocamlopt
OCAMLDEP=ocamldep
INCLUDES=                 # all relevant -I options here
OCAMLFLAGS=$(INCLUDES)    # add other options for ocamlc here
OCAMLOPTFLAGS=$(INCLUDES) # add other options for ocamlopt here

# prog1 should be compiled to bytecode, and is composed of three
# units: mod1, mod2 and mod3.

# The list of object files for prog1
PROG1_OBJS=mod1.cmo mod2.cmo mod3.cmo

prog1: $(PROG1_OBJS)
        $(OCAMLC) -o prog1 $(OCAMLFLAGS) $(PROG1_OBJS)

# prog2 should be compiled to native-code, and is composed of two
# units: mod4 and mod5.

# The list of object files for prog2
PROG2_OBJS=mod4.cmx mod5.cmx

prog2: $(PROG2_OBJS)
        $(OCAMLOPT) -o prog2 $(OCAMLFLAGS) $(PROG2_OBJS)

# Common rules

%.cmo: %.ml
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

%.cmi: %.mli
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

%.cmx: %.ml
        $(OCAMLOPT) $(OCAMLOPTFLAGS) -c $&lt;

# Clean up
clean:
        rm -f prog1 prog2
        rm -f *.cm[iox]

# Dependencies
depend:
        $(OCAMLDEP) $(INCLUDES) *.mli *.ml &gt; .depend

include .depend
</pre><p>
If you use module aliases to give shorter names to modules, you need
to change the above definitions. Assuming that your map file is called
<span class="machine"><span class="font-tt">mylib.mli</span></span>, here are minimal modifications.
</p><pre>OCAMLFLAGS=$(INCLUDES) -open Mylib

mylib.cmi: mylib.mli
        $(OCAMLC) $(INCLUDES) -no-alias-deps -w -49 -c $&lt;

depend:
        $(OCAMLDEP) $(INCLUDES) -map mylib.mli $(PROG1_OBJS:.cmo=.ml) &gt; .depend
</pre><p>Note that in this case you should not compute dependencies for
<span class="machine"><span class="font-tt">mylib.mli</span></span> together with the other files, hence the need to pass
explicitly the list of files to process.
If <span class="machine"><span class="font-tt">mylib.mli</span></span> itself has dependencies, you should compute them using
<span class="machine"><span class="font-tt">-as-map</span></span>.

</p>
<!--TOC chapter id="sec394" ChapterÂ 19â€ƒThe documentation generator (ocamldoc)-->
<h1 class="chapter" id="sec394">ChapterÂ 19â€ƒThe documentation generator (ocamldoc)</h1><!--SEC END --><p> <a id="c:ocamldoc"></a>
</p><!--NAME ocamldoc.html-->
<p>This chapter describes OCamldoc, a tool that generates documentation from
special comments embedded in source files. The comments used by OCamldoc
are of the form <span class="machine"><span class="font-tt">(**</span></span>â€¦<span class="machine"><span class="font-tt">*)</span></span> and follow the format described
in section <a href="#s%3Aocamldoc-comments">19.2</a>.</p><p>OCamldoc can produce documentation in various formats: HTML, L<sup>A</sup>T<sub>E</sub>X,
TeXinfo, Unix man pages, and <span class="machine"><span class="font-tt">dot</span></span> dependency graphs. Moreover,
users can add their own custom generators, as explained in
section <a href="#s%3Aocamldoc-custom-generators">19.3</a>.</p><p>In this chapter, we use the word <em>element</em> to refer to any of the
following parts of an OCaml source file: a type declaration, a value,
a module, an exception, a module type, a type constructor, a record
field, a class, a class type, a class method, a class value or a class
inheritance clause.</p>
<!--TOC section id="s:ocamldoc-usage" 19.1â€ƒUsage-->
<h2 class="section" id="s:ocamldoc-usage"><a class="section-anchor" href="#s:ocamldoc-usage" aria-hidden="true">ï»¿</a>19.1â€ƒUsage</h2><!--SEC END -->
<!--TOC subsection id="ss:ocamldoc-invocation" 19.1.1â€ƒInvocation-->
<h3 class="subsection" id="ss:ocamldoc-invocation"><a class="section-anchor" href="#ss:ocamldoc-invocation" aria-hidden="true">ï»¿</a>19.1.1â€ƒInvocation</h3><!--SEC END --><p>OCamldoc is invoked via the command <span class="machine"><span class="font-tt">ocamldoc</span></span>, as follows:
</p><pre>
        ocamldoc <span class="font-it">options</span> <span class="font-it">sourcefiles</span>
</pre><!--TOC subsubsection id="sss:ocamldoc-output" Options for choosing the output format-->
<h4 class="subsubsection" id="sss:ocamldoc-output"><a class="section-anchor" href="#sss:ocamldoc-output" aria-hidden="true">ï»¿</a>Options for choosing the output format</h4><!--SEC END --><p>The following options determine the format for the generated
documentation.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-html</span></span></span></dt><dd class="dd-description">
Generate documentation in HTML default format. The generated HTML pages
are stored in the current directory, or in the directory specified
with the <span class="font-bold"><span class="font-tt">-d</span></span> option. You can customize the style of the
generated pages by editing the generated <span class="machine"><span class="font-tt">style.css</span></span> file, or by providing
your own style sheet using option <span class="machine"><span class="font-tt">-css-style</span></span>.
The file <span class="machine"><span class="font-tt">style.css</span></span> is not generated if it already exists or if -css-style is used.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-latex</span></span></span></dt><dd class="dd-description">
Generate documentation in L<sup>A</sup>T<sub>E</sub>X default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <span class="machine"><span class="font-tt">ocamldoc.out</span></span>, or in the file
specified with the <span class="font-bold"><span class="font-tt">-o</span></span> option. The document uses the style file
<span class="machine"><span class="font-tt">ocamldoc.sty</span></span>. This file is generated when using the <span class="machine"><span class="font-tt">-latex</span></span> option,
if it does not already exist.
You can change this file to customize the style of your L<sup>A</sup>T<sub>E</sub>X documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-texi</span></span></span></dt><dd class="dd-description">
Generate documentation in TeXinfo default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <span class="machine"><span class="font-tt">ocamldoc.out</span></span>, or in the file
specified with the <span class="font-bold"><span class="font-tt">-o</span></span> option.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-man</span></span></span></dt><dd class="dd-description">
Generate documentation as a set of Unix <span class="machine"><span class="font-tt">man</span></span> pages. The generated pages
are stored in the current directory, or in the directory specified
with the <span class="font-bold"><span class="font-tt">-d</span></span> option.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dot</span></span></span></dt><dd class="dd-description">
Generate a dependency graph for the toplevel modules, in a format suitable
for displaying and processing by <span class="machine"><span class="font-tt">dot</span></span>. The <span class="machine"><span class="font-tt">dot</span></span> tool is available from
<a href="https://graphviz.org/"><span class="font-tt">https://graphviz.org/</span></a>.
The textual representation of the graph is written to the file
<span class="machine"><span class="font-tt">ocamldoc.out</span></span>, or to the file specified with the <span class="font-bold"><span class="font-tt">-o</span></span> option.
Use <span class="machine"><span class="font-tt">dot ocamldoc.out</span></span> to display it.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-g</span></span> <span class="font-it">file.cm[o,a,xs]</span></span></dt><dd class="dd-description">
Dynamically load the given file, which defines a custom documentation
generator. See section <a href="#ss%3Aocamldoc-compilation-and-usage">19.4.1</a>. This
option is supported by the <span class="machine"><span class="font-tt">ocamldoc</span></span> command (to load <span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span> files)
and by its native-code version <span class="machine"><span class="font-tt">ocamldoc.opt</span></span> (to load <span class="machine"><span class="font-tt">.cmxs</span></span> files).
If the given file is a simple one and does not exist in
the current directory, then ocamldoc looks for it in the custom
generators default directory, and in the directories specified with
optional <span class="machine"><span class="font-tt">-i</span></span> options.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-customdir</span></span></span></dt><dd class="dd-description">
Display the custom generators default directory.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-i</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add the given directory to the path where to look for custom generators.</dd></dl><!--TOC subsubsection id="sss:ocamldoc-options" General options-->
<h4 class="subsubsection" id="sss:ocamldoc-options"><a class="section-anchor" href="#sss:ocamldoc-options" aria-hidden="true">ï»¿</a>General options</h4><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-d</span></span> <span class="font-it">dir</span></span></dt><dd class="dd-description">
Generate files in directory <span class="font-it">dir</span>, rather than the current directory.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dump</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Dump collected information into <span class="font-it">file</span>. This information can be
read with the <span class="machine"><span class="font-tt">-load</span></span> option in a subsequent invocation of <span class="machine"><span class="font-tt">ocamldoc</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-hide</span></span> <span class="font-it">modules</span></span></dt><dd class="dd-description">
Hide the given complete module names in the generated documentation.
<span class="font-it">modules</span> is a list of complete module names separated
by â€™<span class="machine"><span class="font-tt">,</span></span>â€™, without blanks. For instance: <span class="machine"><span class="font-tt">Stdlib,M2.M3</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inv-merge-ml-mli</span></span></span></dt><dd class="dd-description">
Reverse the precedence of implementations and interfaces when merging.
All elements
in implementation files are kept, and the <span class="font-bold"><span class="font-tt">-m</span></span> option
indicates which parts of the comments in interface files are merged
with the comments in implementation files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-keep-code</span></span></span></dt><dd class="dd-description">
Always keep the source code for values, methods and instance variables,
when available.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-load</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Load information from <span class="font-it">file</span>, which has been produced by
<span class="machine"><span class="font-tt">ocamldoc -dump</span></span>. Several <span class="machine"><span class="font-tt">-load</span></span> options can be given.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-m</span></span> <span class="font-it">flags</span></span></dt><dd class="dd-description">
Specify merge options between interfaces and implementations.
(see section <a href="#ss%3Aocamldoc-merge">19.1.2</a> for details).
<span class="font-it">flags</span> can be one or several of the following characters:
<dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">d</span></span></span></dt><dd class="dd-description"> merge description
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">a</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@author</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">v</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@version</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">l</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@see</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">s</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@since</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">b</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@before</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">o</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@deprecated</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">p</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@param</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">e</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@raise</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">r</span></span></span></dt><dd class="dd-description"> merge <span class="machine"><span class="font-tt">@return</span></span>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">A</span></span></span></dt><dd class="dd-description"> merge everything
</dd></dl></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-custom-tags</span></span></span></dt><dd class="dd-description">
Do not allow custom @-tags (see section <a href="#ss%3Aocamldoc-tags">19.2.5</a>).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-stop</span></span></span></dt><dd class="dd-description">
Keep elements placed after/between the <span class="machine"><span class="font-tt">(**/**)</span></span> special comment(s)
(see section <a href="#s%3Aocamldoc-comments">19.2</a>).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Output the generated documentation to <span class="font-it">file</span> instead of <span class="machine"><span class="font-tt">ocamldoc.out</span></span>.
This option is meaningful only in conjunction with the
<span class="font-bold"><span class="font-tt">-latex</span></span>, <span class="font-bold"><span class="font-tt">-texi</span></span>, or <span class="font-bold"><span class="font-tt">-dot</span></span> options.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-pp</span></span> <span class="font-it">command</span></span></dt><dd class="dd-description">
Pipe sources through preprocessor <span class="font-it">command</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-impl</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Process the file <span class="font-it">filename</span> as an implementation file, even if its
extension is not <span class="machine"><span class="font-tt">.ml</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Process the file <span class="font-it">filename</span> as an interface file, even if its
extension is not <span class="machine"><span class="font-tt">.mli</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-text</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Process the file <span class="font-it">filename</span> as a text file, even if its
extension is not <span class="machine"><span class="font-tt">.txt</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-sort</span></span></span></dt><dd class="dd-description">
Sort the list of top-level modules before generating the documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-stars</span></span></span></dt><dd class="dd-description">
Remove blank characters until the first asterisk (â€™<span class="machine"><span class="font-tt">*</span></span>â€™) in each
line of comments.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-t</span></span> <span class="font-it">title</span></span></dt><dd class="dd-description">
Use <span class="font-it">title</span> as the title for the generated documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intro</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Use content of <span class="font-it">file</span> as ocamldoc text to use as introduction (HTML,
L<sup>A</sup>T<sub>E</sub>X and TeXinfo only).
For HTML, the file is used to create the whole <span class="machine"><span class="font-tt">index.html</span></span> file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-v</span></span></span></dt><dd class="dd-description">
Verbose mode. Display progress information.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-warn-error</span></span></span></dt><dd class="dd-description">
Treat Ocamldoc warnings as errors.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-hide-warnings</span></span></span></dt><dd class="dd-description">
Do not print OCamldoc warnings.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.
</dd></dl><!--TOC subsubsection id="sss:ocamldoc-type-checking" Type-checking options-->
<h4 class="subsubsection" id="sss:ocamldoc-type-checking"><a class="section-anchor" href="#sss:ocamldoc-type-checking" aria-hidden="true">ï»¿</a>Type-checking options</h4><!--SEC END --><p>OCamldoc calls the OCaml type-checker to obtain type
information. The following options impact the type-checking phase.
They have the same meaning as for the <span class="machine"><span class="font-tt">ocamlc</span></span> and <span class="machine"><span class="font-tt">ocamlopt</span></span> commands.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Add <span class="font-it">directory</span> to the list of directories search for compiled
interface files (<span class="machine"><span class="font-tt">.cmi</span></span> files).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-nolabels</span></span></span></dt><dd class="dd-description">
Ignore non-optional labels in types.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rectypes</span></span></span></dt><dd class="dd-description">
Allow arbitrary recursive types. (See the <span class="machine"><span class="font-tt">-rectypes</span></span> option to <span class="machine"><span class="font-tt">ocamlc</span></span>.)</dd></dl><!--TOC subsubsection id="sss:ocamldoc-html" Options for generating HTML pages-->
<h4 class="subsubsection" id="sss:ocamldoc-html"><a class="section-anchor" href="#sss:ocamldoc-html" aria-hidden="true">ï»¿</a>Options for generating HTML pages</h4><!--SEC END --><p>The following options apply in conjunction with the <span class="machine"><span class="font-tt">-html</span></span> option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-all-params</span></span></span></dt><dd class="dd-description">
Display the complete list of parameters for functions and methods.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-charset</span></span> <span class="font-it">charset</span></span></dt><dd class="dd-description">
Add information about character encoding being <span class="font-it">charset</span>
(default is iso-8859-1).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-colorize-code</span></span></span></dt><dd class="dd-description">
Colorize the OCaml code enclosed in <span class="machine"><span class="font-tt">[ ]</span></span> and <span class="machine"><span class="font-tt">{[ ]}</span></span>, using colors
to emphasize keywords, etc. If the code fragments are not
syntactically correct, no color is added.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-css-style</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Use <span class="font-it">filename</span> as the Cascading Style Sheet file.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-index-only</span></span></span></dt><dd class="dd-description">
Generate only index files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-short-functors</span></span></span></dt><dd class="dd-description">
Use a short form to display functors:
<pre>
module M : functor (A:Module) -&gt; functor (B:Module2) -&gt; sig .. end
</pre>
is displayed as:
<pre>
module M (A:Module) (B:Module2) : sig .. end
</pre></dd></dl><!--TOC subsubsection id="sss:ocamldoc-latex" Options for generating L<sup>A</sup>T<sub>E</sub>X files-->
<h4 class="subsubsection" id="sss:ocamldoc-latex"><a class="section-anchor" href="#sss:ocamldoc-latex" aria-hidden="true">ï»¿</a>Options for generating L<sup>A</sup>T<sub>E</sub>X files</h4><!--SEC END --><p>The following options apply in conjunction with the <span class="machine"><span class="font-tt">-latex</span></span> option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-latex-value-prefix</span></span> <span class="font-it">prefix</span></span></dt><dd class="dd-description">
Give a prefix to use for the labels of the values in the generated
L<sup>A</sup>T<sub>E</sub>X document.
The default prefix is the empty string. You can also use the options
<span class="font-tt">-latex-type-prefix</span>, <span class="font-tt">-latex-exception-prefix</span>,
<span class="font-tt">-latex-module-prefix</span>,
<span class="font-tt">-latex-module-type-prefix</span>, <span class="font-tt">-latex-class-prefix</span>,
<span class="font-tt">-latex-class-type-prefix</span>,
<span class="font-tt">-latex-attribute-prefix</span> and <span class="font-tt">-latex-method-prefix</span>.<p>These options are useful when you have, for example, a type and a value with
the same name. If you do not specify prefixes, L<sup>A</sup>T<sub>E</sub>X will complain about
multiply defined labels.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-latextitle</span></span> <span class="font-it">n,style</span></span></dt><dd class="dd-description">
Associate style number <span class="font-it">n</span> to the given L<sup>A</sup>T<sub>E</sub>X sectioning command
<span class="font-it">style</span>, e.g. <span class="machine"><span class="font-tt">section</span></span> or <span class="machine"><span class="font-tt">subsection</span></span>. (L<sup>A</sup>T<sub>E</sub>X only.) This is
useful when including the generated document in another L<sup>A</sup>T<sub>E</sub>X document,
at a given sectioning level. The default association is 1 for <span class="machine"><span class="font-tt">section</span></span>,
2 for <span class="machine"><span class="font-tt">subsection</span></span>, 3 for <span class="machine"><span class="font-tt">subsubsection</span></span>, 4 for <span class="machine"><span class="font-tt">paragraph</span></span> and 5 for
<span class="machine"><span class="font-tt">subparagraph</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noheader</span></span></span></dt><dd class="dd-description">
Suppress header in generated documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-notoc</span></span></span></dt><dd class="dd-description">
Do not generate a table of contents.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-notrailer</span></span></span></dt><dd class="dd-description">
Suppress trailer in generated documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-sepfiles</span></span></span></dt><dd class="dd-description">
Generate one <span class="machine"><span class="font-tt">.tex</span></span> file per toplevel module, instead of the global
<span class="machine"><span class="font-tt">ocamldoc.out</span></span> file.
</dd></dl><!--TOC subsubsection id="sss:ocamldoc-info" Options for generating TeXinfo files-->
<h4 class="subsubsection" id="sss:ocamldoc-info"><a class="section-anchor" href="#sss:ocamldoc-info" aria-hidden="true">ï»¿</a>Options for generating TeXinfo files</h4><!--SEC END --><p>The following options apply in conjunction with the <span class="machine"><span class="font-tt">-texi</span></span> option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-esc8</span></span></span></dt><dd class="dd-description">
Escape accented characters in Info files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-info-entry</span></span></span></dt><dd class="dd-description">
Specify Info directory entry.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-info-section</span></span></span></dt><dd class="dd-description">
Specify section of Info directory.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noheader</span></span></span></dt><dd class="dd-description">
Suppress header in generated documentation.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-noindex</span></span></span></dt><dd class="dd-description">
Do not build index for Info files.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-notrailer</span></span></span></dt><dd class="dd-description">
Suppress trailer in generated documentation.
</dd></dl><!--TOC subsubsection id="sss:ocamldoc-dot" Options for generating <span class="machine"><span class="font-tt">dot</span></span> graphs-->
<h4 class="subsubsection" id="sss:ocamldoc-dot"><a class="section-anchor" href="#sss:ocamldoc-dot" aria-hidden="true">ï»¿</a>Options for generating <span class="machine"><span class="font-tt">dot</span></span> graphs</h4><!--SEC END --><p>The following options apply in conjunction with the <span class="machine"><span class="font-tt">-dot</span></span> option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dot-colors</span></span> <span class="font-it">colors</span></span></dt><dd class="dd-description">
Specify the colors to use in the generated <span class="machine"><span class="font-tt">dot</span></span> code.
When generating module dependencies, <span class="machine"><span class="font-tt">ocamldoc</span></span> uses different colors
for modules, depending on the directories in which they reside.
When generating types dependencies, <span class="machine"><span class="font-tt">ocamldoc</span></span> uses different colors
for types, depending on the modules in which they are defined.
<span class="font-it">colors</span> is a list of color names separated by â€™<span class="machine"><span class="font-tt">,</span></span>â€™, as
in <span class="machine"><span class="font-tt">Red,Blue,Green</span></span>. The available colors are the ones supported by
the <span class="machine"><span class="font-tt">dot</span></span> tool.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dot-include-all</span></span></span></dt><dd class="dd-description">
Include all modules in the <span class="machine"><span class="font-tt">dot</span></span> output, not only modules given
on the command line or loaded with the <span class="font-bold"><span class="font-tt">-load</span></span> option.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dot-reduce</span></span></span></dt><dd class="dd-description">
Perform a transitive reduction of the dependency graph before
outputting the <span class="machine"><span class="font-tt">dot</span></span> code. This can be useful if there are
a lot of transitive dependencies that clutter the graph.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-dot-types</span></span></span></dt><dd class="dd-description">
Output <span class="machine"><span class="font-tt">dot</span></span> code describing the type dependency graph instead of
the module dependency graph.
</dd></dl><!--TOC subsubsection id="sss:ocamldoc-man" Options for generating man files-->
<h4 class="subsubsection" id="sss:ocamldoc-man"><a class="section-anchor" href="#sss:ocamldoc-man" aria-hidden="true">ï»¿</a>Options for generating man files</h4><!--SEC END --><p>The following options apply in conjunction with the <span class="machine"><span class="font-tt">-man</span></span> option:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-man-mini</span></span></span></dt><dd class="dd-description">
Generate man pages only for modules, module types, classes and class
types, instead of pages for all elements.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-man-suffix</span></span> <span class="font-it">suffix</span></span></dt><dd class="dd-description">
Set the suffix used for generated man filenames. Default is â€™<span class="machine"><span class="font-tt">3o</span></span>â€™,
as in <span class="machine"><span class="font-tt">List.3o</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-man-section</span></span> <span class="font-it">section</span></span></dt><dd class="dd-description">
Set the section number used for generated man filenames. Default is â€™<span class="machine"><span class="font-tt">3</span></span>â€™.</dd></dl>
<!--TOC subsection id="ss:ocamldoc-merge" 19.1.2â€ƒMerging of module information-->
<h3 class="subsection" id="ss:ocamldoc-merge"><a class="section-anchor" href="#ss:ocamldoc-merge" aria-hidden="true">ï»¿</a>19.1.2â€ƒMerging of module information</h3><!--SEC END --><p>Information on a module can be extracted either from the <span class="machine"><span class="font-tt">.mli</span></span> or <span class="machine"><span class="font-tt">.ml</span></span>
file, or both, depending on the files given on the command line.
When both <span class="machine"><span class="font-tt">.mli</span></span> and <span class="machine"><span class="font-tt">.ml</span></span> files are given for the same module,
information extracted from these files is merged according to the
following rules:
</p><ul class="itemize"><li class="li-itemize">Only elements (values, types, classes, ...) declared in the <span class="machine"><span class="font-tt">.mli</span></span>
file are kept. In other terms, definitions from the <span class="machine"><span class="font-tt">.ml</span></span> file that are
not exported in the <span class="machine"><span class="font-tt">.mli</span></span> file are not documented.
</li><li class="li-itemize">Descriptions of elements and descriptions in @-tags are handled
as follows. If a description for the same element or in the same
@-tag of the same element is present in both files, then the
description of the <span class="machine"><span class="font-tt">.ml</span></span> file is concatenated to the one in the <span class="machine"><span class="font-tt">.mli</span></span> file,
if the corresponding <span class="machine"><span class="font-tt">-m</span></span> flag is given on the command line.
If a description is present in the <span class="machine"><span class="font-tt">.ml</span></span> file and not in the
<span class="machine"><span class="font-tt">.mli</span></span> file, the <span class="machine"><span class="font-tt">.ml</span></span> description is kept.
In either case, all the information given in the <span class="machine"><span class="font-tt">.mli</span></span> file is kept.
</li></ul>
<!--TOC subsection id="ss:ocamldoc-rules" 19.1.3â€ƒCoding rules-->
<h3 class="subsection" id="ss:ocamldoc-rules"><a class="section-anchor" href="#ss:ocamldoc-rules" aria-hidden="true">ï»¿</a>19.1.3â€ƒCoding rules</h3><!--SEC END --><p>
The following rules must be respected in order to avoid name clashes
resulting in cross-reference errors:
</p><ul class="itemize"><li class="li-itemize">In a module, there must not be two modules, two module types or
a module and a module type with the same name.
In the default HTML generator, modules <span class="machine"><span class="font-tt">ab</span></span> and <span class="machine"><span class="font-tt">AB</span></span> will be printed
to the same file on case insensitive file systems.
</li><li class="li-itemize">In a module, there must not be two classes, two class types or
a class and a class type with the same name.
</li><li class="li-itemize">In a module, there must not be two values, two types, or two
exceptions with the same name.
</li><li class="li-itemize">Values defined in tuple, as in <span class="machine"><span class="font-tt">let (x,y,z) = (1,2,3)</span></span>
are not kept by OCamldoc.
</li><li class="li-itemize">Avoid the following construction:

<div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Foo <span class="ocamlcomment">(* which has a module Bar with a value x *)</span>
<span class="ocamlkeyword">module</span> Foo =
  <span class="ocamlkeyword">struct</span>
    <span class="ocamlkeyword">module</span> Bar =
      <span class="ocamlkeyword">struct</span>
        <span class="ocamlkeyword">let</span> x = 1
      <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">end</span>
  <span class="ocamlkeyword">let</span> dummy = Bar.x</div></div>

</div>

In this case, OCamldoc will associate <span class="machine"><span class="font-tt">Bar.x</span></span> to the <span class="machine"><span class="font-tt">x</span></span> of module
<span class="machine"><span class="font-tt">Foo</span></span> defined just above, instead of to the <span class="machine"><span class="font-tt">Bar.x</span></span> defined in the
opened module <span class="machine"><span class="font-tt">Foo</span></span>.
</li></ul>
<!--TOC section id="s:ocamldoc-comments" 19.2â€ƒSyntax of documentation comments-->
<h2 class="section" id="s:ocamldoc-comments"><a class="section-anchor" href="#s:ocamldoc-comments" aria-hidden="true">ï»¿</a>19.2â€ƒSyntax of documentation comments</h2><!--SEC END --><p>Comments containing documentation material are called <em>special
comments</em> and are written between <span class="machine"><span class="font-tt">(**</span></span> and <span class="machine"><span class="font-tt">*)</span></span>. Special comments
must start exactly with <span class="machine"><span class="font-tt">(**</span></span>. Comments beginning with <span class="machine"><span class="font-tt">(</span></span> and more
than two <span class="machine"><span class="font-tt">*</span></span> are ignored.</p>
<!--TOC subsection id="ss:ocamldoc-placement" 19.2.1â€ƒPlacement of documentation comments-->
<h3 class="subsection" id="ss:ocamldoc-placement"><a class="section-anchor" href="#ss:ocamldoc-placement" aria-hidden="true">ï»¿</a>19.2.1â€ƒPlacement of documentation comments</h3><!--SEC END --><p>
OCamldoc can associate comments to some elements of the language
encountered in the source files. The association is made according to
the locations of comments with respect to the language elements. The
locations of comments in <span class="machine"><span class="font-tt">.mli</span></span> and <span class="machine"><span class="font-tt">.ml</span></span> files are different.</p>
<!--TOC subsubsection id="sss:ocamldoc-mli" Comments in <span class="machine"><span class="font-tt">.mli</span></span> files-->
<h4 class="subsubsection" id="sss:ocamldoc-mli"><a class="section-anchor" href="#sss:ocamldoc-mli" aria-hidden="true">ï»¿</a>Comments in <span class="machine"><span class="font-tt">.mli</span></span> files</h4><!--SEC END --><p>
A special comment is associated to an element if it is placed before or
after the element.<br>
A special comment before an element is associated to this element ifÂ :
</p><ul class="itemize"><li class="li-itemize">There is no blank line or another special comment between the special
comment and the element. However, a regular comment can occur between
the special comment and the element.
</li><li class="li-itemize">The special comment is not already associated to the previous element.
</li><li class="li-itemize">The special comment is not the first one of a toplevel module.
</li></ul><p>A special comment after an element is associated to this element if
there is no blank line or comment between the special comment and the
element.</p><p>There are two exceptions: for constructors and record fields in
type definitions, the associated comment can only be placed after the
constructor or field definition, without blank lines or other comments
between them. The special comment for a constructor
with another constructor following must be placed before the â€™<span class="machine"><span class="font-tt">|</span></span>â€™
character separating the two constructors.</p><p>The following sample interface file <span class="machine"><span class="font-tt">foo.mli</span></span> illustrates the
placement rules for comments in <span class="machine"><span class="font-tt">.mli</span></span> files.</p><div class="caml-example signature">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(** The first special comment of the file is the comment associated
    with the whole module.*)</span>


<span class="ocamlcomment">(** Special comments can be placed between elements and are kept
    by the OCamldoc tool, but are not associated to any element.
    @-tags in these comments are ignored.*)</span>

<span class="ocamlcomment">(*******************************************************************)</span>
<span class="ocamlcomment">(** Comments like the one above, with more than two asterisks,
    are ignored. *)</span>

<span class="ocamlcomment">(** The comment for function f. *)</span>
<span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; int
<span class="ocamlcomment">(** The continuation of the comment for function f. *)</span>

<span class="ocamlcomment">(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)</span>
<span class="ocamlcomment">(* Hello, I'm a simple comment :-) *)</span>
<span class="ocamlkeyword">exception</span> My_exception <span class="ocamlkeyword">of</span> (int -&gt; int) * int

<span class="ocamlcomment">(** Comment for type weather  *)</span>
<span class="ocamlkeyword">type</span> weather =
| Rain <span class="ocamlkeyword">of</span> int <span class="ocamlcomment">(** The comment for constructor Rain *)</span>
| Sun <span class="ocamlcomment">(** The comment for constructor Sun *)</span>

<span class="ocamlcomment">(** Comment for type weather2  *)</span>
<span class="ocamlkeyword">type</span> weather2 =
| Rain <span class="ocamlkeyword">of</span> int <span class="ocamlcomment">(** The comment for constructor Rain *)</span>
| Sun <span class="ocamlcomment">(** The comment for constructor Sun *)</span>
<span class="ocamlcomment">(** I can continue the comment for type weather2 here
  because there is already a comment associated to the last constructor.*)</span>

<span class="ocamlcomment">(** The comment for type my_record *)</span>
<span class="ocamlkeyword">type</span> my_record = {
    foo : int ;    <span class="ocamlcomment">(** Comment for field foo *)</span>
    bar : string ; <span class="ocamlcomment">(** Comment for field bar *)</span>
  }
  <span class="ocamlcomment">(** Continuation of comment for type my_record *)</span>

<span class="ocamlcomment">(** Comment for foo *)</span>
<span class="ocamlkeyword">val</span> foo : string
<span class="ocamlcomment">(** This comment is associated to foo and not to bar. *)</span>
<span class="ocamlkeyword">val</span> bar : string
<span class="ocamlcomment">(** This comment is associated to bar. *)</span>

<span class="ocamlcomment">(** The comment for class my_class *)</span>
<span class="ocamlkeyword">class</span> my_class :
  <span class="ocamlkeyword">object</span>
    <span class="ocamlcomment">(** A comment to describe inheritance from cl *)</span>
    <span class="ocamlkeyword">inherit</span> cl

    <span class="ocamlcomment">(** The comment for attribute tutu *)</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> tutu : string

    <span class="ocamlcomment">(** The comment for attribute toto. *)</span>
    <span class="ocamlkeyword">val</span> toto : int

    <span class="ocamlcomment">(** This comment is not attached to titi since
        there is a blank line before titi, but is kept
        as a comment in the class. *)</span>

    <span class="ocamlkeyword">val</span> titi : string

    <span class="ocamlcomment">(** Comment for method toto *)</span>
    <span class="ocamlkeyword">method</span> toto : string

    <span class="ocamlcomment">(** Comment for method m *)</span>
    <span class="ocamlkeyword">method</span> m : float -&gt; int
  <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for the class type my_class_type *)</span>
<span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> my_class_type =
  <span class="ocamlkeyword">object</span>
    <span class="ocamlcomment">(** The comment for variable x. *)</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int

    <span class="ocamlcomment">(** The comment for method m. *)</span>
    <span class="ocamlkeyword">method</span> m : int -&gt; int
<span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for module Foo *)</span>
<span class="ocamlkeyword">module</span> Foo :
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlcomment">(** The comment for x *)</span>
    <span class="ocamlkeyword">val</span> x : int

    <span class="ocamlcomment">(** A special comment that is kept but not associated to any element *)</span>
  <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for module type my_module_type. *)</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> my_module_type =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlcomment">(** The comment for value x. *)</span>
    <span class="ocamlkeyword">val</span> x : int

    <span class="ocamlcomment">(** The comment for module M. *)</span>
    <span class="ocamlkeyword">module</span> M :
      <span class="ocamlkeyword">sig</span>
        <span class="ocamlcomment">(** The comment for value y. *)</span>
        <span class="ocamlkeyword">val</span> y : int

        <span class="ocamlcomment">(* ... *)</span>
      <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC subsubsection id="sss:ocamldoc-comments-ml" Comments in <span class="font-tt">.ml</span> files-->
<h4 class="subsubsection" id="sss:ocamldoc-comments-ml"><a class="section-anchor" href="#sss:ocamldoc-comments-ml" aria-hidden="true">ï»¿</a>Comments in <span class="font-tt">.ml</span> files</h4><!--SEC END --><p>A special comment is associated to an element if it is placed before
the element and there is no blank line between the comment and the
element. Meanwhile, there can be a simple comment between the special
comment and the element. There are two exceptions, for
constructors and record fields in type definitions, whose associated
comment must be placed after the constructor or field definition,
without blank line between them. The special comment for a constructor
with another constructor following must be placed before the â€™<span class="machine"><span class="font-tt">|</span></span>â€™
character separating the two constructors.</p><p>The following example of file <span class="machine"><span class="font-tt">toto.ml</span></span> shows where to place comments
in a <span class="machine"><span class="font-tt">.ml</span></span> file.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(** The first special comment of the file is the comment associated
    to the whole module. *)</span>

<span class="ocamlcomment">(** The comment for function f *)</span>
<span class="ocamlkeyword">let</span> f x y = x + y

<span class="ocamlcomment">(** This comment is not attached to any element since there is another
    special comment just before the next element. *)</span>

<span class="ocamlcomment">(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)</span>
<span class="ocamlcomment">(* A simple comment. *)</span>
<span class="ocamlkeyword">exception</span> My_exception <span class="ocamlkeyword">of</span> (int -&gt; int) * int

<span class="ocamlcomment">(** Comment for type weather  *)</span>
<span class="ocamlkeyword">type</span> weather =
| Rain <span class="ocamlkeyword">of</span> int <span class="ocamlcomment">(** The comment for constructor Rain *)</span>
| Sun <span class="ocamlcomment">(** The comment for constructor Sun *)</span>

<span class="ocamlcomment">(** The comment for type my_record *)</span>
<span class="ocamlkeyword">type</span> my_record = {
    foo : int ;    <span class="ocamlcomment">(** Comment for field foo *)</span>
    bar : string ; <span class="ocamlcomment">(** Comment for field bar *)</span>
  }

<span class="ocamlcomment">(** The comment for class my_class *)</span>
<span class="ocamlkeyword">class</span> my_class =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlcomment">(** A comment to describe inheritance from cl *)</span>
      <span class="ocamlkeyword">inherit</span> cl

      <span class="ocamlcomment">(** The comment for the instance variable tutu *)</span>
      <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> tutu = <span class="ocamlstring">"tutu"</span>
      <span class="ocamlcomment">(** The comment for toto *)</span>
      <span class="ocamlkeyword">val</span> toto = 1
      <span class="ocamlkeyword">val</span> titi = <span class="ocamlstring">"titi"</span>
      <span class="ocamlcomment">(** Comment for method toto *)</span>
      <span class="ocamlkeyword">method</span> toto = tutu ^ <span class="ocamlstring">"!"</span>
      <span class="ocamlcomment">(** Comment for method m *)</span>
      <span class="ocamlkeyword">method</span> m (f : float) = 1
    <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for class type my_class_type *)</span>
<span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> my_class_type =
  <span class="ocamlkeyword">object</span>
    <span class="ocamlcomment">(** The comment for the instance variable x. *)</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> x : int
    <span class="ocamlcomment">(** The comment for method m. *)</span>
    <span class="ocamlkeyword">method</span> m : int -&gt; int
  <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for module Foo *)</span>
<span class="ocamlkeyword">module</span> Foo =
  <span class="ocamlkeyword">struct</span>
    <span class="ocamlcomment">(** The comment for x *)</span>
    <span class="ocamlkeyword">let</span> x = 0
    <span class="ocamlcomment">(** A special comment in the class, but not associated to any element. *)</span>
  <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** The comment for module type my_module_type. *)</span>
<span class="ocamlkeyword">module</span> <span class="ocamlkeyword">type</span> my_module_type =
  <span class="ocamlkeyword">sig</span>
    <span class="ocamlcomment">(* Comment for value x. *)</span>
    <span class="ocamlkeyword">val</span> x : int
    <span class="ocamlcomment">(* ... *)</span>
  <span class="ocamlkeyword">end</span></div></div>

</div>
<!--TOC subsection id="ss:ocamldoc-stop" 19.2.2â€ƒThe Stop special comment-->
<h3 class="subsection" id="ss:ocamldoc-stop"><a class="section-anchor" href="#ss:ocamldoc-stop" aria-hidden="true">ï»¿</a>19.2.2â€ƒThe Stop special comment</h3><!--SEC END --><p>
The special comment <span class="machine"><span class="font-tt">(**/**)</span></span> tells OCamldoc to discard
elements placed after this comment, up to the end of the current
class, class type, module or module type, or up to the next stop comment.
For instance:

</p><div class="caml-example signature">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">class</span> <span class="ocamlkeyword">type</span> foo =
  <span class="ocamlkeyword">object</span>
    <span class="ocamlcomment">(** comment for method m *)</span>
    <span class="ocamlkeyword">method</span> m : string

    <span class="ocamlcomment">(**/**)</span>

    <span class="ocamlcomment">(** This method won't appear in the documentation *)</span>
    <span class="ocamlkeyword">method</span> bar : int
  <span class="ocamlkeyword">end</span>

<span class="ocamlcomment">(** This value appears in the documentation, since the Stop special comment
    in the class does not affect the parent module of the class.*)</span>
<span class="ocamlkeyword">val</span> foo : string

<span class="ocamlcomment">(**/**)</span>
<span class="ocamlcomment">(** The value bar does not appear in the documentation.*)</span>
<span class="ocamlkeyword">val</span> bar : string
<span class="ocamlcomment">(**/**)</span>

<span class="ocamlcomment">(** The type t appears since in the documentation since the previous stop comment
toggled off the "no documentation mode". *)</span>
<span class="ocamlkeyword">type</span> t = string</div></div>

</div><p>The <span class="font-bold"><span class="font-tt">-no-stop</span></span> option to <span class="machine"><span class="font-tt">ocamldoc</span></span> causes the Stop special
comments to be ignored.</p>
<!--TOC subsection id="ss:ocamldoc-syntax" 19.2.3â€ƒSyntax of documentation comments-->
<h3 class="subsection" id="ss:ocamldoc-syntax"><a class="section-anchor" href="#ss:ocamldoc-syntax" aria-hidden="true">ï»¿</a>19.2.3â€ƒSyntax of documentation comments</h3><!--SEC END --><p>The inside of documentation comments <span class="machine"><span class="font-tt">(**</span></span>â€¦<span class="machine"><span class="font-tt">*)</span></span> consists of
free-form text with optional formatting annotations, followed by
optional <em>tags</em> giving more specific information about parameters,
version, authors, â€¦ The tags are distinguished by a leading <span class="machine"><span class="font-tt">@</span></span>
character. Thus, a documentation comment has the following shape:
</p><pre>(** The comment begins with a description, which is text formatted
   according to the rules described in the next section.
   The description continues until the first non-escaped '@' character.
   @author Mr Smith
   @param x description for parameter x
*)
</pre><p>Some elements support only a subset of all @-tags. Tags that are not
relevant to the documented element are simply ignored. For instance,
all tags are ignored when documenting type constructors, record
fields, and class inheritance clauses. Similarly, a <span class="machine"><span class="font-tt">@param</span></span> tag on a
class instance variable is ignored.</p><p>At last, <span class="machine"><span class="font-tt">(**)</span></span> is the empty documentation comment.</p>
<!--TOC subsection id="ss:ocamldoc-formatting" 19.2.4â€ƒText formatting-->
<h3 class="subsection" id="ss:ocamldoc-formatting"><a class="section-anchor" href="#ss:ocamldoc-formatting" aria-hidden="true">ï»¿</a>19.2.4â€ƒText formatting</h3><!--SEC END --><p>Here is the BNF grammar for the simple markup language used to format
text descriptions.</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="text"><span class="nonterminal">text</span></a></td><td class="c005">::=</td><td class="c007">â€„{<a class="syntax" href="#text-element"><span class="nonterminal">text-element</span></a>}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="inline-text"><span class="nonterminal">inline-text</span></a></td><td class="c005">::=</td><td class="c007">â€„{<a class="syntax" href="#inline-text-element"><span class="nonterminal">inline-text-element</span></a>}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</table></td></tr>
</table></div><div class="syntaxleft"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="text-element"><span class="nonterminal">text-element</span></a></td><td class="c005">::=</td></tr>
</table></div><table class="c001 cellpading0"><tr><td class="c014">âˆ£</td><td class="c013"><a class="syntax" href="#inline-text-element"><span class="nonterminal">inline-text-element</span></a></td><td class="c010">&nbsp;</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"><span class="nonterminal">blank-line</span></td><td class="c010">force a new line. </td></tr>
</table><p><br>

</p><div class="syntaxleft"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="inline-text-element"><span class="nonterminal">inline-text-element</span></a></td><td class="c005">::=</td></tr>
</table></div><table class="c001 cellpading0"><tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{</span> { <span class="syntax-token">0</span> â€¦ <span class="syntax-token">9</span> }<sup>+</sup> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">format <a class="syntax" href="#text"><span class="nonterminal">text</span></a> as a section header;
the integer following <span class="machine"><span class="font-tt">{</span></span> indicates the sectioning level. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{</span> { <span class="syntax-token">0</span> â€¦ <span class="syntax-token">9</span> }<sup>+</sup> <span class="syntax-token">:</span>  <span class="nonterminal">label</span>  <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010"> same, but also associate the name <span class="nonterminal">label</span> to the current point.
This point can be referenced by its fully-qualified label in a
<span class="machine"><span class="font-tt">{!</span></span> command, just like any other element. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{b</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">set <a class="syntax" href="#text"><span class="nonterminal">text</span></a> in bold. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{i</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">set <a class="syntax" href="#text"><span class="nonterminal">text</span></a> in italic. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{e</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">emphasize <a class="syntax" href="#text"><span class="nonterminal">text</span></a>. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{C</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">center <a class="syntax" href="#text"><span class="nonterminal">text</span></a>. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{L</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">left align <a class="syntax" href="#text"><span class="nonterminal">text</span></a>. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{R</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">right align <a class="syntax" href="#text"><span class="nonterminal">text</span></a>. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{ul</span> <a class="syntax" href="#list"><span class="nonterminal">list</span></a> <span class="syntax-token">}</span> </td><td class="c010">build a list. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{ol</span> <a class="syntax" href="#list"><span class="nonterminal">list</span></a> <span class="syntax-token">}</span> </td><td class="c010">build an enumerated list. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{{:</span> <span class="nonterminal">string</span> <span class="syntax-token">}</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">put a link to the given address
(given as <span class="nonterminal">string</span>) on the given <a class="syntax" href="#text"><span class="nonterminal">text</span></a>. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">[</span> <span class="nonterminal">string</span> <span class="syntax-token">]</span> </td><td class="c010">set the given <span class="nonterminal">string</span> in source code style. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{[</span> <span class="nonterminal">string</span> <span class="syntax-token">]}</span> </td><td class="c010">set the given <span class="nonterminal">string</span> in preformatted
				source code style.</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{v</span> <span class="nonterminal">string</span> <span class="syntax-token">v}</span> </td><td class="c010">set the given <span class="nonterminal">string</span> in verbatim style. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{%</span> <span class="nonterminal">string</span> <span class="syntax-token">%}</span> </td><td class="c010">target-specific content
(L<sup>A</sup>T<sub>E</sub>X code by default, see details
in <a href="#sss%3Aocamldoc-target-specific-syntax">19.2.4.4</a>) </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{!</span> <span class="nonterminal">string</span> <span class="syntax-token">}</span> </td><td class="c010">insert a cross-reference to an element
(see section <a href="#sss%3Aocamldoc-crossref">19.2.4.2</a> for the syntax of cross-references).</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{{!</span> <span class="nonterminal">string</span> <span class="syntax-token">}</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">insert a cross-reference with the given text. </td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{!modules:</span> <span class="nonterminal">string</span> <span class="nonterminal">string</span> ... <span class="syntax-token">}</span> </td><td class="c010">insert an index table
for the given module names. Used in HTML only.</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{!indexlist}</span> </td><td class="c010">insert a table of links to the various indexes
(types, values, modules, ...). Used in HTML only.</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{^</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">set text in superscript.</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"> <span class="syntax-token">{_</span> <a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a> <span class="syntax-token">}</span> </td><td class="c010">set text in subscript.</td></tr>
<tr><td class="c014">âˆ£</td><td class="c013"><span class="nonterminal">escaped-string</span></td><td class="c010">typeset the given string as is;
special characters (â€™<span class="machine"><span class="font-tt">{</span></span>â€™, â€™<span class="machine"><span class="font-tt">}</span></span>â€™, â€™<span class="machine"><span class="font-tt">[</span></span>â€™, â€™<span class="machine"><span class="font-tt">]</span></span>â€™ and â€™<span class="machine"><span class="font-tt">@</span></span>â€™)
must be	escaped by a â€™<span class="machine"><span class="font-tt">\</span></span>â€™</td></tr>
</table><p> <br>

</p>
<!--TOC subsubsection id="sss:ocamldoc-list" 19.2.4.1â€ƒList formatting-->
<h4 class="subsubsection" id="sss:ocamldoc-list"><a class="section-anchor" href="#sss:ocamldoc-list" aria-hidden="true">ï»¿</a>19.2.4.1â€ƒList formatting</h4><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="list"><span class="nonterminal">list</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„{â€„<span class="syntax-token">{-</span>â€„<a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a>â€„<span class="syntax-token">}</span>â€„}<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„{â€„<span class="syntax-token">{li</span>â€„<a class="syntax" href="#inline-text"><span class="nonterminal">inline-text</span></a>â€„<span class="syntax-token">}</span>â€„}<sup>+</sup>
</td></tr>
</table></td></tr>
</table></div><p>A shortcut syntax exists for lists and enumerated lists:
</p><pre>(** Here is a {b list}
- item 1
- item 2
- item 3

The list is ended by the blank line.*)
</pre><p>is equivalent to:
</p><pre>(** Here is a {b list}
{ul {- item 1}
{- item 2}
{- item 3}}
The list is ended by the blank line.*)
</pre><p>
The same shortcut is available for enumerated lists, using â€™<span class="machine"><span class="font-tt">+</span></span>â€™
instead of â€™<span class="machine"><span class="font-tt">-</span></span>â€™.
Note that only one list can be defined by this shortcut in nested lists.</p>
<!--TOC subsubsection id="sss:ocamldoc-crossref" 19.2.4.2â€ƒCross-reference formatting-->
<h4 class="subsubsection" id="sss:ocamldoc-crossref"><a class="section-anchor" href="#sss:ocamldoc-crossref" aria-hidden="true">ï»¿</a>19.2.4.2â€ƒCross-reference formatting</h4><!--SEC END --><p>Cross-references are fully qualified element names, as in the example
<span class="machine"><span class="font-tt">{!Foo.Bar.t}</span></span>. This is an ambiguous reference as it may designate
a type name, a value name, a class name, etc. It is possible to make
explicit the intended syntactic class, using <span class="machine"><span class="font-tt">{!type:Foo.Bar.t}</span></span> to
designate a type, and <span class="machine"><span class="font-tt">{!val:Foo.Bar.t}</span></span> a value of the same name.</p><p>The list of possible syntactic class is as follows:
</p><div class="center">
<table class="c001 cellpading0"><tr><td class="c005"><span class="machine"><span class="font-tt">tag</span></span></td><td class="c005">syntactic class</td></tr>
<tr><td class="hrule" colspan=2></td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">module:</span></span></td><td class="c007">module </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">modtype:</span></span></td><td class="c007">module type </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">class:</span></span></td><td class="c007">class </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">classtype:</span></span></td><td class="c007">class type </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">val:</span></span></td><td class="c007">value </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">type:</span></span></td><td class="c007">type </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">exception:</span></span></td><td class="c007">exception </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">attribute:</span></span></td><td class="c007">attribute </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">method:</span></span></td><td class="c007">class method </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">section:</span></span></td><td class="c007">ocamldoc section </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">const:</span></span></td><td class="c007">variant constructor </td></tr>
<tr><td class="c008"><span class="machine"><span class="font-tt">recfield:</span></span></td><td class="c007">record field
</td></tr>
</table>
</div><p>In the case of variant constructors or record field, the constructor
or field name should be preceded by the name of the correspond type â€“
to avoid the ambiguity of several types having the same constructor
names. For example, the constructor <span class="machine"><span class="font-tt">Node</span></span> of the type <span class="machine"><span class="font-tt">tree</span></span> will be
referenced as <span class="machine"><span class="font-tt">{!tree.Node}</span></span> or <span class="machine"><span class="font-tt">{!const:tree.Node}</span></span>, or possibly
<span class="machine"><span class="font-tt">{!Mod1.Mod2.tree.Node}</span></span> from outside the module.</p>
<!--TOC subsubsection id="sss:ocamldoc-preamble" 19.2.4.3â€ƒFirst sentence-->
<h4 class="subsubsection" id="sss:ocamldoc-preamble"><a class="section-anchor" href="#sss:ocamldoc-preamble" aria-hidden="true">ï»¿</a>19.2.4.3â€ƒFirst sentence</h4><!--SEC END --><p>In the description of a value, type, exception, module, module type, class
or class type, the <em>first sentence</em> is sometimes used in indexes, or
when just a part of the description is needed. The first sentence
is composed of the first characters of the description, until
</p><ul class="itemize"><li class="li-itemize">the first dot followed by a blank, or
</li><li class="li-itemize">the first blank line
</li></ul><p>
outside of the following text formatting :
 <span class="syntax-token">{ul</span> <a class="syntax" href="#list"><span class="nonterminal">list</span></a> <span class="syntax-token">}</span> ,
 <span class="syntax-token">{ol</span> <a class="syntax" href="#list"><span class="nonterminal">list</span></a> <span class="syntax-token">}</span> ,
 <span class="syntax-token">[</span> <span class="nonterminal">string</span> <span class="syntax-token">]</span> ,
 <span class="syntax-token">{[</span> <span class="nonterminal">string</span> <span class="syntax-token">]}</span> ,
 <span class="syntax-token">{v</span> <span class="nonterminal">string</span> <span class="syntax-token">v}</span> ,
 <span class="syntax-token">{%</span> <span class="nonterminal">string</span> <span class="syntax-token">%}</span> ,
 <span class="syntax-token">{!</span> <span class="nonterminal">string</span> <span class="syntax-token">}</span> ,
 <span class="syntax-token">{^</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> <span class="syntax-token">}</span> ,
 <span class="syntax-token">{_</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> <span class="syntax-token">}</span> .</p>
<!--TOC subsubsection id="sss:ocamldoc-target-specific-syntax" 19.2.4.4â€ƒTarget-specific formatting-->
<h4 class="subsubsection" id="sss:ocamldoc-target-specific-syntax"><a class="section-anchor" href="#sss:ocamldoc-target-specific-syntax" aria-hidden="true">ï»¿</a>19.2.4.4â€ƒTarget-specific formatting</h4><!--SEC END --><p>The content inside <span class="machine"><span class="font-tt">{%foo: ... %}</span></span> is target-specific and will only be
interpreted by the backend <span class="machine"><span class="font-tt">foo</span></span>, and ignored by the others. The
backends of the distribution are <span class="machine"><span class="font-tt">latex</span></span>, <span class="machine"><span class="font-tt">html</span></span>, <span class="machine"><span class="font-tt">texi</span></span> and <span class="machine"><span class="font-tt">man</span></span>. If
no target is specified (syntax <span class="machine"><span class="font-tt">{% ... %}</span></span>), <span class="machine"><span class="font-tt">latex</span></span> is chosen by
default. Custom generators may support their own target prefix.</p>
<!--TOC subsubsection id="sss:ocamldoc-html-tags" 19.2.4.5â€ƒRecognized HTML tags-->
<h4 class="subsubsection" id="sss:ocamldoc-html-tags"><a class="section-anchor" href="#sss:ocamldoc-html-tags" aria-hidden="true">ï»¿</a>19.2.4.5â€ƒRecognized HTML tags</h4><!--SEC END --><p>
The HTML tags <span class="machine"><span class="font-tt">&lt;b&gt;..&lt;/b&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;code&gt;..&lt;/code&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;i&gt;..&lt;/i&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;ul&gt;..&lt;/ul&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;ol&gt;..&lt;/ol&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;li&gt;..&lt;/li&gt;</span></span>,
<span class="machine"><span class="font-tt">&lt;center&gt;..&lt;/center&gt;</span></span> and
<span class="machine"><span class="font-tt">&lt;h[0-9]&gt;..&lt;/h[0-9]&gt;</span></span> can be used instead of, respectively,
 <span class="syntax-token">{b ..}</span> ,
 <span class="syntax-token">[..]</span> ,
 <span class="syntax-token">{i ..}</span> ,
 <span class="syntax-token">{ul ..}</span> ,
 <span class="syntax-token">{ol ..}</span> ,
 <span class="syntax-token">{li ..}</span> ,
 <span class="syntax-token">{C ..}</span>  and
<span class="machine"><span class="font-tt">{[0-9] ..}</span></span>.</p>
<!--TOC subsection id="ss:ocamldoc-tags" 19.2.5â€ƒDocumentation tags (@-tags)-->
<h3 class="subsection" id="ss:ocamldoc-tags"><a class="section-anchor" href="#ss:ocamldoc-tags" aria-hidden="true">ï»¿</a>19.2.5â€ƒDocumentation tags (@-tags)</h3><!--SEC END -->
<!--TOC subsubsection id="sss:ocamldoc-builtin-tags" Predefined tags-->
<h4 class="subsubsection" id="sss:ocamldoc-builtin-tags"><a class="section-anchor" href="#sss:ocamldoc-builtin-tags" aria-hidden="true">ï»¿</a>Predefined tags</h4><!--SEC END --><p>
The following table gives the list of predefined @-tags, with their
syntax and meaning.<br>

</p><table class="cellpadding1" border=1 style="border-spacing:0;"><tr><td class="c011"> <span class="syntax-token">@author</span> <span class="nonterminal">string</span> </td><td class="c011">The author of the element. One author per
<span class="machine"><span class="font-tt">@author</span></span> tag.
There may be several <span class="machine"><span class="font-tt">@author</span></span> tags for the same element. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@deprecated</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">The <a class="syntax" href="#text"><span class="nonterminal">text</span></a> should describe when the element was
deprecated, what to use as a replacement, and possibly the reason
for deprecation. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@param</span> <span class="nonterminal">id</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Associate the given description (<a class="syntax" href="#text"><span class="nonterminal">text</span></a>) to the
given parameter name <span class="nonterminal">id</span>. This tag is used for functions,
methods, classes and functors. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@raise</span> <span class="nonterminal">Exc</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Explain that the element may raise
the exception <span class="nonterminal">Exc</span>. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@return</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Describe the return value and
its possible values. This tag is used for functions
and methods. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@see</span> <span class="syntax-token">&lt;</span> <span class="nonterminal">URL</span> <span class="syntax-token">&gt;</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Add a reference to the <span class="nonterminal">URL</span>
with the given <a class="syntax" href="#text"><span class="nonterminal">text</span></a> as comment. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@see</span> <span class="syntax-token">'</span><span class="nonterminal">filename</span><span class="syntax-token">'</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Add a reference to the given file name
(written between single quotes), with the given <a class="syntax" href="#text"><span class="nonterminal">text</span></a> as comment. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@see</span> <span class="syntax-token">"</span><span class="nonterminal">document-name</span><span class="syntax-token">"</span> <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Add a reference to the given
document name (written between double quotes), with the given <a class="syntax" href="#text"><span class="nonterminal">text</span></a>
as comment. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@since</span> <span class="nonterminal">string</span> </td><td class="c011">Indicate when the element was introduced. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@before</span>  <span class="nonterminal">version</span>  <a class="syntax" href="#text"><span class="nonterminal">text</span></a> </td><td class="c011">Associate the given description (<a class="syntax" href="#text"><span class="nonterminal">text</span></a>)
to the given <span class="nonterminal">version</span> in order to document compatibility issues. </td></tr>
<tr><td class="c011">
 <span class="syntax-token">@version</span> <span class="nonterminal">string</span> </td><td class="c011">The version number for the element. </td></tr>
</table>
<!--TOC subsubsection id="sss:ocamldoc-custom-tags" Custom tags-->
<h4 class="subsubsection" id="sss:ocamldoc-custom-tags"><a class="section-anchor" href="#sss:ocamldoc-custom-tags" aria-hidden="true">ï»¿</a>Custom tags</h4><!--SEC END --><p>
You can use custom tags in the documentation comments, but they will
have no effect if the generator used does not handle them. To use a
custom tag, for example <span class="machine"><span class="font-tt">foo</span></span>, just put <span class="machine"><span class="font-tt">@foo</span></span> with some text in your
comment, as in:
</p><pre>(** My comment to show you a custom tag.
@foo this is the text argument to the [foo] custom tag.
*)
</pre><p>
To handle custom tags, you need to define a custom generator,
as explained in section <a href="#ss%3Aocamldoc-handling-custom-tags">19.3.2</a>.</p>
<!--TOC section id="s:ocamldoc-custom-generators" 19.3â€ƒCustom generators-->
<h2 class="section" id="s:ocamldoc-custom-generators"><a class="section-anchor" href="#s:ocamldoc-custom-generators" aria-hidden="true">ï»¿</a>19.3â€ƒCustom generators</h2><!--SEC END --><p>OCamldoc operates in two steps:
</p><ol class="enumerate" type=1><li class="li-enumerate">analysis of the source files;
</li><li class="li-enumerate">generation of documentation, through a documentation generator,
	which is an object of class <span class="machine"><span class="font-tt">Odoc_args.class_generator</span></span>.
</li></ol><p>
Users can provide their own documentation generator to be used during
step 2 instead of the default generators.
All the information retrieved during the analysis step is available through
the <span class="machine"><span class="font-tt">Odoc_info</span></span> module, which gives access to all the types and functions
representing the elements found in the given modules, with their associated
description.</p><p>The files you can use to define custom generators are installed in the
<span class="machine"><span class="font-tt">ocamldoc</span></span> sub-directory of the OCaml standard library.</p>
<!--TOC subsection id="ss:ocamldoc-generators" 19.3.1â€ƒThe generator modules-->
<h3 class="subsection" id="ss:ocamldoc-generators"><a class="section-anchor" href="#ss:ocamldoc-generators" aria-hidden="true">ï»¿</a>19.3.1â€ƒThe generator modules</h3><!--SEC END --><p>
The type of a generator module depends on the kind of generated documentation.
Here is the list of generator module types, with the name of the generator
class in the moduleÂ :
</p><ul class="itemize"><li class="li-itemize">for HTMLÂ : <span class="machine"><span class="font-tt">Odoc_html.Html_generator</span></span> (class <span class="machine"><span class="font-tt">html</span></span>),
</li><li class="li-itemize">for L<sup>A</sup>T<sub>E</sub>XÂ : <span class="machine"><span class="font-tt">Odoc_latex.Latex_generator</span></span> (class <span class="machine"><span class="font-tt">latex</span></span>),
</li><li class="li-itemize">for TeXinfoÂ : <span class="machine"><span class="font-tt">Odoc_texi.Texi_generator</span></span> (class <span class="machine"><span class="font-tt">texi</span></span>),
</li><li class="li-itemize">for man pagesÂ : <span class="machine"><span class="font-tt">Odoc_man.Man_generator</span></span> (class <span class="machine"><span class="font-tt">man</span></span>),
</li><li class="li-itemize">for graphviz (dot)Â : <span class="machine"><span class="font-tt">Odoc_dot.Dot_generator</span></span> (class <span class="machine"><span class="font-tt">dot</span></span>),
</li><li class="li-itemize">for other kindsÂ : <span class="machine"><span class="font-tt">Odoc_gen.Base</span></span> (class <span class="machine"><span class="font-tt">generator</span></span>).
</li></ul><p>
That is, to define a new generator, one must implement a module with
the expected signature, and with the given generator class, providing
the <span class="machine"><span class="font-tt">generate</span></span> method as entry point to make the generator generates
documentation for a given list of modulesÂ :</p><pre>        method generate : Odoc_info.Module.t_module list -&gt; unit
</pre><p>
This method will be called with the list of analysed and possibly
merged <span class="machine"><span class="font-tt">Odoc_info.t_module</span></span> structures.</p><p>It is recommended to inherit from the current generator of the same
kind as the one you want to define. Doing so, it is possible to
load various custom generators to combine improvements brought by each one.</p><p>This is done using first class modules (see chapter <a href="#s%3Afirst-class-modules">12.5</a>).</p><p>The easiest way to define a custom generator is the following this example,
here extending the current HTML generator. We donâ€™t have to know if this is
the original HTML generator defined in ocamldoc or if it has been extended
already by a previously loaded custom generatorÂ :</p><pre>module Generator (G : Odoc_html.Html_generator) =
struct
  class html =
    object(self)
      inherit G.html as html
      (* ... *)

      method generate module_list =
        (* ... *)
        ()

      (* ... *)
  end
end;;

let _ = Odoc_args.extend_html_generator (module Generator : Odoc_gen.Html_functor);;
</pre><p>
To know which methods to override and/or which methods are available,
have a look at the different base implementations, depending on the
kind of generator you are extendingÂ :

</p><ul class="itemize"><li class="li-itemize">for HTMLÂ : <a href="https://github.com/ocaml/ocaml/blob/5.0/ocamldoc/odoc_html.ml"><span class="machine"><span class="font-tt">odoc_html.ml</span></span></a>,
</li><li class="li-itemize">for L<sup>A</sup>T<sub>E</sub>XÂ : <a href="https://github.com/ocaml/ocaml/blob/5.0/ocamldoc/odoc_latex.ml"><span class="machine"><span class="font-tt">odoc_latex.ml</span></span></a>,
</li><li class="li-itemize">for TeXinfoÂ : <a href="https://github.com/ocaml/ocaml/blob/5.0/ocamldoc/odoc_texi.ml"><span class="machine"><span class="font-tt">odoc_texi.ml</span></span></a>,
</li><li class="li-itemize">for man pagesÂ : <a href="https://github.com/ocaml/ocaml/blob/5.0/ocamldoc/odoc_man.ml"><span class="machine"><span class="font-tt">odoc_man.ml</span></span></a>,
</li><li class="li-itemize">for graphviz (dot)Â : <a href="https://github.com/ocaml/ocaml/blob/5.0/ocamldoc/odoc_dot.ml"><span class="machine"><span class="font-tt">odoc_dot.ml</span></span></a>.
</li></ul>
<!--TOC subsection id="ss:ocamldoc-handling-custom-tags" 19.3.2â€ƒHandling custom tags-->
<h3 class="subsection" id="ss:ocamldoc-handling-custom-tags"><a class="section-anchor" href="#ss:ocamldoc-handling-custom-tags" aria-hidden="true">ï»¿</a>19.3.2â€ƒHandling custom tags</h3><!--SEC END --><p>Making a custom generator handle custom tags (see
<a href="#sss%3Aocamldoc-custom-tags">19.2.5</a>) is very simple.</p><!--TOC subsubsection id="sss:ocamldoc-html-generator" For HTML-->
<h4 class="subsubsection" id="sss:ocamldoc-html-generator"><a class="section-anchor" href="#sss:ocamldoc-html-generator" aria-hidden="true">ï»¿</a>For HTML</h4><!--SEC END --><p>
Here is how to develop a HTML generator handling your custom tags.</p><p>The class <span class="machine"><span class="font-tt">Odoc_html.Generator.html</span></span> inherits
from the class <span class="machine"><span class="font-tt">Odoc_html.info</span></span>, containing a field <span class="machine"><span class="font-tt">tag_functions</span></span> which is a
list pairs composed of a custom tag (e.g. <span class="machine"><span class="font-tt">"foo"</span></span>) and a function taking
a <span class="machine"><span class="font-tt">text</span></span> and returning HTML code (of type <span class="machine"><span class="font-tt">string</span></span>).
To handle a new tag <span class="machine"><span class="font-tt">bar</span></span>, extend the current HTML generator
and complete the <span class="machine"><span class="font-tt">tag_functions</span></span> field:
</p><pre>module Generator (G : Odoc_html.Html_generator) =
struct
  class html =
    object(self)
      inherit G.html

      (** Return HTML code for the given text of a bar tag. *)
      method html_of_bar t = (* your code here *)

      initializer
        tag_functions &lt;- ("bar", self#html_of_bar) :: tag_functions
  end
end
let _ = Odoc_args.extend_html_generator (module Generator : Odoc_gen.Html_functor);;
</pre><p>
Another method of the class <span class="machine"><span class="font-tt">Odoc_html.info</span></span> will look for the
function associated to a custom tag and apply it to the text given to
the tag. If no function is associated to a custom tag, then the method
prints a warning message on <span class="machine"><span class="font-tt">stderr</span></span>.</p>
<!--TOC subsubsection id="sss:ocamldoc-other-generators" For other generators-->
<h4 class="subsubsection" id="sss:ocamldoc-other-generators"><a class="section-anchor" href="#sss:ocamldoc-other-generators" aria-hidden="true">ï»¿</a>For other generators</h4><!--SEC END --><p>
You can act the same way for other kinds of generators.</p>
<!--TOC section id="s:ocamldoc-adding-flags" 19.4â€ƒAdding command line options-->
<h2 class="section" id="s:ocamldoc-adding-flags"><a class="section-anchor" href="#s:ocamldoc-adding-flags" aria-hidden="true">ï»¿</a>19.4â€ƒAdding command line options</h2><!--SEC END --><p>
The command line analysis is performed after loading the module containing the
documentation generator, thus allowing command line options to be added to the
list of existing ones. Adding an option can be done with the function
</p><pre>        Odoc_args.add_option : string * Arg.spec * string -&gt; unit
</pre><p>Note: Existing command line options can be redefined using
this function.</p>
<!--TOC subsection id="ss:ocamldoc-compilation-and-usage" 19.4.1â€ƒCompilation and usage-->
<h3 class="subsection" id="ss:ocamldoc-compilation-and-usage"><a class="section-anchor" href="#ss:ocamldoc-compilation-and-usage" aria-hidden="true">ï»¿</a>19.4.1â€ƒCompilation and usage</h3><!--SEC END -->
<!--TOC subsubsection id="sss:ocamldoc-generator-class" Defining a custom generator class in one file-->
<h4 class="subsubsection" id="sss:ocamldoc-generator-class"><a class="section-anchor" href="#sss:ocamldoc-generator-class" aria-hidden="true">ï»¿</a>Defining a custom generator class in one file</h4><!--SEC END --><p>
Let <span class="machine"><span class="font-tt">custom.ml</span></span> be the file defining a new generator class.
Compilation of <span class="machine"><span class="font-tt">custom.ml</span></span> can be performed by the following commandÂ :
</p><pre>
        ocamlc -I +ocamldoc -c custom.ml
</pre><p>
The file <span class="machine"><span class="font-tt">custom.cmo</span></span> is created and can be used this wayÂ :
</p><pre>
        ocamldoc -g custom.cmo <span class="font-it">other-options</span> <span class="font-it">source-files</span>
</pre><p>
Options selecting a built-in generator to <span class="machine"><span class="font-tt">ocamldoc</span></span>, such as
<span class="machine"><span class="font-tt">-html</span></span>, have no effect if a custom generator of the same kind is provided using
<span class="machine"><span class="font-tt">-g</span></span>. If the kinds do not match, the selected built-in generator is used and the
custom one is ignored.</p>
<!--TOC subsubsection id="sss:ocamldoc-modular-generator" Defining a custom generator class in several files-->
<h4 class="subsubsection" id="sss:ocamldoc-modular-generator"><a class="section-anchor" href="#sss:ocamldoc-modular-generator" aria-hidden="true">ï»¿</a>Defining a custom generator class in several files</h4><!--SEC END --><p>
It is possible to define a generator class in several modules, which
are defined in several files <span class="font-it">file</span><sub>1</sub><span class="machine"><span class="font-tt">.ml</span></span>[<span class="machine"><span class="font-tt">i</span></span>],
<span class="font-it">file</span><sub>2</sub><span class="machine"><span class="font-tt">.ml</span></span>[<span class="machine"><span class="font-tt">i</span></span>], ..., <span class="font-it">file</span><sub><span class="font-it">n</span></sub><span class="machine"><span class="font-tt">.ml</span></span>[<span class="machine"><span class="font-tt">i</span></span>]. A <span class="machine"><span class="font-tt">.cma</span></span>
library file must be created, including all these files.</p><p>The following commands create the <span class="machine"><span class="font-tt">custom.cma</span></span> file from files
<span class="font-it">file</span><sub>1</sub><span class="machine"><span class="font-tt">.ml</span></span>[<span class="machine"><span class="font-tt">i</span></span>], ..., <span class="font-it">file</span><sub><span class="font-it">n</span></sub><span class="machine"><span class="font-tt">.ml</span></span>[<span class="machine"><span class="font-tt">i</span></span>]Â :
</p><pre>
ocamlc -I +ocamldoc -c <span class="font-it">file</span><sub>1</sub>.ml[i]
ocamlc -I +ocamldoc -c <span class="font-it">file</span><sub>2</sub>.ml[i]
...
ocamlc -I +ocamldoc -c <span class="font-it">file</span><sub><span class="font-it">n</span></sub>.ml[i]
ocamlc -o custom.cma -a <span class="font-it">file</span><sub>1</sub>.cmo <span class="font-it">file</span><sub>2</sub>.cmo ... <span class="font-it">file</span><sub><span class="font-it">n</span></sub>.cmo
</pre><p>
Then, the following command uses <span class="machine"><span class="font-tt">custom.cma</span></span> as custom generator:
</p><pre>
        ocamldoc -g custom.cma <span class="font-it">other-options</span> <span class="font-it">source-files</span>
</pre>
<!--TOC chapter id="sec431" ChapterÂ 20â€ƒThe debugger (ocamldebug)-->
<h1 class="chapter" id="sec431">ChapterÂ 20â€ƒThe debugger (ocamldebug)</h1><!--SEC END --><p> <a id="c:debugger"></a>
</p><!--NAME debugger.html-->
<p>This chapter describes the OCaml source-level replay debugger
<span class="machine"><span class="font-tt">ocamldebug</span></span>.</p><blockquote class="quote"><span class="osvariant">Unix:</span>â€ƒ The debugger is available on Unix systems that provide
BSD sockets.
</blockquote><blockquote class="quote"><span class="osvariant">Windows:</span>â€ƒ The debugger is available under the Cygwin port of
OCaml, but not under the native Win32 ports.
</blockquote>
<!--TOC section id="s:debugger-compilation" 20.1â€ƒCompiling for debugging-->
<h2 class="section" id="s:debugger-compilation"><a class="section-anchor" href="#s:debugger-compilation" aria-hidden="true">ï»¿</a>20.1â€ƒCompiling for debugging</h2><!--SEC END --><p>Before the debugger can be used, the program must be compiled and
linked with the <span class="machine"><span class="font-tt">-g</span></span> option: all <span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span> files that are part
of the program should have been created with <span class="machine"><span class="font-tt">ocamlc -g</span></span>, and they
must be linked together with <span class="machine"><span class="font-tt">ocamlc -g</span></span>.</p><p>Compiling with <span class="machine"><span class="font-tt">-g</span></span> entails no penalty on the running time of
programs: object files and bytecode executable files are bigger and
take longer to produce, but the executable files run at
exactly the same speed as if they had been compiled without <span class="machine"><span class="font-tt">-g</span></span>.</p>
<!--TOC section id="s:debugger-invocation" 20.2â€ƒInvocation-->
<h2 class="section" id="s:debugger-invocation"><a class="section-anchor" href="#s:debugger-invocation" aria-hidden="true">ï»¿</a>20.2â€ƒInvocation</h2><!--SEC END -->
<!--TOC subsection id="ss:debugger-start" 20.2.1â€ƒStarting the debugger-->
<h3 class="subsection" id="ss:debugger-start"><a class="section-anchor" href="#ss:debugger-start" aria-hidden="true">ï»¿</a>20.2.1â€ƒStarting the debugger</h3><!--SEC END --><p>The OCaml debugger is invoked by running the program
<span class="machine"><span class="font-tt">ocamldebug</span></span> with the name of the bytecode executable file as first
argument:
</p><pre>
        ocamldebug [<span class="font-it">options</span>] <span class="font-it">program</span> [<span class="font-it">arguments</span>]
</pre><p>
The arguments following <span class="font-it">program</span> are optional, and are passed as
command-line arguments to the program being debugged. (See also the
<span class="machine"><span class="font-tt">set arguments</span></span> command.)</p><p>The following command-line options are recognized:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-c </span></span> <span class="font-it">count</span></span></dt><dd class="dd-description">
Set the maximum number of simultaneously live checkpoints to <span class="font-it">count</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cd </span></span> <span class="font-it">dir</span></span></dt><dd class="dd-description">
Run the debugger program from the working directory <span class="font-it">dir</span>,
instead of the current directory. (See also the <span class="machine"><span class="font-tt">cd</span></span> command.)</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-emacs</span></span></span></dt><dd class="dd-description">
Tell the debugger it is executed under Emacs. (See
sectionÂ <a href="#s%3Ainf-debugger">20.10</a> for information on how to run the
debugger under Emacs.)</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-I </span></span><span class="font-it">directory</span></span></dt><dd class="dd-description">
Add <span class="font-it">directory</span> to the list of directories searched for source
files and compiled files. (See also the <span class="machine"><span class="font-tt">directory</span></span> command.)</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-s </span></span><span class="font-it">socket</span></span></dt><dd class="dd-description">
Use <span class="font-it">socket</span> for communicating with the debugged program. See the
description of the command <span class="machine"><span class="font-tt">set socket</span></span> (sectionÂ <a href="#ss%3Adebugger-communication">20.8.8</a>)
for the format of <span class="font-it">socket</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.
</dd></dl>
<!--TOC subsection id="ss:debugger-init-file" 20.2.2â€ƒInitialization file-->
<h3 class="subsection" id="ss:debugger-init-file"><a class="section-anchor" href="#ss:debugger-init-file" aria-hidden="true">ï»¿</a>20.2.2â€ƒInitialization file</h3><!--SEC END --><p>On start-up, the debugger will read commands from an initialization
file before giving control to the user. The default file is
<span class="machine"><span class="font-tt">.ocamldebug</span></span> in the current directory if it exists, otherwise
<span class="machine"><span class="font-tt">.ocamldebug</span></span> in the userâ€™s home directory.</p>
<!--TOC subsection id="ss:debugger-exut" 20.2.3â€ƒExiting the debugger-->
<h3 class="subsection" id="ss:debugger-exut"><a class="section-anchor" href="#ss:debugger-exut" aria-hidden="true">ï»¿</a>20.2.3â€ƒExiting the debugger</h3><!--SEC END --><p>The command <span class="machine"><span class="font-tt">quit</span></span> exits the debugger. You can also exit the debugger
by typing an end-of-file character (usually <span class="machine"><span class="font-tt">ctrl-D</span></span>).</p><p>Typing an interrupt character (usually <span class="machine"><span class="font-tt">ctrl-C</span></span>) will not exit the
debugger, but will terminate the action of any debugger command that is in
progress and return to the debugger command level.</p>
<!--TOC section id="s:debugger-commands" 20.3â€ƒCommands-->
<h2 class="section" id="s:debugger-commands"><a class="section-anchor" href="#s:debugger-commands" aria-hidden="true">ï»¿</a>20.3â€ƒCommands</h2><!--SEC END --><p>A debugger command is a single line of input. It starts with a command
name, which is followed by arguments depending on this name. Examples:
</p><pre>        run
        goto 1000
        set arguments arg1 arg2
</pre><p>
A command name can be truncated as long as there is no ambiguity. For
instance, <span class="machine"><span class="font-tt">go 1000</span></span> is understood as <span class="machine"><span class="font-tt">goto 1000</span></span>, since there are no
other commands whose name starts with <span class="machine"><span class="font-tt">go</span></span>. For the most frequently
used commands, ambiguous abbreviations are allowed. For instance, <span class="machine"><span class="font-tt">r</span></span>
stands for <span class="machine"><span class="font-tt">run</span></span> even though there are others commands starting with
<span class="machine"><span class="font-tt">r</span></span>. You can test the validity of an abbreviation using the <span class="machine"><span class="font-tt">help</span></span> command.</p><p>If the previous command has been successful, a blank line (typing just
<span class="machine"><span class="font-tt">RET</span></span>) will repeat it.</p>
<!--TOC subsection id="ss:debugger-help" 20.3.1â€ƒGetting help-->
<h3 class="subsection" id="ss:debugger-help"><a class="section-anchor" href="#ss:debugger-help" aria-hidden="true">ï»¿</a>20.3.1â€ƒGetting help</h3><!--SEC END --><p>The OCaml debugger has a simple on-line help system, which gives
a brief description of each command and variable.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">help</span></span></span></dt><dd class="dd-description">
Print the list of commands.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">help </span></span><span class="font-it">command</span></span></dt><dd class="dd-description">
Give help about the command <span class="font-it">command</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">help set </span></span><span class="font-it">variable</span>, <span class="machine"><span class="font-tt">help show </span></span><span class="font-it">variable</span></span></dt><dd class="dd-description">
Give help about the variable <span class="font-it">variable</span>. The list of all debugger
variables can be obtained with <span class="machine"><span class="font-tt">help set</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">help info </span></span><span class="font-it">topic</span></span></dt><dd class="dd-description">
Give help about <span class="font-it">topic</span>. Use <span class="machine"><span class="font-tt">help info</span></span> to get a list of known topics.
</dd></dl>
<!--TOC subsection id="ss:debugger-state" 20.3.2â€ƒAccessing the debugger state-->
<h3 class="subsection" id="ss:debugger-state"><a class="section-anchor" href="#ss:debugger-state" aria-hidden="true">ï»¿</a>20.3.2â€ƒAccessing the debugger state</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set </span></span><span class="font-it">variable</span> <span class="font-it">value</span></span></dt><dd class="dd-description">
Set the debugger variable <span class="font-it">variable</span> to the value <span class="font-it">value</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">show </span></span><span class="font-it">variable</span></span></dt><dd class="dd-description">
Print the value of the debugger variable <span class="font-it">variable</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">info </span></span><span class="font-it">subject</span></span></dt><dd class="dd-description">
Give information about the given subject.
For instance, <span class="machine"><span class="font-tt">info breakpoints</span></span> will print the list of all breakpoints.
</dd></dl>
<!--TOC section id="s:debugger-execution" 20.4â€ƒExecuting a program-->
<h2 class="section" id="s:debugger-execution"><a class="section-anchor" href="#s:debugger-execution" aria-hidden="true">ï»¿</a>20.4â€ƒExecuting a program</h2><!--SEC END -->
<!--TOC subsection id="ss:debugger-events" 20.4.1â€ƒEvents-->
<h3 class="subsection" id="ss:debugger-events"><a class="section-anchor" href="#ss:debugger-events" aria-hidden="true">ï»¿</a>20.4.1â€ƒEvents</h3><!--SEC END --><p>Events are â€œinterestingâ€ locations in the source code, corresponding
to the beginning or end of evaluation of â€œinterestingâ€
sub-expressions. Events are the unit of single-stepping (stepping goes
to the next or previous event encountered in the program execution).
Also, breakpoints can only be set at events. Thus, events play the
role of line numbers in debuggers for conventional languages.</p><p>During program execution, a counter is incremented at each event
encountered. The value of this counter is referred as the <em>current
time</em>. Thanks to reverse execution, it is possible to jump back and
forth to any time of the execution.</p><p>Here is where the debugger events (written â‹ˆ) are located in
the source code:
</p><ul class="itemize"><li class="li-itemize">Following a function application:
<pre>
(f arg)â‹ˆ
</pre>
</li><li class="li-itemize">On entrance to a function:
<pre>
fun x y z -&gt; â‹ˆ ...
</pre>
</li><li class="li-itemize">On each case of a pattern-matching definition (function,
<span class="machine"><span class="font-tt">match</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span> construct, <span class="machine"><span class="font-tt">try</span></span>â€¦<span class="machine"><span class="font-tt">with</span></span> construct):
<pre>
function pat1 -&gt; â‹ˆ expr1
       | ...
       | patN -&gt; â‹ˆ exprN
</pre>
</li><li class="li-itemize">Between subexpressions of a sequence:
<pre>
expr1; â‹ˆ expr2; â‹ˆ ...; â‹ˆ exprN
</pre>
</li><li class="li-itemize">In the two branches of a conditional expression:
<pre>
if cond then â‹ˆ expr1 else â‹ˆ expr2
</pre>
</li><li class="li-itemize">At the beginning of each iteration of a loop:
<pre>
while cond do â‹ˆ body done
for i = a to b do â‹ˆ body done
</pre>
</li></ul><p>
Exceptions: A function application followed by a function return is replaced
by the compiler by a jump (tail-call optimization). In this case, no
event is put after the function application.
</p>
<!--TOC subsection id="ss:debugger-starting-program" 20.4.2â€ƒStarting the debugged program-->
<h3 class="subsection" id="ss:debugger-starting-program"><a class="section-anchor" href="#ss:debugger-starting-program" aria-hidden="true">ï»¿</a>20.4.2â€ƒStarting the debugged program</h3><!--SEC END --><p>The debugger starts executing the debugged program only when needed.
This allows setting breakpoints or assigning debugger variables before
execution starts. There are several ways to start execution:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">run</span></span></span></dt><dd class="dd-description"> Run the program until a breakpoint is hit, or the program
terminates.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">goto 0</span></span></span></dt><dd class="dd-description"> Load the program and stop on the first event.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">goto </span></span><span class="font-it">time</span></span></dt><dd class="dd-description"> Load the program and execute it until the
given time. Useful when you already know approximately at what time
the problem appears. Also useful to set breakpoints on function values
that have not been computed at time 0 (see sectionÂ <a href="#s%3Abreakpoints">20.5</a>).
</dd></dl><p>The execution of a program is affected by certain information it
receives when the debugger starts it, such as the command-line
arguments to the program and its working directory. The debugger
provides commands to specify this information (<span class="machine"><span class="font-tt">set arguments</span></span> and <span class="machine"><span class="font-tt">cd</span></span>).
These commands must be used before program execution starts. If you try
to change the arguments or the working directory after starting your
program, the debugger will kill the program (after asking for confirmation).</p>
<!--TOC subsection id="ss:debugger-running" 20.4.3â€ƒRunning the program-->
<h3 class="subsection" id="ss:debugger-running"><a class="section-anchor" href="#ss:debugger-running" aria-hidden="true">ï»¿</a>20.4.3â€ƒRunning the program</h3><!--SEC END --><p>The following commands execute the program forward or backward,
starting at the current time. The execution will stop either when
specified by the command or when a breakpoint is encountered.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">run</span></span></span></dt><dd class="dd-description"> Execute the program forward from current time. Stops at
next breakpoint or when the program terminates.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">reverse</span></span></span></dt><dd class="dd-description"> Execute the program backward from current time.
Mostly useful to go to the last breakpoint encountered before the
current time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">step </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description"> Run the program and stop at the next
event. With an argument, do it <span class="font-it">count</span> times. If <span class="font-it">count</span> is 0,
run until the program terminates or a breakpoint is hit.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">backstep </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description"> Run the program backward and stop at
the previous event. With an argument, do it <span class="font-it">count</span> times.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">next </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description"> Run the program and stop at the next
event, skipping over function calls. With an argument, do it
<span class="font-it">count</span> times.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">previous </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description"> Run the program backward and stop at
the previous event, skipping over function calls. With an argument, do
it <span class="font-it">count</span> times.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">finish</span></span></span></dt><dd class="dd-description"> Run the program until the current function returns.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">start</span></span></span></dt><dd class="dd-description"> Run the program backward and stop at the first event
before the current function invocation.
</dd></dl>
<!--TOC subsection id="ss:debugger-time-travel" 20.4.4â€ƒTime travel-->
<h3 class="subsection" id="ss:debugger-time-travel"><a class="section-anchor" href="#ss:debugger-time-travel" aria-hidden="true">ï»¿</a>20.4.4â€ƒTime travel</h3><!--SEC END --><p>You can jump directly to a given time, without stopping on
breakpoints, using the <span class="machine"><span class="font-tt">goto</span></span> command.</p><p>As you move through the program, the debugger maintains an history of
the successive times you stop at. The <span class="machine"><span class="font-tt">last</span></span> command can be used to
revisit these times: each <span class="machine"><span class="font-tt">last</span></span> command moves one step back through
the history. That is useful mainly to undo commands such as <span class="machine"><span class="font-tt">step</span></span>
and <span class="machine"><span class="font-tt">next</span></span>.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">goto </span></span><span class="font-it">time</span></span></dt><dd class="dd-description">
Jump to the given time.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">last </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description">
Go back to the latest time recorded in the execution history. With an
argument, do it <span class="font-it">count</span> times.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set history </span></span><span class="font-it">size</span></span></dt><dd class="dd-description">
Set the size of the execution history.
</dd></dl>
<!--TOC subsection id="ss:debugger-kill" 20.4.5â€ƒKilling the program-->
<h3 class="subsection" id="ss:debugger-kill"><a class="section-anchor" href="#ss:debugger-kill" aria-hidden="true">ï»¿</a>20.4.5â€ƒKilling the program</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">kill</span></span></span></dt><dd class="dd-description"> Kill the program being executed. This command is mainly
useful if you wish to recompile the program without leaving the debugger.
</dd></dl>
<!--TOC section id="s:breakpoints" 20.5â€ƒBreakpoints-->
<h2 class="section" id="s:breakpoints"><a class="section-anchor" href="#s:breakpoints" aria-hidden="true">ï»¿</a>20.5â€ƒBreakpoints</h2><!--SEC END --><p>A breakpoint causes the program to stop whenever a certain point in
the program is reached. It can be set in several ways using the
<span class="machine"><span class="font-tt">break</span></span> command. Breakpoints are assigned numbers when set, for
further reference. The most comfortable way to set breakpoints is
through the Emacs interface (see sectionÂ <a href="#s%3Ainf-debugger">20.10</a>).</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break</span></span></span></dt><dd class="dd-description">
Set a breakpoint at the current position in the program execution. The
current position must be on an event (i.e., neither at the beginning,
nor at the end of the program).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break </span></span><span class="font-it">function</span></span></dt><dd class="dd-description">
Set a breakpoint at the beginning of <span class="font-it">function</span>. This works only
when the functional value of the identifier <span class="font-it">function</span> has been
computed and assigned to the identifier. Hence this command cannot be
used at the very beginning of the program execution, when all
identifiers are still undefined; use <span class="machine"><span class="font-tt">goto</span></span> <span class="font-it">time</span> to advance
execution until the functional value is available.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break @</span></span> [<span class="font-it">module</span>] <span class="font-it">line</span></span></dt><dd class="dd-description">
Set a breakpoint in module <span class="font-it">module</span> (or in the current module if
<span class="font-it">module</span> is not given), at the first event of line <span class="font-it">line</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break @</span></span> [<span class="font-it">module</span>] <span class="font-it">line</span> <span class="font-it">column</span></span></dt><dd class="dd-description">
Set a breakpoint in module <span class="font-it">module</span> (or in the current module if
<span class="font-it">module</span> is not given), at the event closest to line <span class="font-it">line</span>,
column <span class="font-it">column</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break @</span></span> [<span class="font-it">module</span>] <span class="machine"><span class="font-tt">#</span></span> <span class="font-it">character</span></span></dt><dd class="dd-description">
Set a breakpoint in module <span class="font-it">module</span> at the event closest to
character number <span class="font-it">character</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">break </span></span> <span class="font-it">frag</span><span class="machine"><span class="font-tt">:</span></span><span class="font-it">pc</span>, <span class="machine"><span class="font-tt">break </span></span> <span class="font-it">pc</span></span></dt><dd class="dd-description">
Set a breakpoint at code address <span class="font-it">frag</span><span class="machine"><span class="font-tt">:</span></span><span class="font-it">pc</span>. The integer
<span class="font-it">frag</span> is the identifier of a code fragment, a set of modules that
have been loaded at once, either initially or with the <span class="machine"><span class="font-tt">Dynlink</span></span>
module. The integer <span class="font-it">pc</span> is the instruction counter within this
code fragment. If <span class="font-it">frag</span> is omitted, it defaults to 0, which is
the code fragment of the program loaded initially.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">delete </span></span>[<span class="font-it">breakpoint-numbers</span>]</span></dt><dd class="dd-description">
Delete the specified breakpoints. Without argument, all breakpoints
are deleted (after asking for confirmation).</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">info breakpoints</span></span></span></dt><dd class="dd-description"> Print the list of all breakpoints.
</dd></dl>
<!--TOC section id="s:debugger-callstack" 20.6â€ƒThe call stack-->
<h2 class="section" id="s:debugger-callstack"><a class="section-anchor" href="#s:debugger-callstack" aria-hidden="true">ï»¿</a>20.6â€ƒThe call stack</h2><!--SEC END --><p>Each time the program performs a function application, it saves the
location of the application (the return address) in a block of data
called a stack frame. The frame also contains the local variables of
the caller function. All the frames are allocated in a region of
memory called the call stack. The command <span class="machine"><span class="font-tt">backtrace</span></span> (or <span class="machine"><span class="font-tt">bt</span></span>)
displays parts of the call stack.</p><p>At any time, one of the stack frames is â€œselectedâ€ by the debugger; several
debugger commands refer implicitly to the selected frame. In particular,
whenever you ask the debugger for the value of a local variable, the
value is found in the selected frame. The commands <span class="machine"><span class="font-tt">frame</span></span>, <span class="machine"><span class="font-tt">up</span></span> and <span class="machine"><span class="font-tt">down</span></span>
select whichever frame you are interested in.</p><p>When the program stops, the debugger automatically selects the
currently executing frame and describes it briefly as the <span class="machine"><span class="font-tt">frame</span></span>
command does.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">frame</span></span></span></dt><dd class="dd-description">
Describe the currently selected stack frame.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">frame</span></span> <span class="font-it">frame-number</span></span></dt><dd class="dd-description">
Select a stack frame by number and describe it. The frame currently
executing when the program stopped has number 0; its caller has number
1; and so on up the call stack.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">backtrace </span></span>[<span class="font-it">count</span>], <span class="machine"><span class="font-tt">bt </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description">
Print the call stack. This is useful to see which sequence of function
calls led to the currently executing frame. With a positive argument,
print only the innermost <span class="font-it">count</span> frames.
With a negative argument, print only the outermost -<span class="font-it">count</span> frames.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">up</span></span> [<span class="font-it">count</span>]</span></dt><dd class="dd-description">
Select and display the stack frame just â€œaboveâ€ the selected frame,
that is, the frame that called the selected frame. An argument says how
many frames to go up.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">down </span></span>[<span class="font-it">count</span>]</span></dt><dd class="dd-description">
Select and display the stack frame just â€œbelowâ€ the selected frame,
that is, the frame that was called by the selected frame. An argument
says how many frames to go down.
</dd></dl>
<!--TOC section id="s:debugger-examining-values" 20.7â€ƒExamining variable values-->
<h2 class="section" id="s:debugger-examining-values"><a class="section-anchor" href="#s:debugger-examining-values" aria-hidden="true">ï»¿</a>20.7â€ƒExamining variable values</h2><!--SEC END --><p>The debugger can print the current value of simple expressions. The
expressions can involve program variables: all the identifiers that
are in scope at the selected program point can be accessed.</p><p>Expressions that can be printed are a subset of OCaml
expressions, as described by the following grammar:
</p><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" id="simple-expr"><span class="nonterminal">simple-expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„{â€„<a class="syntax" href="#capitalized-ident"><span class="nonterminal">capitalized-ident</span></a>â€„<span class="syntax-token">.</span>â€„}â€„<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">*</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">$</span>â€„<span class="nonterminal">integer</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#simple-expr"><span class="nonterminal">simple-expr</span></a>â€„<span class="syntax-token">.</span>â€„<a class="syntax" href="#lowercase-ident"><span class="nonterminal">lowercase-ident</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#simple-expr"><span class="nonterminal">simple-expr</span></a>â€„<span class="syntax-token">.(</span>â€„<span class="nonterminal">integer</span>â€„<span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<a class="syntax" href="#simple-expr"><span class="nonterminal">simple-expr</span></a>â€„<span class="syntax-token">.[</span>â€„<span class="nonterminal">integer</span>â€„<span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">!</span>â€„<a class="syntax" href="#simple-expr"><span class="nonterminal">simple-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">(</span>â€„<a class="syntax" href="#simple-expr"><span class="nonterminal">simple-expr</span></a>â€„<span class="syntax-token">)</span>
</td></tr>
</table></td></tr>
</table></div><p>
The first two cases refer to a value identifier, either unqualified or
qualified by the path to the structure that define it.
<span class="machine"><span class="font-tt">*</span></span> refers to the result just computed (typically, the value of a
function application), and is valid only if the selected event is an
â€œafterâ€ event (typically, a function application).
<span class="syntax-token">$</span> <span class="nonterminal">integer</span> refer to a previously printed value. The remaining four
forms select part of an expression: respectively, a record field, an
array element, a string element, and the current contents of a
reference.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">print </span></span><span class="font-it">variables</span></span></dt><dd class="dd-description">
Print the values of the given variables. <span class="machine"><span class="font-tt">print</span></span> can be abbreviated as
<span class="machine"><span class="font-tt">p</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">display </span></span><span class="font-it">variables</span></span></dt><dd class="dd-description">
Same as <span class="machine"><span class="font-tt">print</span></span>, but limit the depth of printing to 1. Useful to
browse large data structures without printing them in full.
<span class="machine"><span class="font-tt">display</span></span> can be abbreviated as <span class="machine"><span class="font-tt">d</span></span>.
</dd></dl><p>When printing a complex expression, a name of the form <span class="machine"><span class="font-tt">$</span></span><span class="font-it">integer</span>
is automatically assigned to its value. Such names are also assigned
to parts of the value that cannot be printed because the maximal
printing depth is exceeded. Named values can be printed later on
with the commands <span class="machine"><span class="font-tt">p $</span></span><span class="font-it">integer</span> or <span class="machine"><span class="font-tt">d $</span></span><span class="font-it">integer</span>.
Named values are valid only as long as the program is stopped. They
are forgotten as soon as the program resumes execution.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set print_depth</span></span> <span class="font-it">d</span></span></dt><dd class="dd-description">
Limit the printing of values to a maximal depth of <span class="font-it">d</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set print_length</span></span> <span class="font-it">l</span></span></dt><dd class="dd-description">
Limit the printing of values to at most <span class="font-it">l</span> nodes printed.
</dd></dl>
<!--TOC section id="s:debugger-control" 20.8â€ƒControlling the debugger-->
<h2 class="section" id="s:debugger-control"><a class="section-anchor" href="#s:debugger-control" aria-hidden="true">ï»¿</a>20.8â€ƒControlling the debugger</h2><!--SEC END -->
<!--TOC subsection id="ss:debugger-name-and-arguments" 20.8.1â€ƒSetting the program name and arguments-->
<h3 class="subsection" id="ss:debugger-name-and-arguments"><a class="section-anchor" href="#ss:debugger-name-and-arguments" aria-hidden="true">ï»¿</a>20.8.1â€ƒSetting the program name and arguments</h3><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set program</span></span> <span class="font-it">file</span></span></dt><dd class="dd-description">
Set the program name to <span class="font-it">file</span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set arguments</span></span> <span class="font-it">arguments</span></span></dt><dd class="dd-description">
Give <span class="font-it">arguments</span> as command-line arguments for the program.
</dd></dl><p>A shell is used to pass the arguments to the debugged program. You can
therefore use wildcards, shell variables, and file redirections inside
the arguments. To debug programs that read from standard input, it is
recommended to redirect their input from a file (using
<span class="machine"><span class="font-tt">set arguments &lt; input-file</span></span>), otherwise input to the program and
input to the debugger are not properly separated, and inputs are not
properly replayed when running the program backwards.</p>
<!--TOC subsection id="ss:debugger-loading" 20.8.2â€ƒHow programs are loaded-->
<h3 class="subsection" id="ss:debugger-loading"><a class="section-anchor" href="#ss:debugger-loading" aria-hidden="true">ï»¿</a>20.8.2â€ƒHow programs are loaded</h3><!--SEC END --><p>The <span class="machine"><span class="font-tt">loadingmode</span></span> variable controls how the program is executed.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set loadingmode direct</span></span></span></dt><dd class="dd-description">
The program is run directly by the debugger. This is the default mode.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set loadingmode runtime</span></span></span></dt><dd class="dd-description">
The debugger execute the OCaml runtime <span class="machine"><span class="font-tt">ocamlrun</span></span> on the program.
Rarely useful; moreover it prevents the debugging of programs compiled
in â€œcustom runtimeâ€ mode.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set loadingmode manual</span></span></span></dt><dd class="dd-description">
The user starts manually the program, when asked by the debugger.
Allows remote debugging (see sectionÂ <a href="#ss%3Adebugger-communication">20.8.8</a>).
</dd></dl>
<!--TOC subsection id="ss:debugger-search-path" 20.8.3â€ƒSearch path for files-->
<h3 class="subsection" id="ss:debugger-search-path"><a class="section-anchor" href="#ss:debugger-search-path" aria-hidden="true">ï»¿</a>20.8.3â€ƒSearch path for files</h3><!--SEC END --><p>The debugger searches for source files and compiled interface files in
a list of directories, the search path. The search path initially
contains the current directory <span class="machine"><span class="font-tt">.</span></span> and the standard library directory.
The <span class="machine"><span class="font-tt">directory</span></span> command adds directories to the path.</p><p>Whenever the search path is modified, the debugger will clear any
information it may have cached about the files.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">directory</span></span> <span class="font-it">directorynames</span></span></dt><dd class="dd-description">
Add the given directories to the search path. These directories are
added at the front, and will therefore be searched first.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">directory</span></span> <span class="font-it">directorynames</span> <span class="machine"><span class="font-tt">for</span></span> <span class="font-it">modulename</span></span></dt><dd class="dd-description">
Same as <span class="machine"><span class="font-tt">directory</span></span> <span class="font-it">directorynames</span>, but the given directories will be
searched only when looking for the source file of a module that has 
been packed into <span class="font-it">modulename</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">directory</span></span></span></dt><dd class="dd-description">
Reset the search path. This requires confirmation.
</dd></dl>
<!--TOC subsection id="ss:debugger-working-dir" 20.8.4â€ƒWorking directory-->
<h3 class="subsection" id="ss:debugger-working-dir"><a class="section-anchor" href="#ss:debugger-working-dir" aria-hidden="true">ï»¿</a>20.8.4â€ƒWorking directory</h3><!--SEC END --><p>Each time a program is started in the debugger, it inherits its working
directory from the current working directory of the debugger. This
working directory is initially whatever it inherited from its parent
process (typically the shell), but you can specify a new working
directory in the debugger with the <span class="machine"><span class="font-tt">cd</span></span> command or the <span class="machine"><span class="font-tt">-cd</span></span>
command-line option.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">cd</span></span> <span class="font-it">directory</span></span></dt><dd class="dd-description">
Set the working directory for <span class="machine"><span class="font-tt">ocamldebug</span></span> to <span class="font-it">directory</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">pwd</span></span></span></dt><dd class="dd-description">
Print the working directory for <span class="machine"><span class="font-tt">ocamldebug</span></span>.
</dd></dl>
<!--TOC subsection id="ss:debugger-reverse-execution" 20.8.5â€ƒTurning reverse execution on and off-->
<h3 class="subsection" id="ss:debugger-reverse-execution"><a class="section-anchor" href="#ss:debugger-reverse-execution" aria-hidden="true">ï»¿</a>20.8.5â€ƒTurning reverse execution on and off</h3><!--SEC END --><p>In some cases, you may want to turn reverse execution off. This speeds
up the program execution, and is also sometimes useful for interactive
programs.</p><p>Normally, the debugger takes checkpoints of the program state from
time to time. That is, it makes a copy of the current state of the
program (using the Unix system call <span class="machine"><span class="font-tt">fork</span></span>). If the variable
<span class="font-it">checkpoints</span> is set to <span class="machine"><span class="font-tt">off</span></span>, the debugger will not take any
checkpoints.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set checkpoints</span></span> <span class="font-it">on/off</span></span></dt><dd class="dd-description">
Select whether the debugger makes checkpoints or not.
</dd></dl>
<!--TOC subsection id="ss:debugger-fork" 20.8.6â€ƒBehavior of the debugger with respect to <span class="machine"><span class="font-tt">fork</span></span>-->
<h3 class="subsection" id="ss:debugger-fork"><a class="section-anchor" href="#ss:debugger-fork" aria-hidden="true">ï»¿</a>20.8.6â€ƒBehavior of the debugger with respect to <span class="machine"><span class="font-tt">fork</span></span></h3><!--SEC END --><p>When the program issues a call to <span class="machine"><span class="font-tt">fork</span></span>, the debugger can either
follow the child or the parent. By default, the debugger follows the
parent process. The variable <span class="font-it">follow_fork_mode</span> controls this
behavior:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set follow_fork_mode</span></span> <span class="font-it">child/parent</span></span></dt><dd class="dd-description">
Select whether to follow the child or the parent in case of a call to
<span class="machine"><span class="font-tt">fork</span></span>.
</dd></dl>
<!--TOC subsection id="ss:debugger-stop-at-new-load" 20.8.7â€ƒStopping execution when new code is loaded-->
<h3 class="subsection" id="ss:debugger-stop-at-new-load"><a class="section-anchor" href="#ss:debugger-stop-at-new-load" aria-hidden="true">ï»¿</a>20.8.7â€ƒStopping execution when new code is loaded</h3><!--SEC END --><p>The debugger is compatible with the <span class="machine"><span class="font-tt">Dynlink</span></span> module. However, when an
external module is not yet loaded, it is impossible to set a
breakpoint in its code. In order to facilitate setting breakpoints in
dynamically loaded code, the debugger stops the program each time new
modules are loaded. This behavior can be disabled using the
<span class="font-it">break_on_load</span> variable:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set break_on_load</span></span> <span class="font-it">on/off</span></span></dt><dd class="dd-description">
Select whether to stop after loading new code.
</dd></dl>
<!--TOC subsection id="ss:debugger-communication" 20.8.8â€ƒCommunication between the debugger and the program-->
<h3 class="subsection" id="ss:debugger-communication"><a class="section-anchor" href="#ss:debugger-communication" aria-hidden="true">ï»¿</a>20.8.8â€ƒCommunication between the debugger and the program</h3><!--SEC END --><p>The debugger communicate with the program being debugged through a
Unix socket. You may need to change the socket name, for example if
you need to run the debugger on a machine and your program on another.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set socket</span></span> <span class="font-it">socket</span></span></dt><dd class="dd-description">
Use <span class="font-it">socket</span> for communication with the program. <span class="font-it">socket</span> can be
either a file name, or an Internet port specification
<span class="font-it">host</span>:<span class="font-it">port</span>, where <span class="font-it">host</span> is a host name or an Internet
address in dot notation, and <span class="font-it">port</span> is a port number on the host.
</dd></dl><p>On the debugged program side, the socket name is passed through the
<span class="machine"><span class="font-tt">CAML_DEBUG_SOCKET</span></span> environment variable.</p>
<!--TOC subsection id="ss:debugger-fine-tuning" 20.8.9â€ƒFine-tuning the debugger-->
<h3 class="subsection" id="ss:debugger-fine-tuning"><a class="section-anchor" href="#ss:debugger-fine-tuning" aria-hidden="true">ï»¿</a>20.8.9â€ƒFine-tuning the debugger</h3><!--SEC END --><p>Several variables enables to fine-tune the debugger. Reasonable
defaults are provided, and you should normally not have to change them.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set processcount</span></span> <span class="font-it">count</span></span></dt><dd class="dd-description">
Set the maximum number of checkpoints to <span class="font-it">count</span>. More checkpoints
facilitate going far back in time, but use more memory and create more
Unix processes.
</dd></dl><p>As checkpointing is quite expensive, it must not be done too often. On
the other hand, backward execution is faster when checkpoints are
taken more often. In particular, backward single-stepping is more
responsive when many checkpoints have been taken just before the
current time. To fine-tune the checkpointing strategy, the debugger
does not take checkpoints at the same frequency for long displacements
(e.g. <span class="machine"><span class="font-tt">run</span></span>) and small ones (e.g. <span class="machine"><span class="font-tt">step</span></span>). The two variables <span class="machine"><span class="font-tt">bigstep</span></span>
and <span class="machine"><span class="font-tt">smallstep</span></span> contain the number of events between two checkpoints
in each case.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set bigstep</span></span> <span class="font-it">count</span></span></dt><dd class="dd-description">
Set the number of events between two checkpoints for long displacements.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">set smallstep</span></span> <span class="font-it">count</span></span></dt><dd class="dd-description">
Set the number of events between two checkpoints for small
displacements.
</dd></dl><p>The following commands display information on checkpoints and events:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">info checkpoints</span></span></span></dt><dd class="dd-description">
Print a list of checkpoints.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">info events</span></span> [<span class="font-it">module</span>]</span></dt><dd class="dd-description">
Print the list of events in the given module (the current module, by default).
</dd></dl>
<!--TOC subsection id="ss:debugger-printers" 20.8.10â€ƒUser-defined printers-->
<h3 class="subsection" id="ss:debugger-printers"><a class="section-anchor" href="#ss:debugger-printers" aria-hidden="true">ï»¿</a>20.8.10â€ƒUser-defined printers</h3><!--SEC END --><p>Just as in the toplevel system (sectionÂ <a href="#s%3Atoplevel-directives">14.2</a>),
the user can register functions for printing values of certain types.
For technical reasons, the debugger cannot call printing functions
that reside in the program being debugged. The code for the printing
functions must therefore be loaded explicitly in the debugger.</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">load_printer "</span></span><span class="font-it">file-name</span><span class="machine"><span class="font-tt">"</span></span></span></dt><dd class="dd-description">
Load in the debugger the indicated <span class="machine"><span class="font-tt">.cmo</span></span> or <span class="machine"><span class="font-tt">.cma</span></span> object file. The
file is loaded in an environment consisting only of the OCaml
standard library plus the definitions provided by object files
previously loaded using <span class="machine"><span class="font-tt">load_printer</span></span>. If this file depends on other
object files not yet loaded, the debugger automatically loads them if
it is able to find them in the search path. The loaded file does not
have direct access to the modules of the program being debugged.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">install_printer </span></span><span class="font-it">printer-name</span></span></dt><dd class="dd-description">
Register the function named <span class="font-it">printer-name</span> (a
value path) as a printer for objects whose types match the argument
type of the function. That is, the debugger will call
<span class="font-it">printer-name</span> when it has such an object to print.
The printing function <span class="font-it">printer-name</span> must use the <span class="machine"><span class="font-tt">Format</span></span> library
module to produce its output, otherwise its output will not be
correctly located in the values printed by the toplevel loop.<p>The value path <span class="font-it">printer-name</span> must refer to one of the functions
defined by the object files loaded using <span class="machine"><span class="font-tt">load_printer</span></span>. It cannot
reference the functions of the program being debugged.</p></dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">remove_printer </span></span><span class="font-it">printer-name</span></span></dt><dd class="dd-description">
Remove the named function from the table of value printers.
</dd></dl>
<!--TOC section id="s:debugger-misc-cmds" 20.9â€ƒMiscellaneous commands-->
<h2 class="section" id="s:debugger-misc-cmds"><a class="section-anchor" href="#s:debugger-misc-cmds" aria-hidden="true">ï»¿</a>20.9â€ƒMiscellaneous commands</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">list</span></span> [<span class="font-it">module</span>] [<span class="font-it">beginning</span>] [<span class="font-it">end</span>]</span></dt><dd class="dd-description">
List the source of module <span class="font-it">module</span>, from line number
<span class="font-it">beginning</span> to line number <span class="font-it">end</span>. By default, 20 lines of the
current module are displayed, starting 10 lines before the current
position.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">source</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read debugger commands from the script <span class="font-it">filename</span>.
</dd></dl>
<!--TOC section id="s:inf-debugger" 20.10â€ƒRunning the debugger under Emacs-->
<h2 class="section" id="s:inf-debugger"><a class="section-anchor" href="#s:inf-debugger" aria-hidden="true">ï»¿</a>20.10â€ƒRunning the debugger under Emacs</h2><!--SEC END --><p>The most user-friendly way to use the debugger is to run it under Emacs with
the OCaml mode available through MELPA and also at
<a href="https://github.com/ocaml/caml-mode"><span class="font-tt">https://github.com/ocaml/caml-mode</span></a>.</p><p>The OCaml debugger is started under Emacs by the command <span class="machine"><span class="font-tt">M-x camldebug</span></span>, with argument the name of the executable file
<span class="font-it">progname</span> to debug. Communication with the debugger takes place
in an Emacs buffer named <span class="machine"><span class="font-tt">*camldebug-</span></span><span class="font-it">progname</span><span class="machine"><span class="font-tt">*</span></span>. The editing
and history facilities of Shell mode are available for interacting
with the debugger.</p><p>In addition, Emacs displays the source files containing the current
event (the current position in the program execution) and highlights
the location of the event. This display is updated synchronously with
the debugger action.</p><p>The following bindings for the most common debugger commands are
available in the <span class="machine"><span class="font-tt">*camldebug-</span></span><span class="font-it">progname</span><span class="machine"><span class="font-tt">*</span></span> buffer:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-s</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">step</span></span>): execute the program one step forward.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-k</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">backstep</span></span>): execute the program one step backward.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-n</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">next</span></span>): execute the program one step
forward, skipping over function calls.
</dd><dt class="dt-description"><span class="font-bold">Middle mouse button</span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">display</span></span>): display named value.
<span class="machine"><span class="font-tt">$</span></span><span class="font-it">n</span> under mouse cursor (support incremental browsing of large
data structures).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-p</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">print</span></span>): print value of identifier at point.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-d</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">display</span></span>): display value of identifier at point.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-r</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">run</span></span>): execute the program forward to next
breakpoint.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-v</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">reverse</span></span>): execute the program backward to
latest breakpoint.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-l</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">last</span></span>): go back one step in the command history.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-t</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">backtrace</span></span>): display backtrace of function calls.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c C-f</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">finish</span></span>): run forward till the current
function returns.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c &lt;</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">up</span></span>): select the stack frame below the
current frame.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-c &gt;</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">down</span></span>): select the stack frame above the
current frame.
</dd></dl><p>In all buffers in OCaml editing mode, the following debugger commands
are also available:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-x C-a C-b</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">break</span></span>): set a breakpoint at event closest
to point
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-x C-a C-p</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">print</span></span>): print value of identifier at point
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">C-x C-a C-d</span></span></span></dt><dd class="dd-description"> (command <span class="machine"><span class="font-tt">display</span></span>): display value of identifier at point
</dd></dl>
<!--TOC chapter id="sec462" ChapterÂ 21â€ƒProfiling (ocamlprof)-->
<h1 class="chapter" id="sec462">ChapterÂ 21â€ƒProfiling (ocamlprof)</h1><!--SEC END --><p> <a id="c:profiler"></a>
</p><!--NAME profil.html-->
<p>This chapter describes how the execution of OCaml
programs can be profiled, by recording how many times functions are
called, branches of conditionals are taken, â€¦</p>
<!--TOC section id="s:ocamlprof-compiling" 21.1â€ƒCompiling for profiling-->
<h2 class="section" id="s:ocamlprof-compiling"><a class="section-anchor" href="#s:ocamlprof-compiling" aria-hidden="true">ï»¿</a>21.1â€ƒCompiling for profiling</h2><!--SEC END --><p>Before profiling an execution, the program must be compiled in
profiling mode, using the <span class="machine"><span class="font-tt">ocamlcp</span></span> front-end to the <span class="machine"><span class="font-tt">ocamlc</span></span> compiler
(see chapterÂ <a href="#c%3Acamlc">13</a>) or the <span class="machine"><span class="font-tt">ocamloptp</span></span> front-end to the
<span class="machine"><span class="font-tt">ocamlopt</span></span> compiler (see chapterÂ <a href="#c%3Anativecomp">16</a>). When compiling
modules separately, <span class="machine"><span class="font-tt">ocamlcp</span></span> or <span class="machine"><span class="font-tt">ocamloptp</span></span> must be used when
compiling the modules (production of <span class="machine"><span class="font-tt">.cmo</span></span> or <span class="machine"><span class="font-tt">.cmx</span></span> files), and can
also be used (though this is not strictly necessary) when linking them
together.</p>
<!--TOC paragraph id="p:ocamlprof-warning" Note-->
<h5 class="paragraph" id="p:ocamlprof-warning"><a class="section-anchor" href="#p:ocamlprof-warning" aria-hidden="true">ï»¿</a>Note</h5><!--SEC END --><p> If a module (<span class="machine"><span class="font-tt">.ml</span></span> file) doesnâ€™t have a corresponding
interface (<span class="machine"><span class="font-tt">.mli</span></span> file), then compiling it with <span class="machine"><span class="font-tt">ocamlcp</span></span> will produce
object files (<span class="machine"><span class="font-tt">.cmi</span></span> and <span class="machine"><span class="font-tt">.cmo</span></span>) that are not compatible with the ones
produced by <span class="machine"><span class="font-tt">ocamlc</span></span>, which may lead to problems (if the <span class="machine"><span class="font-tt">.cmi</span></span> or
<span class="machine"><span class="font-tt">.cmo</span></span> is still around) when switching between profiling and
non-profiling compilations. To avoid this problem, you should always
have a <span class="machine"><span class="font-tt">.mli</span></span> file for each <span class="machine"><span class="font-tt">.ml</span></span> file. The same problem exists with
<span class="machine"><span class="font-tt">ocamloptp</span></span>.</p>
<!--TOC paragraph id="p:ocamlprof-reserved" Note-->
<h5 class="paragraph" id="p:ocamlprof-reserved"><a class="section-anchor" href="#p:ocamlprof-reserved" aria-hidden="true">ï»¿</a>Note</h5><!--SEC END --><p> To make sure your programs can be compiled in
profiling mode, avoid using any identifier that begins with
<span class="machine"><span class="font-tt">__ocaml_prof</span></span>.</p><p>The amount of profiling information can be controlled through the <span class="machine"><span class="font-tt">-P</span></span>
option to <span class="machine"><span class="font-tt">ocamlcp</span></span> or <span class="machine"><span class="font-tt">ocamloptp</span></span>, followed by one or several letters
indicating which parts of the program should be profiled:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">a</span></span></span></dt><dd class="dd-description"> all options
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">f</span></span></span></dt><dd class="dd-description"> function calls : a count point is set at the beginning of
each function body
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">i</span></span></span></dt><dd class="dd-description"> <span class="font-bold">if â€¦then â€¦else â€¦</span> : count points are set in
both <span class="font-bold">then</span> branch and <span class="font-bold">else</span> branch
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">l</span></span></span></dt><dd class="dd-description"> <span class="font-bold">while, for</span> loops: a count point is set at the beginning of
the loop body
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">m</span></span></span></dt><dd class="dd-description"> <span class="font-bold">match</span> branches: a count point is set at the beginning of the
body of each branch
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">t</span></span></span></dt><dd class="dd-description"> <span class="font-bold">try â€¦with â€¦</span> branches: a count point is set at the
beginning of the body of each branch
</dd></dl><p>For instance, compiling with <span class="machine"><span class="font-tt">ocamlcp -P film</span></span> profiles function calls,
ifâ€¦thenâ€¦elseâ€¦, loops and pattern matching.</p><p>Calling <span class="machine"><span class="font-tt">ocamlcp</span></span> or <span class="machine"><span class="font-tt">ocamloptp</span></span> without the <span class="machine"><span class="font-tt">-P</span></span> option defaults to
<span class="machine"><span class="font-tt">-P fm</span></span>, meaning that only function calls and pattern matching are
profiled.</p>
<!--TOC paragraph id="sec466" Note-->
<h5 class="paragraph" id="sec466"><a class="section-anchor" href="#sec466" aria-hidden="true">ï»¿</a>Note</h5><!--SEC END --><p> For compatibility with previous releases, <span class="machine"><span class="font-tt">ocamlcp</span></span>
also accepts the <span class="machine"><span class="font-tt">-p</span></span> option, with the same arguments and behaviour as
<span class="machine"><span class="font-tt">-P</span></span>.</p><p>The <span class="machine"><span class="font-tt">ocamlcp</span></span> and <span class="machine"><span class="font-tt">ocamloptp</span></span> commands also accept all the options of
the corresponding <span class="machine"><span class="font-tt">ocamlc</span></span> or <span class="machine"><span class="font-tt">ocamlopt</span></span> compiler, except the <span class="machine"><span class="font-tt">-pp</span></span>
(preprocessing) option.</p>
<!--TOC section id="s:ocamlprof-profiling" 21.2â€ƒProfiling an execution-->
<h2 class="section" id="s:ocamlprof-profiling"><a class="section-anchor" href="#s:ocamlprof-profiling" aria-hidden="true">ï»¿</a>21.2â€ƒProfiling an execution</h2><!--SEC END --><p>Running an executable that has been compiled with <span class="machine"><span class="font-tt">ocamlcp</span></span> or
<span class="machine"><span class="font-tt">ocamloptp</span></span> records the execution counts for the specified parts of
the program and saves them in a file called <span class="machine"><span class="font-tt">ocamlprof.dump</span></span> in the
current directory.</p><p>If the environment variable <span class="machine"><span class="font-tt">OCAMLPROF_DUMP</span></span> is set when the program
exits, its value is used as the file name instead of <span class="machine"><span class="font-tt">ocamlprof.dump</span></span>.</p><p>The dump file is written only if the program terminates
normally (by calling <span class="machine"><span class="font-tt">exit</span></span> or by falling through). It is not written
if the program terminates with an uncaught exception.</p><p>If a compatible dump file already exists in the current directory, then the
profiling information is accumulated in this dump file. This allows, for
instance, the profiling of several executions of a program on
different inputs. Note that dump files produced by byte-code
executables (compiled with <span class="machine"><span class="font-tt">ocamlcp</span></span>) are compatible with the dump
files produced by native executables (compiled with <span class="machine"><span class="font-tt">ocamloptp</span></span>).</p>
<!--TOC section id="s:ocamlprof-printing" 21.3â€ƒPrinting profiling information-->
<h2 class="section" id="s:ocamlprof-printing"><a class="section-anchor" href="#s:ocamlprof-printing" aria-hidden="true">ï»¿</a>21.3â€ƒPrinting profiling information</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlprof</span></span> command produces a source listing of the program modules
where execution counts have been inserted as comments. For instance,
</p><pre>        ocamlprof foo.ml
</pre><p>prints the source code for the <span class="machine"><span class="font-tt">foo</span></span> module, with comments indicating
how many times the functions in this module have been called. Naturally,
this information is accurate only if the source file has not been modified
after it was compiled.</p><p>The following options are recognized by <span class="machine"><span class="font-tt">ocamlprof</span></span>:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional newline-terminated command line arguments from <span class="font-it">filename</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-args0</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Read additional null character terminated command line arguments from <span class="font-it">filename</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-f</span></span> <span class="font-it">dumpfile</span></span></dt><dd class="dd-description">
Specifies an alternate dump file of profiling information to be read.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-F</span></span> <span class="font-it">string</span></span></dt><dd class="dd-description">
Specifies an additional string to be output with profiling information.
By default, <span class="machine"><span class="font-tt">ocamlprof</span></span> will annotate programs with comments of the form
<span class="font-tt">(* <span class="font-it">n</span> *)</span> where <span class="font-it">n</span> is the counter value for a profiling
point. With option <span class="font-tt">-F <span class="font-it">s</span></span>, the annotation will be
<span class="font-tt">(* <span class="font-it">sn</span> *)</span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-impl</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Process the file <span class="font-it">filename</span> as an implementation file, even if its
extension is not <span class="machine"><span class="font-tt">.ml</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-intf</span></span> <span class="font-it">filename</span></span></dt><dd class="dd-description">
Process the file <span class="font-it">filename</span> as an interface file, even if its
extension is not <span class="machine"><span class="font-tt">.mli</span></span>.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-version</span></span></span></dt><dd class="dd-description">
Print version string and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-vnum</span></span></span></dt><dd class="dd-description">
Print short version number and exit.</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-help</span></span> or <span class="machine"><span class="font-tt">--help</span></span></span></dt><dd class="dd-description">
Display a short usage summary and exit.
</dd></dl>
<!--TOC section id="s:ocamlprof-time-profiling" 21.4â€ƒTime profiling-->
<h2 class="section" id="s:ocamlprof-time-profiling"><a class="section-anchor" href="#s:ocamlprof-time-profiling" aria-hidden="true">ï»¿</a>21.4â€ƒTime profiling</h2><!--SEC END --><p>Profiling with <span class="machine"><span class="font-tt">ocamlprof</span></span> only records execution counts, not the actual
time spent within each function. There is currently no way to perform
time profiling on bytecode programs generated by <span class="machine"><span class="font-tt">ocamlc</span></span>. For time
profiling of native code, users are recommended to use standard tools
such as perf (on Linux), Instruments (on macOS) and DTrace. Profiling
with <span class="machine"><span class="font-tt">gprof</span></span> is no longer supported.

</p>
<!--TOC chapter id="c:intf-c" ChapterÂ 22â€ƒInterfacing C with OCaml-->
<h1 class="chapter" id="c:intf-c">ChapterÂ 22â€ƒInterfacing C with OCaml</h1><!--SEC END --><!--NAME intfc.html-->
<p>This chapter describes how user-defined primitives, written in C, can
be linked with OCaml code and called from OCaml functions, and how
these C functions can call back to OCaml code.</p>
<!--TOC section id="s:c-overview" 22.1â€ƒOverview and compilation information-->
<h2 class="section" id="s:c-overview"><a class="section-anchor" href="#s:c-overview" aria-hidden="true">ï»¿</a>22.1â€ƒOverview and compilation information</h2><!--SEC END -->
<!--TOC subsection id="ss:c-prim-decl" 22.1.1â€ƒDeclaring primitives-->
<h3 class="subsection" id="ss:c-prim-decl"><a class="section-anchor" href="#ss:c-prim-decl" aria-hidden="true">ï»¿</a>22.1.1â€ƒDeclaring primitives</h3><!--SEC END --><div class="syntax"><table class="display dcenter"><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c008"><a class="syntax" href="#definition"><span class="nonterminal">definition</span></a></td><td class="c005">::=</td><td class="c007">â€„...
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">âˆ£</td><td class="c007">â€„<span class="syntax-token">external</span>â€„<a class="syntax" href="#value-name"><span class="nonterminal">value-name</span></a>â€„<span class="syntax-token">:</span>â€„<a class="syntax" href="#typexpr"><span class="nonterminal">typexpr</span></a>â€„<span class="syntax-token">=</span>â€„<a class="syntax" href="#external-declaration"><span class="nonterminal">external-declaration</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="external-declaration"><span class="nonterminal">external-declaration</span></a></td><td class="c005">::=</td><td class="c007">â€„<a class="syntax" href="#string-literal"><span class="nonterminal">string-literal</span></a>â€„[â€„<a class="syntax" href="#string-literal"><span class="nonterminal">string-literal</span></a>â€„[â€„<a class="syntax" href="#string-literal"><span class="nonterminal">string-literal</span></a>â€„]â€„]
</td></tr>
</table></td></tr>
</table></div><p>User primitives are declared in an implementation file or
<span class="syntax-token">struct</span>â€¦<span class="syntax-token">end</span> module expression using the <span class="syntax-token">external</span> keyword:
</p><pre>
        external <span class="font-it">name</span> : <span class="font-it">type</span> = <span class="font-it">C-function-name</span>
</pre><p>
This defines the value name <span class="font-it">name</span> as a function with type
<span class="font-it">type</span> that executes by calling the given C function.
For instance, here is how the <span class="machine"><span class="font-tt">seek_in</span></span> primitive is declared in the
standard library module <span class="machine"><span class="font-tt">Stdlib</span></span>:
</p><pre>        external seek_in : in_channel -&gt; int -&gt; unit = "caml_ml_seek_in"
</pre><p>Primitives with several arguments are always curried. The C function
does not necessarily have the same name as the ML function.</p><p>External functions thus defined can be specified in interface files or
<span class="syntax-token">sig</span>â€¦<span class="syntax-token">end</span> signatures either as regular values
</p><pre>
        val <span class="font-it">name</span> : <span class="font-it">type</span>
</pre><p>
thus hiding their implementation as C functions, or explicitly as
â€œmanifestâ€ external functions
</p><pre>
        external <span class="font-it">name</span> : <span class="font-it">type</span> = <span class="font-it">C-function-name</span>
</pre><p>
The latter is slightly more efficient, as it allows clients of the
module to call directly the C function instead of going through the
corresponding OCaml function. On the other hand, it should not be used
in library modules if they have side-effects at toplevel, as this
direct call interferes with the linkerâ€™s algorithm for removing unused
modules from libraries at link-time.</p><p>The arity (number of arguments) of a primitive is automatically
determined from its OCaml type in the <span class="machine"><span class="font-tt">external</span></span> declaration, by
counting the number of function arrows in the type. For instance,
<span class="machine"><span class="font-tt">seek_in</span></span> above has arity 2, and the <span class="machine"><span class="font-tt">caml_ml_seek_in</span></span> C function
is called with two arguments. Similarly,
</p><pre>    external seek_in_pair: in_channel * int -&gt; unit = "caml_ml_seek_in_pair"
</pre><p>has arity 1, and the <span class="machine"><span class="font-tt">caml_ml_seek_in_pair</span></span> C function receives one argument
(which is a pair of OCaml values).</p><p>Type abbreviations are not expanded when determining the arity of a
primitive. For instance,
</p><pre>        type int_endo = int -&gt; int
        external f : int_endo -&gt; int_endo = "f"
        external g : (int -&gt; int) -&gt; (int -&gt; int) = "f"
</pre><p><span class="machine"><span class="font-tt">f</span></span> has arity 1, but <span class="machine"><span class="font-tt">g</span></span> has arity 2. This allows a primitive to
return a functional value (as in the <span class="machine"><span class="font-tt">f</span></span> example above): just remember
to name the functional return type in a type abbreviation.</p><p>The language accepts external declarations with one or two
flag strings in addition to the C functionâ€™s name. These flags are
reserved for the implementation of the standard library.</p>
<!--TOC subsection id="ss:c-prim-impl" 22.1.2â€ƒImplementing primitives-->
<h3 class="subsection" id="ss:c-prim-impl"><a class="section-anchor" href="#ss:c-prim-impl" aria-hidden="true">ï»¿</a>22.1.2â€ƒImplementing primitives</h3><!--SEC END --><p>User primitives with arity <span class="font-it">n</span> â‰¤ 5 are implemented by C functions
that take <span class="font-it">n</span> arguments of type <span class="machine"><span class="font-tt">value</span></span>, and return a result of type
<span class="machine"><span class="font-tt">value</span></span>. The type <span class="machine"><span class="font-tt">value</span></span> is the type of the representations for OCaml
values. It encodes objects of several base types (integers,
floating-point numbers, strings,Â â€¦) as well as OCaml data
structures. The type <span class="machine"><span class="font-tt">value</span></span> and the associated conversion
functions and macros are described in detail below. For instance,
here is the declaration for the C function implementing the <span class="machine"><span class="font-tt">In_channel.input</span></span>
primitive, which takes 4 arguments:
</p><pre>CAMLprim value input(value channel, value buffer, value offset, value length)
{
  ...
}
</pre><p>When the primitive function is applied in an OCaml program, the C
function is called with the values of the expressions to which the
primitive is applied as arguments. The value returned by the function is
passed back to the OCaml program as the result of the function
application.</p><p>User primitives with arity greater than 5 should be implemented by two
C functions. The first function, to be used in conjunction with the
bytecode compiler <span class="machine"><span class="font-tt">ocamlc</span></span>, receives two arguments: a pointer to an
array of OCaml values (the values for the arguments), and an
integer which is the number of arguments provided. The other function,
to be used in conjunction with the native-code compiler <span class="machine"><span class="font-tt">ocamlopt</span></span>,
takes its arguments directly. For instance, here are the two C
functions for the 7-argument primitive <span class="machine"><span class="font-tt">Nat.add_nat</span></span>:
</p><pre>CAMLprim value add_nat_native(value nat1, value ofs1, value len1,
                              value nat2, value ofs2, value len2,
                              value carry_in)
{
  ...
}
CAMLprim value add_nat_bytecode(value * argv, int argn)
{
  return add_nat_native(argv[0], argv[1], argv[2], argv[3],
                        argv[4], argv[5], argv[6]);
}
</pre><p>The names of the two C functions must be given in the primitive
declaration, as follows:
</p><pre>
        external <span class="font-it">name</span> : <span class="font-it">type</span> =
                 <span class="font-it">bytecode-C-function-name</span> <span class="font-it">native-code-C-function-name</span>
</pre><p>
For instance, in the case of <span class="machine"><span class="font-tt">add_nat</span></span>, the declaration is:
</p><pre>        external add_nat: nat -&gt; int -&gt; int -&gt; nat -&gt; int -&gt; int -&gt; int -&gt; int
                        = "add_nat_bytecode" "add_nat_native"
</pre><p>
Implementing a user primitive is actually two separate tasks: on the
one hand, decoding the arguments to extract C values from the given
OCaml values, and encoding the return value as an OCaml
value; on the other hand, actually computing the result from the arguments.
Except for very simple primitives, it is often preferable to have two
distinct C functions to implement these two tasks. The first function
actually implements the primitive, taking native C values as
arguments and returning a native C value. The second function,
often called the â€œstub codeâ€, is a simple wrapper around the first
function that converts its arguments from OCaml values to C values,
calls the first function, and converts the returned C value to an OCaml
value. For instance, here is the stub code for the <span class="machine"><span class="font-tt">Int64.float_of_bits</span></span>
primitive:
</p><pre>CAMLprim value caml_int64_float_of_bits(value vi)
{
  return caml_copy_double(caml_int64_float_of_bits_unboxed(Int64_val(vi)));
}
</pre><p>(Here, <span class="machine"><span class="font-tt">caml_copy_double</span></span> and <span class="machine"><span class="font-tt">Int64_val</span></span> are conversion functions and
macros for the type <span class="machine"><span class="font-tt">value</span></span>, that will be described later. The <span class="machine"><span class="font-tt">CAMLprim</span></span> macro
expands to the required compiler directives to ensure that the
function is exported and accessible from OCaml.)
The hard work is performed by the function <span class="machine"><span class="font-tt">caml_int64_float_of_bits_unboxed</span></span>, which is
declared as:
</p><pre>double caml_int64_float_of_bits_unboxed(int64_t i)
{
  ...
}
</pre><p>
To write C code that operates on OCaml values, the following
include files are provided:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Include file</span></td><td class="c004"><span class="font-bold">Provides</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">caml/mlvalues.h</span></span></td><td class="c011">definition of the <span class="machine"><span class="font-tt">value</span></span> type, and conversion
macros </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/alloc.h</span></span></td><td class="c011">allocation functions (to create structured OCaml
objects) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/memory.h</span></span></td><td class="c011">miscellaneous memory-related functions
and macros (for GC interface, in-place modification of structures, etc). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/fail.h</span></span></td><td class="c011">functions for raising exceptions
(see sectionÂ <a href="#ss%3Ac-exceptions">22.4.5</a>) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/callback.h</span></span></td><td class="c011">callback from C to OCaml (see
sectionÂ <a href="#s%3Ac-callback">22.7</a>). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/custom.h</span></span></td><td class="c011">operations on custom blocks (see
sectionÂ <a href="#s%3Ac-custom">22.9</a>). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/intext.h</span></span></td><td class="c011">operations for writing user-defined
serialization and deserialization functions for custom blocks
(see sectionÂ <a href="#s%3Ac-custom">22.9</a>). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml/threads.h</span></span></td><td class="c011">operations for interfacing in the presence
of multiple threads (see sectionÂ <a href="#s%3AC-multithreading">22.12</a>). </td></tr>
</table></div></div><p>
These files reside in the <span class="machine"><span class="font-tt">caml/</span></span> subdirectory of the OCaml
standard library directory, which is returned by the command
<span class="machine"><span class="font-tt">ocamlc -where</span></span> (usually <span class="machine"><span class="font-tt">/usr/local/lib/ocaml</span></span> or <span class="machine"><span class="font-tt">/usr/lib/ocaml</span></span>).</p>
<!--TOC subsection id="ss:staticlink-c-code" 22.1.3â€ƒStatically linking C code with OCaml code-->
<h3 class="subsection" id="ss:staticlink-c-code"><a class="section-anchor" href="#ss:staticlink-c-code" aria-hidden="true">ï»¿</a>22.1.3â€ƒStatically linking C code with OCaml code</h3><!--SEC END --><p>The OCaml runtime system comprises three main parts: the bytecode
interpreter, the memory manager, and a set of C functions that
implement the primitive operations. Some bytecode instructions are
provided to call these C functions, designated by their offset in a
table of functions (the table of primitives).</p><p>In the default mode, the OCaml linker produces bytecode for the
standard runtime system, with a standard set of primitives. References
to primitives that are not in this standard set result in the
â€œunavailable C primitiveâ€ error. (Unless dynamic loading of C
libraries is supported â€“ see sectionÂ <a href="#ss%3Adynlink-c-code">22.1.4</a> below.)</p><p>In the â€œcustom runtimeâ€ mode, the OCaml linker scans the
object files and determines the set of required primitives. Then, it
builds a suitable runtime system, by calling the native code linker with:
</p><ul class="itemize"><li class="li-itemize">the table of the required primitives;
</li><li class="li-itemize">a library that provides the bytecode interpreter, the
memory manager, and the standard primitives;
</li><li class="li-itemize">libraries and object code files (<span class="machine"><span class="font-tt">.o</span></span> files) mentioned on the
command line for the OCaml linker, that provide implementations
for the userâ€™s primitives.
</li></ul><p>
This builds a runtime system with the required primitives. The OCaml
linker generates bytecode for this custom runtime system. The
bytecode is appended to the end of the custom runtime system, so that
it will be automatically executed when the output file (custom
runtime + bytecode) is launched.</p><p>To link in â€œcustom runtimeâ€ mode, execute the <span class="machine"><span class="font-tt">ocamlc</span></span> command with:
</p><ul class="itemize"><li class="li-itemize">the <span class="machine"><span class="font-tt">-custom</span></span> option;
</li><li class="li-itemize">the names of the desired OCaml object files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span> files) ;
</li><li class="li-itemize">the names of the C object files and libraries (<span class="machine"><span class="font-tt">.o</span></span> and <span class="machine"><span class="font-tt">.a</span></span>
files) that implement the required primitives. Under Unix and Windows,
a library named <span class="machine"><span class="font-tt">lib</span></span><span class="font-it">name</span><span class="machine"><span class="font-tt">.a</span></span> (respectively, <span class="machine"><span class="font-tt">.lib</span></span>) residing in one of
the standard library directories can also be specified as <span class="machine"><span class="font-tt">-cclib -l</span></span><span class="font-it">name</span>.
</li></ul><p>If you are using the native-code compiler <span class="machine"><span class="font-tt">ocamlopt</span></span>, the <span class="machine"><span class="font-tt">-custom</span></span>
flag is not needed, as the final linking phase of <span class="machine"><span class="font-tt">ocamlopt</span></span> always
builds a standalone executable. To build a mixed OCaml/C executable,
execute the <span class="machine"><span class="font-tt">ocamlopt</span></span> command with:
</p><ul class="itemize"><li class="li-itemize">the names of the desired OCaml native object files (<span class="machine"><span class="font-tt">.cmx</span></span> and
<span class="machine"><span class="font-tt">.cmxa</span></span> files);
</li><li class="li-itemize">the names of the C object files and libraries (<span class="machine"><span class="font-tt">.o</span></span>, <span class="machine"><span class="font-tt">.a</span></span>,
<span class="machine"><span class="font-tt">.so</span></span> or <span class="machine"><span class="font-tt">.dll</span></span> files) that implement the required primitives.
</li></ul><p>Starting with Objective Caml 3.00, it is possible to record the
<span class="machine"><span class="font-tt">-custom</span></span> option as well as the names of C libraries in an OCaml
library file <span class="machine"><span class="font-tt">.cma</span></span> or <span class="machine"><span class="font-tt">.cmxa</span></span>. For instance, consider an OCaml library
<span class="machine"><span class="font-tt">mylib.cma</span></span>, built from the OCaml object files <span class="machine"><span class="font-tt">a.cmo</span></span> and <span class="machine"><span class="font-tt">b.cmo</span></span>,
which reference C code in <span class="machine"><span class="font-tt">libmylib.a</span></span>. If the library is
built as follows:
</p><pre>
        ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</pre><p>
users of the library can simply link with <span class="machine"><span class="font-tt">mylib.cma</span></span>:
</p><pre>
        ocamlc -o myprog mylib.cma ...
</pre><p>
and the system will automatically add the <span class="machine"><span class="font-tt">-custom</span></span> and <span class="machine"><span class="font-tt">-cclib -lmylib</span></span> options, achieving the same effect as
</p><pre>
        ocamlc -o myprog -custom a.cmo b.cmo ... -cclib -lmylib
</pre><p>
The alternative is of course to build the library without extra
options:
</p><pre>
        ocamlc -a -o mylib.cma a.cmo b.cmo
</pre><p>
and then ask users to provide the <span class="machine"><span class="font-tt">-custom</span></span> and <span class="machine"><span class="font-tt">-cclib -lmylib</span></span>
options themselves at link-time:
</p><pre>
        ocamlc -o myprog -custom mylib.cma ... -cclib -lmylib
</pre><p>
The former alternative is more convenient for the final users of the
library, however.</p>
<!--TOC subsection id="ss:dynlink-c-code" 22.1.4â€ƒDynamically linking C code with OCaml code-->
<h3 class="subsection" id="ss:dynlink-c-code"><a class="section-anchor" href="#ss:dynlink-c-code" aria-hidden="true">ï»¿</a>22.1.4â€ƒDynamically linking C code with OCaml code</h3><!--SEC END --><p>Starting with Objective Caml 3.03, an alternative to static linking of C code
using the <span class="machine"><span class="font-tt">-custom</span></span> code is provided. In this mode, the OCaml linker
generates a pure bytecode executable (no embedded custom runtime
system) that simply records the names of dynamically-loaded libraries
containing the C code. The standard OCaml runtime system <span class="machine"><span class="font-tt">ocamlrun</span></span>
then loads dynamically these libraries, and resolves references to the
required primitives, before executing the bytecode.</p><p>This facility is currently available on all platforms supported by
OCaml except Cygwin 64 bits.</p><p>To dynamically link C code with OCaml code, the C code must first be
compiled into a shared library (under Unix) or DLL (under Windows).
This involves 1- compiling the C files with appropriate C compiler
flags for producing position-independent code (when required by the
operating system), and 2- building a
shared library from the resulting object files. The resulting shared
library or DLL file must be installed in a place where <span class="machine"><span class="font-tt">ocamlrun</span></span> can
find it later at program start-up time (see
sectionÂ <a href="#s%3Aocamlrun-dllpath">15.3</a>).
Finally (step 3), execute the <span class="machine"><span class="font-tt">ocamlc</span></span> command with
</p><ul class="itemize"><li class="li-itemize">the names of the desired OCaml object files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span> files) ;
</li><li class="li-itemize">the names of the C shared libraries (<span class="machine"><span class="font-tt">.so</span></span> or <span class="machine"><span class="font-tt">.dll</span></span> files) that
implement the required primitives. Under Unix and Windows,
a library named <span class="machine"><span class="font-tt">dll</span></span><span class="font-it">name</span><span class="machine"><span class="font-tt">.so</span></span> (respectively, <span class="machine"><span class="font-tt">.dll</span></span>) residing
in one of the standard library directories can also be specified as
<span class="machine"><span class="font-tt">-dllib -l</span></span><span class="font-it">name</span>.
</li></ul><p>
Do <em>not</em> set the <span class="machine"><span class="font-tt">-custom</span></span> flag, otherwise youâ€™re back to static linking
as described in sectionÂ <a href="#ss%3Astaticlink-c-code">22.1.3</a>.
The <span class="machine"><span class="font-tt">ocamlmklib</span></span> tool (see sectionÂ <a href="#s%3Aocamlmklib">22.14</a>)
automates steps 2 and 3.</p><p>As in the case of static linking, it is possible (and recommended) to
record the names of C libraries in an OCaml <span class="machine"><span class="font-tt">.cma</span></span> library archive.
Consider again an OCaml library
<span class="machine"><span class="font-tt">mylib.cma</span></span>, built from the OCaml object files <span class="machine"><span class="font-tt">a.cmo</span></span> and <span class="machine"><span class="font-tt">b.cmo</span></span>,
which reference C code in <span class="machine"><span class="font-tt">dllmylib.so</span></span>. If the library is
built as follows:
</p><pre>
        ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</pre><p>
users of the library can simply link with <span class="machine"><span class="font-tt">mylib.cma</span></span>:
</p><pre>
        ocamlc -o myprog mylib.cma ...
</pre><p>
and the system will automatically add the <span class="machine"><span class="font-tt">-dllib -lmylib</span></span> option,
achieving the same effect as
</p><pre>
        ocamlc -o myprog a.cmo b.cmo ... -dllib -lmylib
</pre><p>
Using this mechanism, users of the library <span class="machine"><span class="font-tt">mylib.cma</span></span> do not need to
know that it references C code, nor whether this C code must be
statically linked (using <span class="machine"><span class="font-tt">-custom</span></span>) or dynamically linked.</p>
<!--TOC subsection id="ss:c-static-vs-dynamic" 22.1.5â€ƒChoosing between static linking and dynamic linking-->
<h3 class="subsection" id="ss:c-static-vs-dynamic"><a class="section-anchor" href="#ss:c-static-vs-dynamic" aria-hidden="true">ï»¿</a>22.1.5â€ƒChoosing between static linking and dynamic linking</h3><!--SEC END --><p>After having described two different ways of linking C code with OCaml
code, we now review the pros and cons of each, to help developers of
mixed OCaml/C libraries decide.</p><p>The main advantage of dynamic linking is that it preserves the
platform-independence of bytecode executables. That is, the bytecode
executable contains no machine code, and can therefore be compiled on
platform <span class="font-it">A</span> and executed on other platforms <span class="font-it">B</span>, <span class="font-it">C</span>, â€¦, as long
as the required shared libraries are available on all these
platforms. In contrast, executables generated by <span class="machine"><span class="font-tt">ocamlc -custom</span></span> run
only on the platform on which they were created, because they embark a
custom-tailored runtime system specific to that platform. In
addition, dynamic linking results in smaller executables.</p><p>Another advantage of dynamic linking is that the final users of the
library do not need to have a C compiler, C linker, and C runtime
libraries installed on their machines. This is no big deal under
Unix and Cygwin, but many Windows users are reluctant to install
Microsoft Visual C just to be able to do <span class="machine"><span class="font-tt">ocamlc -custom</span></span>.</p><p>There are two drawbacks to dynamic linking. The first is that the
resulting executable is not stand-alone: it requires the shared
libraries, as well as <span class="machine"><span class="font-tt">ocamlrun</span></span>, to be installed on the machine
executing the code. If you wish to distribute a stand-alone
executable, it is better to link it statically, using <span class="machine"><span class="font-tt">ocamlc -custom -ccopt -static</span></span> or <span class="machine"><span class="font-tt">ocamlopt -ccopt -static</span></span>. Dynamic linking also
raises the â€œDLL hellâ€ problem: some care must be taken to ensure
that the right versions of the shared libraries are found at start-up
time.</p><p>The second drawback of dynamic linking is that it complicates the
construction of the library. The C compiler and linker flags to
compile to position-independent code and build a shared library vary
wildly between different Unix systems. Also, dynamic linking is not
supported on all Unix systems, requiring a fall-back case to static
linking in the Makefile for the library. The <span class="machine"><span class="font-tt">ocamlmklib</span></span> command
(see sectionÂ <a href="#s%3Aocamlmklib">22.14</a>) tries to hide some of these system
dependencies.</p><p>In conclusion: dynamic linking is highly recommended under the native
Windows port, because there are no portability problems and it is much
more convenient for the end users. Under Unix, dynamic linking should
be considered for mature, frequently used libraries because it
enhances platform-independence of bytecode executables. For new or
rarely-used libraries, static linking is much simpler to set up in a
portable way.</p>
<!--TOC subsection id="ss:custom-runtime" 22.1.6â€ƒBuilding standalone custom runtime systems-->
<h3 class="subsection" id="ss:custom-runtime"><a class="section-anchor" href="#ss:custom-runtime" aria-hidden="true">ï»¿</a>22.1.6â€ƒBuilding standalone custom runtime systems</h3><!--SEC END --><p>It is sometimes inconvenient to build a custom runtime system each
time OCaml code is linked with C libraries, like <span class="machine"><span class="font-tt">ocamlc -custom</span></span> does.
For one thing, the building of the runtime system is slow on some
systems (that have bad linkers or slow remote file systems); for
another thing, the platform-independence of bytecode files is lost,
forcing to perform one <span class="machine"><span class="font-tt">ocamlc -custom</span></span> link per platform of interest.</p><p>An alternative to <span class="machine"><span class="font-tt">ocamlc -custom</span></span> is to build separately a custom
runtime system integrating the desired C libraries, then generate
â€œpureâ€ bytecode executables (not containing their own runtime
system) that can run on this custom runtime. This is achieved by the
<span class="machine"><span class="font-tt">-make-runtime</span></span> and <span class="machine"><span class="font-tt">-use-runtime</span></span> flags to <span class="machine"><span class="font-tt">ocamlc</span></span>. For example,
to build a custom runtime system integrating the C parts of the
â€œUnixâ€ and â€œThreadsâ€ libraries, do:
</p><pre>        ocamlc -make-runtime -o /home/me/ocamlunixrun unix.cma threads.cma
</pre><p>To generate a bytecode executable that runs on this runtime system,
do:
</p><pre>
        ocamlc -use-runtime /home/me/ocamlunixrun -o myprog \
                unix.cma threads.cma <span class="font-it">your .cmo and .cma files</span>
</pre><p>
The bytecode executable <span class="machine"><span class="font-tt">myprog</span></span> can then be launched as usual:
<span class="machine"><span class="font-tt">myprog</span></span> <span class="font-it">args</span> or <span class="machine"><span class="font-tt">/home/me/ocamlunixrun myprog</span></span> <span class="font-it">args</span>.</p><p>Notice that the bytecode libraries <span class="machine"><span class="font-tt">unix.cma</span></span> and <span class="machine"><span class="font-tt">threads.cma</span></span> must
be given twice: when building the runtime system (so that <span class="machine"><span class="font-tt">ocamlc</span></span>
knows which C primitives are required) and also when building the
bytecode executable (so that the bytecode from <span class="machine"><span class="font-tt">unix.cma</span></span> and
<span class="machine"><span class="font-tt">threads.cma</span></span> is actually linked in).</p>
<!--TOC section id="s:c-value" 22.2â€ƒThe <span class="font-tt">value</span> type-->
<h2 class="section" id="s:c-value"><a class="section-anchor" href="#s:c-value" aria-hidden="true">ï»¿</a>22.2â€ƒThe <span class="font-tt">value</span> type</h2><!--SEC END --><p>All OCaml objects are represented by the C type <span class="machine"><span class="font-tt">value</span></span>,
defined in the include file <span class="machine"><span class="font-tt">caml/mlvalues.h</span></span>, along with macros to
manipulate values of that type. An object of type <span class="machine"><span class="font-tt">value</span></span> is either:
</p><ul class="itemize"><li class="li-itemize">an unboxed integer;
</li><li class="li-itemize">or a pointer to a block inside the heap,
allocated through one of the <code class="verb">caml_alloc_*</code> functions described
in sectionÂ <a href="#ss%3Ac-block-allocation">22.4.4</a>.
</li></ul>
<!--TOC subsection id="ss:c-int" 22.2.1â€ƒInteger values-->
<h3 class="subsection" id="ss:c-int"><a class="section-anchor" href="#ss:c-int" aria-hidden="true">ï»¿</a>22.2.1â€ƒInteger values</h3><!--SEC END --><p>Integer values encode 63-bit signed integers (31-bit on 32-bit
architectures). They are unboxed (unallocated).</p>
<!--TOC subsection id="ss:c-blocks" 22.2.2â€ƒBlocks-->
<h3 class="subsection" id="ss:c-blocks"><a class="section-anchor" href="#ss:c-blocks" aria-hidden="true">ï»¿</a>22.2.2â€ƒBlocks</h3><!--SEC END --><p>Blocks in the heap are garbage-collected, and therefore have strict
structure constraints. Each block includes a header containing the
size of the block (in words), and the tag of the block.
The tag governs how the contents of the blocks are structured. A tag
lower than <span class="machine"><span class="font-tt">No_scan_tag</span></span> indicates a structured block, containing
well-formed values, which is recursively traversed by the garbage
collector. A tag greater than or equal to <span class="machine"><span class="font-tt">No_scan_tag</span></span> indicates a
raw block, whose contents are not scanned by the garbage collector.
For the benefit of ad-hoc polymorphic primitives such as equality and
structured input-output, structured and raw blocks are further
classified according to their tags as follows:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Tag</span></td><td class="c004"><span class="font-bold">Contents of the block</span> </td></tr>
<tr><td class="c012">
0 to <span class="machine"><span class="font-tt">No_scan_tag</span></span>âˆ’1</td><td class="c011">A structured block (an array of
OCaml objects). Each field is a <span class="machine"><span class="font-tt">value</span></span>. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">Closure_tag</span></span></td><td class="c011">A closure representing a functional value. The first
word is a pointer to a piece of code, the remaining words are
<span class="machine"><span class="font-tt">value</span></span> containing the environment. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">String_tag</span></span></td><td class="c011">A character string or a byte sequence. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">Double_tag</span></span></td><td class="c011">A double-precision floating-point number. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">Double_array_tag</span></span></td><td class="c011">An array or record of double-precision
floating-point numbers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">Abstract_tag</span></span></td><td class="c011">A block representing an abstract datatype. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">Custom_tag</span></span></td><td class="c011">A block representing an abstract datatype
with user-defined finalization, comparison, hashing,
serialization and deserialization functions attached. </td></tr>
</table></div></div>
<!--TOC subsection id="ss:c-outside-head" 22.2.3â€ƒPointers outside the heap-->
<h3 class="subsection" id="ss:c-outside-head"><a class="section-anchor" href="#ss:c-outside-head" aria-hidden="true">ï»¿</a>22.2.3â€ƒPointers outside the heap</h3><!--SEC END --><p>In earlier versions of OCaml, it was possible to use
word-aligned pointers to addresses outside the heap as OCaml values,
just by casting the pointer to type <span class="machine"><span class="font-tt">value</span></span>. This usage is no longer
supported since OCaml 5.0.</p><p>A correct way to manipulate pointers to out-of-heap blocks from
OCaml is to store those pointers in OCaml blocks with tag
<span class="machine"><span class="font-tt">Abstract_tag</span></span> or <span class="machine"><span class="font-tt">Custom_tag</span></span>, then use the blocks as the OCaml
values.</p><p>Here is an example of encapsulation of out-of-heap pointers of C type
<span class="machine"><span class="font-tt">ty *</span></span> inside <span class="machine"><span class="font-tt">Abstract_tag</span></span> blocks. SectionÂ <a href="#s%3Ac-intf-example">22.6</a>
gives a more complete example using <span class="machine"><span class="font-tt">Custom_tag</span></span> blocks.
</p><pre>/* Create an OCaml value encapsulating the pointer p */
static value val_of_typtr(ty * p)
{
  value v = caml_alloc(1, Abstract_tag);
  *((ty **) Data_abstract_val(v)) = p;
  return v;
}

/* Extract the pointer encapsulated in the given OCaml value */
static ty * typtr_of_val(value v)
{
  return *((ty **) Data_abstract_val(v));
}
</pre><p>Alternatively, out-of-heap pointers can be treated as â€œnativeâ€
integers, that is, boxed 32-bit integers on a 32-bit platform and
boxed 64-bit integers on a 64-bit platform.
</p><pre>/* Create an OCaml value encapsulating the pointer p */
static value val_of_typtr(ty * p)
{
  return caml_copy_nativeint((intnat) p);
}

/* Extract the pointer encapsulated in the given OCaml value */
static ty * typtr_of_val(value v)
{
  return (ty *) Nativeint_val(v);
}
</pre><p>For pointers that are at least 2-aligned (the low bit is guaranteed to
be zero), we have yet another valid representation as an OCaml tagged
integer.
</p><pre>/* Create an OCaml value encapsulating the pointer p */
static value val_of_typtr(ty * p)
{
  assert (((uintptr_t) p &amp; 1) == 0);  /* check correct alignment */
  return (value) p | 1;
}

/* Extract the pointer encapsulated in the given OCaml value */
static ty * typtr_of_val(value v)
{
  return (ty *) (v &amp; ~1);
}
</pre>
<!--TOC section id="s:c-ocaml-datatype-repr" 22.3â€ƒRepresentation of OCaml data types-->
<h2 class="section" id="s:c-ocaml-datatype-repr"><a class="section-anchor" href="#s:c-ocaml-datatype-repr" aria-hidden="true">ï»¿</a>22.3â€ƒRepresentation of OCaml data types</h2><!--SEC END --><p>This section describes how OCaml data types are encoded in the
<span class="machine"><span class="font-tt">value</span></span> type.</p>
<!--TOC subsection id="ss:c-atomic" 22.3.1â€ƒAtomic types-->
<h3 class="subsection" id="ss:c-atomic"><a class="section-anchor" href="#ss:c-atomic" aria-hidden="true">ï»¿</a>22.3.1â€ƒAtomic types</h3><!--SEC END --><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">OCaml type</span></td><td class="c004"><span class="font-bold">Encoding</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">int</span></span></td><td class="c006">Unboxed integer values. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">char</span></span></td><td class="c006">Unboxed integer values (ASCII code). </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">float</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">Double_tag</span></span>. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">bytes</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">String_tag</span></span>. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">string</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">String_tag</span></span>. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">int32</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">Custom_tag</span></span>. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">int64</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">Custom_tag</span></span>. </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">nativeint</span></span></td><td class="c006">Blocks with tag <span class="machine"><span class="font-tt">Custom_tag</span></span>. </td></tr>
</table></div></div>
<!--TOC subsection id="ss:c-tuples-and-records" 22.3.2â€ƒTuples and records-->
<h3 class="subsection" id="ss:c-tuples-and-records"><a class="section-anchor" href="#ss:c-tuples-and-records" aria-hidden="true">ï»¿</a>22.3.2â€ƒTuples and records</h3><!--SEC END --><p>Tuples are represented by pointers to blocks, with tagÂ 0.</p><p>Records are also represented by zero-tagged blocks. The ordering of
labels in the record type declaration determines the layout of
the record fields: the value associated to the label
declared first is stored in fieldÂ 0 of the block, the value associated
to the second label goes in fieldÂ 1, and so on.</p><p>As an optimization, records whose fields all have static type <span class="machine"><span class="font-tt">float</span></span>
are represented as arrays of floating-point numbers, with tag
<span class="machine"><span class="font-tt">Double_array_tag</span></span>. (See the section below on arrays.)</p><p>As another optimization, unboxable record types are represented
specially; unboxable record types are the immutable record types that
have only one field. An unboxable type will be represented in one of
two ways: boxed or unboxed. Boxed record types are represented as
described above (by a block with tag 0 or <span class="machine"><span class="font-tt">Double_array_tag</span></span>). An
unboxed record type is represented directly by the value of its field
(i.e. there is no block to represent the record itself).</p><p>The representation is chosen according to the following, in decreasing
order of priority:
</p><ul class="itemize"><li class="li-itemize">An attribute (<span class="machine"><span class="font-tt">[@@boxed]</span></span> or <span class="machine"><span class="font-tt">[@@unboxed]</span></span>) on the type declaration.
</li><li class="li-itemize">A compiler option (<span class="machine"><span class="font-tt">-unboxed-types</span></span> or <span class="machine"><span class="font-tt">-no-unboxed-types</span></span>).
</li><li class="li-itemize">The default representation. In the present version of OCaml, the
default is the boxed representation.
</li></ul>
<!--TOC subsection id="ss:c-arrays" 22.3.3â€ƒArrays-->
<h3 class="subsection" id="ss:c-arrays"><a class="section-anchor" href="#ss:c-arrays" aria-hidden="true">ï»¿</a>22.3.3â€ƒArrays</h3><!--SEC END --><p>Arrays of integers and pointers are represented like tuples,
that is, as pointers to blocks taggedÂ 0. They are accessed with the
<span class="machine"><span class="font-tt">Field</span></span> macro for reading and the <span class="machine"><span class="font-tt">caml_modify</span></span> function for writing.</p><p>Arrays of floating-point numbers (type <span class="machine"><span class="font-tt">float array</span></span>)
have a special, unboxed, more efficient representation.
These arrays are represented by pointers to blocks with tag
<span class="machine"><span class="font-tt">Double_array_tag</span></span>. They should be accessed with the <span class="machine"><span class="font-tt">Double_field</span></span>
and <span class="machine"><span class="font-tt">Store_double_field</span></span> macros.</p>
<!--TOC subsection id="ss:c-concrete-datatypes" 22.3.4â€ƒConcrete data types-->
<h3 class="subsection" id="ss:c-concrete-datatypes"><a class="section-anchor" href="#ss:c-concrete-datatypes" aria-hidden="true">ï»¿</a>22.3.4â€ƒConcrete data types</h3><!--SEC END --><p>Constructed terms are represented either by unboxed integers (for
constant constructors) or by blocks whose tag encode the constructor
(for non-constant constructors). The constant constructors and the
non-constant constructors for a given concrete type are numbered
separately, starting from 0, in the order in which they appear in the
concrete type declaration. A constant constructor is represented by
the unboxed integer equal to its constructor number. A non-constant
constructor declared with <span class="font-it">n</span> arguments is represented by
a block of size <span class="font-it">n</span>, tagged with the constructor number; the <span class="font-it">n</span>
fields contain its arguments. Example:</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Constructed term</span></td><td class="c004"><span class="font-bold">Representation</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">()</span></span></td><td class="c011"><span class="machine"><span class="font-tt">Val_int(0)</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">false</span></span></td><td class="c011"><span class="machine"><span class="font-tt">Val_int(0)</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">true</span></span></td><td class="c011"><span class="machine"><span class="font-tt">Val_int(1)</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">[]</span></span></td><td class="c011"><span class="machine"><span class="font-tt">Val_int(0)</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">h::t</span></span></td><td class="c011">Block with size = 2 and tag = 0; first field
contains <span class="machine"><span class="font-tt">h</span></span>, second field <span class="machine"><span class="font-tt">t</span></span>. </td></tr>
</table></div></div><p>As a convenience, <span class="machine"><span class="font-tt">caml/mlvalues.h</span></span> defines the macros <span class="machine"><span class="font-tt">Val_unit</span></span>,
<span class="machine"><span class="font-tt">Val_false</span></span> and <span class="machine"><span class="font-tt">Val_true</span></span> to refer to <span class="machine"><span class="font-tt">()</span></span>, <span class="machine"><span class="font-tt">false</span></span> and <span class="machine"><span class="font-tt">true</span></span>.</p><p>The following example illustrates the assignment of
integers and block tags to constructors:
</p><pre>type t =
  | A             (* First constant constructor -&gt; integer "Val_int(0)" *)
  | B of string   (* First non-constant constructor -&gt; block with tag 0 *)
  | C             (* Second constant constructor -&gt; integer "Val_int(1)" *)
  | D of bool     (* Second non-constant constructor -&gt; block with tag 1 *)
  | E of t * t    (* Third non-constant constructor -&gt; block with tag 2 *)
</pre><p>As an optimization, unboxable concrete data types are represented
specially; a concrete data type is unboxable if it has exactly one
constructor and this constructor has exactly one argument. Unboxable
concrete data types are represented in the same ways as unboxable
record types: see the description in
sectionÂ <a href="#ss%3Ac-tuples-and-records">22.3.2</a>.</p>
<!--TOC subsection id="ss:c-objects" 22.3.5â€ƒObjects-->
<h3 class="subsection" id="ss:c-objects"><a class="section-anchor" href="#ss:c-objects" aria-hidden="true">ï»¿</a>22.3.5â€ƒObjects</h3><!--SEC END --><p>Objects are represented as blocks with tag <span class="machine"><span class="font-tt">Object_tag</span></span>. The first
field of the block refers to the objectâ€™s class and associated method
suite, in a format that cannot easily be exploited from C. The second
field contains a unique object ID, used for comparisons. The remaining
fields of the object contain the values of the instance variables of
the object. It is unsafe to access directly instance variables, as the
type system provides no guarantee about the instance variables
contained by an object.
</p><p>One may extract a public method from an object using the C function
<span class="machine"><span class="font-tt">caml_get_public_method</span></span> (declared in <span class="machine"><span class="font-tt">&lt;caml/mlvalues.h&gt;</span></span>.)
Since public method tags are hashed in the same way as variant tags,
and methods are functions taking self as first argument, if you want
to do the method call <span class="machine"><span class="font-tt">foo#bar</span></span> from the C side, you should call:
</p><pre>  callback(caml_get_public_method(foo, hash_variant("bar")), foo);
</pre>
<!--TOC subsection id="ss:c-polyvar" 22.3.6â€ƒPolymorphic variants-->
<h3 class="subsection" id="ss:c-polyvar"><a class="section-anchor" href="#ss:c-polyvar" aria-hidden="true">ï»¿</a>22.3.6â€ƒPolymorphic variants</h3><!--SEC END --><p>Like constructed terms, polymorphic variant values are represented either
as integers (for polymorphic variants without argument), or as blocks
(for polymorphic variants with an argument). Unlike constructed
terms, variant constructors are not numbered starting from 0, but
identified by a hash value (an OCaml integer), as computed by the C function
<span class="machine"><span class="font-tt">hash_variant</span></span> (declared in <span class="machine"><span class="font-tt">&lt;caml/mlvalues.h&gt;</span></span>):
the hash value for a variant constructor named, say, <span class="machine"><span class="font-tt">VConstr</span></span>
is <span class="machine"><span class="font-tt">hash_variant("VConstr")</span></span>.</p><p>The variant value <span class="machine"><span class="font-tt">`VConstr</span></span> is represented by
<span class="machine"><span class="font-tt">hash_variant("VConstr")</span></span>. The variant value <span class="machine"><span class="font-tt">`VConstr(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> is
represented by a block of size 2 and tag 0, with field number 0
containing <span class="machine"><span class="font-tt">hash_variant("VConstr")</span></span> and field number 1 containing
<span class="font-it">v</span>.</p><p>Unlike constructed values, polymorphic variant values taking several
arguments are not flattened.
That is, <span class="machine"><span class="font-tt">`VConstr(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">w</span><span class="machine"><span class="font-tt">)</span></span> is represented by a block
of size 2, whose field number 1 contains the representation of the
pair <span class="machine"><span class="font-tt">(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">w</span><span class="machine"><span class="font-tt">)</span></span>, rather than a block of size 3
containing <span class="font-it">v</span> and <span class="font-it">w</span> in fields 1 and 2.</p>
<!--TOC section id="s:c-ops-on-values" 22.4â€ƒOperations on values-->
<h2 class="section" id="s:c-ops-on-values"><a class="section-anchor" href="#s:c-ops-on-values" aria-hidden="true">ï»¿</a>22.4â€ƒOperations on values</h2><!--SEC END -->
<!--TOC subsection id="ss:c-kind-tests" 22.4.1â€ƒKind tests-->
<h3 class="subsection" id="ss:c-kind-tests"><a class="section-anchor" href="#ss:c-kind-tests" aria-hidden="true">ï»¿</a>22.4.1â€ƒKind tests</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">Is_long(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> is true if value <span class="font-it">v</span> is an immediate integer,
false otherwise
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Is_block(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> is true if value <span class="font-it">v</span> is a pointer to a block,
and false if it is an immediate integer.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Is_none(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> is true if value <span class="font-it">v</span> is <span class="machine"><span class="font-tt">None</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Is_some(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> is true if value <span class="font-it">v</span> (assumed to be of option
type) corresponds to the <span class="machine"><span class="font-tt">Some</span></span> constructor.
</li></ul>
<!--TOC subsection id="ss:c-int-ops" 22.4.2â€ƒOperations on integers-->
<h3 class="subsection" id="ss:c-int-ops"><a class="section-anchor" href="#ss:c-int-ops" aria-hidden="true">ï»¿</a>22.4.2â€ƒOperations on integers</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">Val_long(</span></span><span class="font-it">l</span><span class="machine"><span class="font-tt">)</span></span> returns the value encoding the <span class="machine"><span class="font-tt">long int</span></span> <span class="font-it">l</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Long_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the <span class="machine"><span class="font-tt">long int</span></span> encoded in value <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Val_int(</span></span><span class="font-it">i</span><span class="machine"><span class="font-tt">)</span></span> returns the value encoding the <span class="machine"><span class="font-tt">int</span></span> <span class="font-it">i</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Int_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the <span class="machine"><span class="font-tt">int</span></span> encoded in value <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Val_bool(</span></span><span class="font-it">x</span><span class="machine"><span class="font-tt">)</span></span> returns the OCaml boolean representing the
truth value of the C integer <span class="font-it">x</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Bool_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns 0 if <span class="font-it">v</span> is the OCaml boolean
<span class="machine"><span class="font-tt">false</span></span>, 1 if <span class="font-it">v</span> is <span class="machine"><span class="font-tt">true</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Val_true</span></span>, <span class="machine"><span class="font-tt">Val_false</span></span> represent the OCaml booleans <span class="machine"><span class="font-tt">true</span></span> and <span class="machine"><span class="font-tt">false</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Val_none</span></span> represents the OCaml value <span class="machine"><span class="font-tt">None</span></span>.
</li></ul>
<!--TOC subsection id="ss:c-block-access" 22.4.3â€ƒAccessing blocks-->
<h3 class="subsection" id="ss:c-block-access"><a class="section-anchor" href="#ss:c-block-access" aria-hidden="true">ï»¿</a>22.4.3â€ƒAccessing blocks</h3><!--SEC END --><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">Wosize_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the size of the block <span class="font-it">v</span>, in words,
excluding the header.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Tag_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the tag of the block <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Field(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns the value contained in the
<span class="font-it">n</span><sup><span class="th">th</span></sup> field of the structured block <span class="font-it">v</span>. Fields are numbered from 0 to
<span class="machine"><span class="font-tt">Wosize_val</span></span>(<span class="font-it">v</span>)âˆ’1.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Store_field(</span></span><span class="font-it">b</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> stores the value
<span class="font-it">v</span> in the field number <span class="font-it">n</span> of value <span class="font-it">b</span>, which must be a
structured block.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Code_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the code part of the closure <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_string_length(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the length (number of bytes)
of the string or byte sequence <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Byte(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns the <span class="font-it">n</span><sup><span class="th">th</span></sup> byte of the string
or byte sequence <span class="font-it">v</span>, with type <span class="machine"><span class="font-tt">char</span></span>. Bytes are numbered from 0 to
<span class="machine"><span class="font-tt">string_length</span></span>(<span class="font-it">v</span>)âˆ’1.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Byte_u(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns the <span class="font-it">n</span><sup><span class="th">th</span></sup> byte of the string
or byte sequence <span class="font-it">v</span>, with type <span class="machine"><span class="font-tt">unsigned char</span></span>. Bytes are
numbered from 0 to <span class="machine"><span class="font-tt">string_length</span></span>(<span class="font-it">v</span>)âˆ’1.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">String_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns a pointer to the first byte of the string
<span class="font-it">v</span>, with type <span class="machine"><span class="font-tt">const char *</span></span>.
This pointer is a valid C string: there is a null byte after the last
byte in the string. However, OCaml strings can contain embedded null bytes,
which will confuse the usual C functions over strings.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Bytes_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns a pointer to the first byte of the
byte sequence <span class="font-it">v</span>, with type <span class="machine"><span class="font-tt">unsigned char *</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Double_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the floating-point number contained in
value <span class="font-it">v</span>, with type <span class="machine"><span class="font-tt">double</span></span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Double_field(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns
the <span class="font-it">n</span><sup><span class="th">th</span></sup> element of the array of floating-point numbers <span class="font-it">v</span> (a
block tagged <span class="machine"><span class="font-tt">Double_array_tag</span></span>).
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Store_double_field(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">d</span><span class="machine"><span class="font-tt">)</span></span> stores the double precision floating-point number <span class="font-it">d</span>
in the <span class="font-it">n</span><sup><span class="th">th</span></sup> element of the array of floating-point numbers <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Data_custom_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns a pointer to the data part
of the custom block <span class="font-it">v</span>. This pointer has type <span class="machine"><span class="font-tt">void *</span></span> and must
be cast to the type of the data contained in the custom block.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Int32_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the 32-bit integer contained
in the <span class="machine"><span class="font-tt">int32</span></span> <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Int64_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the 64-bit integer contained
in the <span class="machine"><span class="font-tt">int64</span></span> <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Nativeint_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the long integer contained
in the <span class="machine"><span class="font-tt">nativeint</span></span> <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_field_unboxed(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the value of the field
of a value <span class="font-it">v</span> of any unboxed type (record or concrete data type).
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_field_boxed(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the value of the field
of a value <span class="font-it">v</span> of any boxed type (record or concrete data type).
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_field_unboxable(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> calls either
<span class="machine"><span class="font-tt">caml_field_unboxed</span></span> or <span class="machine"><span class="font-tt">caml_field_boxed</span></span> according to the default
representation of unboxable types in the current version of OCaml.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">Some_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the argument <span class="machine"><span class="font-tt">\var{x}</span></span> of a value <span class="font-it">v</span> of
the form <span class="machine"><span class="font-tt">Some(</span></span><span class="font-it">x</span><span class="machine"><span class="font-tt">)</span></span>.
</li></ul><p>
The expressions <span class="machine"><span class="font-tt">Field(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span>,
<span class="machine"><span class="font-tt">Byte(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> and
<span class="machine"><span class="font-tt">Byte_u(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span>
are valid l-values. Hence, they can be assigned to, resulting in an
in-place modification of value <span class="font-it">v</span>.
Assigning directly to <span class="machine"><span class="font-tt">Field(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> must
be done with care to avoid confusing the garbage collector (see
below).</p>
<!--TOC subsection id="ss:c-block-allocation" 22.4.4â€ƒAllocating blocks-->
<h3 class="subsection" id="ss:c-block-allocation"><a class="section-anchor" href="#ss:c-block-allocation" aria-hidden="true">ï»¿</a>22.4.4â€ƒAllocating blocks</h3><!--SEC END -->
<!--TOC subsubsection id="sss:c-simple-allocation" Simple interface-->
<h4 class="subsubsection" id="sss:c-simple-allocation"><a class="section-anchor" href="#sss:c-simple-allocation" aria-hidden="true">ï»¿</a>Simple interface</h4><!--SEC END --><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">Atom(</span></span><span class="font-it">t</span><span class="machine"><span class="font-tt">)</span></span> returns an â€œatomâ€ (zero-sized block) with tag <span class="font-it">t</span>.
Zero-sized blocks are preallocated outside of the heap. It is
incorrect to try and allocate a zero-sized block using the functions below.
For instance, <span class="machine"><span class="font-tt">Atom(0)</span></span> represents the empty array.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">t</span><span class="machine"><span class="font-tt">)</span></span> returns a fresh block of size <span class="font-it">n</span>
with tag <span class="font-it">t</span>. If <span class="font-it">t</span> is less than <span class="machine"><span class="font-tt">No_scan_tag</span></span>, then the
fields of the block are initialized with a valid value in order to
satisfy the GC constraints.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_tuple(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns a fresh block of size
<span class="font-it">n</span> words, with tag 0.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_string(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> returns a byte sequence (or string) value of
length <span class="font-it">n</span> bytes. The sequence initially contains uninitialized bytes.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_initialized_string(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">p</span><span class="machine"><span class="font-tt">)</span></span> returns a byte sequence
(or string) value of length <span class="font-it">n</span> bytes. The value is initialized from the
<span class="font-it">n</span> bytes starting at address <span class="font-it">p</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_copy_string(</span></span><span class="font-it">s</span><span class="machine"><span class="font-tt">)</span></span> returns a string or byte sequence value
containing a copy of the null-terminated C string <span class="font-it">s</span> (a <span class="machine"><span class="font-tt">char *</span></span>).
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_copy_double(</span></span><span class="font-it">d</span><span class="machine"><span class="font-tt">)</span></span> returns a floating-point value initialized
with the <span class="machine"><span class="font-tt">double</span></span> <span class="font-it">d</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_copy_int32(</span></span><span class="font-it">i</span><span class="machine"><span class="font-tt">)</span></span>, <span class="machine"><span class="font-tt">caml_copy_int64(</span></span><span class="font-it">i</span><span class="machine"><span class="font-tt">)</span></span> and
<span class="machine"><span class="font-tt">caml_copy_nativeint(</span></span><span class="font-it">i</span><span class="machine"><span class="font-tt">)</span></span> return a value of OCaml type <span class="machine"><span class="font-tt">int32</span></span>,
<span class="machine"><span class="font-tt">int64</span></span> and <span class="machine"><span class="font-tt">nativeint</span></span>, respectively, initialized with the integer
<span class="font-it">i</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_array(</span></span><span class="font-it">f</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">a</span><span class="machine"><span class="font-tt">)</span></span> allocates an array of values, calling
function <span class="font-it">f</span> over each element of the input array <span class="font-it">a</span> to transform it
into a value. The array <span class="font-it">a</span> is an array of pointers terminated by the
null pointer. The function <span class="font-it">f</span> receives each pointer as argument, and
returns a value. The zero-tagged block returned by
<span class="machine"><span class="font-tt">alloc_array(</span></span><span class="font-it">f</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">a</span><span class="machine"><span class="font-tt">)</span></span> is filled with the values returned by the
successive calls to <span class="font-it">f</span>. (This function must not be used to build
an array of floating-point numbers.)
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_copy_string_array(</span></span><span class="font-it">p</span><span class="machine"><span class="font-tt">)</span></span> allocates an array of strings or byte
sequences, copied from the pointer to a string array <span class="font-it">p</span>
(a <span class="machine"><span class="font-tt">char **</span></span>). <span class="font-it">p</span> must be NULL-terminated.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_float_array(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> allocates an array of floating point
numbers of size <span class="font-it">n</span>. The array initially contains uninitialized values.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_unboxed(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns the value (of any unboxed
type) whose field is the value <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_boxed(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> allocates and returns a value (of
any boxed type) whose field is the value <span class="font-it">v</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_unboxable(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> calls either
<span class="machine"><span class="font-tt">caml_alloc_unboxed</span></span> or <span class="machine"><span class="font-tt">caml_alloc_boxed</span></span> according to the default
representation of unboxable types in the current version of OCaml.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_some(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> allocates a block representing
<span class="machine"><span class="font-tt">Some(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span>.
</li></ul>
<!--TOC subsubsection id="sss:c-low-level-alloc" Low-level interface-->
<h4 class="subsubsection" id="sss:c-low-level-alloc"><a class="section-anchor" href="#sss:c-low-level-alloc" aria-hidden="true">ï»¿</a>Low-level interface</h4><!--SEC END --><p>The following functions are slightly more efficient than <span class="machine"><span class="font-tt">caml_alloc</span></span>, but
also much more difficult to use.</p><p>From the standpoint of the allocation functions, blocks are divided
according to their size as zero-sized blocks, small blocks (with size
less than or equal to <code class="verb">Max_young_wosize</code>), and large blocks (with
size greater than <code class="verb">Max_young_wosize</code>). The constant
<code class="verb">Max_young_wosize</code> is declared in the include file <span class="machine"><span class="font-tt">mlvalues.h</span></span>. It
is guaranteed to be at least 64 (words), so that any block with
constant size less than or equal to 64 can be assumed to be small. For
blocks whose size is computed at run-time, the size must be compared
against <code class="verb">Max_young_wosize</code> to determine the correct allocation procedure.</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_small(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">t</span><span class="machine"><span class="font-tt">)</span></span> returns a fresh small block of size
<span class="font-it">n</span> â‰¤ <span class="machine"><span class="font-tt">Max_young_wosize</span></span> words, with tag <span class="font-it">t</span>.
If this block is a structured block (i.e. if <span class="font-it">t</span> &lt; <span class="machine"><span class="font-tt">No_scan_tag</span></span>), then
the fields of the block (initially containing garbage) must be initialized
with legal values (using direct assignment to the fields of the block)
before the next allocation.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_alloc_shr(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">t</span><span class="machine"><span class="font-tt">)</span></span> returns a fresh block of size
<span class="font-it">n</span>, with tag <span class="font-it">t</span>.
The size of the block can be greater than <code class="verb">Max_young_wosize</code>. (It
can also be smaller, but in this case it is more efficient to call
<span class="machine"><span class="font-tt">caml_alloc_small</span></span> instead of <span class="machine"><span class="font-tt">caml_alloc_shr</span></span>.)
If this block is a structured block (i.e. if <span class="font-it">t</span> &lt; <span class="machine"><span class="font-tt">No_scan_tag</span></span>), then
the fields of the block (initially containing garbage) must be initialized
with legal values (using the <span class="machine"><span class="font-tt">caml_initialize</span></span> function described below)
before the next allocation.
</li></ul>
<!--TOC subsection id="ss:c-exceptions" 22.4.5â€ƒRaising exceptions-->
<h3 class="subsection" id="ss:c-exceptions"><a class="section-anchor" href="#ss:c-exceptions" aria-hidden="true">ï»¿</a>22.4.5â€ƒRaising exceptions</h3><!--SEC END --><p>Two functions are provided to raise two standard exceptions:
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_failwith(</span></span><span class="font-it">s</span><span class="machine"><span class="font-tt">)</span></span>, where <span class="font-it">s</span> is a null-terminated C string (with
type <code class="verb">char *</code>), raises exception <span class="machine"><span class="font-tt">Failure</span></span> with argument <span class="font-it">s</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_invalid_argument(</span></span><span class="font-it">s</span><span class="machine"><span class="font-tt">)</span></span>, where <span class="font-it">s</span> is a null-terminated C
string (with type <code class="verb">char *</code>), raises exception <span class="machine"><span class="font-tt">Invalid_argument</span></span>
with argument <span class="font-it">s</span>.
</li></ul><p>Raising arbitrary exceptions from C is more delicate: the
exception identifier is dynamically allocated by the OCaml program, and
therefore must be communicated to the C function using the
registration facility described below in sectionÂ <a href="#ss%3Ac-register-exn">22.7.3</a>.
Once the exception identifier is recovered in C, the following
functions actually raise the exception:
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_raise_constant(</span></span><span class="font-it">id</span><span class="machine"><span class="font-tt">)</span></span> raises the exception <span class="font-it">id</span> with
no argument;
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_raise_with_arg(</span></span><span class="font-it">id</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> raises the exception
<span class="font-it">id</span> with the OCaml value <span class="font-it">v</span> as argument;
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_raise_with_args(</span></span><span class="font-it">id</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span>
raises the exception <span class="font-it">id</span> with the OCaml values
<span class="font-it">v</span><span class="machine"><span class="font-tt">[0]</span></span>, â€¦, <span class="font-it">v</span><span class="machine"><span class="font-tt">[</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">-1]</span></span> as arguments;
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_raise_with_string(</span></span><span class="font-it">id</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">s</span><span class="machine"><span class="font-tt">)</span></span>, where <span class="font-it">s</span> is a
null-terminated C string, raises the exception <span class="font-it">id</span> with a copy of
the C string <span class="font-it">s</span> as argument.
</li></ul>
<!--TOC section id="s:c-gc-harmony" 22.5â€ƒLiving in harmony with the garbage collector-->
<h2 class="section" id="s:c-gc-harmony"><a class="section-anchor" href="#s:c-gc-harmony" aria-hidden="true">ï»¿</a>22.5â€ƒLiving in harmony with the garbage collector</h2><!--SEC END --><p>Unused blocks in the heap are automatically reclaimed by the garbage
collector. This requires some cooperation from C code that
manipulates heap-allocated blocks.</p>
<!--TOC subsection id="ss:c-simple-gc-harmony" 22.5.1â€ƒSimple interface-->
<h3 class="subsection" id="ss:c-simple-gc-harmony"><a class="section-anchor" href="#ss:c-simple-gc-harmony" aria-hidden="true">ï»¿</a>22.5.1â€ƒSimple interface</h3><!--SEC END --><p>All the macros described in this section are declared in the
<span class="machine"><span class="font-tt">memory.h</span></span> header file.</p><div class="theorem"><span class="font-bold">RuleÂ 1</span>â€ƒ<em>
A function that has parameters or local variables of type <span class="machine"><span class="font-tt">value</span></span> must
begin with a call to one of the <span class="machine"><span class="font-tt">CAMLparam</span></span> macros and return with
<span class="machine"><span class="font-tt">CAMLreturn</span></span>, <span class="machine"><span class="font-tt">CAMLreturn0</span></span>, or <span class="machine"><span class="font-tt">CAMLreturnT</span></span>. In particular, <span class="machine"><span class="font-tt">CAMLlocal</span></span>
and <span class="machine"><span class="font-tt">CAMLxparam</span></span> can only be called </em>after <em><span class="machine"><span class="font-tt">CAMLparam</span></span>.
</em></div><p>There are six <span class="machine"><span class="font-tt">CAMLparam</span></span> macros: <span class="machine"><span class="font-tt">CAMLparam0</span></span> to <span class="machine"><span class="font-tt">CAMLparam5</span></span>, which
take zero to five arguments respectively. If your function has no more
than 5 parameters of type <span class="machine"><span class="font-tt">value</span></span>, use the corresponding macros
with these parameters as arguments. If your function has more than 5
parameters of type <span class="machine"><span class="font-tt">value</span></span>, use <span class="machine"><span class="font-tt">CAMLparam5</span></span> with five of these
parameters, and use one or more calls to the <span class="machine"><span class="font-tt">CAMLxparam</span></span> macros for
the remaining parameters (<span class="machine"><span class="font-tt">CAMLxparam1</span></span> to <span class="machine"><span class="font-tt">CAMLxparam5</span></span>).</p><p>The macros <span class="machine"><span class="font-tt">CAMLreturn</span></span>, <span class="machine"><span class="font-tt">CAMLreturn0</span></span>, and <span class="machine"><span class="font-tt">CAMLreturnT</span></span> are used to
replace the C
keyword <span class="machine"><span class="font-tt">return</span></span>. Every occurrence of <span class="machine"><span class="font-tt">return x</span></span> must be replaced by
<span class="machine"><span class="font-tt">CAMLreturn (x)</span></span> if <span class="machine"><span class="font-tt">x</span></span> has type <span class="machine"><span class="font-tt">value</span></span>, or <span class="machine"><span class="font-tt">CAMLreturnT (t, x)</span></span>
(where <span class="machine"><span class="font-tt">t</span></span> is the type of <span class="machine"><span class="font-tt">x</span></span>); every occurrence of <span class="machine"><span class="font-tt">return</span></span> without
argument must be
replaced by <span class="machine"><span class="font-tt">CAMLreturn0</span></span>. If your C function is a procedure (i.e. if
it returns void), you must insert <span class="machine"><span class="font-tt">CAMLreturn0</span></span> at the end (to replace
Câ€™s implicit <span class="machine"><span class="font-tt">return</span></span>).</p>
<!--TOC paragraph id="sec499" Note:-->
<h5 class="paragraph" id="sec499"><a class="section-anchor" href="#sec499" aria-hidden="true">ï»¿</a>Note:</h5><!--SEC END --><p> some C compilers give bogus warnings about unused
variables <span class="machine"><span class="font-tt">caml__dummy_xxx</span></span> at each use of <span class="machine"><span class="font-tt">CAMLparam</span></span> and
<span class="machine"><span class="font-tt">CAMLlocal</span></span>. You should ignore them.</p><p> <br>
</p><p>Example:
</p><pre>void foo (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  ...
  CAMLreturn0;
}
</pre>
<!--TOC paragraph id="sec500" Note:-->
<h5 class="paragraph" id="sec500"><a class="section-anchor" href="#sec500" aria-hidden="true">ï»¿</a>Note:</h5><!--SEC END --><p> if your function is a primitive with more than 5 arguments
for use with the byte-code runtime, its arguments are not <span class="machine"><span class="font-tt">value</span></span>s and
must not be declared (they have types <span class="machine"><span class="font-tt">value *</span></span> and <span class="machine"><span class="font-tt">int</span></span>).</p><div class="theorem"><span class="font-bold">RuleÂ 2</span>â€ƒ<em>
Local variables of type <span class="machine"><span class="font-tt">value</span></span> must be declared with one of the
<span class="machine"><span class="font-tt">CAMLlocal</span></span> macros. Arrays of <span class="machine"><span class="font-tt">value</span></span>s are declared with
<span class="machine"><span class="font-tt">CAMLlocalN</span></span>. These macros must be used at the beginning of the
function, not in a nested block.
</em></div><p>The macros <span class="machine"><span class="font-tt">CAMLlocal1</span></span> to <span class="machine"><span class="font-tt">CAMLlocal5</span></span> declare and initialize one to
five local variables of type <span class="machine"><span class="font-tt">value</span></span>. The variable names are given as
arguments to the macros. <span class="machine"><span class="font-tt">CAMLlocalN(</span></span><span class="font-it">x</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span> declares
and initializes a local variable of type <span class="machine"><span class="font-tt">value [</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">]</span></span>. You can
use several calls to these macros if you have more than 5 local
variables.</p><p>Example:
</p><pre>CAMLprim value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  ...
  CAMLreturn (result);
}
</pre><div class="theorem"><span class="font-bold">RuleÂ 3</span>â€ƒ<em>
Assignments to the fields of structured blocks must be done with the
<span class="machine"><span class="font-tt">Store_field</span></span> macro (for normal blocks) or <span class="machine"><span class="font-tt">Store_double_field</span></span> macro
(for arrays and records of floating-point numbers). Other assignments
must not use <span class="machine"><span class="font-tt">Store_field</span></span> nor <span class="machine"><span class="font-tt">Store_double_field</span></span>.
</em></div><p><span class="machine"><span class="font-tt">Store_field (</span></span><span class="font-it">b</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> stores the value
<span class="font-it">v</span> in the field number <span class="font-it">n</span> of value <span class="font-it">b</span>, which must be a
block (i.e. <span class="machine"><span class="font-tt">Is_block(</span></span><span class="font-it">b</span><span class="machine"><span class="font-tt">)</span></span> must be true).</p><p>Example:
</p><pre>CAMLprim value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  Store_field (result, 0, v1);
  Store_field (result, 1, v2);
  Store_field (result, 2, v3);
  CAMLreturn (result);
}
</pre>
<!--TOC paragraph id="sec501" Warning:-->
<h5 class="paragraph" id="sec501"><a class="section-anchor" href="#sec501" aria-hidden="true">ï»¿</a>Warning:</h5><!--SEC END --><p> The first argument of <span class="machine"><span class="font-tt">Store_field</span></span> and
<span class="machine"><span class="font-tt">Store_double_field</span></span> must be a variable declared by <span class="machine"><span class="font-tt">CAMLparam*</span></span> or
a parameter declared by <span class="machine"><span class="font-tt">CAMLlocal*</span></span> to ensure that a garbage
collection triggered by the evaluation of the other arguments will not
invalidate the first argument after it is computed.</p>
<!--TOC paragraph id="sec502" Use with CAMLlocalN:-->
<h5 class="paragraph" id="sec502"><a class="section-anchor" href="#sec502" aria-hidden="true">ï»¿</a>Use with CAMLlocalN:</h5><!--SEC END --><p> Arrays of values declared using
<span class="machine"><span class="font-tt">CAMLlocalN</span></span> must not be written to using <span class="machine"><span class="font-tt">Store_field</span></span>.
Use the normal C array syntax instead.</p><div class="theorem"><span class="font-bold">RuleÂ 4</span>â€ƒ<em> Global variables containing values must be registered
with the garbage collector using the <span class="machine"><span class="font-tt">caml_register_global_root</span></span> function,
save that global variables and locations that will only ever contain OCaml
integers (and never pointers) do not have to be registered.</em><p><em>The same is true for any memory location outside the OCaml heap that contains a
value and is not guaranteed to be reachableâ€”for as long as it contains such
valueâ€”from either another registered global variable or location, local
variable declared with <span class="machine"><span class="font-tt">CAMLlocal</span></span> or function parameter declared with
<span class="machine"><span class="font-tt">CAMLparam</span></span>.
</em></p></div><p>Registration of a global variable <span class="machine"><span class="font-tt">v</span></span> is achieved by calling
<span class="machine"><span class="font-tt">caml_register_global_root(&amp;v)</span></span> just before or just after a valid value is
stored in <span class="machine"><span class="font-tt">v</span></span> for the first time; likewise, registration of an arbitrary
location <span class="machine"><span class="font-tt">p</span></span> is achieved by calling <span class="machine"><span class="font-tt">caml_register_global_root(p)</span></span>.</p><p>You must not call any of the OCaml runtime functions or macros between
registering and storing the value. Neither must you store anything in the
variable <span class="machine"><span class="font-tt">v</span></span> (likewise, the location <span class="machine"><span class="font-tt">p</span></span>) that is not a valid value.</p><p>The registration causes the contents of the variable or memory location to be
updated by the garbage collector whenever the value in such variable or location
is moved within the OCaml heap. In the presence of threads care must be taken to
ensure appropriate synchronisation with the OCaml runtime to avoid a race
condition against the garbage collector when reading or writing the value. (See
section
<a href="#ss%3Aparallel-execution-long-running-c-code">22.12.2</a>.)</p><p>A registered global variable <span class="machine"><span class="font-tt">v</span></span> can be un-registered by calling
<span class="machine"><span class="font-tt">caml_remove_global_root(&amp;v)</span></span>.</p><p>If the contents of the global variable <span class="machine"><span class="font-tt">v</span></span> are seldom modified after
registration, better performance can be achieved by calling
<span class="machine"><span class="font-tt">caml_register_generational_global_root(&amp;v)</span></span> to register <span class="machine"><span class="font-tt">v</span></span> (after
its initialization with a valid <span class="machine"><span class="font-tt">value</span></span>, but before any allocation or
call to the GC functions),
and <span class="machine"><span class="font-tt">caml_remove_generational_global_root(&amp;v)</span></span> to un-register it. In
this case, you must not modify the value of <span class="machine"><span class="font-tt">v</span></span> directly, but you must
use <span class="machine"><span class="font-tt">caml_modify_generational_global_root(&amp;v,x)</span></span> to set it to <span class="machine"><span class="font-tt">x</span></span>.
The garbage collector takes advantage of the guarantee that <span class="machine"><span class="font-tt">v</span></span> is not
modified between calls to <span class="machine"><span class="font-tt">caml_modify_generational_global_root</span></span> to scan it
less often. This improves performance if the
modifications of <span class="machine"><span class="font-tt">v</span></span> happen less often than minor collections.</p>
<!--TOC paragraph id="sec503" Note:-->
<h5 class="paragraph" id="sec503"><a class="section-anchor" href="#sec503" aria-hidden="true">ï»¿</a>Note:</h5><!--SEC END --><p> The <span class="machine"><span class="font-tt">CAML</span></span> macros use identifiers (local variables, type
identifiers, structure tags) that start with <span class="machine"><span class="font-tt">caml__</span></span>. Do not use any
identifier starting with <span class="machine"><span class="font-tt">caml__</span></span> in your programs.</p>
<!--TOC subsection id="ss:c-low-level-gc-harmony" 22.5.2â€ƒLow-level interface-->
<h3 class="subsection" id="ss:c-low-level-gc-harmony"><a class="section-anchor" href="#ss:c-low-level-gc-harmony" aria-hidden="true">ï»¿</a>22.5.2â€ƒLow-level interface</h3><!--SEC END --><p>We now give the GC rules corresponding to the low-level allocation
functions <span class="machine"><span class="font-tt">caml_alloc_small</span></span> and <span class="machine"><span class="font-tt">caml_alloc_shr</span></span>. You can ignore those rules
if you stick to the simplified allocation function <span class="machine"><span class="font-tt">caml_alloc</span></span>.</p><div class="theorem"><span class="font-bold">RuleÂ 5</span>â€ƒ<em> After a structured block (a block with tag less than
<span class="machine"><span class="font-tt">No_scan_tag</span></span>) is allocated with the low-level functions, all fields
of this block must be filled with well-formed values before the next
allocation operation. If the block has been allocated with
<span class="machine"><span class="font-tt">caml_alloc_small</span></span>, filling is performed by direct assignment to the fields
of the block:
</em><pre><em>
        Field(<span class="font-it">v</span>, <span class="font-it">n</span>) = </em><span class="font-it">v</span><sub><span class="font-it">n</span></sub><em>;
</em></pre><em>
If the block has been allocated with <span class="machine"><span class="font-tt">caml_alloc_shr</span></span>, filling is performed
through the <span class="machine"><span class="font-tt">caml_initialize</span></span> function:
</em><pre><em>
        caml_initialize(&amp;Field(<span class="font-it">v</span>, <span class="font-it">n</span>), </em><span class="font-it">v</span><sub><span class="font-it">n</span></sub><em>);
</em></pre>
</div><p>The next allocation can trigger a garbage collection. The garbage
collector assumes that all structured blocks contain well-formed
values. Newly created blocks contain random data, which generally do
not represent well-formed values.</p><p>If you really need to allocate before the fields can receive their
final value, first initialize with a constant value (e.g.
<span class="machine"><span class="font-tt">Val_unit</span></span>), then allocate, then modify the fields with the correct
value (see ruleÂ 6).</p><div class="theorem"><span class="font-bold">RuleÂ 6</span>â€ƒ<em> Direct assignment to a field of a block, as in
</em><pre><em>
        Field(<span class="font-it">v</span>, <span class="font-it">n</span>) = <span class="font-it">w</span>;
</em></pre><em>
is safe only if <span class="font-it">v</span> is a block newly allocated by <span class="machine"><span class="font-tt">caml_alloc_small</span></span>;
that is, if no allocation took place between the
allocation of <span class="font-it">v</span> and the assignment to the field. In all other cases,
never assign directly. If the block has just been allocated by <span class="machine"><span class="font-tt">caml_alloc_shr</span></span>,
use <span class="machine"><span class="font-tt">caml_initialize</span></span> to assign a value to a field for the first time:
</em><pre><em>
        caml_initialize(&amp;Field(<span class="font-it">v</span>, <span class="font-it">n</span>), <span class="font-it">w</span>);
</em></pre><em>
Otherwise, you are updating a field that previously contained a
well-formed value; then, call the <span class="machine"><span class="font-tt">caml_modify</span></span> function:
</em><pre><em>
        caml_modify(&amp;Field(<span class="font-it">v</span>, <span class="font-it">n</span>), <span class="font-it">w</span>);
</em></pre>
</div><p>To illustrate the rules above, here is a C function that builds and
returns a list containing the two integers given as parameters.
First, we write it using the simplified allocation functions:
</p><pre>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc(2, 0);                   /* Allocate a cons cell */
  Store_field(r, 0, Val_int(i2));         /* car = the integer i2 */
  Store_field(r, 1, Val_int(0));          /* cdr = the empty list [] */
  result = caml_alloc(2, 0);              /* Allocate the other cons cell */
  Store_field(result, 0, Val_int(i1));    /* car = the integer i1 */
  Store_field(result, 1, r);              /* cdr = the first cons cell */
  CAMLreturn (result);
}
</pre><p>Here, the registering of <span class="machine"><span class="font-tt">result</span></span> is not strictly needed, because no
allocation takes place after it gets its value, but itâ€™s easier and
safer to simply register all the local variables that have type <span class="machine"><span class="font-tt">value</span></span>.</p><p>Here is the same function written using the low-level allocation
functions. We notice that the cons cells are small blocks and can be
allocated with <span class="machine"><span class="font-tt">caml_alloc_small</span></span>, and filled by direct assignments on
their fields.
</p><pre>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
  Field(r, 0) = Val_int(i2);              /* car = the integer i2 */
  Field(r, 1) = Val_int(0);               /* cdr = the empty list [] */
  result = caml_alloc_small(2, 0);        /* Allocate the other cons cell */
  Field(result, 0) = Val_int(i1);         /* car = the integer i1 */
  Field(result, 1) = r;                   /* cdr = the first cons cell */
  CAMLreturn (result);
}
</pre><p>In the two examples above, the list is built bottom-up. Here is an
alternate way, that proceeds top-down. It is less efficient, but
illustrates the use of <span class="machine"><span class="font-tt">caml_modify</span></span>.
</p><pre>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (tail, r);

  r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
  Field(r, 0) = Val_int(i1);              /* car = the integer i1 */
  Field(r, 1) = Val_int(0);               /* A dummy value
  tail = caml_alloc_small(2, 0);          /* Allocate the other cons cell */
  Field(tail, 0) = Val_int(i2);           /* car = the integer i2 */
  Field(tail, 1) = Val_int(0);            /* cdr = the empty list [] */
  caml_modify(&amp;Field(r, 1), tail);        /* cdr of the result = tail */
  CAMLreturn (r);
}
</pre><p>It would be incorrect to perform
<span class="machine"><span class="font-tt">Field(r, 1) = tail</span></span> directly, because the allocation of <span class="machine"><span class="font-tt">tail</span></span>
has taken place since <span class="machine"><span class="font-tt">r</span></span> was allocated.</p>
<!--TOC subsection id="ss:c-process-pending-actions" 22.5.3â€ƒPending actions and asynchronous exceptions-->
<h3 class="subsection" id="ss:c-process-pending-actions"><a class="section-anchor" href="#ss:c-process-pending-actions" aria-hidden="true">ï»¿</a>22.5.3â€ƒPending actions and asynchronous exceptions</h3><!--SEC END --><p>Since 4.10, allocation functions are guaranteed not to call any OCaml
callbacks from C, including finalisers and signal handlers, and delay
their execution instead.</p><p>The function <code class="verb">caml_process_pending_actions</code> from
<span class="machine"><span class="font-tt">&lt;caml/signals.h&gt;</span></span> executes any pending signal handlers and
finalisers, Memprof callbacks, and requested minor and major garbage
collections. In particular, it can raise asynchronous exceptions. It
is recommended to call it regularly at safe points inside long-running
non-blocking C code.</p><p>The variant <code class="verb">caml_process_pending_actions_exn</code> is provided, that
returns the exception instead of raising it directly into OCaml code.
Its result must be tested using <span class="font-tt">Is_exception_result</span>, and
followed by <span class="font-tt">Extract_exception</span> if appropriate. It is typically
used for clean up before re-raising:</p><pre>    CAMLlocal1(exn);
    ...
    exn = caml_process_pending_actions_exn();
    if(Is_exception_result(exn)) {
      exn = Extract_exception(exn);
      ...cleanup...
      caml_raise(exn);
    }
</pre><p>
Correct use of exceptional return, in particular in the presence of
garbage collection, is further detailed in SectionÂ <a href="#ss%3Ac-callbacks">22.7.1</a>.</p>
<!--TOC section id="s:c-intf-example" 22.6â€ƒA complete example-->
<h2 class="section" id="s:c-intf-example"><a class="section-anchor" href="#s:c-intf-example" aria-hidden="true">ï»¿</a>22.6â€ƒA complete example</h2><!--SEC END --><p>This section outlines how the functions from the Unix <span class="machine"><span class="font-tt">curses</span></span> library
can be made available to OCaml programs. First of all, here is
the interface <span class="machine"><span class="font-tt">curses.ml</span></span> that declares the <span class="machine"><span class="font-tt">curses</span></span> primitives and
data types:
</p><pre>(* File curses.ml -- declaration of primitives and data types *)
type window                   (* The type "window" remains abstract *)
external initscr: unit -&gt; window = "caml_curses_initscr"
external endwin: unit -&gt; unit = "caml_curses_endwin"
external refresh: unit -&gt; unit = "caml_curses_refresh"
external wrefresh : window -&gt; unit = "caml_curses_wrefresh"
external newwin: int -&gt; int -&gt; int -&gt; int -&gt; window = "caml_curses_newwin"
external addch: char -&gt; unit = "caml_curses_addch"
external mvwaddch: window -&gt; int -&gt; int -&gt; char -&gt; unit = "caml_curses_mvwaddch"
external addstr: string -&gt; unit = "caml_curses_addstr"
external mvwaddstr: window -&gt; int -&gt; int -&gt; string -&gt; unit
         = "caml_curses_mvwaddstr"
(* lots more omitted *)
</pre><p>To compile this interface:
</p><pre>        ocamlc -c curses.ml
</pre><p>
To implement these functions, we just have to provide the stub code;
the core functions are already implemented in the <span class="machine"><span class="font-tt">curses</span></span> library.
The stub code file, <span class="machine"><span class="font-tt">curses_stubs.c</span></span>, looks like this:
</p><pre>/* File curses_stubs.c -- stub code for curses */
#include &lt;curses.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/custom.h&gt;

/* Encapsulation of opaque window handles (of type WINDOW *)
   as OCaml custom blocks. */

static struct custom_operations curses_window_ops = {
  "fr.inria.caml.curses_windows",
  custom_finalize_default,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default,
  custom_compare_ext_default,
  custom_fixed_length_default
};

/* Accessing the WINDOW * part of an OCaml custom block */
#define Window_val(v) (*((WINDOW **) Data_custom_val(v)))

/* Allocating an OCaml custom block to hold the given WINDOW * */
static value alloc_window(WINDOW * w)
{
  value v = caml_alloc_custom(&amp;curses_window_ops, sizeof(WINDOW *), 0, 1);
  Window_val(v) = w;
  return v;
}

CAMLprim value caml_curses_initscr(value unit)
{
  CAMLparam1 (unit);
  CAMLreturn (alloc_window(initscr()));
}

CAMLprim value caml_curses_endwin(value unit)
{
  CAMLparam1 (unit);
  endwin();
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_refresh(value unit)
{
  CAMLparam1 (unit);
  refresh();
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_wrefresh(value win)
{
  CAMLparam1 (win);
  wrefresh(Window_val(win));
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_newwin(value nlines, value ncols, value x0, value y0)
{
  CAMLparam4 (nlines, ncols, x0, y0);
  CAMLreturn (alloc_window(newwin(Int_val(nlines), Int_val(ncols),
                                  Int_val(x0), Int_val(y0))));
}

CAMLprim value caml_curses_addch(value c)
{
  CAMLparam1 (c);
  addch(Int_val(c));            /* Characters are encoded like integers */
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_mvwaddch(value win, value x, value y, value c)
{
  CAMLparam4 (win, x, y, c);
  mvwaddch(Window_val(win), Int_val(x), Int_val(y), Int_val(c));
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_addstr(value s)
{
  CAMLparam1 (s);
  addstr(String_val(s));
  CAMLreturn (Val_unit);
}

CAMLprim value caml_curses_mvwaddstr(value win, value x, value y, value s)
{
  CAMLparam4 (win, x, y, s);
  mvwaddstr(Window_val(win), Int_val(x), Int_val(y), String_val(s));
  CAMLreturn (Val_unit);
}

/* This goes on for pages. */
</pre><p>
The file <span class="machine"><span class="font-tt">curses_stubs.c</span></span> can be compiled with:
</p><pre>        cc -c -I`ocamlc -where` curses_stubs.c
</pre><p>or, even simpler,
</p><pre>        ocamlc -c curses_stubs.c
</pre><p>(When passed a <span class="machine"><span class="font-tt">.c</span></span> file, the <span class="machine"><span class="font-tt">ocamlc</span></span> command simply calls the C
compiler on that file, with the right <span class="machine"><span class="font-tt">-I</span></span> option.)</p><p>Now, here is a sample OCaml program <span class="machine"><span class="font-tt">prog.ml</span></span> that uses the <span class="machine"><span class="font-tt">curses</span></span>
module:
</p><pre>(* File prog.ml -- main program using curses *)
open Curses;;
let main_window = initscr () in
let small_window = newwin 10 5 20 10 in
  mvwaddstr main_window 10 2 "Hello";
  mvwaddstr small_window 4 3 "world";
  refresh();
  Unix.sleep 5;
  endwin()
</pre><p>To compile and link this program, run:
</p><pre>       ocamlc -custom -o prog unix.cma curses.cmo prog.ml curses_stubs.o -cclib -lcurses
</pre><p>(On some machines, you may need to put
<span class="machine"><span class="font-tt">-cclib -lcurses -cclib -ltermcap</span></span> or <span class="machine"><span class="font-tt">-cclib -ltermcap</span></span>
instead of <span class="machine"><span class="font-tt">-cclib -lcurses</span></span>.)</p>
<!--TOC section id="s:c-callback" 22.7â€ƒAdvanced topic: callbacks from C to OCaml-->
<h2 class="section" id="s:c-callback"><a class="section-anchor" href="#s:c-callback" aria-hidden="true">ï»¿</a>22.7â€ƒAdvanced topic: callbacks from C to OCaml</h2><!--SEC END --><p>So far, we have described how to call C functions from OCaml. In this
section, we show how C functions can call OCaml functions, either as
callbacks (OCaml calls C which calls OCaml), or with the main program
written in C.</p>
<!--TOC subsection id="ss:c-callbacks" 22.7.1â€ƒApplying OCaml closures from C-->
<h3 class="subsection" id="ss:c-callbacks"><a class="section-anchor" href="#ss:c-callbacks" aria-hidden="true">ï»¿</a>22.7.1â€ƒApplying OCaml closures from C</h3><!--SEC END --><p>C functions can apply OCaml function values (closures) to OCaml values.
The following functions are provided to perform the applications:
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_callback(</span></span><span class="font-it">f, a</span><span class="machine"><span class="font-tt">)</span></span> applies the functional value <span class="font-it">f</span> to
the value <span class="font-it">a</span> and returns the value returned byÂ <span class="font-it">f</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_callback2(</span></span><span class="font-it">f, a, b</span><span class="machine"><span class="font-tt">)</span></span> applies the functional value <span class="font-it">f</span>
(which is assumed to be a curried OCaml function with two arguments) to
<span class="font-it">a</span> and <span class="font-it">b</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_callback3(</span></span><span class="font-it">f, a, b, c</span><span class="machine"><span class="font-tt">)</span></span> applies the functional value <span class="font-it">f</span>
(a curried OCaml function with three arguments) to <span class="font-it">a</span>, <span class="font-it">b</span> and <span class="font-it">c</span>.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_callbackN(</span></span><span class="font-it">f, n, args</span><span class="machine"><span class="font-tt">)</span></span> applies the functional value <span class="font-it">f</span>
to the <span class="font-it">n</span> arguments contained in the C array of values <span class="font-it">args</span>.
</li></ul><p>
If the function <span class="font-it">f</span> does not return, but raises an exception that
escapes the scope of the application, then this exception is
propagated to the next enclosing OCaml code, skipping over the C
code. That is, if an OCaml function <span class="font-it">f</span> calls a C function <span class="font-it">g</span> that
calls back an OCaml function <span class="font-it">h</span> that raises a stray exception, then the
execution of <span class="font-it">g</span> is interrupted and the exception is propagated back
into <span class="font-it">f</span>.</p><p>If the C code wishes to catch exceptions escaping the OCaml function,
it can use the functions <span class="machine"><span class="font-tt">caml_callback_exn</span></span>, <span class="machine"><span class="font-tt">caml_callback2_exn</span></span>,
<span class="machine"><span class="font-tt">caml_callback3_exn</span></span>, <span class="machine"><span class="font-tt">caml_callbackN_exn</span></span>. These functions take the same
arguments as their non-<span class="machine"><span class="font-tt">_exn</span></span> counterparts, but catch escaping
exceptions and return them to the C code. The return value <span class="font-it">v</span> of the
<span class="machine"><span class="font-tt">caml_callback*_exn</span></span> functions must be tested with the macro
<span class="machine"><span class="font-tt">Is_exception_result(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span>. If the macro returns â€œfalseâ€, no
exception occurred, and <span class="font-it">v</span> is the value returned by the OCaml
function. If <span class="machine"><span class="font-tt">Is_exception_result(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns â€œtrueâ€,
an exception escaped, and its value (the exception descriptor) can be
recovered using <span class="machine"><span class="font-tt">Extract_exception(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span>.</p>
<!--TOC paragraph id="sec509" Warning:-->
<h5 class="paragraph" id="sec509"><a class="section-anchor" href="#sec509" aria-hidden="true">ï»¿</a>Warning:</h5><!--SEC END --><p> If the OCaml function returned with an exception,
<span class="machine"><span class="font-tt">Extract_exception</span></span> should be applied to the exception result prior
to calling a function that may trigger garbage collection.
Otherwise, if <span class="font-it">v</span> is reachable during garbage collection, the runtime
can crash since <span class="font-it">v</span> does not contain a valid value.</p><p>Example:
</p><pre>    CAMLprim value call_caml_f_ex(value closure, value arg)
    {
      CAMLparam2(closure, arg);
      CAMLlocal2(res, tmp);
      res = caml_callback_exn(closure, arg);
      if(Is_exception_result(res)) {
        res = Extract_exception(res);
        tmp = caml_alloc(3, 0); /* Safe to allocate: res contains valid value. */
        ...
      }
      CAMLreturn (res);
    }
</pre>
<!--TOC subsection id="ss:c-closures" 22.7.2â€ƒObtaining or registering OCaml closures for use in C functions-->
<h3 class="subsection" id="ss:c-closures"><a class="section-anchor" href="#ss:c-closures" aria-hidden="true">ï»¿</a>22.7.2â€ƒObtaining or registering OCaml closures for use in C functions</h3><!--SEC END --><p>There are two ways to obtain OCaml function values (closures) to
be passed to the <span class="machine"><span class="font-tt">callback</span></span> functions described above. One way is to
pass the OCaml function as an argument to a primitive function. For
example, if the OCaml code contains the declaration
</p><pre>    external apply : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = "caml_apply"
</pre><p>the corresponding C stub can be written as follows:
</p><pre>    CAMLprim value caml_apply(value vf, value vx)
    {
      CAMLparam2(vf, vx);
      CAMLlocal1(vy);
      vy = caml_callback(vf, vx);
      CAMLreturn(vy);
    }
</pre><p>
Another possibility is to use the registration mechanism provided by
OCaml. This registration mechanism enables OCaml code to register
OCaml functions under some global name, and C code to retrieve the
corresponding closure by this global name.</p><p>On the OCaml side, registration is performed by evaluating
<span class="machine"><span class="font-tt">Callback.register</span></span> <span class="font-it">n</span> <span class="font-it">v</span>. Here, <span class="font-it">n</span> is the global name
(an arbitrary string) and <span class="font-it">v</span> the OCaml value. For instance:
</p><pre>    let f x = print_string "f is applied to "; print_int x; print_newline()
    let _ = Callback.register "test function" f
</pre><p>
On the C side, a pointer to the value registered under name <span class="font-it">n</span> is
obtained by calling <span class="machine"><span class="font-tt">caml_named_value(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">)</span></span>. The returned
pointer must then be dereferenced to recover the actual OCaml value.
If no value is registered under the name <span class="font-it">n</span>, the null pointer is
returned. For example, here is a C wrapper that calls the OCaml function <span class="machine"><span class="font-tt">f</span></span>
above:
</p><pre>    void call_caml_f(int arg)
    {
        caml_callback(*caml_named_value("test function"), Val_int(arg));
    }
</pre><p>
The pointer returned by <span class="machine"><span class="font-tt">caml_named_value</span></span> is constant and can safely
be cached in a C variable to avoid repeated name lookups. The value
pointed to cannot be changed from C. However, it might change during
garbage collection, so must always be recomputed at the point of
use. Here is a more efficient variant of <span class="machine"><span class="font-tt">call_caml_f</span></span> above that
calls <span class="machine"><span class="font-tt">caml_named_value</span></span> only once:
</p><pre>    void call_caml_f(int arg)
    {
        static const value * closure_f = NULL;
        if (closure_f == NULL) {
            /* First time around, look up by name */
            closure_f = caml_named_value("test function");
        }
        caml_callback(*closure_f, Val_int(arg));
    }
</pre>
<!--TOC subsection id="ss:c-register-exn" 22.7.3â€ƒRegistering OCaml exceptions for use in C functions-->
<h3 class="subsection" id="ss:c-register-exn"><a class="section-anchor" href="#ss:c-register-exn" aria-hidden="true">ï»¿</a>22.7.3â€ƒRegistering OCaml exceptions for use in C functions</h3><!--SEC END --><p>The registration mechanism described above can also be used to
communicate exception identifiers from OCaml to C. The OCaml code
registers the exception by evaluating
<span class="machine"><span class="font-tt">Callback.register_exception</span></span> <span class="font-it">n</span> <span class="font-it">exn</span>, where <span class="font-it">n</span> is an
arbitrary name and <span class="font-it">exn</span> is an exception value of the
exception to register. For example:
</p><pre>    exception Error of string
    let _ = Callback.register_exception "test exception" (Error "any string")
</pre><p>The C code can then recover the exception identifier using
<span class="machine"><span class="font-tt">caml_named_value</span></span> and pass it as first argument to the functions
<span class="machine"><span class="font-tt">raise_constant</span></span>, <span class="machine"><span class="font-tt">raise_with_arg</span></span>, and <span class="machine"><span class="font-tt">raise_with_string</span></span> (described
in sectionÂ <a href="#ss%3Ac-exceptions">22.4.5</a>) to actually raise the exception. For
example, here is a C function that raises the <span class="machine"><span class="font-tt">Error</span></span> exception with
the given argument:
</p><pre>    void raise_error(char * msg)
    {
        caml_raise_with_string(*caml_named_value("test exception"), msg);
    }
</pre>
<!--TOC subsection id="ss:main-c" 22.7.4â€ƒMain program in C-->
<h3 class="subsection" id="ss:main-c"><a class="section-anchor" href="#ss:main-c" aria-hidden="true">ï»¿</a>22.7.4â€ƒMain program in C</h3><!--SEC END --><p>In normal operation, a mixed OCaml/C program starts by executing the
OCaml initialization code, which then may proceed to call C
functions. We say that the main program is the OCaml code. In some
applications, it is desirable that the C code plays the role of the
main program, calling OCaml functions when needed. This can be achieved as
follows:
</p><ul class="itemize"><li class="li-itemize">The C part of the program must provide a <span class="machine"><span class="font-tt">main</span></span> function,
which will override the default <span class="machine"><span class="font-tt">main</span></span> function provided by the OCaml
runtime system. Execution will start in the user-defined <span class="machine"><span class="font-tt">main</span></span> function
just like for a regular C program.</li><li class="li-itemize">At some point, the C code must call <span class="machine"><span class="font-tt">caml_main(argv)</span></span> to
initialize the OCaml code. The <span class="machine"><span class="font-tt">argv</span></span> argument is a C array of strings
(type <span class="machine"><span class="font-tt">char **</span></span>), terminated with a <span class="machine"><span class="font-tt">NULL</span></span> pointer,
which represents the command-line arguments, as
passed as second argument to <span class="machine"><span class="font-tt">main</span></span>. The OCaml array <span class="machine"><span class="font-tt">Sys.argv</span></span> will
be initialized from this parameter. For the bytecode compiler,
<span class="machine"><span class="font-tt">argv[0]</span></span> and <span class="machine"><span class="font-tt">argv[1]</span></span> are also consulted to find the file containing
the bytecode.</li><li class="li-itemize">The call to <span class="machine"><span class="font-tt">caml_main</span></span> initializes the OCaml runtime system,
loads the bytecode (in the case of the bytecode compiler), and
executes the initialization code of the OCaml program. Typically, this
initialization code registers callback functions using <span class="machine"><span class="font-tt">Callback.register</span></span>.
Once the OCaml initialization code is complete, control returns to the
C code that called <span class="machine"><span class="font-tt">caml_main</span></span>.</li><li class="li-itemize">The C code can then invoke OCaml functions using the callback
mechanism (see sectionÂ <a href="#ss%3Ac-callbacks">22.7.1</a>).
</li></ul>
<!--TOC subsection id="ss:c-embedded-code" 22.7.5â€ƒEmbedding the OCaml code in the C code-->
<h3 class="subsection" id="ss:c-embedded-code"><a class="section-anchor" href="#ss:c-embedded-code" aria-hidden="true">ï»¿</a>22.7.5â€ƒEmbedding the OCaml code in the C code</h3><!--SEC END --><p>The bytecode compiler in custom runtime mode (<span class="machine"><span class="font-tt">ocamlc -custom</span></span>)
normally appends the bytecode to the executable file containing the
custom runtime. This has two consequences. First, the final linking
step must be performed by <span class="machine"><span class="font-tt">ocamlc</span></span>. Second, the OCaml runtime library
must be able to find the name of the executable file from the
command-line arguments. When using <span class="machine"><span class="font-tt">caml_main(argv)</span></span> as in
sectionÂ <a href="#ss%3Amain-c">22.7.4</a>, this means that <span class="machine"><span class="font-tt">argv[0]</span></span> or <span class="machine"><span class="font-tt">argv[1]</span></span> must
contain the executable file name.</p><p>An alternative is to embed the bytecode in the C code. The
<span class="machine"><span class="font-tt">-output-obj</span></span> and <span class="machine"><span class="font-tt">-output-complete-obj</span></span> options to <span class="machine"><span class="font-tt">ocamlc</span></span> are
provided for this purpose. They cause the <span class="machine"><span class="font-tt">ocamlc</span></span> compiler to output a
C object file (<span class="machine"><span class="font-tt">.o</span></span> file, <span class="machine"><span class="font-tt">.obj</span></span> under Windows) containing the
bytecode for the OCaml part of the program, as well as a
<span class="machine"><span class="font-tt">caml_startup</span></span> function. The C object file produced by <span class="machine"><span class="font-tt">ocamlc -output-complete-obj</span></span> also contains the runtime and autolink
libraries. The C object file produced by <span class="machine"><span class="font-tt">ocamlc -output-obj</span></span> or
<span class="machine"><span class="font-tt">ocamlc -output-complete-obj</span></span> can then be linked with C code using the
standard C compiler, or stored in a C library.</p><p>The <span class="machine"><span class="font-tt">caml_startup</span></span> function must be called from the main C program in
order to initialize the OCaml runtime and execute the OCaml
initialization code. Just like <span class="machine"><span class="font-tt">caml_main</span></span>, it takes one <span class="machine"><span class="font-tt">argv</span></span>
parameter containing the command-line parameters. Unlike <span class="machine"><span class="font-tt">caml_main</span></span>,
this <span class="machine"><span class="font-tt">argv</span></span> parameter is used only to initialize <span class="machine"><span class="font-tt">Sys.argv</span></span>, but not
for finding the name of the executable file.</p><p>The <span class="machine"><span class="font-tt">caml_startup</span></span> function calls the uncaught exception handler (or
enters the debugger, if running under ocamldebug) if an exception escapes
from a top-level module initialiser. Such exceptions may be caught in the
C code by instead using the <span class="machine"><span class="font-tt">caml_startup_exn</span></span> function and testing the result
using <span class="font-tt">Is_exception_result</span> (followed by <span class="font-tt">Extract_exception</span> if
appropriate).</p><p>The <span class="machine"><span class="font-tt">-output-obj</span></span> and <span class="machine"><span class="font-tt">-output-complete-obj</span></span> options can also be used to
obtain the C source file.
More interestingly, these options can also produce
directly a shared library (<span class="machine"><span class="font-tt">.so</span></span> file, <span class="machine"><span class="font-tt">.dll</span></span> under Windows) that
contains the OCaml code, the OCaml runtime system and any other static
C code given to <span class="machine"><span class="font-tt">ocamlc</span></span> (<span class="machine"><span class="font-tt">.o</span></span>, <span class="machine"><span class="font-tt">.a</span></span>, respectively, <span class="machine"><span class="font-tt">.obj</span></span>, <span class="machine"><span class="font-tt">.lib</span></span>).
This use of <span class="machine"><span class="font-tt">-output-obj</span></span> and <span class="machine"><span class="font-tt">-output-complete-obj</span></span>
is very similar to a normal linking
step, but instead of producing a main program that automatically runs
the OCaml code, it produces a shared library that can run the OCaml
code on demand. The three possible behaviors of <span class="machine"><span class="font-tt">-output-obj</span></span>
and <span class="machine"><span class="font-tt">-output-complete-obj</span></span>
(to produce a C source code <span class="machine"><span class="font-tt">.c</span></span>, a C object file <span class="machine"><span class="font-tt">.o</span></span>, a shared library <span class="machine"><span class="font-tt">.so</span></span>),
are selected according to the extension of the resulting file (given
with <span class="machine"><span class="font-tt">-o</span></span>).</p><p>The native-code compiler <span class="machine"><span class="font-tt">ocamlopt</span></span> also supports the <span class="machine"><span class="font-tt">-output-obj</span></span>
and <span class="machine"><span class="font-tt">-output-complete-obj</span></span> options, causing it to output a C object
file or a shared library containing the native code for all OCaml
modules on the command-line, as well as the OCaml startup code.
Initialization is performed by calling <span class="machine"><span class="font-tt">caml_startup</span></span> (or
<span class="machine"><span class="font-tt">caml_startup_exn</span></span>) as in the case of the bytecode compiler. The file
produced by <span class="machine"><span class="font-tt">ocamlopt -output-complete-obj</span></span> also contains the runtime
and autolink libraries.</p><p>For the final linking phase, in addition to the object file produced
by <span class="machine"><span class="font-tt">-output-obj</span></span>, you will have to provide the OCaml runtime
library (<span class="machine"><span class="font-tt">libcamlrun.a</span></span> for bytecode, <span class="machine"><span class="font-tt">libasmrun.a</span></span> for native-code),
as well as all C libraries that are required by the OCaml libraries
used. For instance, assume the OCaml part of your program uses the
Unix library. With <span class="machine"><span class="font-tt">ocamlc</span></span>, you should do:
</p><pre>
        ocamlc -output-obj -o camlcode.o unix.cma <span class="font-it">other</span> .cmo <span class="font-it">and</span> .cma <span class="font-it">files</span>
        cc -o myprog <span class="font-it">C objects and libraries</span> \
           camlcode.o -Lâ€˜ocamlc -whereâ€˜ -lunix -lcamlrun
</pre><p>
With <span class="machine"><span class="font-tt">ocamlopt</span></span>, you should do:
</p><pre>
        ocamlopt -output-obj -o camlcode.o unix.cmxa <span class="font-it">other</span> .cmx <span class="font-it">and</span> .cmxa <span class="font-it">files</span>
        cc -o myprog <span class="font-it">C objects and libraries</span> \
           camlcode.o -Lâ€˜ocamlc -whereâ€˜ -lunix -lasmrun
</pre><p>For the final linking phase, in addition to the object file produced
by <span class="machine"><span class="font-tt">-output-complete-obj</span></span>, you will have only to provide the C
libraries required by the OCaml runtime.</p><p>For instance, assume the OCaml part of your program uses the
Unix library. With <span class="machine"><span class="font-tt">ocamlc</span></span>, you should do:
</p><pre>
        ocamlc -output-complete-obj -o camlcode.o unix.cma <span class="font-it">other</span> .cmo <span class="font-it">and</span> .cma <span class="font-it">files</span>
        cc -o myprog <span class="font-it">C objects and libraries</span> \
           camlcode.o <span class="font-it">C libraries required by the runtime, eg -lm  -ldl -lcurses -lpthread</span>
</pre><p>
With <span class="machine"><span class="font-tt">ocamlopt</span></span>, you should do:
</p><pre>
        ocamlopt -output-complete-obj -o camlcode.o unix.cmxa <span class="font-it">other</span> .cmx <span class="font-it">and</span> .cmxa <span class="font-it">files</span>
        cc -o myprog <span class="font-it">C objects and libraries</span> \
           camlcode.o <span class="font-it">C libraries required by the runtime, eg -lm -ldl</span>
</pre>
<!--TOC paragraph id="sec514" Warning:-->
<h5 class="paragraph" id="sec514"><a class="section-anchor" href="#sec514" aria-hidden="true">ï»¿</a>Warning:</h5><!--SEC END --><p> On some ports, special options are required on the final
linking phase that links together the object file produced by the
<span class="machine"><span class="font-tt">-output-obj</span></span> and <span class="machine"><span class="font-tt">-output-complete-obj</span></span> options and the remainder of the program. Those options
are shown in the configuration file <span class="machine"><span class="font-tt">Makefile.config</span></span> generated during
compilation of OCaml, as the variable <span class="machine"><span class="font-tt">OC_LDFLAGS</span></span>.
</p><ul class="itemize"><li class="li-itemize">Windows with the MSVC compiler: the object file produced by
OCaml have been compiled with the <span class="machine"><span class="font-tt">/MD</span></span> flag, and therefore
all other object files linked with it should also be compiled with
<span class="machine"><span class="font-tt">/MD</span></span>.
</li><li class="li-itemize">other systems: you may have to add one or both of
<span class="machine"><span class="font-tt">-lm</span></span> and <span class="machine"><span class="font-tt">-ldl</span></span>, depending on your OS and C compiler.
</li></ul>
<!--TOC paragraph id="sec515" Stack backtraces.-->
<h5 class="paragraph" id="sec515"><a class="section-anchor" href="#sec515" aria-hidden="true">ï»¿</a>Stack backtraces.</h5><!--SEC END --><p> When OCaml bytecode produced by
<span class="machine"><span class="font-tt">ocamlc -g</span></span> is embedded in a C program, no debugging information is
included, and therefore it is impossible to print stack backtraces on
uncaught exceptions. This is not the case when native code produced
by <span class="machine"><span class="font-tt">ocamlopt -g</span></span> is embedded in a C program: stack backtrace
information is available, but the backtrace mechanism needs to be
turned on programmatically. This can be achieved from the OCaml side
by calling <span class="machine"><span class="font-tt">Printexc.record_backtrace true</span></span> in the initialization of
one of the OCaml modules. This can also be achieved from the C side
by calling <span class="machine"><span class="font-tt">caml_record_backtraces(1);</span></span> in the OCaml-C glue code.
(<span class="machine"><span class="font-tt">caml_record_backtraces</span></span> is declared in <span class="machine"><span class="font-tt">backtrace.h</span></span>)</p>
<!--TOC paragraph id="sec516" Unloading the runtime.-->
<h5 class="paragraph" id="sec516"><a class="section-anchor" href="#sec516" aria-hidden="true">ï»¿</a>Unloading the runtime.</h5><!--SEC END --><p>In case the shared library produced with <span class="machine"><span class="font-tt">-output-obj</span></span> is to be loaded and
unloaded repeatedly by a single process, care must be taken to unload the
OCaml runtime explicitly, in order to avoid various system resource leaks.</p><p>Since 4.05, <span class="machine"><span class="font-tt">caml_shutdown</span></span> function can be used to shut the runtime down
gracefully, which equals the following:
</p><ul class="itemize"><li class="li-itemize">Running the functions that were registered with <span class="machine"><span class="font-tt">Stdlib.at_exit</span></span>.
</li><li class="li-itemize">Triggering finalization of allocated custom blocks (see
sectionÂ <a href="#s%3Ac-custom">22.9</a>). For example, <span class="machine"><span class="font-tt">Stdlib.in_channel</span></span> and
<span class="machine"><span class="font-tt">Stdlib.out_channel</span></span> are represented by custom blocks that enclose file
descriptors, which are to be released.
</li><li class="li-itemize">Unloading the dependent shared libraries that were loaded by the runtime,
including <span class="machine"><span class="font-tt">dynlink</span></span> plugins.
</li><li class="li-itemize">Freeing the memory blocks that were allocated by the runtime with
<span class="machine"><span class="font-tt">malloc</span></span>. Inside C primitives, it is advised to use <span class="machine"><span class="font-tt">caml_stat_*</span></span> functions
from <span class="machine"><span class="font-tt">memory.h</span></span> for managing static (that is, non-moving) blocks of heap
memory, as all the blocks allocated with these functions are automatically
freed by <span class="machine"><span class="font-tt">caml_shutdown</span></span>. For ensuring compatibility with legacy C stubs that
have used <span class="machine"><span class="font-tt">caml_stat_*</span></span> incorrectly, this behaviour is only enabled if the
runtime is started with a specialized <span class="machine"><span class="font-tt">caml_startup_pooled</span></span> function.
</li></ul><p>As a shared library may have several clients simultaneously, it is made for
convenience that <span class="machine"><span class="font-tt">caml_startup</span></span> (and <span class="machine"><span class="font-tt">caml_startup_pooled</span></span>) may be called
multiple times, given that each such call is paired with a corresponding call
to <span class="machine"><span class="font-tt">caml_shutdown</span></span> (in a nested fashion). The runtime will be unloaded once
there are no outstanding calls to <span class="machine"><span class="font-tt">caml_startup</span></span>.</p><p>Once a runtime is unloaded, it cannot be started up again without reloading the
shared library and reinitializing its static data. Therefore, at the moment, the
facility is only useful for building reloadable shared libraries.</p>
<!--TOC paragraph id="sec517" Unix signal handling.-->
<h5 class="paragraph" id="sec517"><a class="section-anchor" href="#sec517" aria-hidden="true">ï»¿</a>Unix signal handling.</h5><!--SEC END --><p> Depending on the target platform and
operating system, the native-code runtime system may install signal
handlers for one or several of the <span class="machine"><span class="font-tt">SIGSEGV</span></span>, <span class="machine"><span class="font-tt">SIGTRAP</span></span> and <span class="machine"><span class="font-tt">SIGFPE</span></span>
signals when <span class="machine"><span class="font-tt">caml_startup</span></span> is called, and reset these signals to
their default behaviors when <span class="machine"><span class="font-tt">caml_shutdown</span></span> is called. The main
program written inÂ C should not try to handle these signals itself.</p>
<!--TOC section id="s:c-advexample" 22.8â€ƒAdvanced example with callbacks-->
<h2 class="section" id="s:c-advexample"><a class="section-anchor" href="#s:c-advexample" aria-hidden="true">ï»¿</a>22.8â€ƒAdvanced example with callbacks</h2><!--SEC END --><p>This section illustrates the callback facilities described in
sectionÂ <a href="#s%3Ac-callback">22.7</a>. We are going to package some OCaml functions
in such a way that they can be linked with C code and called from C
just like any C functions. The OCaml functions are defined in the
following <span class="machine"><span class="font-tt">mod.ml</span></span> OCaml source:</p><pre>(* File mod.ml -- some "useful" OCaml functions *)

let rec fib n = if n &lt; 2 then 1 else fib(n-1) + fib(n-2)

let format_result n = Printf.sprintf "Result is: %d\n" n

(* Export those two functions to C *)

let _ = Callback.register "fib" fib
let _ = Callback.register "format_result" format_result
</pre><p>
Here is the C stub code for calling these functions from C:</p><pre>/* File modwrap.c -- wrappers around the OCaml functions */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/callback.h&gt;

int fib(int n)
{
  static const value * fib_closure = NULL;
  if (fib_closure == NULL) fib_closure = caml_named_value("fib");
  return Int_val(caml_callback(*fib_closure, Val_int(n)));
}

char * format_result(int n)
{
  static const value * format_result_closure = NULL;
  if (format_result_closure == NULL)
    format_result_closure = caml_named_value("format_result");
  return strdup(String_val(caml_callback(*format_result_closure, Val_int(n))));
  /* We copy the C string returned by String_val to the C heap
     so that it remains valid after garbage collection. */
}
</pre><p>
We now compile the OCaml code to a C object file and put it in a C
library along with the stub code in <span class="machine"><span class="font-tt">modwrap.c</span></span> and the OCaml runtime system:
</p><pre>        ocamlc -custom -output-obj -o modcaml.o mod.ml
        ocamlc -c modwrap.c
        cp `ocamlc -where`/libcamlrun.a mod.a &amp;&amp; chmod +w mod.a
        ar r mod.a modcaml.o modwrap.o
</pre><p>(One can also use <span class="machine"><span class="font-tt">ocamlopt -output-obj</span></span> instead of <span class="machine"><span class="font-tt">ocamlc -custom -output-obj</span></span>. In this case, replace <span class="machine"><span class="font-tt">libcamlrun.a</span></span> (the bytecode
runtime library) by <span class="machine"><span class="font-tt">libasmrun.a</span></span> (the native-code runtime library).)</p><p>Now, we can use the two functions <span class="machine"><span class="font-tt">fib</span></span> and <span class="machine"><span class="font-tt">format_result</span></span> in any C
program, just like regular C functions. Just remember to call
<span class="machine"><span class="font-tt">caml_startup</span></span> (or <span class="machine"><span class="font-tt">caml_startup_exn</span></span>) once before.</p><pre>/* File main.c -- a sample client for the OCaml functions */

#include &lt;stdio.h&gt;
#include &lt;caml/callback.h&gt;

extern int fib(int n);
extern char * format_result(int n);

int main(int argc, char ** argv)
{
  int result;

  /* Initialize OCaml code */
  caml_startup(argv);
  /* Do some computation */
  result = fib(10);
  printf("fib(10) = %s\n", format_result(result));
  return 0;
}
</pre><p>
To build the whole program, just invoke the C compiler as follows:
</p><pre>        cc -o prog -I `ocamlc -where` main.c mod.a -lcurses
</pre><p>(On some machines, you may need to put <span class="machine"><span class="font-tt">-ltermcap</span></span> or
<span class="machine"><span class="font-tt">-lcurses -ltermcap</span></span> instead of <span class="machine"><span class="font-tt">-lcurses</span></span>.)</p>
<!--TOC section id="s:c-custom" 22.9â€ƒAdvanced topic: custom blocks-->
<h2 class="section" id="s:c-custom"><a class="section-anchor" href="#s:c-custom" aria-hidden="true">ï»¿</a>22.9â€ƒAdvanced topic: custom blocks</h2><!--SEC END --><p>Blocks with tag <span class="machine"><span class="font-tt">Custom_tag</span></span> contain both arbitrary user data and a
pointer to a C struct, with type <span class="machine"><span class="font-tt">struct custom_operations</span></span>, that
associates user-provided finalization, comparison, hashing,
serialization and deserialization functions to this block.</p>
<!--TOC subsection id="ss:c-custom-ops" 22.9.1â€ƒThe <span class="machine"><span class="font-tt">struct custom</span></span><span class="machine"><span class="font-tt">_</span></span><span class="machine"><span class="font-tt">operations</span></span>-->
<h3 class="subsection" id="ss:c-custom-ops"><a class="section-anchor" href="#ss:c-custom-ops" aria-hidden="true">ï»¿</a>22.9.1â€ƒThe <span class="machine"><span class="font-tt">struct custom_operations</span></span></h3><!--SEC END --><p>The <span class="machine"><span class="font-tt">struct custom_operations</span></span> is defined in <span class="machine"><span class="font-tt">&lt;caml/custom.h&gt;</span></span> and
contains the following fields:
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">char *identifier</span></span> <br>
A zero-terminated character string serving as an identifier for
serialization and deserialization operations.</li><li class="li-itemize"><span class="machine"><span class="font-tt">void  (*finalize)(value v)</span></span> <br>
The <span class="machine"><span class="font-tt">finalize</span></span> field contains a pointer to a C function that is called
when the block becomes unreachable and is about to be reclaimed.
The block is passed as first argument to the function.
The <span class="machine"><span class="font-tt">finalize</span></span> field can also be <span class="machine"><span class="font-tt">custom_finalize_default</span></span> to indicate that no
finalization function is associated with the block.</li><li class="li-itemize"><span class="machine"><span class="font-tt">int (*compare)(value v1, value v2)</span></span> <br>
The <span class="machine"><span class="font-tt">compare</span></span> field contains a pointer to a C function that is
called whenever two custom blocks are compared using OCamlâ€™s generic
comparison operators (<span class="machine"><span class="font-tt">=</span></span>, <span class="machine"><span class="font-tt">&lt;&gt;</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, <span class="machine"><span class="font-tt">&gt;=</span></span>, <span class="machine"><span class="font-tt">&lt;</span></span>, <span class="machine"><span class="font-tt">&gt;</span></span> and
<span class="machine"><span class="font-tt">compare</span></span>). The C function should return 0 if the data contained in
the two blocks are structurally equal, a negative integer if the data
from the first block is less than the data from the second block, and
a positive integer if the data from the first block is greater than
the data from the second block.<p>The <span class="machine"><span class="font-tt">compare</span></span> field can be set to <span class="machine"><span class="font-tt">custom_compare_default</span></span>; this
default comparison function simply raises <span class="machine"><span class="font-tt">Failure</span></span>.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">int (*compare_ext)(value v1, value v2)</span></span> <br>
(Since 3.12.1)
The <span class="machine"><span class="font-tt">compare_ext</span></span> field contains a pointer to a C function that is
called whenever one custom block and one unboxed integer are compared using OCamlâ€™s generic
comparison operators (<span class="machine"><span class="font-tt">=</span></span>, <span class="machine"><span class="font-tt">&lt;&gt;</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, <span class="machine"><span class="font-tt">&gt;=</span></span>, <span class="machine"><span class="font-tt">&lt;</span></span>, <span class="machine"><span class="font-tt">&gt;</span></span> and
<span class="machine"><span class="font-tt">compare</span></span>). As in the case of the <span class="machine"><span class="font-tt">compare</span></span> field, the C function
should return 0 if the two arguments are structurally equal, a
negative integer if the first argument compares less than the second
argument, and a positive integer if the first argument compares
greater than the second argument.<p>The <span class="machine"><span class="font-tt">compare_ext</span></span> field can be set to <span class="machine"><span class="font-tt">custom_compare_ext_default</span></span>; this
default comparison function simply raises <span class="machine"><span class="font-tt">Failure</span></span>.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">intnat (*hash)(value v)</span></span> <br>
The <span class="machine"><span class="font-tt">hash</span></span> field contains a pointer to a C function that is called
whenever OCamlâ€™s generic hash operator (see module <a href="libref/Hashtbl.html"><span class="font-tt">Hashtbl</span></a>) is
applied to a custom block. The C function can return an arbitrary
integer representing the hash value of the data contained in the
given custom block. The hash value must be compatible with the
<span class="machine"><span class="font-tt">compare</span></span> function, in the sense that two structurally equal data
(that is, two custom blocks for which <span class="machine"><span class="font-tt">compare</span></span> returns 0) must have
the same hash value.<p>The <span class="machine"><span class="font-tt">hash</span></span> field can be set to <span class="machine"><span class="font-tt">custom_hash_default</span></span>, in which case
the custom block is ignored during hash computation.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">void (*serialize)(value v, uintnat * bsize_32, uintnat * bsize_64)</span></span> <br>
The <span class="machine"><span class="font-tt">serialize</span></span> field contains a pointer to a C function that is
called whenever the custom block needs to be serialized (marshaled)
using the OCaml functions <span class="machine"><span class="font-tt">output_value</span></span> or <span class="machine"><span class="font-tt">Marshal.to_...</span></span>.
For a custom block, those functions first write the identifier of the
block (as given by the <span class="machine"><span class="font-tt">identifier</span></span> field) to the output stream,
then call the user-provided <span class="machine"><span class="font-tt">serialize</span></span> function. That function is
responsible for writing the data contained in the custom block, using
the <span class="machine"><span class="font-tt">serialize_...</span></span> functions defined in <span class="machine"><span class="font-tt">&lt;caml/intext.h&gt;</span></span> and listed
below. The user-provided <span class="machine"><span class="font-tt">serialize</span></span> function must then store in its
<span class="machine"><span class="font-tt">bsize_32</span></span> and <span class="machine"><span class="font-tt">bsize_64</span></span> parameters the sizes in bytes of the data
part of the custom block on a 32-bit architecture and on a 64-bit
architecture, respectively.<p>The <span class="machine"><span class="font-tt">serialize</span></span> field can be set to <span class="machine"><span class="font-tt">custom_serialize_default</span></span>,
in which case the <span class="machine"><span class="font-tt">Failure</span></span> exception is raised when attempting to
serialize the custom block.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">uintnat (*deserialize)(void * dst)</span></span> <br>
The <span class="machine"><span class="font-tt">deserialize</span></span> field contains a pointer to a C function that is
called whenever a custom block with identifier <span class="machine"><span class="font-tt">identifier</span></span> needs to
be deserialized (un-marshaled) using the OCaml functions <span class="machine"><span class="font-tt">input_value</span></span>
or <span class="machine"><span class="font-tt">Marshal.from_...</span></span>. This user-provided function is responsible for
reading back the data written by the <span class="machine"><span class="font-tt">serialize</span></span> operation, using the
<span class="machine"><span class="font-tt">deserialize_...</span></span> functions defined in <span class="machine"><span class="font-tt">&lt;caml/intext.h&gt;</span></span> and listed
below. It must then rebuild the data part of the custom block
and store it at the pointer given as the <span class="machine"><span class="font-tt">dst</span></span> argument. Finally, it
returns the size in bytes of the data part of the custom block.
This size must be identical to the <span class="machine"><span class="font-tt">wsize_32</span></span> result of
the <span class="machine"><span class="font-tt">serialize</span></span> operation if the architecture is 32 bits, or
<span class="machine"><span class="font-tt">wsize_64</span></span> if the architecture is 64 bits.<p>The <span class="machine"><span class="font-tt">deserialize</span></span> field can be set to <span class="machine"><span class="font-tt">custom_deserialize_default</span></span>
to indicate that deserialization is not supported. In this case,
do not register the <span class="machine"><span class="font-tt">struct custom_operations</span></span> with the deserializer
using <span class="machine"><span class="font-tt">register_custom_operations</span></span> (see below).</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">const struct custom_fixed_length* fixed_length</span></span> <br>
(Since 4.08.0)
Normally, space in the serialized output is reserved to write the
<span class="machine"><span class="font-tt">bsize_32</span></span> and <span class="machine"><span class="font-tt">bsize_64</span></span> fields returned by <span class="machine"><span class="font-tt">serialize</span></span>. However, for
very short custom blocks, this space can be larger than the data
itself! As a space optimisation, if <span class="machine"><span class="font-tt">serialize</span></span> always returns the
same values for <span class="machine"><span class="font-tt">bsize_32</span></span> and <span class="machine"><span class="font-tt">bsize_64</span></span>, then these values may be
specified in the <span class="machine"><span class="font-tt">fixed_length</span></span> structure, and do not consume space in
the serialized output.
</li></ul><p>Note: the <span class="machine"><span class="font-tt">finalize</span></span>, <span class="machine"><span class="font-tt">compare</span></span>, <span class="machine"><span class="font-tt">hash</span></span>, <span class="machine"><span class="font-tt">serialize</span></span> and <span class="machine"><span class="font-tt">deserialize</span></span>
functions attached to custom block descriptors must never trigger a
garbage collection. Within these functions, do not call any of the
OCaml allocation functions, and do not perform a callback into OCaml
code. Do not use <span class="machine"><span class="font-tt">CAMLparam</span></span> to register the parameters to these
functions, and do not use <span class="machine"><span class="font-tt">CAMLreturn</span></span> to return the result.</p>
<!--TOC subsection id="ss:c-custom-alloc" 22.9.2â€ƒAllocating custom blocks-->
<h3 class="subsection" id="ss:c-custom-alloc"><a class="section-anchor" href="#ss:c-custom-alloc" aria-hidden="true">ï»¿</a>22.9.2â€ƒAllocating custom blocks</h3><!--SEC END --><p>Custom blocks must be allocated via <span class="machine"><span class="font-tt">caml_alloc_custom</span></span> or
<span class="machine"><span class="font-tt">caml_alloc_custom_mem</span></span>:
</p><div class="center">
<span class="machine"><span class="font-tt">caml_alloc_custom(</span></span><span class="font-it">ops</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">size</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">used</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">max</span><span class="machine"><span class="font-tt">)</span></span>
</div><p>
returns a fresh custom block, with room for <span class="font-it">size</span> bytes of user
data, and whose associated operations are given by <span class="font-it">ops</span> (a
pointer to a <span class="machine"><span class="font-tt">struct custom_operations</span></span>, usually statically allocated
as a C global variable).</p><p>The two parameters <span class="font-it">used</span> and <span class="font-it">max</span> are used to control the
speed of garbage collection when the finalized object contains
pointers to out-of-heap resources. Generally speaking, the
OCaml incremental major collector adjusts its speed relative to the
allocation rate of the program. The faster the program allocates, the
harder the GC works in order to reclaim quickly unreachable blocks
and avoid having large amount of â€œfloating garbageâ€ (unreferenced
objects that the GC has not yet collected).</p><p>Normally, the allocation rate is measured by counting the in-heap size
of allocated blocks. However, it often happens that finalized
objects contain pointers to out-of-heap memory blocks and other resources
(such as file descriptors, X Windows bitmaps, etc.). For those
blocks, the in-heap size of blocks is not a good measure of the
quantity of resources allocated by the program.</p><p>The two arguments <span class="font-it">used</span> and <span class="font-it">max</span> give the GC an idea of how
much out-of-heap resources are consumed by the finalized block
being allocated: you give the amount of resources allocated to this
object as parameter <span class="font-it">used</span>, and the maximum amount that you want
to see in floating garbage as parameter <span class="font-it">max</span>. The units are
arbitrary: the GC cares only about the ratio <span class="font-it">used</span> / <span class="font-it">max</span>.</p><p>For instance, if you are allocating a finalized block holding an X
Windows bitmap of <span class="font-it">w</span> by <span class="font-it">h</span> pixels, and youâ€™d rather not
have more than 1 mega-pixels of unreclaimed bitmaps, specify
<span class="font-it">used</span> = <span class="font-it">w</span> * <span class="font-it">h</span> and <span class="font-it">max</span> = 1000000.</p><p>Another way to describe the effect of the <span class="font-it">used</span> and <span class="font-it">max</span>
parameters is in terms of full GC cycles. If you allocate many custom
blocks with <span class="font-it">used</span> / <span class="font-it">max</span> = 1 / <span class="font-it">N</span>, the GC will then do one
full cycle (examining every object in the heap and calling
finalization functions on those that are unreachable) every <span class="font-it">N</span>
allocations. For instance, if <span class="font-it">used</span> = 1 and <span class="font-it">max</span> = 1000,
the GC will do one full cycle at least every 1000 allocations of
custom blocks.</p><p>If your finalized blocks contain no pointers to out-of-heap resources,
or if the previous discussion made little sense to you, just take
<span class="font-it">used</span> = 0 and <span class="font-it">max</span> = 1. But if you later find that the
finalization functions are not called â€œoften enoughâ€, consider
increasing the <span class="font-it">used</span> / <span class="font-it">max</span> ratio.</p><div class="center">
<span class="machine"><span class="font-tt">caml_alloc_custom_mem(</span></span><span class="font-it">ops</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">size</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">used</span><span class="machine"><span class="font-tt">)</span></span>
</div><p>
Use this function when your custom block holds only out-of-heap memory
(memory allocated with <span class="machine"><span class="font-tt">malloc</span></span> or <span class="machine"><span class="font-tt">caml_stat_alloc</span></span>) and no other
resources. <span class="machine"><span class="font-tt">used</span></span> should be the number of bytes of out-of-heap
memory that are held by your custom block. This function works like
<span class="machine"><span class="font-tt">caml_alloc_custom</span></span> except that the <span class="machine"><span class="font-tt">max</span></span> parameter is under the
control of the user (via the <span class="machine"><span class="font-tt">custom_major_ratio</span></span>,
<span class="machine"><span class="font-tt">custom_minor_ratio</span></span>, and <span class="machine"><span class="font-tt">custom_minor_max_size</span></span> parameters) and
proportional to the heap sizes. It has been available since OCaml 4.08.0.</p>
<!--TOC subsection id="ss:c-custom-access" 22.9.3â€ƒAccessing custom blocks-->
<h3 class="subsection" id="ss:c-custom-access"><a class="section-anchor" href="#ss:c-custom-access" aria-hidden="true">ï»¿</a>22.9.3â€ƒAccessing custom blocks</h3><!--SEC END --><p>The data part of a custom block <span class="font-it">v</span> can be
accessed via the pointer <span class="machine"><span class="font-tt">Data_custom_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span>. This pointer
has type <span class="machine"><span class="font-tt">void *</span></span> and should be cast to the actual type of the data
stored in the custom block.</p><p>The contents of custom blocks are not scanned by the garbage
collector, and must therefore not contain any pointer inside the OCaml
heap. In other terms, never store an OCaml <span class="machine"><span class="font-tt">value</span></span> in a custom block,
and do not use <span class="machine"><span class="font-tt">Field</span></span>, <span class="machine"><span class="font-tt">Store_field</span></span> nor <span class="machine"><span class="font-tt">caml_modify</span></span> to access the data
part of a custom block. Conversely, any C data structure (not
containing heap pointers) can be stored in a custom block.</p>
<!--TOC subsection id="ss:c-custom-serialization" 22.9.4â€ƒWriting custom serialization and deserialization functions-->
<h3 class="subsection" id="ss:c-custom-serialization"><a class="section-anchor" href="#ss:c-custom-serialization" aria-hidden="true">ï»¿</a>22.9.4â€ƒWriting custom serialization and deserialization functions</h3><!--SEC END --><p>The following functions, defined in <span class="machine"><span class="font-tt">&lt;caml/intext.h&gt;</span></span>, are provided to
write and read back the contents of custom blocks in a portable way.
Those functions handle endianness conversions when e.g. data is
written on a little-endian machine and read back on a big-endian machine.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Function</span></td><td class="c004"><span class="font-bold">Action</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">caml_serialize_int_1</span></span></td><td class="c011">Write a 1-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_int_2</span></span></td><td class="c011">Write a 2-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_int_4</span></span></td><td class="c011">Write a 4-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_int_8</span></span></td><td class="c011">Write a 8-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_float_4</span></span></td><td class="c011">Write a 4-byte float </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_float_8</span></span></td><td class="c011">Write a 8-byte float </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_block_1</span></span></td><td class="c011">Write an array of 1-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_block_2</span></span></td><td class="c011">Write an array of 2-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_block_4</span></span></td><td class="c011">Write an array of 4-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_serialize_block_8</span></span></td><td class="c011">Write an array of 8-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_uint_1</span></span></td><td class="c011">Read an unsigned 1-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_sint_1</span></span></td><td class="c011">Read a signed 1-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_uint_2</span></span></td><td class="c011">Read an unsigned 2-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_sint_2</span></span></td><td class="c011">Read a signed 2-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_uint_4</span></span></td><td class="c011">Read an unsigned 4-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_sint_4</span></span></td><td class="c011">Read a signed 4-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_uint_8</span></span></td><td class="c011">Read an unsigned 8-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_sint_8</span></span></td><td class="c011">Read a signed 8-byte integer </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_float_4</span></span></td><td class="c011">Read a 4-byte float </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_float_8</span></span></td><td class="c011">Read an 8-byte float </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_block_1</span></span></td><td class="c011">Read an array of 1-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_block_2</span></span></td><td class="c011">Read an array of 2-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_block_4</span></span></td><td class="c011">Read an array of 4-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_block_8</span></span></td><td class="c011">Read an array of 8-byte quantities </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">caml_deserialize_error</span></span></td><td class="c011">Signal an error during deserialization;
<span class="machine"><span class="font-tt">input_value</span></span> or <span class="machine"><span class="font-tt">Marshal.from_...</span></span> raise a <span class="machine"><span class="font-tt">Failure</span></span> exception after
cleaning up their internal data structures </td></tr>
</table></div></div><p>Serialization functions are attached to the custom blocks to which
they apply. Obviously, deserialization functions cannot be attached
this way, since the custom block does not exist yet when
deserialization begins! Thus, the <span class="machine"><span class="font-tt">struct custom_operations</span></span> that
contain deserialization functions must be registered with the
deserializer in advance, using the <span class="machine"><span class="font-tt">register_custom_operations</span></span>
function declared in <span class="machine"><span class="font-tt">&lt;caml/custom.h&gt;</span></span>. Deserialization proceeds by
reading the identifier off the input stream, allocating a custom block
of the size specified in the input stream, searching the registered
<span class="machine"><span class="font-tt">struct custom_operation</span></span> blocks for one with the same identifier, and
calling its <span class="machine"><span class="font-tt">deserialize</span></span> function to fill the data part of the custom block.</p>
<!--TOC subsection id="ss:c-custom-idents" 22.9.5â€ƒChoosing identifiers-->
<h3 class="subsection" id="ss:c-custom-idents"><a class="section-anchor" href="#ss:c-custom-idents" aria-hidden="true">ï»¿</a>22.9.5â€ƒChoosing identifiers</h3><!--SEC END --><p>Identifiers in <span class="machine"><span class="font-tt">struct custom_operations</span></span> must be chosen carefully,
since they must identify uniquely the data structure for serialization
and deserialization operations. In particular, consider including a
version number in the identifier; this way, the format of the data can
be changed later, yet backward-compatible deserialisation functions
can be provided.</p><p>Identifiers starting with <span class="machine"><span class="font-tt">_</span></span> (an underscore character) are reserved
for the OCaml runtime system; do not use them for your custom
data. We recommend to use a URL
(<span class="machine"><span class="font-tt">http://mymachine.mydomain.com/mylibrary/version-number</span></span>)
or a Java-style package name
(<span class="machine"><span class="font-tt">com.mydomain.mymachine.mylibrary.version-number</span></span>)
as identifiers, to minimize the risk of identifier collision.</p>
<!--TOC subsection id="ss:c-finalized" 22.9.6â€ƒFinalized blocks-->
<h3 class="subsection" id="ss:c-finalized"><a class="section-anchor" href="#ss:c-finalized" aria-hidden="true">ï»¿</a>22.9.6â€ƒFinalized blocks</h3><!--SEC END --><p>Custom blocks generalize the finalized blocks that were present in
OCaml prior to version 3.00. For backward compatibility, the
format of custom blocks is compatible with that of finalized blocks,
and the <span class="machine"><span class="font-tt">alloc_final</span></span> function is still available to allocate a custom
block with a given finalization function, but default comparison,
hashing and serialization functions. <span class="machine"><span class="font-tt">caml_alloc_final(</span></span><span class="font-it">n</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">f</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">used</span><span class="machine"><span class="font-tt">, </span></span><span class="font-it">max</span><span class="machine"><span class="font-tt">)</span></span> returns a fresh custom block of
size <span class="font-it">n</span>+1 words, with finalization function <span class="font-it">f</span>. The first
word is reserved for storing the custom operations; the other
<span class="font-it">n</span> words are available for your data. The two parameters
<span class="font-it">used</span> and <span class="font-it">max</span> are used to control the speed of garbage
collection, as described for <span class="machine"><span class="font-tt">caml_alloc_custom</span></span>.</p>
<!--TOC section id="s:C-Bigarrays" 22.10â€ƒAdvanced topic: Bigarrays and the OCaml-C interface-->
<h2 class="section" id="s:C-Bigarrays"><a class="section-anchor" href="#s:C-Bigarrays" aria-hidden="true">ï»¿</a>22.10â€ƒAdvanced topic: Bigarrays and the OCaml-C interface</h2><!--SEC END --><p>This section explains how C stub code that interfaces C or Fortran
code with OCaml code can use Bigarrays.</p>
<!--TOC subsection id="ss:C-Bigarrays-include" 22.10.1â€ƒInclude file-->
<h3 class="subsection" id="ss:C-Bigarrays-include"><a class="section-anchor" href="#ss:C-Bigarrays-include" aria-hidden="true">ï»¿</a>22.10.1â€ƒInclude file</h3><!--SEC END --><p>The include file <span class="machine"><span class="font-tt">&lt;caml/bigarray.h&gt;</span></span> must be included in the C stub
file. It declares the functions, constants and macros discussed
below.</p>
<!--TOC subsection id="ss:C-Bigarrays-access" 22.10.2â€ƒAccessing an OCaml bigarray from C or Fortran-->
<h3 class="subsection" id="ss:C-Bigarrays-access"><a class="section-anchor" href="#ss:C-Bigarrays-access" aria-hidden="true">ï»¿</a>22.10.2â€ƒAccessing an OCaml bigarray from C or Fortran</h3><!--SEC END --><p>If <span class="font-it">v</span> is a OCaml <span class="machine"><span class="font-tt">value</span></span> representing a Bigarray, the expression
<span class="machine"><span class="font-tt">Caml_ba_data_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> returns a pointer to the data part of the array.
This pointer is of type <span class="machine"><span class="font-tt">void *</span></span> and can be cast to the appropriate C
type for the array (e.g. <span class="machine"><span class="font-tt">double []</span></span>, <span class="machine"><span class="font-tt">char [][10]</span></span>, etc).</p><p>Various characteristics of the OCaml Bigarray can be consulted from C
as follows:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">C expression</span></td><td class="c004"><span class="font-bold">Returns</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">Caml_ba_array_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)-&gt;num_dims</span></span></td><td class="c006">number of dimensions </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">Caml_ba_array_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)-&gt;dim[</span></span><span class="font-it">i</span><span class="machine"><span class="font-tt">]</span></span></td><td class="c006"><span class="font-it">i</span>-th dimension </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">Caml_ba_array_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)-&gt;flags &amp; BIGARRAY_KIND_MASK</span></span></td><td class="c006">kind of array elements </td></tr>
</table></div></div><p>
The kind of array elements is one of the following constants:
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Constant</span></td><td class="c004"><span class="font-bold">Element kind</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">CAML_BA_FLOAT32</span></span></td><td class="c006">32-bit single-precision floats </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_FLOAT64</span></span></td><td class="c006">64-bit double-precision floats </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_SINT8</span></span></td><td class="c006">8-bit signed integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_UINT8</span></span></td><td class="c006">8-bit unsigned integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_SINT16</span></span></td><td class="c006">16-bit signed integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_UINT16</span></span></td><td class="c006">16-bit unsigned integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_INT32</span></span></td><td class="c006">32-bit signed integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_INT64</span></span></td><td class="c006">64-bit signed integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_CAML_INT</span></span></td><td class="c006">31- or 63-bit signed integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_NATIVE_INT</span></span></td><td class="c006">32- or 64-bit (platform-native) integers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_COMPLEX32</span></span></td><td class="c006">32-bit single-precision complex numbers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_COMPLEX64</span></span></td><td class="c006">64-bit double-precision complex numbers </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">CAML_BA_CHAR</span></span></td><td class="c006">8-bit characters </td></tr>
</table></div></div>
<!--TOC paragraph id="sec529" Warning:-->
<h5 class="paragraph" id="sec529"><a class="section-anchor" href="#sec529" aria-hidden="true">ï»¿</a>Warning:</h5><!--SEC END --><p>
<span class="machine"><span class="font-tt">Caml_ba_array_val(</span></span><span class="font-it">v</span><span class="machine"><span class="font-tt">)</span></span> must always be dereferenced immediately and not stored
anywhere, including local variables.
It resolves to a derived pointer: it is not a valid OCaml value but points to
a memory region managed by the GC. For this reason this value must not be
stored in any memory location that could be live cross a GC.</p><p>The following example shows the passing of a two-dimensional Bigarray
to a C function and a Fortran function.
</p><pre>    extern void my_c_function(double * data, int dimx, int dimy);
    extern void my_fortran_function_(double * data, int * dimx, int * dimy);

    CAMLprim value caml_stub(value bigarray)
    {
      int dimx = Caml_ba_array_val(bigarray)-&gt;dim[0];
      int dimy = Caml_ba_array_val(bigarray)-&gt;dim[1];
      /* C passes scalar parameters by value */
      my_c_function(Caml_ba_data_val(bigarray), dimx, dimy);
      /* Fortran passes all parameters by reference */
      my_fortran_function_(Caml_ba_data_val(bigarray), &amp;dimx, &amp;dimy);
      return Val_unit;
    }
</pre>
<!--TOC subsection id="ss:C-Bigarrays-wrap" 22.10.3â€ƒWrapping a C or Fortran array as an OCaml Bigarray-->
<h3 class="subsection" id="ss:C-Bigarrays-wrap"><a class="section-anchor" href="#ss:C-Bigarrays-wrap" aria-hidden="true">ï»¿</a>22.10.3â€ƒWrapping a C or Fortran array as an OCaml Bigarray</h3><!--SEC END --><p>A pointer <span class="font-it">p</span> to an already-allocated C or Fortran array can be
wrapped and returned to OCaml as a Bigarray using the <span class="machine"><span class="font-tt">caml_ba_alloc</span></span>
or <span class="machine"><span class="font-tt">caml_ba_alloc_dims</span></span> functions.
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_ba_alloc(</span></span><span class="font-it">kind</span> <span class="machine"><span class="font-tt">|</span></span> <span class="font-it">layout</span>, <span class="font-it">numdims</span>, <span class="font-it">p</span>, <span class="font-it">dims</span><span class="machine"><span class="font-tt">)</span></span><p>Return an OCaml Bigarray wrapping the data pointed to by <span class="font-it">p</span>.
<span class="font-it">kind</span> is the kind of array elements (one of the <span class="machine"><span class="font-tt">CAML_BA_</span></span>
kind constants above). <span class="font-it">layout</span> is <span class="machine"><span class="font-tt">CAML_BA_C_LAYOUT</span></span> for an
array with C layout and <span class="machine"><span class="font-tt">CAML_BA_FORTRAN_LAYOUT</span></span> for an array with
Fortran layout. <span class="font-it">numdims</span> is the number of dimensions in the
array. <span class="font-it">dims</span> is an array of <span class="font-it">numdims</span> long integers, giving
the sizes of the array in each dimension.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_ba_alloc_dims(</span></span><span class="font-it">kind</span> <span class="machine"><span class="font-tt">|</span></span> <span class="font-it">layout</span>, <span class="font-it">numdims</span>,
<span class="font-it">p</span>, <span class="machine"><span class="font-tt">(long) </span></span><span class="font-it">dim</span><sub>1</sub>, <span class="machine"><span class="font-tt">(long) </span></span><span class="font-it">dim</span><sub>2</sub>, â€¦, <span class="machine"><span class="font-tt">(long) </span></span><span class="font-it">dim</span><sub><span class="font-it">numdims</span></sub><span class="machine"><span class="font-tt">)</span></span><p>Same as <span class="machine"><span class="font-tt">caml_ba_alloc</span></span>, but the sizes of the array in each dimension
are listed as extra arguments in the function call, rather than being
passed as an array.
</p></li></ul><p>
The following example illustrates how statically-allocated C and
Fortran arrays can be made available to OCaml.
</p><pre>    extern long my_c_array[100][200];
    extern float my_fortran_array_[300][400];

    CAMLprim value caml_get_c_array(value unit)
    {
      long dims[2];
      dims[0] = 100; dims[1] = 200;
      return caml_ba_alloc(CAML_BA_NATIVE_INT | CAML_BA_C_LAYOUT,
                           2, my_c_array, dims);
    }

    CAMLprim value caml_get_fortran_array(value unit)
    {
      return caml_ba_alloc_dims(CAML_BA_FLOAT32 | CAML_BA_FORTRAN_LAYOUT,
                                2, my_fortran_array_, 300L, 400L);
    }
</pre>
<!--TOC section id="s:C-cheaper-call" 22.11â€ƒAdvanced topic: cheaper C call-->
<h2 class="section" id="s:C-cheaper-call"><a class="section-anchor" href="#s:C-cheaper-call" aria-hidden="true">ï»¿</a>22.11â€ƒAdvanced topic: cheaper C call</h2><!--SEC END --><p>This section describe how to make calling C functions cheaper.</p><p><span class="font-bold">Note:</span> this only applies to the native compiler. So whenever you
use any of these methods, you have to provide an alternative byte-code
stub that ignores all the special annotations.</p>
<!--TOC subsection id="ss:c-unboxed" 22.11.1â€ƒPassing unboxed values-->
<h3 class="subsection" id="ss:c-unboxed"><a class="section-anchor" href="#ss:c-unboxed" aria-hidden="true">ï»¿</a>22.11.1â€ƒPassing unboxed values</h3><!--SEC END --><p>We said earlier that all OCaml objects are represented by the C type
<span class="machine"><span class="font-tt">value</span></span>, and one has to use macros such as <span class="machine"><span class="font-tt">Int_val</span></span> to decode data from
the <span class="machine"><span class="font-tt">value</span></span> type. It is however possible to tell the OCaml native-code
compiler to do this for us and pass arguments unboxed to the C function.
Similarly it is possible to tell OCaml to expect the result unboxed and box
it for us.</p><p>The motivation is that, by letting â€˜ocamloptâ€˜ deal with boxing, it can
often decide to suppress it entirely.</p><p>For instance letâ€™s consider this example:</p><pre>external foo : float -&gt; float -&gt; float = "foo"

let f a b =
  let len = Array.length a in
  assert (Array.length b = len);
  let res = Array.make len 0. in
  for i = 0 to len - 1 do
    res.(i) &lt;- foo a.(i) b.(i)
  done
</pre><p>
Float arrays are unboxed in OCaml, however the C function <span class="machine"><span class="font-tt">foo</span></span> expect
its arguments as boxed floats and returns a boxed float. Hence the
OCaml compiler has no choice but to box <span class="machine"><span class="font-tt">a.(i)</span></span> and <span class="machine"><span class="font-tt">b.(i)</span></span> and unbox
the result of <span class="machine"><span class="font-tt">foo</span></span>. This results in the allocation of <span class="machine"><span class="font-tt">3 * len</span></span>
temporary float values.</p><p>Now if we annotate the arguments and result with <span class="machine"><span class="font-tt">[@unboxed]</span></span>, the
native-code compiler will be able to avoid all these allocations:</p><pre>external foo
  :  (float [@unboxed])
  -&gt; (float [@unboxed])
  -&gt; (float [@unboxed])
  = "foo_byte" "foo"
</pre><p>
In this case the C functions must look like:</p><pre>CAMLprim double foo(double a, double b)
{
  ...
}

CAMLprim value foo_byte(value a, value b)
{
  return caml_copy_double(foo(Double_val(a), Double_val(b)))
}
</pre><p>
For convenience, when all arguments and the result are annotated with
<span class="machine"><span class="font-tt">[@unboxed]</span></span>, it is possible to put the attribute only once on the
declaration itself. So we can also write instead:</p><pre>external foo : float -&gt; float -&gt; float = "foo_byte" "foo" [@@unboxed]
</pre><p>
The following table summarize what OCaml types can be unboxed, and
what C types should be used in correspondence:</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">OCaml type</span></td><td class="c004"><span class="font-bold">C type</span> </td></tr>
<tr><td class="c006">
<span class="machine"><span class="font-tt">float</span></span></td><td class="c006"><span class="machine"><span class="font-tt">double</span></span> </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">int32</span></span></td><td class="c006"><span class="machine"><span class="font-tt">int32_t</span></span> </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">int64</span></span></td><td class="c006"><span class="machine"><span class="font-tt">int64_t</span></span> </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">nativeint</span></span></td><td class="c006"><span class="machine"><span class="font-tt">intnat</span></span> </td></tr>
</table></div></div><p>Similarly, it is possible to pass untagged OCaml integers between
OCaml and C. This is done by annotating the arguments and/or result
with <span class="machine"><span class="font-tt">[@untagged]</span></span>:</p><pre>external f : string -&gt; (int [@untagged]) = "f_byte" "f"
</pre><p>
The corresponding C type must be <span class="machine"><span class="font-tt">intnat</span></span>.</p><p><span class="font-bold">Note:</span> do not use the C <span class="machine"><span class="font-tt">int</span></span> type in correspondence with <span class="machine"><span class="font-tt">(int [@untagged])</span></span>. This is because they often differ in size.</p>
<!--TOC subsection id="ss:c-direct-call" 22.11.2â€ƒDirect C call-->
<h3 class="subsection" id="ss:c-direct-call"><a class="section-anchor" href="#ss:c-direct-call" aria-hidden="true">ï»¿</a>22.11.2â€ƒDirect C call</h3><!--SEC END --><p>In order to be able to run the garbage collector in the middle of
a C function, the OCaml native-code compiler generates some bookkeeping
code around C calls. Technically it wraps every C call with the C function
<span class="machine"><span class="font-tt">caml_c_call</span></span> which is part of the OCaml runtime.</p><p>For small functions that are called repeatedly, this indirection can have
a big impact on performances. However this is not needed if we know that
the C function doesnâ€™t allocate, doesnâ€™t raise exceptions, and doesnâ€™t release
the domain lock (see sectionÂ <a href="#ss%3Aparallel-execution-long-running-c-code">22.12.2</a>).
We can instruct the OCaml native-code compiler of this fact by annotating the
external declaration with the attribute <span class="machine"><span class="font-tt">[@@noalloc]</span></span>:</p><pre>external bar : int -&gt; int -&gt; int = "foo" [@@noalloc]
</pre><p>
In this case calling <span class="machine"><span class="font-tt">bar</span></span> from OCaml is as cheap as calling any other
OCaml function, except for the fact that the OCaml compiler canâ€™t
inline C functions...</p>
<!--TOC subsection id="ss:c-direct-call-example" 22.11.3â€ƒExample: calling C library functions without indirection-->
<h3 class="subsection" id="ss:c-direct-call-example"><a class="section-anchor" href="#ss:c-direct-call-example" aria-hidden="true">ï»¿</a>22.11.3â€ƒExample: calling C library functions without indirection</h3><!--SEC END --><p>Using these attributes, it is possible to call C library functions
with no indirection. For instance many math functions are defined this
way in the OCaml standard library:</p><pre>external sqrt : float -&gt; float = "caml_sqrt_float" "sqrt"
  [@@unboxed] [@@noalloc]
(** Square root. *)

external exp : float -&gt; float = "caml_exp_float" "exp" [@@unboxed] [@@noalloc]
(** Exponential. *)

external log : float -&gt; float = "caml_log_float" "log" [@@unboxed] [@@noalloc]
(** Natural logarithm. *)
</pre>
<!--TOC section id="s:C-multithreading" 22.12â€ƒAdvanced topic: multithreading-->
<h2 class="section" id="s:C-multithreading"><a class="section-anchor" href="#s:C-multithreading" aria-hidden="true">ï»¿</a>22.12â€ƒAdvanced topic: multithreading</h2><!--SEC END --><p>Using multiple threads (shared-memory concurrency) in a mixed OCaml/C
application requires special precautions, which are described in this
section.</p>
<!--TOC subsection id="ss:c-thread-register" 22.12.1â€ƒRegistering threads created from C-->
<h3 class="subsection" id="ss:c-thread-register"><a class="section-anchor" href="#ss:c-thread-register" aria-hidden="true">ï»¿</a>22.12.1â€ƒRegistering threads created from C</h3><!--SEC END --><p>Callbacks from C to OCaml are possible only if the calling thread is
known to the OCaml run-time system. Threads created from OCaml (through
the <span class="machine"><span class="font-tt">Thread.create</span></span> function of the system threads library) are
automatically known to the run-time system. If the application
creates additional threads from C and wishes to callback into OCaml
code from these threads, it must first register them with the run-time
system. The following functions are declared in the include file
<span class="machine"><span class="font-tt">&lt;caml/threads.h&gt;</span></span>.</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_c_thread_register()</span></span> registers the calling thread with the OCaml
run-time system. Returns 1 on success, 0 on error. Registering an
already-registered thread does nothing and returns 0.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_c_thread_unregister()</span></span> must be called before the thread
terminates, to unregister it from the OCaml run-time system.
Returns 1 on success, 0 on error. If the calling thread was not
previously registered, does nothing and returns 0.
</li></ul>
<!--TOC subsection id="ss:parallel-execution-long-running-c-code" 22.12.2â€ƒParallel execution of long-running C code with systhreads-->
<h3 class="subsection" id="ss:parallel-execution-long-running-c-code"><a class="section-anchor" href="#ss:parallel-execution-long-running-c-code" aria-hidden="true">ï»¿</a>22.12.2â€ƒParallel execution of long-running C code with systhreads</h3><!--SEC END --><p>Domains are the unit of parallelism for OCaml programs. When using
the systhreads library, multiple threads might be attached to the same
domain. However, at any time, at most one of those thread can be executing
OCaml code or C code that uses the OCaml run-time system by domain.
Technically, this is enforced by a â€œdomain lockâ€
that any thread must hold while executing such code within a domain.</p><p>When OCaml calls the C code implementing a primitive, the domain lock
is held, therefore the C code has full access to the facilities of the
run-time system. However, no other thread in the same domain can execute
OCaml code concurrently with the C code of the primitive.
See also chapterÂ <a href="#s%3Apar_c_bindings">9.6</a> for the behaviour with multiple domains.</p><p>If a C primitive runs for a long time or performs potentially blocking
input-output operations, it can explicitly release the domain lock,
enabling other OCaml threads in the same domain to run concurrently with
its operations.
The C code must re-acquire the domain lock before returning to OCaml.
This is achieved with the following functions, declared in
the include file <span class="machine"><span class="font-tt">&lt;caml/threads.h&gt;</span></span>.</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_release_runtime_system()</span></span>
The calling thread releases the domain lock and other OCaml resources,
enabling other threads to run OCaml code in parallel with the execution
of the calling thread.
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_acquire_runtime_system()</span></span>
The calling thread re-acquires the domain lock and other OCaml
resources. It may block until no other thread in the same domain uses
the OCaml run-time system.
</li></ul><p>These functions poll for pending signals by calling asynchronous
callbacks (sectionÂ <a href="#ss%3Ac-process-pending-actions">22.5.3</a>) before releasing and
after acquiring the lock. They can therefore execute arbitrary OCaml
code including raising an asynchronous exception.</p><p>After <span class="machine"><span class="font-tt">caml_release_runtime_system()</span></span> was called and until
<span class="machine"><span class="font-tt">caml_acquire_runtime_system()</span></span> is called, the C code must not access
any OCaml data, nor call any function of the run-time system, nor call
back into OCaml code. Consequently, arguments provided by OCaml to the
C primitive must be copied into C data structures before calling
<span class="machine"><span class="font-tt">caml_release_runtime_system()</span></span>, and results to be returned to OCaml
must be encoded as OCaml values after <span class="machine"><span class="font-tt">caml_acquire_runtime_system()</span></span>
returns.</p><p>Example: the following C primitive invokes <span class="machine"><span class="font-tt">gethostbyname</span></span> to find the
IP address of a host name. The <span class="machine"><span class="font-tt">gethostbyname</span></span> function can block for
a long time, so we choose to release the OCaml run-time system while it
is running.
</p><pre>CAMLprim stub_gethostbyname(value vname)
{
  CAMLparam1 (vname);
  CAMLlocal1 (vres);
  struct hostent * h;
  char * name;

  /* Copy the string argument to a C string, allocated outside the
     OCaml heap. */
  name = caml_stat_strdup(String_val(vname));
  /* Release the OCaml run-time system */
  caml_release_runtime_system();
  /* Resolve the name */
  h = gethostbyname(name);
  /* Free the copy of the string, which we might as well do before
     acquiring the runtime system to benefit from parallelism. */
  caml_stat_free(name);
  /* Re-acquire the OCaml run-time system */
  caml_acquire_runtime_system();
  /* Encode the relevant fields of h as the OCaml value vres */
  ... /* Omitted */
  /* Return to OCaml */
  CAMLreturn (vres);
}
</pre><p>
The macro <span class="machine"><span class="font-tt">Caml_state</span></span> evaluates to the domain state variable, and
checks in debug mode that the domain lock is held. Such a check is
also placed in normal mode at key entry points of the C API; this is
why calling some of the runtime functions and macros without correctly
owning the domain lock can result in a fatal error: <span class="machine"><span class="font-tt">no domain lock held</span></span>. The variant <span class="machine"><span class="font-tt">Caml_state_opt</span></span> does not perform any check but
evaluates to <span class="machine"><span class="font-tt">NULL</span></span> when the domain lock is not held. This lets you
determine whether a thread belonging to a domain currently holds its
domain lock, for various purposes.</p><p>Callbacks from C to OCaml must be performed while holding the domain
lock to the OCaml run-time system. This is naturally the case if the
callback is performed by a C primitive that did not release the
run-time system. If the C primitive released the run-time system
previously, or the callback is performed from other C code that was
not invoked from OCaml (e.g. an event loop in a GUI application), the
run-time system must be acquired before the callback and released
after:
</p><pre>  caml_acquire_runtime_system();
  /* Resolve OCaml function vfun to be invoked */
  /* Build OCaml argument varg to the callback */
  vres = callback(vfun, varg);
  /* Copy relevant parts of result vres to C data structures */
  caml_release_runtime_system();
</pre><p>
Note: the <span class="machine"><span class="font-tt">acquire</span></span> and <span class="machine"><span class="font-tt">release</span></span> functions described above were
introduced in OCaml 3.12. Older code uses the following historical
names, declared in <span class="machine"><span class="font-tt">&lt;caml/signals.h&gt;</span></span>:
</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">caml_enter_blocking_section</span></span> as an alias for
<span class="machine"><span class="font-tt">caml_release_runtime_system</span></span>
</li><li class="li-itemize"><span class="machine"><span class="font-tt">caml_leave_blocking_section</span></span> as an alias for
<span class="machine"><span class="font-tt">caml_acquire_runtime_system</span></span>
</li></ul><p>
Intuition: a â€œblocking sectionâ€ is a piece of C code that does not
use the OCaml run-time system, typically a blocking input/output operation.</p>
<!--TOC section id="s:interfacing-windows-unicode-apis" 22.13â€ƒAdvanced topic: interfacing with Windows Unicode APIs-->
<h2 class="section" id="s:interfacing-windows-unicode-apis"><a class="section-anchor" href="#s:interfacing-windows-unicode-apis" aria-hidden="true">ï»¿</a>22.13â€ƒAdvanced topic: interfacing with Windows Unicode APIs</h2><!--SEC END --><p>This section contains some general guidelines for writing C stubs that use
Windows Unicode APIs.</p><p>The OCaml system under Windows can be configured at build time in one of two
modes:</p><ul class="itemize"><li class="li-itemize"><span class="font-bold">legacy mode:</span> All path names, environment variables, command line
arguments, etc. on the OCaml side are assumed to be encoded using the current
8-bit code page of the system.</li><li class="li-itemize"><span class="font-bold">Unicode mode:</span> All path names, environment variables, command line
arguments, etc. on the OCaml side are assumed to be encoded using UTF-8.</li></ul><p>In what follows, we say that a string has the <em>OCaml encoding</em> if it is
encoded in UTF-8 when in Unicode mode, in the current code page in legacy mode,
or is an arbitrary string under Unix. A string has the <em>platform encoding</em>
if it is encoded in UTF-16 under Windows or is an arbitrary string under Unix.</p><p>From the point of view of the writer of C stubs, the challenges of interacting
with Windows Unicode APIs are twofold:</p><ul class="itemize"><li class="li-itemize">The Windows API uses the UTF-16 encoding to support Unicode. The runtime
system performs the necessary conversions so that the OCaml programmer only
needs to deal with the OCaml encoding. C stubs that call Windows Unicode APIs
need to use specific runtime functions to perform the necessary conversions in a
compatible way.</li><li class="li-itemize">When writing stubs that need to be compiled under both Windows and Unix,
the stubs need to be written in a way that allow the necessary conversions under
Windows but that also work under Unix, where typically nothing particular needs
to be done to support Unicode.</li></ul><p>The native C character type under Windows is <span class="machine"><span class="font-tt">WCHAR</span></span>, two bytes wide, while
under Unix it is <span class="machine"><span class="font-tt">char</span></span>, one byte wide. A type <span class="machine"><span class="font-tt">char_os</span></span> is defined in
<span class="machine"><span class="font-tt">&lt;caml/misc.h&gt;</span></span> that stands for the concrete C character type of each
platform. Strings in the platform encoding are of type <span class="machine"><span class="font-tt">char_os *</span></span>.</p><p>The following functions are exposed to help write compatible C stubs. To use
them, you need to include both <span class="machine"><span class="font-tt">&lt;caml/misc.h&gt;</span></span> and <span class="machine"><span class="font-tt">&lt;caml/osdeps.h&gt;</span></span>.</p><ul class="itemize"><li class="li-itemize"><span class="machine"><span class="font-tt">char_os* caml_stat_strdup_to_os(const char *)</span></span> copies the argument while
translating from OCaml encoding to the platform encoding. This function is
typically used to convert the <span class="machine"><span class="font-tt">char *</span></span> underlying an OCaml string before passing
it to an operating system API that takes a Unicode argument. Under Unix, it is
equivalent to <span class="machine"><span class="font-tt">caml_stat_strdup</span></span>.<p><span class="font-bold">Note:</span> For maximum backwards compatibility in Unicode mode, if the argument
is not a valid UTF-8 string, this function will fall back to assuming that it is
encoded in the current code page.</p></li><li class="li-itemize"><span class="machine"><span class="font-tt">char* caml_stat_strdup_of_os(const char_os *)</span></span> copies the argument while
translating from the platform encoding to the OCaml encoding. It is the inverse
of <span class="machine"><span class="font-tt">caml_stat_strdup_to_os</span></span>. This function is typically used to convert a string
obtained from the operating system before passing it on to OCaml code. Under
Unix, it is equivalent to <span class="machine"><span class="font-tt">caml_stat_strdup</span></span>.</li><li class="li-itemize"><span class="machine"><span class="font-tt">value caml_copy_string_of_os(char_os *)</span></span> allocates an OCaml string with
contents equal to the argument string converted to the OCaml encoding. This
function is essentially equivalent to <span class="machine"><span class="font-tt">caml_stat_strdup_of_os</span></span> followed by
<span class="machine"><span class="font-tt">caml_copy_string</span></span>, except that it avoids the allocation of the intermediate
string returned by <span class="machine"><span class="font-tt">caml_stat_strdup_of_os</span></span>. Under Unix, it is equivalent to
<span class="machine"><span class="font-tt">caml_copy_string</span></span>.</li></ul><p><span class="font-bold">Note:</span> The strings returned by <span class="machine"><span class="font-tt">caml_stat_strdup_to_os</span></span> and
<span class="machine"><span class="font-tt">caml_stat_strdup_of_os</span></span> are allocated using <span class="machine"><span class="font-tt">caml_stat_alloc</span></span>, so they need to
be deallocated using <span class="machine"><span class="font-tt">caml_stat_free</span></span> when they are no longer needed.</p>
<!--TOC paragraph id="sec539" Example-->
<h5 class="paragraph" id="sec539"><a class="section-anchor" href="#sec539" aria-hidden="true">ï»¿</a>Example</h5><!--SEC END --><p> We want to bind the function <span class="machine"><span class="font-tt">getenv</span></span> in a way that works
both under Unix and Windows. Under Unix this function has the prototype:</p><pre>    char *getenv(const char *);
</pre><p>While the Unicode version under Windows has the prototype:
</p><pre>    WCHAR *_wgetenv(const WCHAR *);
</pre><p>
In terms of <span class="machine"><span class="font-tt">char_os</span></span>, both functions take an argument of type <span class="machine"><span class="font-tt">char_os *</span></span> and
return a result of the same type. We begin by choosing the right implementation
of the function to bind:</p><pre>#ifdef _WIN32
#define getenv_os _wgetenv
#else
#define getenv_os getenv
#endif
</pre><p>
The rest of the binding is the same for both platforms:</p><pre>#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/misc.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/fail.h&gt;
#include &lt;caml/osdeps.h&gt;
#include &lt;stdlib.h&gt;

CAMLprim value stub_getenv(value var_name)
{
  CAMLparam1(var_name);
  CAMLlocal1(var_value);
  char_os *var_name_os, *var_value_os;

  var_name_os = caml_stat_strdup_to_os(String_val(var_name));
  var_value_os = getenv_os(var_name_os);
  caml_stat_free(var_name_os);

  if (var_value_os == NULL)
    caml_raise_not_found();

  var_value = caml_copy_string_of_os(var_value_os);

  CAMLreturn(var_value);
}
</pre>
<!--TOC section id="s:ocamlmklib" 22.14â€ƒBuilding mixed C/OCaml libraries: <span class="font-tt">ocamlmklib</span>-->
<h2 class="section" id="s:ocamlmklib"><a class="section-anchor" href="#s:ocamlmklib" aria-hidden="true">ï»¿</a>22.14â€ƒBuilding mixed C/OCaml libraries: <span class="font-tt">ocamlmklib</span></h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">ocamlmklib</span></span> command facilitates the construction of libraries
containing both OCaml code and C code, and usable both in static
linking and dynamic linking modes. This command is available under
Windows since Objective Caml 3.11 and under other operating systems since
Objective Caml 3.03.</p><p>The <span class="machine"><span class="font-tt">ocamlmklib</span></span> command takes three kinds of arguments:
</p><ul class="itemize"><li class="li-itemize">OCaml source files and object files (<span class="machine"><span class="font-tt">.cmo</span></span>, <span class="machine"><span class="font-tt">.cmx</span></span>, <span class="machine"><span class="font-tt">.ml</span></span>)
comprising the OCaml part of the library;
</li><li class="li-itemize">C object files (<span class="machine"><span class="font-tt">.o</span></span>, <span class="machine"><span class="font-tt">.a</span></span>, respectively, <span class="machine"><span class="font-tt">.obj</span></span>, <span class="machine"><span class="font-tt">.lib</span></span>)
comprising the C part of the library;
</li><li class="li-itemize">Support libraries for the C part (<span class="machine"><span class="font-tt">-l</span></span><span class="font-it">lib</span>).
</li></ul><p>
It generates the following outputs:
</p><ul class="itemize"><li class="li-itemize">An OCaml bytecode library <span class="machine"><span class="font-tt">.cma</span></span> incorporating the <span class="machine"><span class="font-tt">.cmo</span></span> and
<span class="machine"><span class="font-tt">.ml</span></span> OCaml files given as arguments, and automatically referencing the
C library generated with the C object files.
</li><li class="li-itemize">An OCaml native-code library <span class="machine"><span class="font-tt">.cmxa</span></span> incorporating the <span class="machine"><span class="font-tt">.cmx</span></span> and
<span class="machine"><span class="font-tt">.ml</span></span> OCaml files given as arguments, and automatically referencing the
C library generated with the C object files.
</li><li class="li-itemize">If dynamic linking is supported on the target platform, a
<span class="machine"><span class="font-tt">.so</span></span> (respectively, <span class="machine"><span class="font-tt">.dll</span></span>) shared library built from the C object files given as arguments,
and automatically referencing the support libraries.
</li><li class="li-itemize">A C static library <span class="machine"><span class="font-tt">.a</span></span>(respectively, <span class="machine"><span class="font-tt">.lib</span></span>) built from the C object files.
</li></ul><p>
In addition, the following options are recognized:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-cclib</span></span>, <span class="machine"><span class="font-tt">-ccopt</span></span>, <span class="machine"><span class="font-tt">-I</span></span>, <span class="machine"><span class="font-tt">-linkall</span></span></span></dt><dd class="dd-description">
These options are passed as is to <span class="machine"><span class="font-tt">ocamlc</span></span> or <span class="machine"><span class="font-tt">ocamlopt</span></span>.
See the documentation of these commands.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rpath</span></span>, <span class="machine"><span class="font-tt">-R</span></span>, <span class="machine"><span class="font-tt">-Wl,-rpath</span></span>, <span class="machine"><span class="font-tt">-Wl,-R</span></span></span></dt><dd class="dd-description">
These options are passed as is to the C compiler. Refer to the
documentation of the C compiler.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-custom</span></span></span></dt><dd class="dd-description"> Force the construction of a statically linked library
only, even if dynamic linking is supported.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-failsafe</span></span></span></dt><dd class="dd-description"> Fall back to building a statically linked library
if a problem occurs while building the shared library (e.g. some of
the support libraries are not available as shared libraries).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-L</span></span><span class="font-it">dir</span></span></dt><dd class="dd-description"> Add <span class="font-it">dir</span> to the search path for support
libraries (<span class="machine"><span class="font-tt">-l</span></span><span class="font-it">lib</span>).
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ocamlc</span></span> <span class="font-it">cmd</span></span></dt><dd class="dd-description"> Use <span class="font-it">cmd</span> instead of <span class="machine"><span class="font-tt">ocamlc</span></span> to call
the bytecode compiler.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-ocamlopt</span></span> <span class="font-it">cmd</span></span></dt><dd class="dd-description"> Use <span class="font-it">cmd</span> instead of <span class="machine"><span class="font-tt">ocamlopt</span></span> to call
the native-code compiler.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-o</span></span> <span class="font-it">output</span></span></dt><dd class="dd-description"> Set the name of the generated OCaml library.
<span class="machine"><span class="font-tt">ocamlmklib</span></span> will generate <span class="font-it">output</span><span class="machine"><span class="font-tt">.cma</span></span> and/or <span class="font-it">output</span><span class="machine"><span class="font-tt">.cmxa</span></span>.
If not specified, defaults to <span class="machine"><span class="font-tt">a</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-oc</span></span> <span class="font-it">outputc</span></span></dt><dd class="dd-description"> Set the name of the generated C library.
<span class="machine"><span class="font-tt">ocamlmklib</span></span> will generate <span class="machine"><span class="font-tt">lib</span></span><span class="font-it">outputc</span><span class="machine"><span class="font-tt">.so</span></span> (if shared
libraries are supported) and <span class="machine"><span class="font-tt">lib</span></span><span class="font-it">outputc</span><span class="machine"><span class="font-tt">.a</span></span>.
If not specified, defaults to the output name given with <span class="machine"><span class="font-tt">-o</span></span>.
</dd></dl><p>On native Windows, the following environment variable is also consulted:</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">OCAML_FLEXLINK</span></span></span></dt><dd class="dd-description"> Alternative executable to use instead of the
configured value. Primarily used for bootstrapping.
</dd></dl>
<!--TOC paragraph id="sec541" Example-->
<h5 class="paragraph" id="sec541"><a class="section-anchor" href="#sec541" aria-hidden="true">ï»¿</a>Example</h5><!--SEC END --><p> Consider an OCaml interface to the standard <span class="machine"><span class="font-tt">libz</span></span>
C library for reading and writing compressed files. Assume this
library resides in <span class="machine"><span class="font-tt">/usr/local/zlib</span></span>. This interface is
composed of an OCaml part <span class="machine"><span class="font-tt">zip.cmo</span></span>/<span class="machine"><span class="font-tt">zip.cmx</span></span> and a C part <span class="machine"><span class="font-tt">zipstubs.o</span></span>
containing the stub code around the <span class="machine"><span class="font-tt">libz</span></span> entry points. The
following command builds the OCaml libraries <span class="machine"><span class="font-tt">zip.cma</span></span> and <span class="machine"><span class="font-tt">zip.cmxa</span></span>,
as well as the companion C libraries <span class="machine"><span class="font-tt">dllzip.so</span></span> and <span class="machine"><span class="font-tt">libzip.a</span></span>:
</p><pre>ocamlmklib -o zip zip.cmo zip.cmx zipstubs.o -lz -L/usr/local/zlib
</pre><p>If shared libraries are supported, this performs the following
commands:
</p><pre>ocamlc -a -o zip.cma zip.cmo -dllib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -cclib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
gcc -shared -o dllzip.so zipstubs.o -lz -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</pre><p>Note: This example is on a Unix system. The exact command lines
may be different on other systems.</p><p>If shared libraries are not supported, the following commands are
performed instead:
</p><pre>ocamlc -a -custom -o zip.cma zip.cmo -cclib -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</pre><p>Instead of building simultaneously the bytecode library, the
native-code library and the C libraries, <span class="machine"><span class="font-tt">ocamlmklib</span></span> can be called
three times to build each separately. Thus,
</p><pre>ocamlmklib -o zip zip.cmo -lz -L/usr/local/zlib
</pre><p>builds the bytecode library <span class="machine"><span class="font-tt">zip.cma</span></span>, and
</p><pre>ocamlmklib -o zip zip.cmx -lz -L/usr/local/zlib
</pre><p>builds the native-code library <span class="machine"><span class="font-tt">zip.cmxa</span></span>, and
</p><pre>ocamlmklib -o zip zipstubs.o -lz -L/usr/local/zlib
</pre><p>builds the C libraries <span class="machine"><span class="font-tt">dllzip.so</span></span> and <span class="machine"><span class="font-tt">libzip.a</span></span>. Notice that the
support libraries (<span class="machine"><span class="font-tt">-lz</span></span>) and the corresponding options
(<span class="machine"><span class="font-tt">-L/usr/local/zlib</span></span>) must be given on all three invocations of <span class="machine"><span class="font-tt">ocamlmklib</span></span>,
because they are needed at different times depending on whether shared
libraries are supported.</p>
<!--TOC section id="s:c-internal-guidelines" 22.15â€ƒCautionary words: the internal runtime API-->
<h2 class="section" id="s:c-internal-guidelines"><a class="section-anchor" href="#s:c-internal-guidelines" aria-hidden="true">ï»¿</a>22.15â€ƒCautionary words: the internal runtime API</h2><!--SEC END --><p>Not all header available in the <span class="machine"><span class="font-tt">caml/</span></span> directory were described in previous
sections. All those unmentioned headers are part of the internal runtime API,
for which there is <em>no</em> stability guarantee. If you really need access
to this internal runtime API, this section provides some guidelines
that may help you to write code that might not break on every new version
of OCaml.
</p>
<!--TOC paragraph id="sec543" Note-->
<h5 class="paragraph" id="sec543"><a class="section-anchor" href="#sec543" aria-hidden="true">ï»¿</a>Note</h5><!--SEC END --><p> Programmers which come to rely on the internal API
for a use-case which they find realistic and useful are encouraged to open
a request for improvement on the bug tracker.</p>
<!--TOC subsection id="ss:c-internals" 22.15.1â€ƒInternal variables and CAML_INTERNALS-->
<h3 class="subsection" id="ss:c-internals"><a class="section-anchor" href="#ss:c-internals" aria-hidden="true">ï»¿</a>22.15.1â€ƒInternal variables and CAML_INTERNALS</h3><!--SEC END --><p>
Since OCaml 4.04, it is possible to get access to every part of the internal
runtime API by defining the <span class="machine"><span class="font-tt">CAML_INTERNALS</span></span> macro before loading caml header files.
If this macro is not defined, parts of the internal runtime API are hidden.</p><p>If you are using internal C variables, do not redefine them by hand. You should
import those variables by including the corresponding header files. The
representation of those variables has already changed once in OCaml 4.10, and is
still under evolution.
If your code relies on such internal and brittle properties, it will be broken
at some point in time.</p><p>For instance, rather than redefining <span class="machine"><span class="font-tt">caml_young_limit</span></span>:
</p><pre>extern int caml_young_limit;
</pre><p>which breaks in OCaml â‰¥ 4.10, you should include the <span class="machine"><span class="font-tt">minor_gc</span></span> header:
</p><pre>#include &lt;caml/minor_gc.h&gt;
</pre>
<!--TOC subsection id="ss:c-internal-macros" 22.15.2â€ƒOCaml version macros-->
<h3 class="subsection" id="ss:c-internal-macros"><a class="section-anchor" href="#ss:c-internal-macros" aria-hidden="true">ï»¿</a>22.15.2â€ƒOCaml version macros</h3><!--SEC END --><p>
Finally, if including the right headers is not enough, or if you need to support
version older than OCaml 4.04, the header file <span class="machine"><span class="font-tt">caml/version.h</span></span> should help
you to define your own compatibility layer.
This file provides few macros defining the current OCaml version.
In particular, the <span class="machine"><span class="font-tt">OCAML_VERSION</span></span> macro describes the current version,
its format is <span class="machine"><span class="font-tt">MmmPP</span></span>.
For example, if you need some specific handling for versions older than 4.10.0,
you could write
</p><pre>#include &lt;caml/version.h&gt;
#if OCAML_VERSION &gt;= 41000
...
#else
...
#endif
</pre>
<!--TOC chapter id="sec546" ChapterÂ 23â€ƒOptimisation with Flambda-->
<h1 class="chapter" id="sec546">ChapterÂ 23â€ƒOptimisation with Flambda</h1><!--SEC END --><!--NAME flambda.html-->

<!--TOC section id="s:flambda-overview" 23.1â€ƒOverview-->
<h2 class="section" id="s:flambda-overview"><a class="section-anchor" href="#s:flambda-overview" aria-hidden="true">ï»¿</a>23.1â€ƒOverview</h2><!--SEC END --><p><em>Flambda</em> is the term used to describe a series of optimisation passes
provided by the native code compilers as of OCaml 4.03.</p><p>Flambda aims to make it easier to write idiomatic OCaml code without
incurring performance penalties.</p><p>To use the Flambda optimisers it is necessary to pass the <span class="font-tt">-flambda</span>
option to the OCaml <span class="font-tt">configure</span> script. (There is no support for a
single compiler that can operate in both Flambda and non-Flambda modes.)
Code compiled with Flambda
cannot be linked into the same program as code compiled without Flambda.
Attempting to do this will result in a compiler error.</p><p>Whether or not a particular <span class="font-tt">ocamlopt</span> uses Flambda may be
determined by invoking it with the <span class="font-tt">-config</span> option and looking
for any line starting with â€œ<span class="font-tt">flambda:</span>â€. If such a line is present
and says â€œ<span class="font-tt">true</span>â€, then Flambda is supported, otherwise it is not.</p><p>Flambda provides full optimisation across different compilation units,
so long as the <span class="font-tt">.cmx</span> files for the dependencies of the unit currently
being compiled are available. (A compilation unit corresponds to a
single <span class="font-tt">.ml</span> source file.) However it does not yet act entirely as
a whole-program compiler: for example, elimination of dead code across
a complete set of compilation units is not supported.</p><p>Optimisation with Flambda is not currently supported when generating
bytecode.</p><p>Flambda should not in general affect the semantics of existing programs.
Two exceptions to this rule are: possible elimination of pure code
that is being benchmarked (see section <a href="#s%3Aflambda-inhibition">23.14</a>) and changes in
behaviour of code using unsafe operations (see section <a href="#s%3Aflambda-unsafe">23.15</a>).</p><p>Flambda does not yet optimise array or string bounds checks. Neither
does it take hints for optimisation from any assertions written by the
user in the code.</p><p>Consult the <em>Glossary</em> at the end of this chapter for definitions of
technical terms used below.</p>
<!--TOC section id="s:flambda-cli" 23.2â€ƒCommand-line flags-->
<h2 class="section" id="s:flambda-cli"><a class="section-anchor" href="#s:flambda-cli" aria-hidden="true">ï»¿</a>23.2â€ƒCommand-line flags</h2><!--SEC END --><p>The Flambda optimisers provide a variety of command-line flags that may
be used to control their behaviour. Detailed descriptions of each flag
are given in the referenced sections. Those sections also describe any
arguments which the particular flags take.</p><p>Commonly-used options:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-O2</span></span></span></dt><dd class="dd-description"> Perform more optimisation than usual. Compilation
times may be lengthened. (This flag is an abbreviation for a certain
set of parameters described in section <a href="#s%3Aflambda-defaults">23.5</a>.)
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-O3</span></span></span></dt><dd class="dd-description"> Perform even more optimisation than usual, possibly
including unrolling of recursive functions. Compilation times may be
significantly lengthened.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-Oclassic</span></span></span></dt><dd class="dd-description"> Make inlining decisions at the point of
definition of a function rather than at the call site(s). This mirrors
the behaviour of OCaml compilers not using Flambda. Compared to compilation
using the new Flambda inlining heuristics (for example at <span class="font-tt">-O2</span>) it
produces
smaller <span class="font-tt">.cmx</span> files, shorter compilation times and code that probably
runs rather slower. When using <span class="font-tt">-Oclassic</span>, only the following options
described in this section are relevant: <span class="font-tt">-inlining-report</span> and
<span class="font-tt">-inline</span>. If any other of the options described in this section are
used, the behaviour is undefined and may cause an error in future versions
of the compiler.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inlining-report</span></span></span></dt><dd class="dd-description"> Emit <span class="font-tt">.inlining</span> files (one per
round of optimisation) showing all of the inlinerâ€™s decisions.
</dd></dl><p>Less commonly-used options:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-remove-unused-arguments</span></span></span></dt><dd class="dd-description"> Remove unused function arguments
even when the argument is not specialised. This may have a small
performance penalty.
See section <a href="#ss%3Aflambda-remove-unused-args">23.10.3</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unbox-closures</span></span></span></dt><dd class="dd-description"> Pass free variables via specialised arguments
rather than closures (an optimisation for reducing allocation). See
section <a href="#ss%3Aflambda-unbox-closures">23.9.3</a>. This may have a small performance penalty.
</dd></dl><p>Advanced options, only needed for detailed tuning:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline</span></span></span></dt><dd class="dd-description"> The behaviour depends on whether <span class="font-tt">-Oclassic</span>
is used.
<ul class="itemize"><li class="li-itemize">When not in <span class="font-tt">-Oclassic</span> mode, <span class="font-tt">-inline</span> limits the total
size of functions considered for inlining during any speculative inlining
search. (See section <a href="#ss%3Aflambda-speculation">23.3.6</a>.) Note that
this parameter does
<span class="font-bold">not</span> control the assessment as to whether any particular function may
be inlined. Raising it to excessive amounts will not necessarily cause
more functions to be inlined.
</li><li class="li-itemize">When in <span class="font-tt">-Oclassic</span> mode, <span class="font-tt">-inline</span> behaves as in
previous versions of the compiler: it is the maximum size of function to
be considered for inlining. See section <a href="#ss%3Aflambda-classic">23.3.1</a>.
</li></ul>
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-toplevel</span></span></span></dt><dd class="dd-description"> The equivalent of <span class="font-tt">-inline</span> but used
when speculative inlining starts at toplevel. See
section <a href="#ss%3Aflambda-speculation">23.3.6</a>.
Not used in <span class="font-tt">-Oclassic</span> mode.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-branch-factor</span></span></span></dt><dd class="dd-description"> Controls how the inliner assesses
whether a code path is likely to be hot or cold. See
section <a href="#ss%3Aflambda-assessment-inlining">23.3.5</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-alloc-cost,
<span class="machine"><span class="font-tt">-inline-branch-cost,
<span class="machine"><span class="font-tt">-inline-call-cost</span></span></span></span></span></span></span></dt><dd class="dd-description"> Controls how the inliner assesses the runtime
performance penalties associated with various operations. See
section <a href="#ss%3Aflambda-assessment-inlining">23.3.5</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-indirect-cost,
<span class="machine"><span class="font-tt">-inline-prim-cost</span></span></span></span></span></dt><dd class="dd-description"> Likewise.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-lifting-benefit</span></span></span></dt><dd class="dd-description"> Controls inlining of functors
at toplevel. See section <a href="#ss%3Aflambda-assessment-inlining">23.3.5</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-max-depth</span></span></span></dt><dd class="dd-description"> The maximum depth of any
speculative inlining search. See section <a href="#ss%3Aflambda-speculation">23.3.6</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-max-unroll</span></span></span></dt><dd class="dd-description"> The maximum depth of any unrolling of
recursive functions during any speculative inlining search.
See section <a href="#ss%3Aflambda-speculation">23.3.6</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-unbox-free-vars-of-closures</span></span></span></dt><dd class="dd-description"> Do not unbox closure variables. See section <a href="#ss%3Aflambda-unbox-fvs">23.9.1</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-no-unbox-specialised-args</span></span></span></dt><dd class="dd-description"> Do not unbox arguments to which functions have been specialised. See
section <a href="#ss%3Aflambda-unbox-spec-args">23.9.2</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-rounds</span></span></span></dt><dd class="dd-description"> How many rounds of optimisation to perform.
See section <a href="#ss%3Aflambda-rounds">23.2.1</a>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-unbox-closures-factor</span></span></span></dt><dd class="dd-description"> Scaling factor for benefit
calculation when using <span class="font-tt">-unbox-closures</span>. See
section <a href="#ss%3Aflambda-unbox-closures">23.9.3</a>.
</dd></dl>
<!--TOC paragraph id="sec549" Notes-->
<h5 class="paragraph" id="sec549"><a class="section-anchor" href="#sec549" aria-hidden="true">ï»¿</a>Notes</h5><!--SEC END --><ul class="itemize"><li class="li-itemize">The set of command line flags relating to optimisation should typically
be specified to be the same across an entire project. Flambda does not
currently record the requested flags in the <span class="font-tt">.cmx</span> files. As such,
inlining of functions from previously-compiled units will subject their code
to the optimisation parameters of the unit currently being compiled, rather
than those specified when they were previously compiled. It is hoped to
rectify this deficiency in the future.</li><li class="li-itemize">Flambda-specific flags do not affect linking with the exception of
affecting the optimisation of code in the startup file (containing
generated functions such as currying helpers). Typically such optimisation
will not be significant, so eliding such flags at link time might be
reasonable.</li><li class="li-itemize">Flambda-specific flags are silently accepted even when the
<span class="font-tt">-flambda</span> option was not provided to the <span class="font-tt">configure</span> script.
(There is no means provided to change this behaviour.)
This is intended to make it more
straightforward to run benchmarks with and without the Flambda optimisers
in effect.
</li><li class="li-itemize">Some of the Flambda flags may be subject to change in future
releases.
</li></ul>
<!--TOC subsection id="ss:flambda-rounds" 23.2.1â€ƒSpecification of optimisation parameters by round-->
<h3 class="subsection" id="ss:flambda-rounds"><a class="section-anchor" href="#ss:flambda-rounds" aria-hidden="true">ï»¿</a>23.2.1â€ƒSpecification of optimisation parameters by round</h3><!--SEC END --><p>Flambda operates in <em>rounds</em>: one round consists of a certain sequence
of transformations that may then be repeated in order to achieve more
satisfactory results. The number of rounds can be set manually using the
<span class="font-tt">-rounds</span> parameter (although this is not necessary when using
predefined optimisation levels such as with <span class="font-tt">-O2</span> and <span class="font-tt">-O3</span>).
For high optimisation the number of rounds might be set at 3 or 4.</p><p>Command-line flags that may apply per round, for example those with
<span class="font-tt"><span class="machine"><span class="font-tt">-cost</span></span></span> in the name, accept arguments of the form:
</p><div class="center">
<em>n</em><span class="font-tt"> | </span><em>round</em><span class="font-tt">=</span><em>n</em>[<span class="font-tt">,</span>...]
</div><ul class="itemize"><li class="li-itemize">If the first form is used, with a single integer specified,
the value will apply to all rounds.
</li><li class="li-itemize">If the second form is used, zero-based <em>round</em> integers specify
values which are to be used only for those rounds.
</li></ul><p>The flags <span class="font-tt">-Oclassic</span>, <span class="font-tt">-O2</span> and <span class="font-tt">-O3</span> are applied before all
other flags, meaning that certain parameters may be overridden without
having to specify every parameter usually invoked by the given optimisation
level.</p>
<!--TOC section id="s:flambda-inlining" 23.3â€ƒInlining-->
<h2 class="section" id="s:flambda-inlining"><a class="section-anchor" href="#s:flambda-inlining" aria-hidden="true">ï»¿</a>23.3â€ƒInlining</h2><!--SEC END --><p><em>Inlining</em> refers to the copying of the code of a function to a
place where the function is called.
The code of the function will be surrounded by bindings of its parameters
to the corresponding arguments.</p><p>The aims of inlining are:
</p><ul class="itemize"><li class="li-itemize">to reduce the runtime overhead caused by function calls (including
setting up for such calls and returning afterwards);
</li><li class="li-itemize">to reduce instruction cache misses by expressing frequently-taken
paths through the program using fewer machine instructions; and
</li><li class="li-itemize">to reduce the amount of allocation (especially of closures).
</li></ul><p>
These goals are often reached not just by inlining itself but also by
other optimisations that the compiler is able to perform as a result of
inlining.</p><p>When a recursive call to a function (within the definition of that function
or another in the same mutually-recursive group) is inlined, the procedure is
also known as <em>unrolling</em>. This is somewhat akin to loop peeling.
For example, given the following code:
</p><pre>let rec fact x =
  if x = 0 then
    1
  else
    x * fact (x - 1)

let n = fact 4
</pre><p>unrolling once at the call site <span class="font-tt">fact 4</span> produces (with the body of
<span class="font-tt">fact</span> unchanged):
</p><pre>let n =
  if 4 = 0 then
    1
  else
    4 * fact (4 - 1)
</pre><p>This simplifies to:
</p><pre>let n = 4 * fact 3
</pre><p>Flambda provides significantly enhanced inlining capabilities relative to
previous versions of the compiler.</p>
<!--TOC subsubsection id="sss:flambda-inlining-aside" Aside: when inlining is performed-->
<h4 class="subsubsection" id="sss:flambda-inlining-aside"><a class="section-anchor" href="#sss:flambda-inlining-aside" aria-hidden="true">ï»¿</a>Aside: when inlining is performed</h4><!--SEC END --><p>Inlining is performed together with all of the other Flambda optimisation
passes, that is to say, after closure conversion. This has three particular
advantages over a potentially more straightforward implementation prior to
closure conversion:
</p><ul class="itemize"><li class="li-itemize">It permits higher-order inlining, for example when a non-inlinable
function always returns the same function yet with different environments
of definition. Not all such cases are supported yet, but it is intended
that such support will be improved in future.
</li><li class="li-itemize">It is easier to integrate with cross-module optimisation, since
imported information about other modules is already in the correct
intermediate language.
</li><li class="li-itemize">It becomes more straightforward to optimise closure allocations since
the layout of closures does not have to be estimated in any way: it is
known. Similarly,
it becomes more straightforward to control which variables end up
in which closures, helping to avoid closure bloat.
</li></ul>
<!--TOC subsection id="ss:flambda-classic" 23.3.1â€ƒClassic inlining heuristic-->
<h3 class="subsection" id="ss:flambda-classic"><a class="section-anchor" href="#ss:flambda-classic" aria-hidden="true">ï»¿</a>23.3.1â€ƒClassic inlining heuristic</h3><!--SEC END --><p>In <span class="font-tt">-Oclassic</span> mode the behaviour of the Flambda inliner
mimics previous versions
of the compiler. (Code may still be subject to further optimisations not
performed by previous versions of the compiler: functors may be inlined,
constants are lifted and unused code is eliminated all as described elsewhere
in this chapter. See sections <a href="#sss%3Aflambda-functors">23.3.3</a>, <a href="#ss%3Aflambda-lift-const">23.8.1</a> and <a href="#s%3Aflambda-remove-unused">23.10</a>.
At the definition site of a function, the body of the
function is measured. It will then be marked as eligible for inlining
(and hence inlined at every direct call site) if:
</p><ul class="itemize"><li class="li-itemize">the measured size (in unspecified units) is smaller than that of a
function call plus the argument of the <span class="font-tt">-inline</span> command-line flag; and
</li><li class="li-itemize">the function is not recursive.
</li></ul><p>Non-Flambda versions of the compiler cannot inline functions that
contain a definition of another function. However <span class="font-tt">-Oclassic</span> does
permit this. Further, non-Flambda versions also cannot inline functions
that are only themselves exposed as a result of a previous pass of inlining,
but again this is permitted by <span class="font-tt">-Oclassic</span>.
For example:
</p><pre>module M : sig
  val i : int
end = struct
  let f x =
    let g y = x + y in
    g
  let h = f 3
  let i = h 4  (* h is correctly discovered to be g and inlined *)
end
</pre><p>
All of this contrasts with the normal Flambda mode, that is to say
without <span class="font-tt">-Oclassic</span>, where:
</p><ul class="itemize"><li class="li-itemize">the inlining decision is made at the <span class="font-bold">call site</span>; and
</li><li class="li-itemize">recursive functions can be handled, by <em>specialisation</em> (see
below).
</li></ul><p>
The Flambda mode is described in the next section.</p>
<!--TOC subsection id="ss:flambda-inlining-overview" 23.3.2â€ƒOverview of â€œFlambdaâ€ inlining heuristics-->
<h3 class="subsection" id="ss:flambda-inlining-overview"><a class="section-anchor" href="#ss:flambda-inlining-overview" aria-hidden="true">ï»¿</a>23.3.2â€ƒOverview of â€œFlambdaâ€ inlining heuristics</h3><!--SEC END --><p>The Flambda inlining heuristics, used whenever the compiler is configured
for Flambda and <span class="font-tt">-Oclassic</span> was not specified, make inlining decisions
at call sites. This helps in situations where the context is important.
For example:
</p><pre>let f b x =
  if b then
    x
  else
    ... big expression ...

let g x = f true x
</pre><p>In this case, we would like to inline <span class="font-tt">f</span> into <span class="font-tt">g</span>, because a
conditional jump can be eliminated and the code size should reduce. If the
inlining decision has been made after the declaration of <span class="font-tt">f</span> without
seeing the use, its size would have probably made it ineligible for
inlining; but at the call site, its final size can be known. Further,
this function should probably not be inlined systematically: if <span class="font-tt">b</span>
is unknown, or indeed <span class="font-tt">false</span>, there is little benefit to trade off
against a large increase in code size. In the existing non-Flambda inliner
this isnâ€™t a great problem because chains of inlining were cut off fairly
quickly. However it has led to excessive use of overly-large inlining
parameters such as <span class="font-tt">-inline 10000</span>.</p><p>In more detail, at each call site the following procedure is followed:
</p><ul class="itemize"><li class="li-itemize">Determine whether it is clear that inlining would be beneficial
without, for the moment, doing any inlining within the function itself.
(The exact assessment of <em>benefit</em> is described below.) If so, the
function is inlined.
</li><li class="li-itemize">If inlining the function is not clearly beneficial, then inlining
will be performed <em>speculatively</em> inside the function itself. The
search for speculative inlining possibilities is controlled by two
parameters: the <em>inlining threshold</em> and the <em>inlining depth</em>.
(These are described in more detail below.)
<ul class="itemize"><li class="li-itemize">If such speculation shows that performing some inlining inside the
function would be beneficial, then such inlining is performed and the
resulting function inlined at the original call site.
</li><li class="li-itemize">Otherwise, nothing happens.
</li></ul>
</li></ul><p>
Inlining within recursive functions of calls to other
functions in the same mutually-recursive group is kept in check by
an <em>unrolling depth</em>, described below. This ensures that functions are
not unrolled to excess. (Unrolling is only enabled
if <span class="font-tt">-O3</span> optimisation level is selected and/or the
<span class="font-tt">-inline-max-unroll</span>
flag is passed with an argument greater than zero.)</p>
<!--TOC subsection id="ss:flambda-by-constructs" 23.3.3â€ƒHandling of specific language constructs-->
<h3 class="subsection" id="ss:flambda-by-constructs"><a class="section-anchor" href="#ss:flambda-by-constructs" aria-hidden="true">ï»¿</a>23.3.3â€ƒHandling of specific language constructs</h3><!--SEC END -->
<!--TOC subsubsection id="sss:flambda-functors" Functors-->
<h4 class="subsubsection" id="sss:flambda-functors"><a class="section-anchor" href="#sss:flambda-functors" aria-hidden="true">ï»¿</a>Functors</h4><!--SEC END --><p>There is nothing particular about functors that inhibits inlining compared
to normal functions. To the inliner, these both look the same, except
that functors are marked as such.</p><p>Applications of functors at toplevel are biased in favour of inlining.
(This bias may be adjusted:
see the documentation for <span class="font-tt">-inline-lifting-benefit</span> below.)</p><p>Applications of functors not at toplevel, for example in a local module
inside some other expression, are treated by the inliner identically to
normal function calls.</p>
<!--TOC subsubsection id="sss:flambda-first-class-modules" First-class modules-->
<h4 class="subsubsection" id="sss:flambda-first-class-modules"><a class="section-anchor" href="#sss:flambda-first-class-modules" aria-hidden="true">ï»¿</a>First-class modules</h4><!--SEC END --><p>The inliner will be able to consider inlining a call to a function in a first
class module if it knows which particular function is going to be called.
The presence of the first-class module record that wraps the set of functions
in the module does not per se inhibit inlining.</p>
<!--TOC subsubsection id="sss:flambda-objects" Objects-->
<h4 class="subsubsection" id="sss:flambda-objects"><a class="section-anchor" href="#sss:flambda-objects" aria-hidden="true">ï»¿</a>Objects</h4><!--SEC END --><p>Method calls to objects are not at present inlined by Flambda.</p>
<!--TOC subsection id="ss:flambda-inlining-reports" 23.3.4â€ƒInlining reports-->
<h3 class="subsection" id="ss:flambda-inlining-reports"><a class="section-anchor" href="#ss:flambda-inlining-reports" aria-hidden="true">ï»¿</a>23.3.4â€ƒInlining reports</h3><!--SEC END --><p>If the <span class="font-tt">-inlining-report</span> option is provided to the compiler then a file
will be emitted corresponding to each round of optimisation. For the
OCaml source file <em>basename</em><span class="font-tt">.ml</span> the files
are named <em>basename</em><span class="font-tt">.</span><em>round</em><span class="font-tt">.inlining.org</span>,
with <em>round</em> a
zero-based integer. Inside the files, which are formatted as â€œorg modeâ€,
will be found English prose describing the decisions that the inliner took.</p>
<!--TOC subsection id="ss:flambda-assessment-inlining" 23.3.5â€ƒAssessment of inlining benefit-->
<h3 class="subsection" id="ss:flambda-assessment-inlining"><a class="section-anchor" href="#ss:flambda-assessment-inlining" aria-hidden="true">ï»¿</a>23.3.5â€ƒAssessment of inlining benefit</h3><!--SEC END --><p>Inlining typically
results in an increase in code size, which if left unchecked, may not only
lead to grossly large executables and excessive compilation times but also
a decrease in performance due to worse locality. As such, the
Flambda inliner trades off the change in code size against
the expected runtime performance benefit, with the benefit being computed
based on the number of operations that the compiler observes may be removed
as a result of inlining.</p><p>For example given the following code:
</p><pre>let f b x =
  if b then
    x
  else
    ... big expression ...

let g x = f true x
</pre><p>it would be observed that inlining of <span class="font-tt">f</span> would remove:
</p><ul class="itemize"><li class="li-itemize">one direct call;
</li><li class="li-itemize">one conditional branch.
</li></ul><p>Formally, an estimate of runtime performance benefit is computed by
first summing
the cost of the operations that are known to be removed as a result of the
inlining and subsequent simplification of the inlined body.
The individual costs for the various kinds of operations may be adjusted
using the various <span class="font-tt">-inline-...-cost</span> flags as follows. Costs are
specified as integers. All of these flags accept a single argument
describing such integers using the conventions
detailed in section <a href="#ss%3Aflambda-rounds">23.2.1</a>.
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-alloc-cost</span></span></span></dt><dd class="dd-description"> The cost of an allocation.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-branch-cost</span></span></span></dt><dd class="dd-description"> The cost of a branch.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-call-cost</span></span></span></dt><dd class="dd-description"> The cost of a direct function call.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-indirect-cost</span></span></span></dt><dd class="dd-description"> The cost of an indirect function call.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">-inline-prim-cost</span></span></span></dt><dd class="dd-description"> The cost of a <em>primitive</em>. Primitives
encompass operations including arithmetic and memory access.
</dd></dl><p>
(Default values are described in section <a href="#s%3Aflambda-defaults">23.5</a> below.)</p><p>The initial benefit value is then scaled by a factor that attempts to
compensate for the fact that the current point in the code, if under some
number of conditional branches, may be cold. (Flambda does not currently
compute hot and cold paths.) The factorâ€”the estimated probability that
the inliner really is on a <em>hot</em> pathâ€”is calculated as
1/(1 + <span class="font-it">f</span>)<sup><span class="font-it">d</span></sup>, where <span class="font-it">f</span> is set by
<span class="font-tt">-inline-branch-factor</span> and <span class="font-it">d</span> is the nesting depth of branches
at the current point. As the inliner descends into more deeply-nested
branches, the benefit of inlining thus lessens.</p><p>The resulting benefit value is known as the <em>estimated benefit</em>.</p><p>The change in code size is also estimated: morally speaking it should be the
change in machine code size, but since that is not available to the inliner,
an approximation is used.</p><p>If the estimated benefit exceeds the increase in code size then the inlined
version of the function will be kept. Otherwise the function will not be
inlined.</p><p>Applications of functors at toplevel will be given
an additional benefit (which may be controlled by the
<span class="font-tt">-inline-lifting-benefit</span> flag) to bias inlining in such situations
towards keeping the inlined version.</p>
<!--TOC subsection id="ss:flambda-speculation" 23.3.6â€ƒControl of speculation-->
<h3 class="subsection" id="ss:flambda-speculation"><a class="section-anchor" href="#ss:flambda-speculation" aria-hidden="true">ï»¿</a>23.3.6â€ƒControl of speculation</h3><!--SEC END --><p>As described above, there are three parameters that restrict the search
for inlining opportunities during speculation:
</p><ul class="itemize"><li class="li-itemize">the <em>inlining threshold</em>;
</li><li class="li-itemize">the <em>inlining depth</em>;
</li><li class="li-itemize">the <em>unrolling depth</em>.
</li></ul><p>
These parameters are ultimately bounded by the arguments provided to
the corresponding command-line flags (or their default values):
</p><ul class="itemize"><li class="li-itemize"><span class="font-tt">-inline</span> (or, if the call site that triggered speculation is
at toplevel, <span class="font-tt">-inline-toplevel</span>);
</li><li class="li-itemize"><span class="font-tt">-inline-max-depth</span>;
</li><li class="li-itemize"><span class="font-tt">-inline-max-unroll</span>.
</li></ul><p>
<span class="font-bold">Note in particular</span> that <span class="font-tt">-inline</span> does not have the meaning that
it has in the previous compiler or in <span class="font-tt">-Oclassic</span> mode. In both of those
situations <span class="font-tt">-inline</span> was effectively some kind of basic assessment of
inlining benefit. However in Flambda inlining mode it corresponds to a
constraint on the search; the assessment of benefit is independent, as
described above.</p><p>When speculation starts the inlining threshold starts at the value set
by <span class="font-tt">-inline</span> (or <span class="font-tt">-inline-toplevel</span> if appropriate, see above).
Upon making a speculative inlining decision the
threshold is reduced by the code size of the function being inlined.
If the threshold becomes exhausted, at or below zero, no further speculation
will be performed.</p><p>The inlining depth starts at zero
and is increased by one every time the inliner
descends into another function. It is then decreased by one every time the
inliner leaves such function. If the depth exceeds the value set by
<span class="font-tt">-inline-max-depth</span> then speculation stops. This parameter is intended
as a general backstop for situations where the inlining
threshold does not control the search sufficiently.</p><p>The unrolling depth applies to calls within the same mutually-recursive
group of functions. Each time an inlining of such a call is performed
the depth is incremented by one when examining the resulting body. If the
depth reaches the limit set by <span class="font-tt">-inline-max-unroll</span> then speculation
stops.</p>
<!--TOC section id="s:flambda-specialisation" 23.4â€ƒSpecialisation-->
<h2 class="section" id="s:flambda-specialisation"><a class="section-anchor" href="#s:flambda-specialisation" aria-hidden="true">ï»¿</a>23.4â€ƒSpecialisation</h2><!--SEC END --><p>The inliner may discover a call site to a recursive function where
something is known about the arguments: for example, they may be equal to
some other variables currently in scope. In this situation it may be
beneficial to <em>specialise</em> the function to those arguments. This is
done by copying the declaration of the function (and any others involved
in any same mutually-recursive declaration) and noting the extra information
about the arguments. The arguments augmented by this information are known
as <em>specialised arguments</em>. In order to try to ensure that specialisation
is not performed uselessly, arguments are only specialised if it can be shown
that they are <em>invariant</em>: in other words, during the execution of the
recursive function(s) themselves, the arguments never change.</p><p>Unless overridden by an attribute (see below), specialisation of a function
will not be attempted if:
</p><ul class="itemize"><li class="li-itemize">the compiler is in <span class="font-tt">-Oclassic</span> mode;
</li><li class="li-itemize">the function is not obviously recursive;
</li><li class="li-itemize">the function is not closed.
</li></ul><p>The compiler can prove invariance of function arguments across multiple
functions within a recursive group (although this has some limitations,
as shown by the example below).</p><p>It should be noted that the <em>unboxing of closures</em> pass (see below)
can introduce specialised arguments on non-recursive functions. (No other
place in the compiler currently does this.)</p>
<!--TOC paragraph id="sec563" Example: the well-known <span class="font-tt">List.iter</span> function-->
<h5 class="paragraph" id="sec563"><a class="section-anchor" href="#sec563" aria-hidden="true">ï»¿</a>Example: the well-known <span class="font-tt">List.iter</span> function</h5><!--SEC END --><p>
This function might be written like so:
</p><pre>let rec iter f l =
  match l with
  | [] -&gt; ()
  | h :: t -&gt;
    f h;
    iter f t
</pre><p>and used like this:
</p><pre>let print_int x =
  print_endline (Int.to_string x)

let run xs =
  iter print_int (List.rev xs)
</pre><p>The argument <span class="font-tt">f</span> to <span class="font-tt">iter</span> is invariant so the function may be
specialised:
</p><pre>let run xs =
  let rec iter' f l =
    (* The compiler knows: f holds the same value as foo throughout iter'. *)
    match l with
    | [] -&gt; ()
    | h :: t -&gt;
      f h;
      iter' f t
  in
  iter' print_int (List.rev xs)
</pre><p>The compiler notes down that for the function <span class="font-tt">iterâ€™</span>, the argument
<span class="font-tt">f</span> is specialised to the constant closure <span class="font-tt">print_int</span>. This
means that the body of <span class="font-tt">iterâ€™</span> may be simplified:
</p><pre>let run xs =
  let rec iter' f l =
    (* The compiler knows: f holds the same value as foo throughout iter'. *)
    match l with
    | [] -&gt; ()
    | h :: t -&gt;
      print_int h;  (* this is now a direct call *)
      iter' f t
  in
  iter' print_int (List.rev xs)
</pre><p>The call to <span class="font-tt">print_int</span> can indeed be inlined:
</p><pre>let run xs =
  let rec iter' f l =
    (* The compiler knows: f holds the same value as foo throughout iter'. *)
    match l with
    | [] -&gt; ()
    | h :: t -&gt;
      print_endline (Int.to_string h);
      iter' f t
  in
  iter' print_int (List.rev xs)
</pre><p>The unused specialised argument <span class="font-tt">f</span> may now be removed, leaving:
</p><pre>let run xs =
  let rec iter' l =
    match l with
    | [] -&gt; ()
    | h :: t -&gt;
      print_endline (Int.to_string h);
      iter' t
  in
  iter' (List.rev xs)
</pre>
<!--TOC paragraph id="sec564" Aside on invariant parameters.-->
<h5 class="paragraph" id="sec564"><a class="section-anchor" href="#sec564" aria-hidden="true">ï»¿</a>Aside on invariant parameters.</h5><!--SEC END --><p> The compiler cannot currently
detect invariance in cases such as the following.
</p><pre>let rec iter_swap f g l =
  match l with
  | [] -&gt; ()
  | 0 :: t -&gt;
    iter_swap g f l
  | h :: t -&gt;
    f h;
    iter_swap f g t
</pre>
<!--TOC subsection id="ss:flambda-assessment-specialisation" 23.4.1â€ƒAssessment of specialisation benefit-->
<h3 class="subsection" id="ss:flambda-assessment-specialisation"><a class="section-anchor" href="#ss:flambda-assessment-specialisation" aria-hidden="true">ï»¿</a>23.4.1â€ƒAssessment of specialisation benefit</h3><!--SEC END --><p>The benefit of specialisation is assessed in a similar way as for inlining.
Specialised argument information may mean that the body of the function
being specialised can be simplified: the removed operations are accumulated
into a benefit. This, together with the size of the duplicated (specialised)
function declaration, is then assessed against the size of the call to the
original function.</p>
<!--TOC section id="s:flambda-defaults" 23.5â€ƒDefault settings of parameters-->
<h2 class="section" id="s:flambda-defaults"><a class="section-anchor" href="#s:flambda-defaults" aria-hidden="true">ï»¿</a>23.5â€ƒDefault settings of parameters</h2><!--SEC END --><p>The default settings (when not using <span class="font-tt">-Oclassic</span>) are for one
round of optimisation using the following parameters.
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Parameter</span></td><td class="c004"><span class="font-bold">Setting</span> </td></tr>
<tr><td class="c006">
<span class="font-tt">-inline</span></td><td class="c006">10 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-factor</span></td><td class="c006">0.1 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-alloc-cost</span></td><td class="c006">7 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-cost</span></td><td class="c006">5 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-call-cost</span></td><td class="c006">5 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-indirect-cost</span></td><td class="c006">4 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-prim-cost</span></td><td class="c006">3 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-lifting-benefit</span></td><td class="c006">1300 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-toplevel</span></td><td class="c006">160 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-depth</span></td><td class="c006">1 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-unroll</span></td><td class="c006">0 </td></tr>
<tr><td class="c006"><span class="font-tt">-unbox-closures-factor</span></td><td class="c006">10 </td></tr>
</table></div></div>
<!--TOC subsection id="ss:flambda-o2" 23.5.1â€ƒSettings at -O2 optimisation level-->
<h3 class="subsection" id="ss:flambda-o2"><a class="section-anchor" href="#ss:flambda-o2" aria-hidden="true">ï»¿</a>23.5.1â€ƒSettings at -O2 optimisation level</h3><!--SEC END --><p>When <span class="font-tt">-O2</span> is specified two rounds of optimisation are performed.
The first round uses the default parameters (see above). The second uses
the following parameters.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Parameter</span></td><td class="c004"><span class="font-bold">Setting</span> </td></tr>
<tr><td class="c006">
<span class="font-tt">-inline</span></td><td class="c006">25 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-factor</span></td><td class="c006">Same as default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-alloc-cost</span></td><td class="c006">Double the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-cost</span></td><td class="c006">Double the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-call-cost</span></td><td class="c006">Double the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-indirect-cost</span></td><td class="c006">Double the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-prim-cost</span></td><td class="c006">Double the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-lifting-benefit</span></td><td class="c006">Same as default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-toplevel</span></td><td class="c006">400 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-depth</span></td><td class="c006">2 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-unroll</span></td><td class="c006">Same as default </td></tr>
<tr><td class="c006"><span class="font-tt">-unbox-closures-factor</span></td><td class="c006">Same as default </td></tr>
</table></div></div>
<!--TOC subsection id="ss:flambda-o3" 23.5.2â€ƒSettings at -O3 optimisation level-->
<h3 class="subsection" id="ss:flambda-o3"><a class="section-anchor" href="#ss:flambda-o3" aria-hidden="true">ï»¿</a>23.5.2â€ƒSettings at -O3 optimisation level</h3><!--SEC END --><p>When <span class="font-tt">-O3</span> is specified three rounds of optimisation are performed.
The first two rounds are as for <span class="font-tt">-O2</span>. The third round uses
the following parameters.</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Parameter</span></td><td class="c004"><span class="font-bold">Setting</span> </td></tr>
<tr><td class="c006">
<span class="font-tt">-inline</span></td><td class="c006">50 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-factor</span></td><td class="c006">Same as default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-alloc-cost</span></td><td class="c006">Triple the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-branch-cost</span></td><td class="c006">Triple the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-call-cost</span></td><td class="c006">Triple the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-indirect-cost</span></td><td class="c006">Triple the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-prim-cost</span></td><td class="c006">Triple the default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-lifting-benefit</span></td><td class="c006">Same as default </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-toplevel</span></td><td class="c006">800 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-depth</span></td><td class="c006">3 </td></tr>
<tr><td class="c006"><span class="font-tt">-inline-max-unroll</span></td><td class="c006">1 </td></tr>
<tr><td class="c006"><span class="font-tt">-unbox-closures-factor</span></td><td class="c006">Same as default </td></tr>
</table></div></div>
<!--TOC section id="s:flambda-manual-control" 23.6â€ƒManual control of inlining and specialisation-->
<h2 class="section" id="s:flambda-manual-control"><a class="section-anchor" href="#s:flambda-manual-control" aria-hidden="true">ï»¿</a>23.6â€ƒManual control of inlining and specialisation</h2><!--SEC END --><p>Should the inliner prove recalcitrant and refuse to inline a particular
function, or if the observed inlining decisions are not to the programmerâ€™s
satisfaction for some other reason, inlining behaviour can be dictated by the
programmer directly in the source code.
One example where this might be appropriate is when the programmer,
but not the compiler, knows that a particular function call is on a cold
code path. It might be desirable to prevent inlining of the function so
that the code size along the hot path is kept smaller, so as to increase
locality.</p><p>The inliner is directed using attributes.
For non-recursive functions (and one-step unrolling of recursive functions,
although <span class="font-tt">@unroll</span> is more clear for this purpose)
the following are supported:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@@inline always</span></span> or <span class="machine"><span class="font-tt">@@inline never</span></span></span></dt><dd class="dd-description"> Attached
to a <em>declaration</em> of a function or functor, these direct the inliner to
either
always or never inline, irrespective of the size/benefit calculation. (If
the function is recursive then the body is substituted and no special
action is taken for the recursive call site(s).)
<span class="machine"><span class="font-tt">@@inline</span></span> with no argument is equivalent to
<span class="machine"><span class="font-tt">@@inline always</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@inlined always</span></span> or <span class="machine"><span class="font-tt">@inlined never</span></span></span></dt><dd class="dd-description"> Attached
to a function <em>application</em>, these direct the inliner likewise. These
attributes at call sites override any other attribute that may be present
on the corresponding declaration.
<span class="machine"><span class="font-tt">@inlined</span></span> with no argument is equivalent to
<span class="machine"><span class="font-tt">@inlined always</span></span>. <span class="machine"><span class="font-tt">@@inlined hint</span></span> is equivalent to
<span class="machine"><span class="font-tt">@@inline always</span></span> except that it will not trigger warning 55 if
the function application cannot be inlined.
</dd></dl><p>For recursive functions the relevant attributes are:
</p><dl class="description"><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@@specialise always</span></span> or <span class="machine"><span class="font-tt">@@specialise never</span></span></span></dt><dd class="dd-description">Attached to a declaration of a function
or functor, this directs the inliner to either always or never
specialise the function so
long as it has appropriate contextual knowledge, irrespective of the
size/benefit calculation.
<span class="machine"><span class="font-tt">@@specialise</span></span> with no argument is equivalent to
<span class="machine"><span class="font-tt">@@specialise always</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@specialised always</span></span> or <span class="machine"><span class="font-tt">@specialised never</span></span></span></dt><dd class="dd-description">Attached to a function application, this
directs the inliner likewise. This attribute at a call site overrides any
other attribute that may be present on the corresponding declaration.
(Note that the function will still only be specialised if there exist
one or more invariant parameters whose values are known.)
<span class="machine"><span class="font-tt">@specialised</span></span> with no argument is equivalent to
<span class="machine"><span class="font-tt">@specialised always</span></span>.
</dd><dt class="dt-description"><span class="font-bold"><span class="machine"><span class="font-tt">@unrolled </span></span></span><span class="font-it">n</span></dt><dd class="dd-description"> This attribute is attached to a function
application and always takes an integer argument. Each time the inliner sees
the attribute it behaves as follows:
<ul class="itemize"><li class="li-itemize">If <span class="font-it">n</span> is zero or less, nothing happens.
</li><li class="li-itemize">Otherwise the function being called is substituted at the call site
with its body having been rewritten such that 
any recursive calls to that function <em>or
any others in the same mutually-recursive group</em> are annotated with the
attribute <span class="font-tt">unrolled(</span><span class="font-it">n</span> âˆ’ 1<span class="font-tt">)</span>. Inlining may continue on that body.
</li></ul>
As such, <span class="font-it">n</span> behaves as the â€œmaximum depth of unrollingâ€.
</dd></dl><p>A compiler warning will be emitted if it was found impossible to obey an
annotation from an <span class="font-tt">@inlined</span> or <span class="font-tt">@specialised</span> attribute.</p>
<!--TOC paragraph id="sec570" Example showing correct placement of attributes-->
<h5 class="paragraph" id="sec570"><a class="section-anchor" href="#sec570" aria-hidden="true">ï»¿</a>Example showing correct placement of attributes</h5><!--SEC END --><pre>module F (M : sig type t end) = struct
  let[@inline never] bar x =
    x * 3

  let foo x =
    (bar [@inlined]) (42 + x)
end [@@inline never]

module X = F [@inlined] (struct type t = int end)
</pre>
<!--TOC section id="s:flambda-simplification" 23.7â€ƒSimplification-->
<h2 class="section" id="s:flambda-simplification"><a class="section-anchor" href="#s:flambda-simplification" aria-hidden="true">ï»¿</a>23.7â€ƒSimplification</h2><!--SEC END --><p>Simplification, which is run in conjunction with inlining,
propagates information (known as <em>approximations</em>) about which
variables hold what values at runtime. Certain relationships between
variables and symbols are also tracked: for example, some variable may be
known to always hold the same value as some other variable; or perhaps
some variable may be known to always hold the value pointed to by some
symbol.</p><p>The propagation can help to eliminate allocations in cases such as:
</p><pre>let f x y =
  ...
  let p = x, y in
  ...
  ... (fst p) ... (snd p) ...
</pre><p>The projections from <span class="font-tt">p</span> may be replaced by uses of the variables
<span class="font-tt">x</span> and <span class="font-tt">y</span>, potentially meaning that <span class="font-tt">p</span> becomes unused.</p><p>The propagation performed by the simplification pass is also important for
discovering which functions flow to indirect call sites. This can enable
the transformation of such call sites into direct call sites, which makes
them eligible for an inlining transformation.</p><p>Note that no information is propagated about the contents of strings,
even in <span class="font-tt">safe-string</span> mode, because it cannot yet be guaranteed
that they are immutable throughout a given program.</p>
<!--TOC section id="s:flambda-other-transfs" 23.8â€ƒOther code motion transformations-->
<h2 class="section" id="s:flambda-other-transfs"><a class="section-anchor" href="#s:flambda-other-transfs" aria-hidden="true">ï»¿</a>23.8â€ƒOther code motion transformations</h2><!--SEC END -->
<!--TOC subsection id="ss:flambda-lift-const" 23.8.1â€ƒLifting of constants-->
<h3 class="subsection" id="ss:flambda-lift-const"><a class="section-anchor" href="#ss:flambda-lift-const" aria-hidden="true">ï»¿</a>23.8.1â€ƒLifting of constants</h3><!--SEC END --><p>Expressions found to be constant will be lifted to symbol
bindingsâ€”that is to say, they will be statically allocated in the
object fileâ€”when
they evaluate to boxed values. Such constants may be straightforward numeric
constants, such as the floating-point number <span class="font-tt">42.0</span>, or more complicated
values such as constant closures.</p><p>Lifting of constants to toplevel reduces allocation at runtime.</p><p>The compiler aims to share constants lifted to toplevel such that there
are no duplicate definitions. However if <span class="font-tt">.cmx</span> files are hidden
from the compiler then maximal sharing may not be possible.</p>
<!--TOC paragraph id="sec574" Notes about float arrays-->
<h5 class="paragraph" id="sec574"><a class="section-anchor" href="#sec574" aria-hidden="true">ï»¿</a>Notes about float arrays</h5><!--SEC END --><p> The following language semantics apply specifically to constant float arrays.
(By â€œconstant float arrayâ€ is meant an array consisting entirely of floating
point numbers that are known at compile time. A common case is a literal
such as <span class="font-tt">[| 42.0; 43.0; |]</span>.
</p><ul class="itemize"><li class="li-itemize">Constant float arrays at the toplevel are mutable and never shared.
(That is to say, for each
such definition there is a distinct symbol in the data section of the object
file pointing at the array.)
</li><li class="li-itemize">Constant float arrays not at toplevel are mutable and are created each
time the expression is evaluated. This can be thought of as an operation that
takes an immutable array (which in the source code has no associated name; let
us call it the <em>initialising array</em>) and
duplicates it into a fresh mutable array.
<ul class="itemize"><li class="li-itemize">If the array is of size four or less, the expression will create a
fresh block and write the values into it one by one. There is no reference
to the initialising array as a whole.</li><li class="li-itemize">Otherwise, the initialising array is lifted out and subject to the
normal constant sharing procedure;
creation of the array consists of bulk copying the initialising array
into a fresh value on the OCaml heap.
</li></ul>
</li></ul>
<!--TOC subsection id="ss:flambda-lift-toplevel-let" 23.8.2â€ƒLifting of toplevel let bindings-->
<h3 class="subsection" id="ss:flambda-lift-toplevel-let"><a class="section-anchor" href="#ss:flambda-lift-toplevel-let" aria-hidden="true">ï»¿</a>23.8.2â€ƒLifting of toplevel let bindings</h3><!--SEC END --><p>Toplevel <span class="font-tt">let</span>-expressions may be lifted to symbol bindings to ensure
that the corresponding bound variables are not captured by closures. If the
defining expression of a given binding is found to be constant, it is bound
as such (the technical term is a <em>let-symbol</em> binding).</p><p>Otherwise, the symbol is bound to a (statically-allocated)
<em>preallocated block</em> containing one field. At runtime, the defining
expression will be evaluated and the first field of the block filled with
the resulting value. This <em>initialise-symbol</em> binding
causes one extra indirection but ensures, by
virtue of the symbolâ€™s address being known at compile time, that uses of the
value are not captured by closures.</p><p>It should be noted that the blocks corresponding to initialise-symbol
bindings are kept alive forever, by virtue of them occurring in a static
table of GC roots within the object file. This extended lifetime of
expressions may on occasion be surprising. If it is desired to create
some non-constant value (for example when writing GC tests) that does not
have this
extended lifetime, then it may be created and used inside a function,
with the application point of that function (perhaps at toplevel)â€”or
indeed the function declaration itselfâ€”marked
as to never be inlined. This technique prevents lifting of the definition
of the value in question (assuming of course that it is not constant).</p>
<!--TOC section id="s:flambda-unboxing" 23.9â€ƒUnboxing transformations-->
<h2 class="section" id="s:flambda-unboxing"><a class="section-anchor" href="#s:flambda-unboxing" aria-hidden="true">ï»¿</a>23.9â€ƒUnboxing transformations</h2><!--SEC END --><p>The transformations in this section relate to the splitting apart of
<em>boxed</em> (that is to say, non-immediate) values. They are largely
intended to reduce allocation, which tends to result in a runtime
performance profile with lower variance and smaller tails.</p>
<!--TOC subsection id="ss:flambda-unbox-fvs" 23.9.1â€ƒUnboxing of closure variables-->
<h3 class="subsection" id="ss:flambda-unbox-fvs"><a class="section-anchor" href="#ss:flambda-unbox-fvs" aria-hidden="true">ï»¿</a>23.9.1â€ƒUnboxing of closure variables</h3><!--SEC END --><p>This transformation is enabled unless
<span class="font-tt">-no-unbox-free-vars-of-closures</span> is provided.</p><p>Variables that appear in closure environments may themselves be boxed
values. As such, they may be split into further closure variables, each
of which corresponds to some projection from the original closure variable(s).
This transformation is called <em>unboxing of closure variables</em> or
<em>unboxing of free variables of closures</em>. It is only applied when
there is
reasonable certainty that there are no uses of the boxed free variable itself
within the corresponding function bodies.
</p>
<!--TOC paragraph id="sec578" Example:-->
<h5 class="paragraph" id="sec578"><a class="section-anchor" href="#sec578" aria-hidden="true">ï»¿</a>Example:</h5><!--SEC END --><p> In the following code, the compiler observes that
the closure returned from the function <span class="font-tt">f</span> contains a variable <span class="font-tt">pair</span>
(free in the body of <span class="font-tt">f</span>) that may be split into two separate variables.
</p><pre>let f x0 x1 =
  let pair = x0, x1 in
  Printf.printf "foo\n";
  fun y -&gt;
    fst pair + snd pair + y
</pre><p>After some simplification one obtains:
</p><pre>let f x0 x1 =
  let pair_0 = x0 in
  let pair_1 = x1 in
  Printf.printf "foo\n";
  fun y -&gt;
    pair_0 + pair_1 + y
</pre><p>and then:
</p><pre>let f x0 x1 =
  Printf.printf "foo\n";
  fun y -&gt;
    x0 + x1 + y
</pre><p>The allocation of the pair has been eliminated.</p><p>This transformation does not operate if it would cause the closure to
contain more than twice as many closure variables as it did beforehand.</p>
<!--TOC subsection id="ss:flambda-unbox-spec-args" 23.9.2â€ƒUnboxing of specialised arguments-->
<h3 class="subsection" id="ss:flambda-unbox-spec-args"><a class="section-anchor" href="#ss:flambda-unbox-spec-args" aria-hidden="true">ï»¿</a>23.9.2â€ƒUnboxing of specialised arguments</h3><!--SEC END --><p>This transformation is enabled unless
<span class="font-tt">-no-unbox-specialised-args</span> is provided.</p><p>It may become the case during compilation that one or more invariant arguments
to a function become specialised to a particular value. When such values are
themselves boxed the corresponding specialised arguments may be split into
more specialised arguments corresponding to the projections out of the boxed
value that occur within the function body. This transformation is called
<em>unboxing of specialised arguments</em>. It is only applied when there is
reasonable certainty that the boxed argument itself is unused within the
function.</p><p>If the function in question is involved in a recursive group then unboxing
of specialised arguments may be immediately replicated across the group
based on the dataflow between invariant arguments.</p>
<!--TOC paragraph id="sec580" Example:-->
<h5 class="paragraph" id="sec580"><a class="section-anchor" href="#sec580" aria-hidden="true">ï»¿</a>Example:</h5><!--SEC END --><p> Having been given the following code, the compiler
will inline <span class="font-tt">loop</span> into <span class="font-tt">f</span>, and then observe <span class="font-tt">inv</span>
being invariant and always the pair formed by adding <span class="font-tt">42</span> and <span class="font-tt">43</span>
to the argument <span class="font-tt">x</span> of the function <span class="font-tt">f</span>.
</p><pre>let rec loop inv xs =
  match xs with
  | [] -&gt; fst inv + snd inv
  | x::xs -&gt; x + loop2 xs inv
and loop2 ys inv =
  match ys with
  | [] -&gt; 4
  | y::ys -&gt; y - loop inv ys

let f x =
  Printf.printf "%d\n" (loop (x + 42, x + 43) [1; 2; 3])
</pre><p>Since the functions have sufficiently few arguments, more specialised
arguments will be added. After some simplification one obtains:
</p><pre>let f x =
  let rec loop' xs inv_0 inv_1 =
    match xs with
    | [] -&gt; inv_0 + inv_1
    | x::xs -&gt; x + loop2' xs inv_0 inv_1
  and loop2' ys inv_0 inv_1 =
    match ys with
    | [] -&gt; 4
    | y::ys -&gt; y - loop' ys inv_0 inv_1
  in
  Printf.printf "%d\n" (loop' [1; 2; 3] (x + 42) (x + 43))
</pre><p>The allocation of the pair within <span class="font-tt">f</span> has been removed. (Since the
two closures for <span class="font-tt">loopâ€™</span> and <span class="font-tt">loop2â€™</span> are constant they will also be
lifted to toplevel with no runtime allocation penalty. This
would also happen without having run the transformation to unbox
specialise arguments.)</p><p>The transformation to unbox specialised arguments never introduces extra
allocation.</p><p>The transformation will not unbox arguments if it would result in the
original function having sufficiently many arguments so as to inhibit
tail-call optimisation.</p><p>The transformation is implemented by creating a wrapper function that
accepts the original arguments. Meanwhile, the original function is renamed
and extra arguments are added corresponding to the unboxed specialised
arguments; this new function
is called from the wrapper. The wrapper will then be inlined
at direct call sites. Indeed, all call sites will be direct unless
<span class="font-tt">-unbox-closures</span> is being used, since they will have been generated
by the compiler when originally specialising the function. (In the case
of <span class="font-tt">-unbox-closures</span> other functions may appear with specialised
arguments; in this case there may be indirect calls and these will incur
a small penalty owing to having to bounce through the wrapper. The technique
of <em>direct call surrogates</em> used for <span class="font-tt">-unbox-closures</span> is not
used by the transformation to unbox specialised arguments.)</p>
<!--TOC subsection id="ss:flambda-unbox-closures" 23.9.3â€ƒUnboxing of closures-->
<h3 class="subsection" id="ss:flambda-unbox-closures"><a class="section-anchor" href="#ss:flambda-unbox-closures" aria-hidden="true">ï»¿</a>23.9.3â€ƒUnboxing of closures</h3><!--SEC END --><p>This transformation is <em>not</em> enabled by default. It may be enabled
using the <span class="font-tt">-unbox-closures</span> flag.</p><p>The transformation replaces closure variables by specialised arguments.
The aim is to cause more closures to become closed. It is particularly
applicable, as a means of reducing allocation, where the function concerned
cannot be inlined or specialised. For example, some non-recursive function
might be too large to inline; or some recursive function might offer
no opportunities for specialisation perhaps because its only argument is
one of type <span class="font-tt">unit</span>.</p><p>At present there may be a small penalty in terms of actual runtime
performance when this transformation is enabled, although more stable
performance may be obtained due to reduced allocation. It is recommended
that developers experiment to determine whether the option is beneficial
for their code. (It is expected that in the future it will be possible
for the performance degradation to be removed.)</p>
<!--TOC paragraph id="sec582" Simple example:-->
<h5 class="paragraph" id="sec582"><a class="section-anchor" href="#sec582" aria-hidden="true">ï»¿</a>Simple example:</h5><!--SEC END --><p> In the following code (which might typically
occur when <span class="font-tt">g</span> is too large to inline) the value of <span class="font-tt">x</span> would usually
be communicated to the application of the <span class="font-tt">+</span> function via the closure
of <span class="font-tt">g</span>.
</p><pre>let f x =
  let g y =
    x + y
  in
  (g [@inlined never]) 42
</pre><p>Unboxing of the closure causes the value for <span class="font-tt">x</span> inside <span class="font-tt">g</span> to
be passed as an argument to <span class="font-tt">g</span> rather than through its closure. This
means that the closure of <span class="font-tt">g</span> becomes constant and may be lifted to
toplevel, eliminating the runtime allocation.</p><p>The transformation is implemented by adding a new wrapper function in the
manner of that used when unboxing specialised arguments. The closure
variables are still free in the wrapper, but the intention is that when
the wrapper is inlined at direct call sites, the relevant values are
passed directly to the main function via the new specialised arguments.</p><p>Adding such a wrapper will penalise indirect calls to the function
(which might exist in arbitrary places; remember that this transformation
is not for example applied only on functions the compiler has produced
as a result of specialisation) since such calls will bounce through
the wrapper. To
mitigate this, if a function is small enough when weighed up against
the number of free variables being removed, it will be duplicated by the
transformation to obtain two versions: the original (used for indirect calls,
since we can do no better) and the wrapper/rewritten function pair as
described in the previous paragraph. The wrapper/rewritten function pair
will only be used at direct call sites of the function. (The wrapper in
this case is known as a <em>direct call surrogate</em>, since
it takes the place of another functionâ€”the unchanged version used for
indirect callsâ€”at direct call sites.)</p><p>The <span class="font-tt">-unbox-closures-factor</span> command line flag, which takes an
integer, may be used to adjust the point at which a function is deemed
large enough to be ineligible for duplication. The benefit of
duplication is scaled by the integer before being evaluated against the
size.</p>
<!--TOC paragraph id="sec583" Harder example:-->
<h5 class="paragraph" id="sec583"><a class="section-anchor" href="#sec583" aria-hidden="true">ï»¿</a>Harder example:</h5><!--SEC END --><p> In the following code, there are two closure
variables that would typically cause closure allocations. One is called
<span class="font-tt">fv</span> and occurs inside the function <span class="font-tt">baz</span>; the other is called
<span class="font-tt">z</span> and occurs inside the function <span class="font-tt">bar</span>.
In this toy (yet sophisticated) example we again use an attribute to
simulate the typical situation where the first argument of <span class="font-tt">baz</span> is
too large to inline.
</p><pre>let foo c =
  let rec bar zs fv =
    match zs with
    | [] -&gt; []
    | z::zs -&gt;
      let rec baz f = function
        | [] -&gt; []
        | a::l -&gt; let r = fv + ((f [@inlined never]) a) in r :: baz f l
      in
      (map2 (fun y -&gt; z + y) [z; 2; 3; 4]) @ bar zs fv
  in
  Printf.printf "%d" (List.length (bar [1; 2; 3; 4] c))
</pre><p>The code resulting from applying <span class="font-tt">-O3 -unbox-closures</span> to this code
passes the free variables via function arguments in
order to eliminate all closure allocation in this example (aside from any
that might be performed inside <span class="font-tt">printf</span>).</p>
<!--TOC section id="s:flambda-remove-unused" 23.10â€ƒRemoval of unused code and values-->
<h2 class="section" id="s:flambda-remove-unused"><a class="section-anchor" href="#s:flambda-remove-unused" aria-hidden="true">ï»¿</a>23.10â€ƒRemoval of unused code and values</h2><!--SEC END -->
<!--TOC subsection id="ss:flambda-redundant-let" 23.10.1â€ƒRemoval of redundant let expressions-->
<h3 class="subsection" id="ss:flambda-redundant-let"><a class="section-anchor" href="#ss:flambda-redundant-let" aria-hidden="true">ï»¿</a>23.10.1â€ƒRemoval of redundant let expressions</h3><!--SEC END --><p>The simplification pass removes unused <span class="font-tt">let</span> bindings so long as
their corresponding defining expressions have â€œno effectsâ€. See
the section â€œTreatment of effectsâ€ below for the precise definition of
this term.</p>
<!--TOC subsection id="ss:flambda-redundant" 23.10.2â€ƒRemoval of redundant program constructs-->
<h3 class="subsection" id="ss:flambda-redundant"><a class="section-anchor" href="#ss:flambda-redundant" aria-hidden="true">ï»¿</a>23.10.2â€ƒRemoval of redundant program constructs</h3><!--SEC END --><p>This transformation is analogous to the removal of <span class="font-tt">let</span>-expressions
whose defining expressions have no effects. It operates instead on symbol
bindings, removing those that have no effects.</p>
<!--TOC subsection id="ss:flambda-remove-unused-args" 23.10.3â€ƒRemoval of unused arguments-->
<h3 class="subsection" id="ss:flambda-remove-unused-args"><a class="section-anchor" href="#ss:flambda-remove-unused-args" aria-hidden="true">ï»¿</a>23.10.3â€ƒRemoval of unused arguments</h3><!--SEC END --><p>This transformation is only enabled by default for specialised arguments.
It may be enabled for all arguments using the <span class="font-tt">-remove-unused-arguments</span>
flag.</p><p>The pass analyses functions to determine which arguments are unused.
Removal is effected by creating a wrapper function, which will be inlined
at every direct call site, that accepts the original arguments and then
discards the unused ones before calling the original function. As a
consequence, this transformation may be detrimental if the original
function is usually indirectly called, since such calls will now bounce
through the wrapper. (The technique of <em>direct call surrogates</em> used
to reduce this penalty during unboxing of closure variables (see above)
does not yet apply to the pass that removes unused arguments.)</p>
<!--TOC subsection id="ss:flambda-removal-closure-vars" 23.10.4â€ƒRemoval of unused closure variables-->
<h3 class="subsection" id="ss:flambda-removal-closure-vars"><a class="section-anchor" href="#ss:flambda-removal-closure-vars" aria-hidden="true">ï»¿</a>23.10.4â€ƒRemoval of unused closure variables</h3><!--SEC END --><p>This transformation performs an analysis across
the whole compilation unit to determine whether there exist closure variables
that are never used. Such closure variables are then eliminated. (Note that
this has to be a whole-unit analysis because a projection of a closure
variable from some particular closure may have propagated to an arbitrary
location within the code due to inlining.)</p>
<!--TOC section id="s:flambda-other" 23.11â€ƒOther code transformations-->
<h2 class="section" id="s:flambda-other"><a class="section-anchor" href="#s:flambda-other" aria-hidden="true">ï»¿</a>23.11â€ƒOther code transformations</h2><!--SEC END -->
<!--TOC subsection id="ss:flambda-non-escaping-refs" 23.11.1â€ƒTransformation of non-escaping references into mutable variables-->
<h3 class="subsection" id="ss:flambda-non-escaping-refs"><a class="section-anchor" href="#ss:flambda-non-escaping-refs" aria-hidden="true">ï»¿</a>23.11.1â€ƒTransformation of non-escaping references into mutable variables</h3><!--SEC END --><p>Flambda performs a simple analysis analogous to that performed elsewhere
in the compiler that can transform <span class="font-tt">ref</span>s into mutable variables
that may then be held in registers (or on the stack as appropriate) rather
than being allocated on the OCaml heap. This only happens so long as the
reference concerned can be shown to not escape from its defining scope.</p>
<!--TOC subsection id="ss:flambda-subst-closure-vars" 23.11.2â€ƒSubstitution of closure variables for specialised arguments-->
<h3 class="subsection" id="ss:flambda-subst-closure-vars"><a class="section-anchor" href="#ss:flambda-subst-closure-vars" aria-hidden="true">ï»¿</a>23.11.2â€ƒSubstitution of closure variables for specialised arguments</h3><!--SEC END --><p>This transformation discovers closure variables that are known to be
equal to specialised arguments. Such closure variables are replaced by
the specialised arguments; the closure variables may then be removed by
the â€œremoval of unused closure variablesâ€ pass (see below).</p>
<!--TOC section id="s:flambda-effects" 23.12â€ƒTreatment of effects-->
<h2 class="section" id="s:flambda-effects"><a class="section-anchor" href="#s:flambda-effects" aria-hidden="true">ï»¿</a>23.12â€ƒTreatment of effects</h2><!--SEC END --><p>The Flambda optimisers classify expressions in order to determine whether
an expression:
</p><ul class="itemize"><li class="li-itemize">does not need to be evaluated at all; and/or
</li><li class="li-itemize">may be duplicated.
</li></ul><p>This is done by forming judgements on the <em>effects</em> and the <em>coeffects</em>
that might be performed were the expression to be executed. Effects talk
about how the expression might affect the world; coeffects talk about how
the world might affect the expression.</p><p>Effects are classified as follows:
</p><dl class="description"><dt class="dt-description"><span class="font-bold">No effects:</span></dt><dd class="dd-description"> The expression does not change the observable state
of the world. For example, it must not write to any mutable storage,
call arbitrary external functions or change control flow (e.g. by raising
an exception). Note that allocation is <em>not</em> classed as having
â€œno effectsâ€ (see below).
<ul class="itemize"><li class="li-itemize">It is assumed in the compiler that expressions with no
effects, whose results are not used, may be eliminated. (This typically
happens where the expression in question is the defining expression of a
<span class="font-tt">let</span>; in such cases the <span class="font-tt">let</span>-expression will be
eliminated.) It is further
assumed that such expressions with no effects may be
duplicated (and thus possibly executed more than once).
</li><li class="li-itemize">Exceptions arising from allocation points, for example
â€œout of memoryâ€ or
exceptions propagated from finalizers or signal handlers, are treated as
â€œeffects out of the etherâ€ and thus ignored for our determination here
of effectfulness. The same goes for floating point operations that may
cause hardware traps on some platforms.
</li></ul>
</dd><dt class="dt-description"><span class="font-bold">Only generative effects:</span></dt><dd class="dd-description"> The expression does not change the
observable state of the world save for possibly affecting the state of
the garbage collector by performing an allocation. Expressions
that only have generative effects and whose results are unused
may be eliminated by the compiler. However, unlike expressions with
â€œno effectsâ€, such expressions will never be eligible for duplication.
</dd><dt class="dt-description"><span class="font-bold">Arbitrary effects:</span></dt><dd class="dd-description"> All other expressions.
</dd></dl><p>There is a single classification for coeffects:
</p><dl class="description"><dt class="dt-description"><span class="font-bold">No coeffects:</span></dt><dd class="dd-description"> The expression does not observe the effects (in
the sense described above) of other expressions. For example, it must not
read from any mutable storage or call arbitrary external functions.
</dd></dl><p>It is assumed in the compiler that, subject to data dependencies,
expressions with neither effects nor coeffects may be reordered with
respect to other expressions.</p>
<!--TOC section id="s:flambda-static-modules" 23.13â€ƒCompilation of statically-allocated modules-->
<h2 class="section" id="s:flambda-static-modules"><a class="section-anchor" href="#s:flambda-static-modules" aria-hidden="true">ï»¿</a>23.13â€ƒCompilation of statically-allocated modules</h2><!--SEC END --><p>Compilation of modules that are able to be statically allocated (for example,
the module corresponding to an entire compilation unit, as opposed to a first
class module dependent on values computed at runtime) initially follows the
strategy used for bytecode. A sequence of <span class="font-tt">let</span>-bindings, which may be
interspersed with arbitrary effects, surrounds a record creation that becomes
the module block. The Flambda-specific transformation follows: these bindings
are lifted to toplevel symbols, as described above.</p>
<!--TOC section id="s:flambda-inhibition" 23.14â€ƒInhibition of optimisation-->
<h2 class="section" id="s:flambda-inhibition"><a class="section-anchor" href="#s:flambda-inhibition" aria-hidden="true">ï»¿</a>23.14â€ƒInhibition of optimisation</h2><!--SEC END --><p>Especially when writing benchmarking suites that run non-side-effecting
algorithms in loops, it may be found that the optimiser entirely
elides the code being benchmarked. This behaviour can be prevented by
using the <span class="font-tt">Sys.opaque_identity</span> function (which indeed behaves as a
normal OCaml function and does not possess any â€œmagicâ€ semantics). The
documentation of the <span class="font-tt">Sys</span> module should be consulted for further details.</p>
<!--TOC section id="s:flambda-unsafe" 23.15â€ƒUse of unsafe operations-->
<h2 class="section" id="s:flambda-unsafe"><a class="section-anchor" href="#s:flambda-unsafe" aria-hidden="true">ï»¿</a>23.15â€ƒUse of unsafe operations</h2><!--SEC END --><p>The behaviour of the Flambda simplification pass means that certain unsafe
operations, which may without Flambda or when using previous versions of
the compiler be safe, must not be used. This specifically refers to
functions found in the <span class="font-tt">Obj</span> module.</p><p>In particular, it is forbidden to change any value (for example using
<span class="font-tt">Obj.set_field</span> or <span class="font-tt">Obj.set_tag</span>) that is not mutable.
(Values returned from C stubs
are always treated as mutable.) The compiler will emit warning 59 if it
detects such a writeâ€”but it cannot warn in all cases. Here is an example
of code that will trigger the warning:
</p><pre>let f x =
  let a = 42, x in
  (Obj.magic a : int ref) := 1;
  fst a
</pre><p>The reason this is unsafe is because the simplification pass believes that
<span class="font-tt">fst a</span> holds the value <span class="font-tt">42</span>; and indeed it must, unless type
soundness has been broken via unsafe operations.</p><p>If it must be the case that code has to be written that triggers warning 59,
but the code is known to actually be correct (for some definition of
correct), then <span class="font-tt">Sys.opaque_identity</span> may be used to wrap the value
before unsafe operations are performed upon it. Great care must be taken
when doing this to ensure that the opacity is added at the correct place.
It must be emphasised that this use of <span class="font-tt">Sys.opaque_identity</span> is only
for <span class="font-bold">exceptional</span> cases. It should not be used in normal code or to
try to guide the optimiser.</p><p>As an example, this code will return the integer <span class="font-tt">1</span>:
</p><pre>let f x =
  let a = Sys.opaque_identity (42, x) in
  (Obj.magic a : int ref) := 1;
  fst a
</pre><p>However the following code will still return <span class="font-tt">42</span>:
</p><pre>let f x =
  let a = 42, x in
  Sys.opaque_identity (Obj.magic a : int ref) := 1;
  fst a
</pre><p>
High levels of inlining performed by Flambda may expose bugs in code
thought previously to be correct. Take care, for example, not
to add type annotations that claim some mutable value is always immediate
if it might be possible for an unsafe operation to update it to a boxed
value.</p>
<!--TOC section id="s:flambda-glossary" 23.16â€ƒGlossary-->
<h2 class="section" id="s:flambda-glossary"><a class="section-anchor" href="#s:flambda-glossary" aria-hidden="true">ï»¿</a>23.16â€ƒGlossary</h2><!--SEC END --><p>The following terminology is used in this chapter of the manual.</p><dl class="description"><dt class="dt-description"><span class="font-bold">Call site</span></dt><dd class="dd-description"> See <em>direct call site</em> and <em>indirect call site</em> below.
</dd><dt class="dt-description"><span class="font-bold">Closed function</span></dt><dd class="dd-description"> A function whose body has no free variables
except its parameters and any to which are bound other functions within
the same (possibly mutually-recursive) declaration.
</dd><dt class="dt-description"><span class="font-bold">Closure</span></dt><dd class="dd-description"> The runtime representation of a function. This
includes pointers to the code of the function
together with the values of any variables that are used in the body of
the function but actually defined outside of the function, in the
enclosing scope.
The values of such variables, collectively known as the
<em>environment</em>, are required because the function may be
invoked from a place where the original bindings of such variables are
no longer in scope. A group of possibly
mutually-recursive functions defined using <em>let rec</em> all share a
single closure. (Note to developers: in the Flambda source code a
<em>closure</em> always corresponds to a single function; a
<em>set of closures</em> refers to a group of such.)
</dd><dt class="dt-description"><span class="font-bold">Closure variable</span></dt><dd class="dd-description"> A member of the environment held within the
closure of a given function.
</dd><dt class="dt-description"><span class="font-bold">Constant</span></dt><dd class="dd-description"> Some entity (typically an expression) the value of which
is known by the compiler at compile time. Constantness may be explicit from
the source code or inferred by the Flambda optimisers.
</dd><dt class="dt-description"><span class="font-bold">Constant closure</span></dt><dd class="dd-description"> A closure that is statically allocated in an
object file. It is almost always the case that the environment portion of
such a closure is empty.
</dd><dt class="dt-description"><span class="font-bold">Defining expression</span></dt><dd class="dd-description"> The expression <span class="font-tt">e</span> in <span class="font-tt">let x = e in eâ€™</span>.
</dd><dt class="dt-description"><span class="font-bold">Direct call site</span></dt><dd class="dd-description"> A place in a programâ€™s code where a function is
called and it is known at compile time which function it will always be.
</dd><dt class="dt-description"><span class="font-bold">Indirect call site</span></dt><dd class="dd-description"> A place in a programâ€™s code where a function
is called but is not known to be a <em>direct call site</em>.
</dd><dt class="dt-description"><span class="font-bold">Program</span></dt><dd class="dd-description"> A collection of <em>symbol bindings</em> forming the
definition of a single compilation unit (i.e. <span class="font-tt">.cmx</span> file).
</dd><dt class="dt-description"><span class="font-bold">Specialised argument</span></dt><dd class="dd-description"> An argument to a function that is known
to always hold a particular value at runtime. These are introduced by the
inliner when specialising recursive functions; and the <span class="font-tt">unbox-closures</span>
pass. (See section <a href="#s%3Aflambda-specialisation">23.4</a>.)
</dd><dt class="dt-description"><span class="font-bold">Symbol</span></dt><dd class="dd-description"> A name referencing a particular place in an object file
or executable image. At that particular place will be some constant value.
Symbols may be examined using operating system-specific tools (for
example <span class="font-tt">objdump</span> on Linux).
</dd><dt class="dt-description"><span class="font-bold">Symbol binding</span></dt><dd class="dd-description"> Analogous to a <span class="font-tt">let</span>-expression but working
at the level of symbols defined in the object file. The address of a symbol is
fixed, but it may be bound to both constant and non-constant expressions.
</dd><dt class="dt-description"><span class="font-bold">Toplevel</span></dt><dd class="dd-description"> An expression in the current program which is not
enclosed within any function declaration.
</dd><dt class="dt-description"><span class="font-bold">Variable</span></dt><dd class="dd-description"> A named entity to which some OCaml value is bound by a
<span class="font-tt">let</span> expression, pattern-matching construction, or similar.
</dd></dl>
<!--TOC chapter id="sec597" ChapterÂ 24â€ƒFuzzing with afl-fuzz-->
<h1 class="chapter" id="sec597">ChapterÂ 24â€ƒFuzzing with afl-fuzz</h1><!--SEC END --><!--NAME afl-fuzz.html-->

<!--TOC section id="s:afl-overview" 24.1â€ƒOverview-->
<h2 class="section" id="s:afl-overview"><a class="section-anchor" href="#s:afl-overview" aria-hidden="true">ï»¿</a>24.1â€ƒOverview</h2><!--SEC END --><p>American fuzzy lop (â€œafl-fuzzâ€) is a <em>fuzzer</em>, a tool for
testing software by providing randomly-generated inputs, searching for
those inputs which cause the program to crash.</p><p>Unlike most fuzzers, afl-fuzz observes the internal behaviour of the
program being tested, and adjusts the test cases it generates to
trigger unexplored execution paths. As a result, test cases generated
by afl-fuzz cover more of the possible behaviours of the tested
program than other fuzzers.</p><p>This requires that programs to be tested are instrumented to
communicate with afl-fuzz. The native-code compiler â€œocamloptâ€ can
generate such instrumentation, allowing afl-fuzz to be used against
programs written in OCaml.</p><p>For more information on afl-fuzz, see the website at
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>.
</p>
<!--TOC section id="s:afl-generate" 24.2â€ƒGenerating instrumentation-->
<h2 class="section" id="s:afl-generate"><a class="section-anchor" href="#s:afl-generate" aria-hidden="true">ï»¿</a>24.2â€ƒGenerating instrumentation</h2><!--SEC END --><p>The instrumentation that afl-fuzz requires is not generated by
default, and must be explicitly enabled, by passing the <span class="font-tt">-afl-instrument</span> option to <span class="font-tt">ocamlopt</span>.</p><p>To fuzz a large system without modifying build tools, OCamlâ€™s <span class="font-tt">configure</span> script also accepts the <span class="font-tt">afl-instrument</span> option. If
OCaml is configured with <span class="font-tt">afl-instrument</span>, then all programs
compiled by <span class="font-tt">ocamlopt</span> will be instrumented.</p>
<!--TOC subsection id="ss:afl-advanced" 24.2.1â€ƒAdvanced options-->
<h3 class="subsection" id="ss:afl-advanced"><a class="section-anchor" href="#ss:afl-advanced" aria-hidden="true">ï»¿</a>24.2.1â€ƒAdvanced options</h3><!--SEC END --><p>In rare cases, it is useful to control the amount of instrumentation
generated. By passing the <span class="font-tt">-afl-inst-ratio N</span> argument to <span class="font-tt">ocamlopt</span> with <span class="font-tt">N</span> less than 100, instrumentation can be
generated for only N% of branches. (See the afl-fuzz documentation on
the parameter <span class="font-tt">AFL_INST_RATIO</span> for the precise effect of this).</p>
<!--TOC section id="s:afl-example" 24.3â€ƒExample-->
<h2 class="section" id="s:afl-example"><a class="section-anchor" href="#s:afl-example" aria-hidden="true">ï»¿</a>24.3â€ƒExample</h2><!--SEC END --><p>As an example, we fuzz-test the following program, <span class="font-tt">readline.ml</span>:</p><pre>let _ =
  let s = read_line () in
  match Array.to_list (Array.init (String.length s) (String.get s)) with
    ['s'; 'e'; 'c'; 'r'; 'e'; 't'; ' '; 'c'; 'o'; 'd'; 'e'] -&gt; failwith "uh oh"
  | _ -&gt; ()
</pre><p>
There is a single input (the string â€œsecret codeâ€) which causes this
program to crash, but finding it by blind random search is infeasible.</p><p>Instead, we compile with afl-fuzz instrumentation enabled:
</p><pre>ocamlopt -afl-instrument readline.ml -o readline
</pre><p>Next, we run the program under afl-fuzz:
</p><pre>mkdir input
echo asdf &gt; input/testcase
mkdir output
afl-fuzz -m none -i input -o output ./readline
</pre><p>By inspecting instrumentation output, the fuzzer finds the crashing input quickly.</p><p>Note: To fuzz-test an OCaml program with afl-fuzz, passing the option <span class="font-tt">-m none</span>
is required to disable afl-fuzzâ€™s default 50MB virtual memory limit.

</p>
<!--TOC chapter id="sec602" ChapterÂ 25â€ƒRuntime tracing with runtime events-->
<h1 class="chapter" id="sec602">ChapterÂ 25â€ƒRuntime tracing with runtime events</h1><!--SEC END --><p>
<a id="c:runtime-tracing"></a>
</p><!--NAME runtime-tracing.html-->
<p>This chapter describes the runtime events tracing system which enables
continuous extraction of performance information from the OCaml runtime with
very low overhead. The system and interfaces are low-level and tightly coupled
to the runtime implementation, it is intended for end-users to rely on tooling
to consume and visualise data of interest.</p><p>Data emitted includes:
</p><ul class="itemize"><li class="li-itemize">Event times of garbage collector and runtime phases
</li><li class="li-itemize">Minor and major heap sizings and utilization
</li><li class="li-itemize">Allocation and promotion rates between heaps
</li></ul>
<!--TOC section id="s:runtime-tracing-overview" 25.1â€ƒOverview-->
<h2 class="section" id="s:runtime-tracing-overview"><a class="section-anchor" href="#s:runtime-tracing-overview" aria-hidden="true">ï»¿</a>25.1â€ƒOverview</h2><!--SEC END --><p>There are three main classes of events emitted by the runtime events system:</p><dl class="description"><dt class="dt-description"><span class="font-bold">Spans</span></dt><dd class="dd-description"> Events spanning over a duration in time. For example, the runtime
events tracing system emits a span event that starts when a minor
collection begins in the OCaml garbage collector and ends when
the collection is completed. Spans can contain other spans, e.g other span
events may be emitted that begin after a minor collection has
begun and end before it does.
</dd><dt class="dt-description"><span class="font-bold">Lifecycle events</span></dt><dd class="dd-description"> Events that occur at a moment in time. For example,
when a domain terminates, a corresponding lifecycle event is emitted.
</dd><dt class="dt-description"><span class="font-bold">Counters</span></dt><dd class="dd-description"> Events that include a measurement of some quantity of
interest. For example, the number of words promoted from the minor to
the major heap during the last minor garbage collection is emitted as a
counter event.
</dd></dl><p>The runtime events tracing system is designed to be used in different contexts:
</p><dl class="description"><dt class="dt-description"><span class="font-bold">Self monitoring</span></dt><dd class="dd-description"> OCaml programs and libraries can install their own callbacks
to listen for runtime events and react to them programmatically, for example,
to export events to disk or over the network.
</dd><dt class="dt-description"><span class="font-bold">External monitoring</span></dt><dd class="dd-description"> An external process can consume the runtime events
of an OCaml program whose runtime tracing system has been enabled by setting
the corresponding environment variable.
</dd></dl><p>The runtime events tracing system logs events to a <em>ring buffer</em>. Consequently,
old events are being overwritten by new events. Consumers can either continuously
consume events or choose to only do so in response to some circumstance, e.g if
a particular query or operation takes longer than expected to complete.</p>
<!--TOC section id="s:runtime-tracing-architecture" 25.2â€ƒArchitecture-->
<h2 class="section" id="s:runtime-tracing-architecture"><a class="section-anchor" href="#s:runtime-tracing-architecture" aria-hidden="true">ï»¿</a>25.2â€ƒArchitecture</h2><!--SEC END --><p>The runtime tracing system conceptually consists of two parts: 1) the probes
which emit events and 2) the events transport that ingests and transports
these events.</p>
<!--TOC subsection id="s:runtime-tracing-probes" 25.2.1â€ƒProbes-->
<h3 class="subsection" id="s:runtime-tracing-probes"><a class="section-anchor" href="#s:runtime-tracing-probes" aria-hidden="true">ï»¿</a>25.2.1â€ƒProbes</h3><!--SEC END --><p>
Probes collect events from the runtime system. These are further
split in to two sets: 1) probes that are always available and 2) probes
that are only available in the instrumented runtime.
Probes in the instrumented runtime are primarily of
interest to developers of the OCaml runtime and garbage collector and, at
present, only consist of major heap allocation size counter events.</p><p>The full set of events emitted by probes and their documentation can be found in
<a href="libref/Runtime_events.html">Module <span class="font-tt">Runtime_events</span></a>.
</p>
<!--TOC subsection id="s:runtime-tracing-ingestion" 25.2.2â€ƒEvents transport-->
<h3 class="subsection" id="s:runtime-tracing-ingestion"><a class="section-anchor" href="#s:runtime-tracing-ingestion" aria-hidden="true">ï»¿</a>25.2.2â€ƒEvents transport</h3><!--SEC END --><p>The events transport part of the system ingests events emitted by the probes
and makes them available to consumers.</p>
<!--TOC subsubsection id="s:runtime-tracing-ringbuffers" Ring buffers-->
<h4 class="subsubsection" id="s:runtime-tracing-ringbuffers"><a class="section-anchor" href="#s:runtime-tracing-ringbuffers" aria-hidden="true">ï»¿</a>Ring buffers</h4><!--SEC END --><p>Events are transported using a data structure known as a <em>ring buffer</em>. This
data structure consists of two pointers into a linear backing array, the tail
pointer points to a location where new events can be written and the head
pointer points to the oldest event in the buffer that can be read. When
insufficient space is available in the backing array to write new events, the
head pointer is advanced and the oldest events are overwritten by new ones.</p><p>The ring buffer implementation used in runtime events can be written by at most
one producer at a time but can be read simultaneously by multiple consumers
without coordination from the producer. There is a unique ring buffer for every
running domain and, on domain termination, ring buffers may be re-used for newly
spawned domains. The ring buffers themselves are stored in a memory-mapped file
with the processes identifier as the name and the extension <span class="machine"><span class="font-tt">.events</span></span>, this
enables them to be read from outside the main OCaml process. See
<a href="libref/Runtime_events.html"><span class="font-tt">Runtime_events</span></a> for more information.</p>
<!--TOC subsubsection id="s:runtime-tracing-apis" Consumption APIs-->
<h4 class="subsubsection" id="s:runtime-tracing-apis"><a class="section-anchor" href="#s:runtime-tracing-apis" aria-hidden="true">ï»¿</a>Consumption APIs</h4><!--SEC END --><p>The runtime event tracing system provides both OCaml and C APIs which are
cursor-based and polling-driven. The high-level process for consuming events
is as follows:</p><ol class="enumerate" type=1><li class="li-enumerate">A cursor is created via <span class="font-tt">Runtime_events.create_cursor</span> for either the
current process or an external process (specified by a path and PID).
</li><li class="li-enumerate"><span class="font-tt">Runtime_events.Callbacks.create</span> is called to register a callback function to receive the events.
</li><li class="li-enumerate">The cursor is polled via <span class="font-tt">Runtime_events.read_poll</span> using the callbacks
created in the previous step. For each matching event in the ring buffers, the
provided callback functions are called.
</li></ol>
<!--TOC section id="s-runtime-tracing-usage" 25.3â€ƒUsage-->
<h2 class="section" id="s-runtime-tracing-usage"><a class="section-anchor" href="#s-runtime-tracing-usage" aria-hidden="true">ï»¿</a>25.3â€ƒUsage</h2><!--SEC END -->
<!--TOC subsection id="s-runtime-tracing-ocaml-apis" 25.3.1â€ƒWith OCaml APIs-->
<h3 class="subsection" id="s-runtime-tracing-ocaml-apis"><a class="section-anchor" href="#s-runtime-tracing-ocaml-apis" aria-hidden="true">ï»¿</a>25.3.1â€ƒWith OCaml APIs</h3><!--SEC END --><p>We start with a simple example that prints the name, begin and end times
of events emitted by the runtime event tracing system:</p><pre>let runtime_begin _ ts phase =
    Printf.printf "Begin\t%s\t%Ld\n"
        (Runtime_events.runtime_phase_name phase)
        (Runtime_events.Timestamp.to_int64 ts)

let runtime_end _ ts phase =
    Printf.printf "End\t%s\t%Ld\n"
        (Runtime_events.runtime_phase_name phase)
        (Runtime_events.Timestamp.to_int64 ts)

let () =
    Runtime_events.start ();
    let cursor = Runtime_events.create_cursor None in
    let callbacks = Runtime_events.Callbacks.create ~runtime_begin ~runtime_end ()
    in
    while true do
        let list_ref = ref [] in (* for later fake GC work *)
        for _ = 1 to 100 do
            (* here we do some fake GC work *)
            list_ref := [];
            for _ = 1 to 10 do
                list_ref := (Sys.opaque_identity(ref 42)) :: !list_ref
            done;
            Gc.full_major ();
        done;
        ignore(Runtime_events.read_poll cursor callbacks None);
        Unix.sleep 1
    done
</pre><p>
The next step is to compile and link the program with the runtime_events
library. This can be done as follows:</p><pre>       ocamlopt -I +runtime_events -I +unix unix.cmxa runtime_events.cmxa
            example.ml -o example
</pre><p>
When using the <em>dune</em> build system, this example can be built as follows:</p><pre>(executable
 (name example)
 (modules example)
 (libraries unix runtime_events))
</pre><p>
Running the compiled binary of the example gives an output similar to:</p><pre>Begin   explicit_gc_full_major  24086187297852
Begin   stw_leader      24086187298594
Begin   minor   24086187299404
Begin   minor_global_roots      24086187299807
End     minor_global_roots      24086187331461
Begin   minor_remembered_set    24086187331631
Begin   minor_finalizers_oldify 24086187544312
End     minor_finalizers_oldify 24086187544704
Begin   minor_remembered_set_promote    24086187544879
End     minor_remembered_set_promote    24086187606414
End     minor_remembered_set    24086187606584
Begin   minor_finalizers_admin  24086187606854
End     minor_finalizers_admin  24086187607152
Begin   minor_local_roots       24086187607329
Begin   minor_local_roots_promote       24086187609699
End     minor_local_roots_promote       24086187610539
End     minor_local_roots       24086187610709
End     minor   24086187611746
Begin   minor_clear     24086187612238
End     minor_clear     24086187612580
End     stw_leader      24086187613209
...
</pre><p>
This is an example of self-monitoring, where a program explicitly starts
listening to runtime events and monitors itself.</p><p>For external monitoring, a program does not need to be aware of the existence of runtime
events. Runtime events can be controlled via the environment variable
<span class="machine"><span class="font-tt">OCAML_RUNTIME_EVENTS_START</span></span> which, when set, will cause the runtime
tracing system to be started at program initialization.</p><p>We could remove <span class="machine"><span class="font-tt">Runtime_events.start ();</span></span> from the previous example and,
instead, call the program as below to produce the same result:</p><pre>OCAML_RUNTIME_EVENTS_START=1 ./example
</pre>
<!--TOC subsubsection id="s-runtime-tracing-environment-variables" Environment variables-->
<h4 class="subsubsection" id="s-runtime-tracing-environment-variables"><a class="section-anchor" href="#s-runtime-tracing-environment-variables" aria-hidden="true">ï»¿</a>Environment variables</h4><!--SEC END --><p>Environment variables can be used to control different aspects of the runtime
event tracing system. The following environment variables are available:</p><ul class="itemize"><li class="li-itemize">OCAML_RUNTIME_EVENTS_START if set will cause the runtime events system
to be started as part of the OCaml runtime initialization.
</li><li class="li-itemize">OCAML_RUNTIME_EVENTS_DIR sets the directory where the <span class="machine"><span class="font-tt">.events</span></span>
files containing the runtime event tracing systemâ€™s ring buffers will be located.
If not present the programâ€™s working directory will be used.
</li><li class="li-itemize">OCAML_RUNTIME_EVENTS_PRESERVE if set will make the OCaml runtime
preserve the runtime events ring buffer files past the termination of the OCaml program.
This can be useful for monitoring very short running programs.
If not set, the <span class="machine"><span class="font-tt">.events</span></span> files of the OCaml program will be deleted
at program termination.
</li></ul><p>The size of the runtime events ring buffers can be configured via OCAMLRUNPARAM,
see section <a href="#s%3Aocamlrun-options">15.2</a> for more information.</p>
<!--TOC subsubsection id="s-runtime-tracing-instrumented-runtime" Building with the instrumented runtime-->
<h4 class="subsubsection" id="s-runtime-tracing-instrumented-runtime"><a class="section-anchor" href="#s-runtime-tracing-instrumented-runtime" aria-hidden="true">ï»¿</a>Building with the instrumented runtime</h4><!--SEC END --><p>To receive events that are only available in the instrumented runtime, the
OCaml program needs to be compiled and linked against the instrumented runtime.
For our example program from earlier, this is achieved as follows:</p><pre>ocamlopt -runtime-variant i -I +runtime_events -I +unix unix.cmxa runtime_events.cmxa example.ml -o example
</pre><p>
And for dune:</p><pre>(executable
 (name example)
 (modules example)
 (flags "-runtime-variant=i")
 (libraries unix runtime_events))
</pre>
<!--TOC subsection id="s-runtime-tracing-tooling" 25.3.2â€ƒWith tooling-->
<h3 class="subsection" id="s-runtime-tracing-tooling"><a class="section-anchor" href="#s-runtime-tracing-tooling" aria-hidden="true">ï»¿</a>25.3.2â€ƒWith tooling</h3><!--SEC END --><p>Programmatic access to events is intended primarily for writers of observability
libraries and tooling that end-users use. The flexible API enables use of
the performance data from runtime events for logging and monitoring purposes.</p><p>In this section we cover several utilities in the <span class="font-tt">runtime_events_tools</span>
package which provide simple ways of extracting and summarising data from runtime
events. The trace utility in particular produces similar data to the previous
â€™eventlogâ€™ instrumentation system available in OCaml 4.12 to 4.14.</p><p>First, install <span class="font-tt">runtime_events_tools</span> in an OCaml 5.0+ opam switch:</p><pre>opam install runtime_events_tools
</pre><p>
This should install the olly tool in your path. You can now generate
runtime traces for programs compiled with OCaml 5.0+ using the trace subcommand:</p><pre>olly trace trace.json 'your_program.exe .. args ..'
</pre><p>
Runtime tracing data will be generated in the json Trace Event Format to trace.json.
This can then be loaded into the Chrome tracing viewer or into <a href="https://ui.perfetto.dev/">Perfetto</a>
to visualize the collected trace.</p>
<!--TOC subsubsection id="s-runtime-tracing-latency" Measuring GC latency-->
<h4 class="subsubsection" id="s-runtime-tracing-latency"><a class="section-anchor" href="#s-runtime-tracing-latency" aria-hidden="true">ï»¿</a>Measuring GC latency</h4><!--SEC END --><p>The olly utility also includes a latency subcommand which consumes runtime
events data and on program completion emits a parseable histogram summary of
pause durations. It can be run as follows:</p><pre>olly latency 'your_program.exe .. args ..'
</pre><p>
This should produce an output similar to the following:</p><pre>GC latency profile:
#[Mean (ms):	2.46,	 Stddev (ms):	3.87]
#[Min (ms):	0.01,	 max (ms):	9.17]

Percentile 	 Latency (ms)
25.0000 	 0.01
50.0000 	 0.23
60.0000 	 0.23
70.0000 	 0.45
75.0000 	 0.45
80.0000 	 0.45
85.0000 	 0.45
90.0000 	 9.17
95.0000 	 9.17
96.0000 	 9.17
97.0000 	 9.17
98.0000 	 9.17
99.0000 	 9.17
99.9000 	 9.17
99.9900 	 9.17
99.9990 	 9.17
99.9999 	 9.17
100.0000 	 9.17
</pre>
<!--TOC chapter id="sec615" ChapterÂ 26â€ƒThe â€œTail Modulo Constructorâ€ program transformation-->
<h1 class="chapter" id="sec615">ChapterÂ 26â€ƒThe â€œTail Modulo Constructorâ€ program transformation</h1><!--SEC END --><p> <a id="c:tail_mod_cons"></a>
</p><!--NAME tail_mod_cons.html-->
<p>(Introduced in OCaml 4.14)</p><p>Note: this feature is considered experimental, and its interface may
evolve, with user feedback, in the next few releases of the language.</p><p>Consider this natural implementation of the <span class="machine"><span class="font-tt">List.map</span></span> function:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map f l =
  <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
  | [] -&gt; []
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    y :: map f xs</div></div>

</div><p>A well-known limitation of this implementation is that the recursive
call, <span class="machine"><span class="font-tt">map f xs</span></span>, is not in <em>tail</em> position. The runtime needs to
remember to continue with <span class="machine"><span class="font-tt">y :: r</span></span> after the call returns a value <span class="machine"><span class="font-tt">r</span></span>,
therefore this function consumes some amount of call-stack space on
each recursive call. The stack usage of <span class="machine"><span class="font-tt">map f li</span></span> is proportional to
the length of <span class="machine"><span class="font-tt">li</span></span>. This is a correctness issue for large lists on
operating systems with limited stack space â€“ the dreaded
<span class="machine"><span class="font-tt">Stack_overflow</span></span> exception.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.length (map Fun.id (List.init 1_000_000 Fun.id));;</div>



<div class="pre caml-output ok">- : int = 1000000</div></div>

</div><p>In this implementation of <span class="machine"><span class="font-tt">map</span></span>, the recursive call happens in
a position that is not a <em>tail</em> position in the program, but
within a datatype constructor application that is itself in
<em>tail</em> position. We say that those positions, that are composed
of tail positions and constructor applications, are <em>tail modulo
constructor</em> (TMC) positions â€“ we sometimes write <em>tail modulo
cons</em> for brevity.</p><p>It is possible to rewrite programs such that tail modulo cons
positions become tail positions; after this transformation, the
implementation of <span class="machine"><span class="font-tt">map</span></span> above becomes <em>tail-recursive</em>, in the
sense that it only consumes a constant amount of stack space. The
OCaml compiler implements this transformation on demand, using the
<span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span> or <span class="machine"><span class="font-tt">[@ocaml.tail_mod_cons]</span></span> attribute on the
function to transform.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map f l =
  <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
  | [] -&gt; []
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    y :: map f xs</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.length (map Fun.id (List.init 1_000_000 Fun.id));;</div>



<div class="pre caml-output ok">- : int = 1000000</div></div>

</div><p>This transformation only improves calls in tail-modulo-cons position,
it does not improve recursive calls that do not fit in this fragment:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* does *not* work: addition is not a data constructor *)</span>
<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> length <span class="ocamlhighlight">l =
  match l with
  | [] -&gt; 0
  | _ :: xs -&gt; 1 + length xs</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 71 [unused-tmc-attribute]: This function is marked @tail_mod_cons
but is never applied in TMC position.</div></div>

</div><p>It is of course possible to use the <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span> transformation
on functions that contain some recursive calls in tail-modulo-cons
position, and some calls in other, arbitrary positions. Only the tail
calls and tail-modulo-cons calls will happen in constant stack space.</p>
<!--TOC paragraph id="sec616" General design-->
<h5 class="paragraph" id="sec616"><a class="section-anchor" href="#sec616" aria-hidden="true">ï»¿</a>General design</h5><!--SEC END --><p> This feature is provided as an explicit
program transformation, not an implicit optimization. It is
annotation-driven: the user is expected to express their intent by
adding annotations in the program using attributes, and will be asked
to do so in any ambiguous situation.</p><p>We expect it to be used mostly by advanced OCaml users needing to get
some guarantees on the stack-consumption behavior of their
programs. Our recommendation is to use the <span class="machine"><span class="font-tt">[@tailcall]</span></span> annotation on
all callsites that should not consume any stack
space. <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span> extends the set of functions on which calls
can be annotated to be tail calls, helping establish stack-consumption
guarantees in more cases.</p>
<!--TOC paragraph id="sec617" Performance-->
<h5 class="paragraph" id="sec617"><a class="section-anchor" href="#sec617" aria-hidden="true">ï»¿</a>Performance</h5><!--SEC END --><p> A standard approach to get a tail-recursive
version of <span class="machine"><span class="font-tt">List.map</span></span> is to use an accumulator to collect output
elements, and reverse it at the end of the traversal.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map f l = map_aux f [] l
<span class="ocamlkeyword">and</span> map_aux f acc l =
  <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
  | [] -&gt; List.rev acc
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    map_aux f (y :: acc) xs</div></div>

</div><p>This version is tail-recursive, but it is measurably slower than the
simple, non-tail-recursive version. In contrast, the tail-mod-cons
transformation provides an implementation that has comparable
performance to the original version, even on small inputs.</p>
<!--TOC paragraph id="sec618" Evaluation order-->
<h5 class="paragraph" id="sec618"><a class="section-anchor" href="#sec618" aria-hidden="true">ï»¿</a>Evaluation order</h5><!--SEC END --><p> Beware that the tail-modulo-cons
transformation has an effect on evaluation order: the constructor
argument that is transformed into tail-position will always be
evaluated last. Consider the following example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> 'a two_headed_list =
  | Nil
  | Consnoc <span class="ocamlkeyword">of</span> 'a * 'a two_headed_list * 'a

<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map f = <span class="ocamlkeyword">function</span>
  | Nil -&gt; Nil
  | Consnoc (front, body, rear) -&gt;
    Consnoc (f front, map f body, f rear)</div></div>

</div><p>Due to the <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span> transformation, the calls to <span class="machine"><span class="font-tt">f front</span></span>
and <span class="machine"><span class="font-tt">f rear</span></span> will be evaluated before <span class="machine"><span class="font-tt">map f body</span></span>. In particular,
this is likely to be different from the evaluation order of the
unannotated version. (The evaluation order of constructor arguments
is unspecified in OCaml, but many implementations typically use
left-to-right or right-to-left.)</p><p>This effect on evaluation order is one of the reasons why the
tail-modulo-cons transformation has to be explicitly requested by the
user, instead of being applied as an automatic optimization.</p>
<!--TOC paragraph id="sec619" Why tail-modulo-cons?-->
<h5 class="paragraph" id="sec619"><a class="section-anchor" href="#sec619" aria-hidden="true">ï»¿</a>Why tail-modulo-cons?</h5><!--SEC END --><p> Other program transformations, in
particular a transformation to continuation-passing style (CPS), can
make all functions tail-recursive, instead of targeting only a small
fragment. Some reasons to provide builtin support for the less-general
tail-mod-cons are as follows:
</p><ul class="itemize"><li class="li-itemize">The tail-mod-cons transformation preserves the performance of
the original, non-tail-recursive version, while
a continuation-passing-style transformation incurs a measurable
constant-factor overhead.
</li><li class="li-itemize">The tail-mod-cons transformation cannot be expressed as
a source-to-source transformation of OCaml programs, as it relies on
mutable state in type-unsafe ways. In contrast,
continuation-passing-style versions can be written by hand, possibly
using a convenient monadic notation.
</li></ul>
<!--TOC section id="sec:disambiguation" 26.1â€ƒDisambiguation-->
<h2 class="section" id="sec:disambiguation"><a class="section-anchor" href="#sec:disambiguation" aria-hidden="true">ï»¿</a>26.1â€ƒDisambiguation</h2><!--SEC END --><p>It may happen that several arguments of a constructor are recursive
calls to a tail-modulo-cons function. The transformation can only turn
one of these calls into a tail call. The compiler will not make an
implicit choice, but ask the user to provide an explicit
disambiguation.</p><p>Consider this type of syntactic expressions (assuming some
pre-existing type <span class="machine"><span class="font-tt">var</span></span> of expression variables):

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> var <span class="ocamlcomment">(* some pre-existing type of variables *)</span>

<span class="ocamlkeyword">type</span> exp =
  | Var <span class="ocamlkeyword">of</span> var
  | Let <span class="ocamlkeyword">of</span> binding * exp
<span class="ocamlkeyword">and</span> binding = var * exp</div></div>

</div><p>Consider a <span class="machine"><span class="font-tt">map</span></span> function on variables. The direct definition has two
recursive calls inside arguments of the <span class="machine"><span class="font-tt">Let</span></span> constructor, so it gets
rejected as ambiguous.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map_vars f exp =
  <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
  | Var v -&gt; Var (f v)
  | Let ((v, def), body) -&gt;
    <span class="ocamlhighlight">Let ((f v, map_vars f def), map_vars f body)</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: [@tail_mod_cons]: this constructor application may be TMC-transformed
       in several different ways. Please disambiguate by adding an explicit
       [@tailcall] attribute to the call that should be made tail-recursive,
       or a [@tailcall false] attribute on calls that should not be
       transformed.
  This call could be annotated.
  This call could be annotated.</div></div>

</div><p>To disambiguate, the user should add a <span class="machine"><span class="font-tt">[@tailcall]</span></span> attribute to the
recursive call that should be transformed to tail position:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map_vars f exp =
  <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
  | Var v -&gt; Var (f v)
  | Let ((v, def), body) -&gt;
    Let ((f v, map_vars f def), (map_vars[@tailcall]) f body)</div></div>

</div><p>

Be aware that the resulting function is <em>not</em> tail-recursive, the
recursive call on <span class="machine"><span class="font-tt">def</span></span> will consume stack space. However, expression
trees tend to be right-leaning (lots of <span class="machine"><span class="font-tt">Let</span></span> in sequence,
rather than nested inside each other), so putting the call on <span class="machine"><span class="font-tt">body</span></span>
in tail position is an interesting improvement over the naive
definition: it gives bounded stack space consumption if we assume
a bound on the nesting depth of <span class="machine"><span class="font-tt">Let</span></span> constructs.</p><p>One would also get an error when using conflicting annotations, asking
for two of the constructor arguments to be put in tail position:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map_vars f exp =
  <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
  | Var v -&gt; Var (f v)
  | Let ((v, def), body) -&gt;
    <span class="ocamlhighlight">Let ((f v, (map_vars[@tailcall]) f def), (map_vars[@tailcall]) f body)</span></div>



<div class="pre caml-output error"><span class="ocamlerror">Error</span>: [@tail_mod_cons]: this constructor application may be TMC-transformed
       in several different ways. Only one of the arguments may become a TMC
       call, but several arguments contain calls that are explicitly marked
       as tail-recursive. Please fix the conflict by reviewing and fixing the
       conflicting annotations.
  This call is explicitly annotated.
  This call is explicitly annotated.</div></div>

</div>
<!--TOC section id="sec:out-of-tmc" 26.2â€ƒDanger: getting out of tail-mod-cons-->
<h2 class="section" id="sec:out-of-tmc"><a class="section-anchor" href="#sec:out-of-tmc" aria-hidden="true">ï»¿</a>26.2â€ƒDanger: getting out of tail-mod-cons</h2><!--SEC END --><p>Due to the nature of the tail-mod-cons transformation
(see SectionÂ <a href="#sec%3Adetails">26.3</a> for a presentation of transformation):
</p><ul class="itemize"><li class="li-itemize">Calls from a tail-mod-cons function to another tail-mod-cons
function declared in the same recursive-binding group are
transformed into tail calls, as soon as they occur in tail position
or tail-modulo-cons position in the source function.
</li><li class="li-itemize">Calls from a function <em>not</em> annotated tail-mod-cons to
a tail-mod-cons function or, conversely, from a tail-mod-cons
function to a non-tail-mod-cons function are transformed into
<em>non</em>-tail calls, even if they syntactically appear in tail
position in the source program.
</li></ul><p>The fact that calls in tail position in the source program may become
non-tail calls if they go from a tail-mod-cons to a non-tail-mod-cons
function is surprising, and the transformation will warn about them.</p><p>For example:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> flatten = <span class="ocamlhighlight">function
| [] -&gt; []
| xs :: xss -&gt;
    let rec append_flatten xs xss =
      match xs with
      | [] -&gt; flatten xss
      | x :: xs -&gt; x :: append_flatten xs xss
    in append_flatten xs xss</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 71 [unused-tmc-attribute]: This function is marked @tail_mod_cons
but is never applied in TMC position.
<span class="ocamlwarning">Warning</span> 72 [tmc-breaks-tailcall]: This call
is in tail-modulo-cons positionin a TMC function,
but the function called is not itself specialized for TMC,
so the call will not be transformed into a tail call.
Please either mark the called function with the [@tail_mod_cons]
attribute, or mark this call with the [@tailcall false] attribute
to make its non-tailness explicit.</div></div>

</div><p>

Here the <span class="machine"><span class="font-tt">append_flatten</span></span> helper is not annotated with
<span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span>, so the calls <span class="machine"><span class="font-tt">append_flatten xs xss</span></span> and <span class="machine"><span class="font-tt">flatten xss</span></span> will <em>not</em> be tail calls. The correct fix here is to annotate
<span class="machine"><span class="font-tt">append_flatten</span></span> to be tail-mod-cons.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> flatten = <span class="ocamlkeyword">function</span>
| [] -&gt; []
| xs :: xss -&gt;
    <span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> append_flatten xs xss =
      <span class="ocamlkeyword">match</span> xs <span class="ocamlkeyword">with</span>
      | [] -&gt; flatten xss
      | x :: xs -&gt; x :: append_flatten xs xss
    <span class="ocamlkeyword">in</span> append_flatten xs xss</div></div>

</div><p>The same warning occurs when <span class="machine"><span class="font-tt">append_flatten</span></span> is a non-tail-mod-cons
function of the same recursive group; using the tail-mod-cons
transformation is a property of individual functions, not whole
recursive groups.

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> flatten = <span class="ocamlhighlight">function
| [] -&gt; []
| xs :: xss -&gt; append_flatten xs xss</span>

<span class="ocamlkeyword">and</span> append_flatten xs xss =
  <span class="ocamlkeyword">match</span> xs <span class="ocamlkeyword">with</span>
  | [] -&gt; flatten xss
  | x :: xs -&gt; x :: append_flatten xs xss</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 71 [unused-tmc-attribute]: This function is marked @tail_mod_cons
but is never applied in TMC position.
<span class="ocamlwarning">Warning</span> 72 [tmc-breaks-tailcall]: This call
is in tail-modulo-cons positionin a TMC function,
but the function called is not itself specialized for TMC,
so the call will not be transformed into a tail call.
Please either mark the called function with the [@tail_mod_cons]
attribute, or mark this call with the [@tailcall false] attribute
to make its non-tailness explicit.</div></div>

</div><p>Again, the fix is to specialize <span class="machine"><span class="font-tt">append_flatten</span></span> as well:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> flatten = <span class="ocamlkeyword">function</span>
| [] -&gt; []
| xs :: xss -&gt; append_flatten xs xss

<span class="ocamlkeyword">and</span>[@tail_mod_cons] append_flatten xs xss =
  <span class="ocamlkeyword">match</span> xs <span class="ocamlkeyword">with</span>
  | [] -&gt; flatten xss
  | x :: xs -&gt; x :: append_flatten xs xss</div></div>

</div><p>Non-recursive functions can also be annotated <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span>; this is
typically useful for local bindings to recursive functions.</p><p>Incorrect version:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map_vars <span class="ocamlhighlight">f exp =
  let self exp = map_vars f exp in
  match exp with
  | Var v -&gt; Var (f v)
  | Let ((v, def), body) -&gt;
    Let ((f v, self def), (self[@tailcall]) body)</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 51 [wrong-tailcall-expectation]: expected tailcall
<span class="ocamlwarning">Warning</span> 51 [wrong-tailcall-expectation]: expected tailcall
<span class="ocamlwarning">Warning</span> 71 [unused-tmc-attribute]: This function is marked @tail_mod_cons
but is never applied in TMC position.</div></div>

</div><p>Recommended fix:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map_vars f exp =
  <span class="ocamlkeyword">let</span>[@tail_mod_cons] self exp = map_vars f exp <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">match</span> exp <span class="ocamlkeyword">with</span>
  | Var v -&gt; Var (f v)
  | Let ((v, def), body) -&gt;
    Let ((f v, self def), (self[@tailcall]) body)</div></div>

</div><p>In other cases, there is either no benefit in making the called function
tail-mod-cons, or it is not possible: for example, it is a function
parameter (the transformation only works with direct calls to
known functions).</p><p>For example, consider a substitution function on binary trees:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> 'a tree = Leaf <span class="ocamlkeyword">of</span> 'a | Node <span class="ocamlkeyword">of</span> 'a tree * 'a tree

<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> bind (f : 'a -&gt; 'a tree) (t : 'a tree) : 'a tree =
  <span class="ocamlkeyword">match</span> t <span class="ocamlkeyword">with</span>
  | Leaf v -&gt; <span class="ocamlhighlight">f v</span>
  | Node (left, right) -&gt;
    Node (bind f left, (bind[@tailcall]) f right)</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 72 [tmc-breaks-tailcall]: This call
is in tail-modulo-cons positionin a TMC function,
but the function called is not itself specialized for TMC,
so the call will not be transformed into a tail call.
Please either mark the called function with the [@tail_mod_cons]
attribute, or mark this call with the [@tailcall false] attribute
to make its non-tailness explicit.</div></div>

</div><p>Here <span class="machine"><span class="font-tt">f</span></span> is a function parameter, not a direct call, and the current
implementation is strictly first-order, it does not support
tail-mod-cons arguments. In this case, the user should indicate that
they realize this call to <span class="machine"><span class="font-tt">f v</span></span> is not, in fact, in tail position, by
using <span class="machine"><span class="font-tt">(f[@tailcall false]) v</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> 'a tree = Leaf <span class="ocamlkeyword">of</span> 'a | Node <span class="ocamlkeyword">of</span> 'a tree * 'a tree

<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> bind (f : 'a -&gt; 'a tree) (t : 'a tree) : 'a tree =
  <span class="ocamlkeyword">match</span> t <span class="ocamlkeyword">with</span>
  | Leaf v -&gt; (f[@tailcall <span class="ocamlkeyword">false</span>]) v
  | Node (left, right) -&gt;
    Node (bind f left, (bind[@tailcall]) f right)</div></div>

</div>
<!--TOC section id="sec:details" 26.3â€ƒDetails on the transformation-->
<h2 class="section" id="sec:details"><a class="section-anchor" href="#sec:details" aria-hidden="true">ï»¿</a>26.3â€ƒDetails on the transformation</h2><!--SEC END --><p>To use this advanced feature, it helps to be aware that the function transformation produces a specialized function in destination-passing-style.</p><p>Recall our <span class="machine"><span class="font-tt">map</span></span> example:

</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map f l =
  <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
  | [] -&gt; []
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    y :: map f xs</div></div>

</div><p>Below is a description of the transformed program in pseudo-OCaml
notation: some operations are not expressible in OCaml source code.
(The transformation in fact happens on the Lambda intermediate
representation of the OCaml compiler.)</p><pre>let rec map f l =
  match l with
  | [] -&gt; []
  | x :: xs -&gt;
    let y = f x in
    let dst = y ::{mutable} Hole in
    map_dps f xs dst 1;
    dst

and map_dps f l dst idx =
  match l with
  | [] -&gt; dst.idx &lt;- []
  | x :: xs -&gt;
    let y = f x in
    let dst' = y ::{mutable} Hole in
    dst.idx &lt;- dst';
    map_dps f xs dst' 1
</pre><p>
The source version of <span class="machine"><span class="font-tt">map</span></span> gets transformed into two functions,
a <em>direct-style</em> version that is also called <span class="machine"><span class="font-tt">map</span></span>, and
a <em>destination-passing-style</em> version (DPS) called <span class="machine"><span class="font-tt">map_dps</span></span>. The
destination-passing-style version does not return a result directly,
instead it writes it into a memory location specified by two
additional function parameters, <span class="machine"><span class="font-tt">dst</span></span> (a memory block) and <span class="machine"><span class="font-tt">i</span></span>
(a position within the memory block).</p><p>The source call <span class="machine"><span class="font-tt">y :: map f xs</span></span> gets transformed into the creation of
a mutable block <span class="machine"><span class="font-tt">y ::{mutable} Hole</span></span>, whose second parameter is an
un-initialized <em>hole</em>. The block is then passed to <span class="machine"><span class="font-tt">map_dps</span></span> as
a destination parameter (with offset <span class="machine"><span class="font-tt">1</span></span>).</p><p>Notice that <span class="machine"><span class="font-tt">map</span></span> does not call itself recursively, it calls
<span class="machine"><span class="font-tt">map_dps</span></span>. Then, <span class="machine"><span class="font-tt">map_dps</span></span> calls itself recursively, in
a tail-recursive way.</p><p>The call from <span class="machine"><span class="font-tt">map</span></span> to <span class="machine"><span class="font-tt">map_dps</span></span> is <em>not</em> a tail call (this is
something that we could improve in the future); but this call happens
only once when invoking <span class="machine"><span class="font-tt">map f l</span></span>, with all list elements after the
first one processed in constant stack by <span class="machine"><span class="font-tt">map_dps</span></span>.</p><p>This explains the â€œgetting out of tail-mod-consâ€
subtleties. Consider our previous example involving mutual recursion
between <span class="machine"><span class="font-tt">flatten</span></span> and <span class="machine"><span class="font-tt">append_flatten</span></span>.
</p><pre>let[@tail_mod_cons] rec flatten l =
  match l with
  | [] -&gt; []
  | xs :: xss -&gt;
    append_flatten xs xss
</pre><p>
The call to <span class="machine"><span class="font-tt">append_flatten</span></span>, which syntactically appears in tail
position, gets transformed differently depending on whether the
function has a destination-passing-style version available, that is,
whether it is itself annotated <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span>:
</p><pre>(* if append_flatten_dps exists *)
and flatten_dps l dst i =
  match l with
  | [] -&gt; dst.i &lt;- []
  | xs :: xss -&gt;
    append_flatten_dps xs xss dst i

(* if append_flatten_dps does not exist *)
and rec flatten_dps l dst i =
  match l with
  | [] -&gt; dst.i &lt;- []
  | xs :: xss -&gt;
    dst.i &lt;- append_flatten xs xss
</pre><p>If <span class="machine"><span class="font-tt">append_flatten</span></span> does not have a destination-passing-style version,
the call gets transformed to a non-tail call.</p>
<!--TOC section id="sec:limitations" 26.4â€ƒCurrent limitations-->
<h2 class="section" id="sec:limitations"><a class="section-anchor" href="#sec:limitations" aria-hidden="true">ï»¿</a>26.4â€ƒCurrent limitations</h2><!--SEC END -->
<!--TOC paragraph id="sec624" Purely syntactic criterion-->
<h5 class="paragraph" id="sec624"><a class="section-anchor" href="#sec624" aria-hidden="true">ï»¿</a>Purely syntactic criterion</h5><!--SEC END --><p> Just like tail calls in
general, the notion of tail-modulo-constructor position is purely
syntactic; some simple refactoring will move calls out of
tail-modulo-constructor position.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* works as expected *)</span>
<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map f li =
  <span class="ocamlkeyword">match</span> li <span class="ocamlkeyword">with</span>
  | [] -&gt; []
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    y ::
      <span class="ocamlcomment">(* this call is in TMC position *)</span>
      map f xs</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* not optimizable anymore *)</span>
<span class="ocamlkeyword">let</span>[@tail_mod_cons] <span class="ocamlkeyword">rec</span> map <span class="ocamlhighlight">f li =
  match li with
  | [] -&gt; []
  | x :: xs -&gt;
    let y = f x in
    let ys =
      (* this call is not in TMC position anymore *)
      map f xs in
    y :: ys</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 71 [unused-tmc-attribute]: This function is marked @tail_mod_cons
but is never applied in TMC position.</div></div>

</div>
<!--TOC paragraph id="sec625" Local, first-order transformation-->
<h5 class="paragraph" id="sec625"><a class="section-anchor" href="#sec625" aria-hidden="true">ï»¿</a>Local, first-order transformation</h5><!--SEC END --><p> When a function gets
transformed with tail-mod-cons, two definitions are generated, one
providing a direct-style interface and one providing the
destination-passing-style version. However, not all calls to this
function in tail-modulo-cons position will use the
destination-passing-style version and become tail calls:
</p><ul class="itemize"><li class="li-itemize">The transformation is local: only tail-mod-cons calls to <span class="machine"><span class="font-tt">foo</span></span>
within the same compilation unit as <span class="machine"><span class="font-tt">foo</span></span> become tail calls.
</li><li class="li-itemize">The transformation is first-order: only direct calls to
known tail-mod-cons functions become tail calls when in
tail-mod-cons position, never calls to function parameters.
</li></ul><p>Consider the call <span class="machine"><span class="font-tt">Option.map foo x</span></span> for example: even if <span class="machine"><span class="font-tt">foo</span></span> is
called in tail-mod-cons position within the definition of
<span class="machine"><span class="font-tt">Option.map</span></span>, that call will never become a tail call. (This would be the
case even if the call to <span class="machine"><span class="font-tt">Option.map</span></span> was inside the <span class="machine"><span class="font-tt">Option</span></span>
module.)</p><p>In general this limitation is not a problem for recursive functions:
the first call from an outside module or a higher-order function will
consume stack space, but further recursive calls in tail-mod-cons
position will get optimized. For example, if <span class="machine"><span class="font-tt">List.map</span></span> is defined as
a tail-mod-cons function, calls from outside the <span class="machine"><span class="font-tt">List</span></span> module will
not become tail calls when in tail positions, but the recursive calls
within the definition of <span class="machine"><span class="font-tt">List.map</span></span> are in tail-modulo-cons positions
and do become tail calls: processing the first element of the list
will consume stack space, but all further elements are handled in
constant space.</p><p>These limitations may be an issue in more complex situations where
mutual recursion happens between functions, with some functions not
annotated tail-mod-cons, or defined across different modules, or called
indirectly, for example through function parameters.</p>
<!--TOC paragraph id="sec626" Non-exact calls to tupled functions-->
<h5 class="paragraph" id="sec626"><a class="section-anchor" href="#sec626" aria-hidden="true">ï»¿</a>Non-exact calls to tupled functions</h5><!--SEC END --><p> OCaml performs an
implicit optimization for â€œtupledâ€ functions, which take a single
parameter that is a tuple: <span class="machine"><span class="font-tt">let f (x, y, z) = ...</span></span>. Direct calls to
these functions with a tuple literal argument (like <span class="machine"><span class="font-tt">f (a, b, c)</span></span>) will
call the â€œtupledâ€ function by passing the parameters directly, instead
of building a tuple of them. Other calls, either indirect calls or calls
passing a more complex tuple value (like <span class="machine"><span class="font-tt">let t = (a, b, c) in f t</span></span>) are
compiled as â€œinexactâ€ calls that go through a wrapper.</p><p>The <span class="machine"><span class="font-tt">[@tail_mod_cons]</span></span> transformation supports tupled functions, but
will only optimize â€œexactâ€ calls in tail position; direct calls to
something other than a tuple literal will not become tail calls. The
user can manually unpack a tuple to force a call to be â€œexactâ€: <span class="machine"><span class="font-tt">let (x, y, z) = t in f (x, y, z)</span></span>. If there is any doubt as to whether a call
can be tail-mod-cons-optimized or not, one can use the <span class="machine"><span class="font-tt">[@tailcall]</span></span>
attribute on the called function, which will warn if the
transformation is not possible.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> map (f, l) =
  <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
  | [] -&gt; []
  | x :: xs -&gt;
    <span class="ocamlkeyword">let</span> y = f x <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> args = (f, xs) <span class="ocamlkeyword">in</span>
    <span class="ocamlcomment">(* this inexact call cannot be tail-optimized, so a warning will be raised *)</span>
    y :: <span class="ocamlhighlight">(map[@tailcall]) args</span></div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 51 [wrong-tailcall-expectation]: expected tailcall</div></div>

</div>
<!--TOC part id="sec627" PartÂ IVâ€ƒThe OCaml library-->
<table class="center"><tr><td><h1 class="part" id="sec627">PartÂ IV<br>
The OCaml library</h1></td></tr>
</table><!--SEC END --><p>
<a id="p:library"></a>
</p>
<!--TOC chapter id="sec628" ChapterÂ 27â€ƒThe core library-->
<h1 class="chapter" id="sec628">ChapterÂ 27â€ƒThe core library</h1><!--SEC END --><p> <a id="c:corelib"></a></p><!--NAME core.html-->
<p>This chapter describes the OCaml core library, which is
composed of declarations for built-in types and exceptions, plus
the module <span class="machine"><span class="font-tt">Stdlib</span></span> that provides basic operations on these
built-in types. The <span class="machine"><span class="font-tt">Stdlib</span></span> module is special in two
ways:
</p><ul class="itemize"><li class="li-itemize">It is automatically linked with the userâ€™s object code files by
the <span class="machine"><span class="font-tt">ocamlc</span></span> command (chapterÂ <a href="#c%3Acamlc">13</a>).</li><li class="li-itemize">It is automatically â€œopenedâ€ when a compilation starts, or
when the toplevel system is launched. Hence, it is possible to use
unqualified identifiers to refer to the functions provided by the
<span class="machine"><span class="font-tt">Stdlib</span></span> module, without adding a <span class="machine"><span class="font-tt">open Stdlib</span></span> directive.
</li></ul>
<!--TOC section id="s:core-builtins" 27.1â€ƒBuilt-in types and predefined exceptions-->
<h2 class="section" id="s:core-builtins"><a class="section-anchor" href="#s:core-builtins" aria-hidden="true">ï»¿</a>27.1â€ƒBuilt-in types and predefined exceptions</h2><!--SEC END --><p>The following built-in types and predefined exceptions are always
defined in the
compilation environment, but are not part of any module. As a
consequence, they can only be referred by their short names.</p><!--TOC subsection id="ss:builtin-types" Built-in types-->
<h3 class="subsection" id="ss:builtin-types"><a class="section-anchor" href="#ss:builtin-types" aria-hidden="true">ï»¿</a>Built-in types</h3><!--SEC END --><pre> type int
</pre><p><a id="hevea_manual6"></a>
</p><blockquote class="quote">
The type of integer numbers.
</blockquote><pre> type char
</pre><p><a id="hevea_manual7"></a>
</p><blockquote class="quote">
The type of characters.
</blockquote><pre> type bytes
</pre><p><a id="hevea_manual8"></a>
</p><blockquote class="quote">
The type of (writable) byte sequences.
</blockquote><pre> type string
</pre><p><a id="hevea_manual9"></a>
</p><blockquote class="quote">
The type of (read-only) character strings.
</blockquote><pre> type float
</pre><p><a id="hevea_manual10"></a>
</p><blockquote class="quote">
The type of floating-point numbers.
</blockquote><pre> type bool = false | true
</pre><p><a id="hevea_manual11"></a>
</p><blockquote class="quote">
The type of booleans (truth values).
</blockquote><pre> type unit = ()
</pre><p><a id="hevea_manual12"></a>
</p><blockquote class="quote">
The type of the unit value.
</blockquote><pre> type exn
</pre><p><a id="hevea_manual13"></a>
</p><blockquote class="quote">
The type of exception values.
</blockquote><pre> type 'a array
</pre><p><a id="hevea_manual14"></a>
</p><blockquote class="quote">
The type of arrays whose elements have type <span class="machine"><span class="font-tt">'a</span></span>.
</blockquote><pre> type 'a list = [] | :: of 'a * 'a list
</pre><p><a id="hevea_manual15"></a>
</p><blockquote class="quote">
The type of lists whose elements have type <span class="machine"><span class="font-tt">'a</span></span>.
</blockquote><pre>type 'a option = None | Some of 'a
</pre><p><a id="hevea_manual16"></a>
</p><blockquote class="quote">
The type of optional values of type <span class="machine"><span class="font-tt">'a</span></span>.
</blockquote><pre>type int32
</pre><p><a id="hevea_manual17"></a>
</p><blockquote class="quote">
The type of signed 32-bit integers.
Literals for 32-bit integers are suffixed by l.
See the <a href="libref/Int32.html"><span class="font-tt">Int32</span></a> module.
</blockquote><pre>type int64
</pre><p><a id="hevea_manual18"></a>
</p><blockquote class="quote">
The type of signed 64-bit integers.
Literals for 64-bit integers are suffixed by L.
See the <a href="libref/Int64.html"><span class="font-tt">Int64</span></a> module.
</blockquote><pre>type nativeint
</pre><p><a id="hevea_manual19"></a>
</p><blockquote class="quote">
The type of signed, platform-native integers (32 bits on 32-bit
processors, 64 bits on 64-bit processors).
Literals for native integers are suffixed by n.
See the <a href="libref/Nativeint.html"><span class="font-tt">Nativeint</span></a> module.
</blockquote><pre>type ('a, 'b, 'c, 'd, 'e, 'f) format6
</pre><p><a id="hevea_manual20"></a>
</p><blockquote class="quote">
The type of format strings. <span class="machine"><span class="font-tt">'a</span></span> is the type of the parameters of
the format, <span class="machine"><span class="font-tt">'f</span></span> is the result type for the <span class="machine"><span class="font-tt">printf</span></span>-style
functions, <span class="machine"><span class="font-tt">'b</span></span> is the type of the first argument given to <span class="machine"><span class="font-tt">%a</span></span> and
<span class="machine"><span class="font-tt">%t</span></span> printing functions (see module <a href="libref/Printf.html"><span class="font-tt">Printf</span></a>),
<span class="machine"><span class="font-tt">'c</span></span> is the result type of these functions, and also the type of the
argument transmitted to the first argument of <span class="machine"><span class="font-tt">kprintf</span></span>-style
functions, <span class="machine"><span class="font-tt">'d</span></span> is the result type for the <span class="machine"><span class="font-tt">scanf</span></span>-style functions
(see module <a href="libref/Scanf.html"><span class="font-tt">Scanf</span></a>), and <span class="machine"><span class="font-tt">'e</span></span> is the type of the receiver function
for the <span class="machine"><span class="font-tt">scanf</span></span>-style functions.
</blockquote><pre>type 'a lazy_t
</pre><p><a id="hevea_manual21"></a>
</p><blockquote class="quote">
This type is used to implement the <a href="libref/Lazy.html"><span class="font-tt">Lazy</span></a> module.
It should not be used directly.
</blockquote><!--TOC subsection id="ss:predef-exn" Predefined exceptions-->
<h3 class="subsection" id="ss:predef-exn"><a class="section-anchor" href="#ss:predef-exn" aria-hidden="true">ï»¿</a>Predefined exceptions</h3><!--SEC END --><pre>exception Match_failure of (string * int * int)
</pre><p><a id="hevea_manual22"></a>
</p><blockquote class="quote">
Exception raised when none of the cases of a pattern-matching
apply. The arguments are the location of the <span class="machine"><span class="font-tt">match</span></span> keyword
in the source code (file name, line number, column number).
</blockquote><pre>exception Assert_failure of (string * int * int)
</pre><p><a id="hevea_manual23"></a>
</p><blockquote class="quote">
Exception raised when an assertion fails. The arguments are
the location of the <span class="machine"><span class="font-tt">assert</span></span> keyword in the source code
(file name, line number, column number).
</blockquote><pre>exception Invalid_argument of string
</pre><p><a id="hevea_manual24"></a>
</p><blockquote class="quote">
Exception raised by library functions to signal that the given
arguments do not make sense. The string gives some information
to the programmer. As a general rule, this exception should not
be caught, it denotes a programming error and the code should be
modified not to trigger it.
</blockquote><pre>exception Failure of string
</pre><p><a id="hevea_manual25"></a>
</p><blockquote class="quote">
Exception raised by library functions to signal that they are
undefined on the given arguments. The string is meant to give some
information to the programmer; you must <em>not</em> pattern match on
the string literal because it may change in future versions (use
<code class="verb">Failure _</code> instead).
</blockquote><pre>exception Not_found
</pre><p><a id="hevea_manual26"></a>
</p><blockquote class="quote">
Exception raised by search functions when the desired object
could not be found.
</blockquote><pre>exception Out_of_memory
</pre><p><a id="hevea_manual27"></a>
</p><blockquote class="quote">
Exception raised by the garbage collector when there is
insufficient memory to complete the computation. (Not reliable for
allocations on the minor heap.)
</blockquote><pre>exception Stack_overflow
</pre><p><a id="hevea_manual28"></a>
</p><blockquote class="quote">
Exception raised by the bytecode interpreter when the evaluation
stack reaches its maximal size. This often indicates infinite or
excessively deep recursion in the userâ€™s program. Before 4.10, it
was not fully implemented by the native-code compiler.
</blockquote><pre>exception Sys_error of string
</pre><p><a id="hevea_manual29"></a>
</p><blockquote class="quote">
Exception raised by the input/output functions to report an
operating system error. The string is meant to give some
information to the programmer; you must <em>not</em> pattern match on
the string literal because it may change in future versions (use
<code class="verb">Sys_error _</code> instead).
</blockquote><pre>exception End_of_file
</pre><p><a id="hevea_manual30"></a>
</p><blockquote class="quote">
Exception raised by input functions to signal that the
end of file has been reached.
</blockquote><pre>exception Division_by_zero
</pre><p><a id="hevea_manual31"></a>
</p><blockquote class="quote">
Exception raised by integer division and remainder operations
when their second argument is zero.
</blockquote><pre>exception Sys_blocked_io
</pre><p><a id="hevea_manual32"></a>
</p><blockquote class="quote">
A special case of <span class="machine"><span class="font-tt">Sys_error</span></span> raised when no I/O is possible
on a non-blocking I/O channel.
</blockquote><pre>exception Undefined_recursive_module of (string * int * int)
</pre><p><a id="hevea_manual33"></a>
</p><blockquote class="quote">
Exception raised when an ill-founded recursive module definition
is evaluated. (See sectionÂ <a href="#s%3Arecursive-modules">12.2</a>.)
The arguments are the location of the definition in the source code
(file name, line number, column number).
</blockquote>
<!--TOC section id="s:stdlib-module" 27.2â€ƒModule <span class="font-tt">Stdlib</span>: the initially opened module-->
<h2 class="section" id="s:stdlib-module"><a class="section-anchor" href="#s:stdlib-module" aria-hidden="true">ï»¿</a>27.2â€ƒModule <span class="font-tt">Stdlib</span>: the initially opened module</h2><!--SEC END --><ul class="ftoc2"><li class="li-links"><a href="libref/Stdlib.html">Module <span class="font-tt">Stdlib</span></a>: the initially opened module
</li></ul>
<!--TOC chapter id="sec633" ChapterÂ 28â€ƒThe standard library-->
<h1 class="chapter" id="sec633">ChapterÂ 28â€ƒThe standard library</h1><!--SEC END --><p> <a id="c:stdlib"></a></p><!--NAME stdlib.html-->
<p>This chapter describes the functions provided by the OCaml
standard library. The modules from the standard library are
automatically linked with the userâ€™s object code files by the <span class="machine"><span class="font-tt">ocamlc</span></span>
command. Hence, these modules can be used in standalone programs without
having to add any <span class="machine"><span class="font-tt">.cmo</span></span> file on the command line for the linking
phase. Similarly, in interactive use, these globals can be used in
toplevel phrases without having to load any <span class="machine"><span class="font-tt">.cmo</span></span> file in memory.</p><p>Unlike the core <span class="machine"><span class="font-tt">Stdlib</span></span> module, submodules are not automatically
â€œopenedâ€ when compilation starts, or when the toplevel system is launched.
Hence it is necessary to use qualified identifiers to refer to the functions
provided by these modules, or to add <span class="machine"><span class="font-tt">open</span></span> directives.</p><p><a id="stdlib:top"></a></p><ul class="ftoc2"><li class="li-links"><a href="libref/Arg.html">Module <span class="font-tt">Arg</span></a>: parsing of command line arguments
</li><li class="li-links"><a href="libref/Array.html">Module <span class="font-tt">Array</span></a>: array operations
</li><li class="li-links"><a href="libref/ArrayLabels.html">Module <span class="font-tt">ArrayLabels</span></a>: array operations (with labels)
</li><li class="li-links"><a href="libref/Atomic.html">Module <span class="font-tt">Atomic</span></a>: atomic references
</li><li class="li-links"><a href="libref/Bigarray.html">Module <span class="font-tt">Bigarray</span></a>: large, multi-dimensional, numerical arrays
</li><li class="li-links"><a href="libref/Bool.html">Module <span class="font-tt">Bool</span></a>: boolean values
</li><li class="li-links"><a href="libref/Buffer.html">Module <span class="font-tt">Buffer</span></a>: extensible buffers
</li><li class="li-links"><a href="libref/Bytes.html">Module <span class="font-tt">Bytes</span></a>: byte sequences
</li><li class="li-links"><a href="libref/BytesLabels.html">Module <span class="font-tt">BytesLabels</span></a>: byte sequences (with labels)
</li><li class="li-links"><a href="libref/Callback.html">Module <span class="font-tt">Callback</span></a>: registering OCaml values with the C runtime
</li><li class="li-links"><a href="libref/Char.html">Module <span class="font-tt">Char</span></a>: character operations
</li><li class="li-links"><a href="libref/Complex.html">Module <span class="font-tt">Complex</span></a>: complex numbers
</li><li class="li-links"><a href="libref/Condition.html">Module <span class="font-tt">Condition</span></a>: condition variables to synchronize between threads
</li><li class="li-links"><a href="libref/Domain.html">Module <span class="font-tt">Domain</span></a>: Domain spawn/join and domain local variables
</li><li class="li-links"><a href="libref/Digest.html">Module <span class="font-tt">Digest</span></a>: MD5 message digest
</li><li class="li-links"><a href="libref/Effect.html">Module <span class="font-tt">Effect</span></a>: deep and shallow effect handlers
</li><li class="li-links"><a href="libref/Either.html">Module <span class="font-tt">Either</span></a>: either values
</li><li class="li-links"><a href="libref/Ephemeron.html">Module <span class="font-tt">Ephemeron</span></a>: Ephemerons and weak hash table
</li><li class="li-links"><a href="libref/Filename.html">Module <span class="font-tt">Filename</span></a>: operations on file names
</li><li class="li-links"><a href="libref/Float.html">Module <span class="font-tt">Float</span></a>: floating-point numbers
</li><li class="li-links"><a href="libref/Format.html">Module <span class="font-tt">Format</span></a>: pretty printing
</li><li class="li-links"><a href="libref/Fun.html">Module <span class="font-tt">Fun</span></a>: function values
</li><li class="li-links"><a href="libref/Gc.html">Module <span class="font-tt">Gc</span></a>: memory management control and statistics; finalized values
</li><li class="li-links"><a href="libref/Hashtbl.html">Module <span class="font-tt">Hashtbl</span></a>: hash tables and hash functions
</li><li class="li-links"><a href="libref/In_channel.html">Module <span class="font-tt">In_channel</span></a>: input channels
</li><li class="li-links"><a href="libref/Int.html">Module <span class="font-tt">Int</span></a>: integers
</li><li class="li-links"><a href="libref/Int32.html">Module <span class="font-tt">Int32</span></a>: 32-bit integers
</li><li class="li-links"><a href="libref/Int64.html">Module <span class="font-tt">Int64</span></a>: 64-bit integers
</li><li class="li-links"><a href="libref/Lazy.html">Module <span class="font-tt">Lazy</span></a>: deferred computations
</li><li class="li-links"><a href="libref/Lexing.html">Module <span class="font-tt">Lexing</span></a>: the run-time library for lexers generated by <span class="font-tt">ocamllex</span>
</li><li class="li-links"><a href="libref/List.html">Module <span class="font-tt">List</span></a>: list operations
</li><li class="li-links"><a href="libref/ListLabels.html">Module <span class="font-tt">ListLabels</span></a>: list operations (with labels)
</li><li class="li-links"><a href="libref/Map.html">Module <span class="font-tt">Map</span></a>: association tables over ordered types
</li><li class="li-links"><a href="libref/Marshal.html">Module <span class="font-tt">Marshal</span></a>: marshaling of data structures
</li><li class="li-links"><a href="libref/MoreLabels.html">Module <span class="font-tt">MoreLabels</span></a>: include modules <span class="font-tt">Hashtbl</span>, <span class="font-tt">Map</span> and <span class="font-tt">Set</span> with labels
</li><li class="li-links"><a href="libref/Mutex.html">Module <span class="font-tt">Mutex</span></a>: locks for mutual exclusion
</li><li class="li-links"><a href="libref/Nativeint.html">Module <span class="font-tt">Nativeint</span></a>: processor-native integers
</li><li class="li-links"><a href="libref/Oo.html">Module <span class="font-tt">Oo</span></a>: object-oriented extension
</li><li class="li-links"><a href="libref/Option.html">Module <span class="font-tt">Option</span></a>: option values
</li><li class="li-links"><a href="libref/Out_channel.html">Module <span class="font-tt">Out_channel</span></a>: output channels
</li><li class="li-links"><a href="libref/Parsing.html">Module <span class="font-tt">Parsing</span></a>: the run-time library for parsers generated by <span class="font-tt">ocamlyacc</span>
</li><li class="li-links"><a href="libref/Printexc.html">Module <span class="font-tt">Printexc</span></a>: facilities for printing exceptions
</li><li class="li-links"><a href="libref/Printf.html">Module <span class="font-tt">Printf</span></a>: formatting printing functions
</li><li class="li-links"><a href="libref/Queue.html">Module <span class="font-tt">Queue</span></a>: first-in first-out queues
</li><li class="li-links"><a href="libref/Random.html">Module <span class="font-tt">Random</span></a>: pseudo-random number generator (PRNG)
</li><li class="li-links"><a href="libref/Result.html">Module <span class="font-tt">Result</span></a>: result values
</li><li class="li-links"><a href="libref/Runtime_events.html">Module <span class="font-tt">Runtime_events</span></a>: Runtime event tracing
</li><li class="li-links"><a href="libref/Scanf.html">Module <span class="font-tt">Scanf</span></a>: formatted input functions
</li><li class="li-links"><a href="libref/Seq.html">Module <span class="font-tt">Seq</span></a>: functional iterators
</li><li class="li-links"><a href="libref/Set.html">Module <span class="font-tt">Set</span></a>: sets over ordered types
</li><li class="li-links"><a href="libref/Semaphore.html">Module <span class="font-tt">Semaphore</span></a>: semaphores, another thread synchronization mechanism
</li><li class="li-links"><a href="libref/Stack.html">Module <span class="font-tt">Stack</span></a>: last-in first-out stacks
</li><li class="li-links"><a href="libref/StdLabels.html">Module <span class="font-tt">StdLabels</span></a>: include modules <span class="font-tt">Array</span>, <span class="font-tt">List</span> and <span class="font-tt">String</span> with labels
</li><li class="li-links"><a href="libref/String.html">Module <span class="font-tt">String</span></a>: string operations
</li><li class="li-links"><a href="libref/StringLabels.html">Module <span class="font-tt">StringLabels</span></a>: string operations (with labels)
</li><li class="li-links"><a href="libref/Sys.html">Module <span class="font-tt">Sys</span></a>: system interface
</li><li class="li-links"><a href="libref/Uchar.html">Module <span class="font-tt">Uchar</span></a>: Unicode characters
</li><li class="li-links"><a href="libref/Unit.html">Module <span class="font-tt">Unit</span></a>: unit values
</li><li class="li-links"><a href="libref/Weak.html">Module <span class="font-tt">Weak</span></a>: arrays of weak pointers
</li></ul>
<!--TOC chapter id="sec634" ChapterÂ 29â€ƒThe compiler front-end-->
<h1 class="chapter" id="sec634">ChapterÂ 29â€ƒThe compiler front-end</h1><!--SEC END --><p> <a id="c:parsinglib"></a></p><!--NAME parsing.html-->
<p>
<a id="Compiler-underscorelibs"></a> </p><p>This chapter describes the OCaml front-end, which declares the abstract
syntax tree used by the compiler, provides a way to parse, print
and pretty-print OCaml code, and ultimately allows one to write abstract
syntax tree preprocessors invoked via the <span class="font-tt">-ppx</span> flag (see chaptersÂ <a href="#c%3Acamlc">13</a>
andÂ <a href="#c%3Anativecomp">16</a>).</p><p>It is important to note that the exported front-end interface follows the evolution of the OCaml language and implementation, and thus does not provide <span class="font-bold">any</span> backwards compatibility guarantees.</p><p>The front-end is a part of <span class="machine"><span class="font-tt">compiler-libs</span></span> library.
Programs that use the <span class="machine"><span class="font-tt">compiler-libs</span></span> library should be built as follows:
</p><pre>
        ocamlfind ocamlc <span class="font-it">other options</span> -package compiler-libs.common <span class="font-it">other files</span>
        ocamlfind ocamlopt <span class="font-it">other options</span> -package compiler-libs.common <span class="font-it">other files</span>
</pre><p>
Use of the <span class="font-tt">ocamlfind</span> utility is recommended. However, if this is not possible, an alternative method may be used:
</p><pre>
        ocamlc <span class="font-it">other options</span> -I +compiler-libs ocamlcommon.cma <span class="font-it">other files</span>
        ocamlopt <span class="font-it">other options</span> -I +compiler-libs ocamlcommon.cmxa <span class="font-it">other files</span>
</pre><p>
For interactive use of the <span class="machine"><span class="font-tt">compiler-libs</span></span> library, start <span class="machine"><span class="font-tt">ocaml</span></span> and
type<br>
<span class="machine"><span class="font-tt">#load "compiler-libs/ocamlcommon.cma";;</span></span>.</p><ul class="ftoc2"><li class="li-links"><a href="compilerlibref/Ast_helper.html">Module <span class="font-tt">Ast_helper</span></a>: helper functions for AST construction
</li><li class="li-links"><a href="compilerlibref/Ast_mapper.html">Module <span class="font-tt">Ast_mapper</span></a>: -ppx rewriter interface
</li><li class="li-links"><a href="compilerlibref/Asttypes.html">Module <span class="font-tt">Asttypes</span></a>: auxiliary types used by Parsetree
</li><li class="li-links"><a href="compilerlibref/Location.html">Module <span class="font-tt">Location</span></a>: source code locations
</li><li class="li-links"><a href="compilerlibref/Longident.html">Module <span class="font-tt">Longident</span></a>: long identifiers
</li><li class="li-links"><a href="compilerlibref/Parse.html">Module <span class="font-tt">Parse</span></a>: OCaml syntax parsing
</li><li class="li-links"><a href="compilerlibref/Parsetree.html">Module <span class="font-tt">Parsetree</span></a>: OCaml syntax tree
</li><li class="li-links"><a href="compilerlibref/Pprintast.html">Module <span class="font-tt">Pprintast</span></a>: OCaml syntax printing
</li></ul>
<!--TOC chapter id="sec635" ChapterÂ 30â€ƒThe unix library: Unix system calls-->
<h1 class="chapter" id="sec635">ChapterÂ 30â€ƒThe unix library: Unix system calls</h1><!--SEC END --><!--NAME libunix.html-->
<p>
<a id="c:unix"></a></p><p>The <span class="machine"><span class="font-tt">unix</span></span> library makes many Unix
system calls and system-related library functions available to
OCaml programs. This chapter describes briefly the functions
provided. Refer to sections 2Â andÂ 3 of the Unix manual for more
details on the behavior of these functions.</p><ul class="ftoc2"><li class="li-links"><a href="libref/Unix.html">Module <span class="font-tt">Unix</span></a>: Unix system calls
</li><li class="li-links"><a href="libref/UnixLabels.html">Module <span class="font-tt">UnixLabels</span></a>: Labeled Unix system calls
</li></ul><p>Not all functions are provided by all Unix variants. If some functions
are not available, they will raise <span class="machine"><span class="font-tt">Invalid_arg</span></span> when called.</p><p>Programs that use the <span class="machine"><span class="font-tt">unix</span></span> library must be linked as follows:
</p><pre>
        ocamlc <span class="font-it">other options</span> -I +unix unix.cma <span class="font-it">other files</span>
        ocamlopt <span class="font-it">other options</span>  -I +unix unix.cmxa <span class="font-it">other files</span>
</pre><p>
For interactive use of the <span class="machine"><span class="font-tt">unix</span></span> library, do:
</p><pre>
        ocamlmktop -o mytop -I +unix unix.cma
        ./mytop
</pre><p>
or (if dynamic linking of C libraries is supported on your platform),
start <span class="machine"><span class="font-tt">ocaml</span></span> and type</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> #directory <span class="ocamlstring">"+unix"</span>;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> #load <span class="ocamlstring">"unix.cma"</span>;;</div></div>

</div><blockquote class="quote"><span class="osvariant">Windows:</span>â€ƒ
The Cygwin port of OCaml fully implements all functions from
the Unix module. The native Win32 ports implement a subset of them.
Below is a list of the functions that are not implemented, or only
partially implemented, by the Win32 ports. Functions not mentioned are
fully implemented and behave as described previously in this chapter.
</blockquote><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border=1><tr><td class="c004"><span class="font-bold">Functions</span></td><td class="c004"><span class="font-bold">Comment</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">fork</span></span></td><td class="c011">not implemented, use <span class="machine"><span class="font-tt">create_process</span></span> or threads </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">wait</span></span></td><td class="c011">not implemented, use <span class="machine"><span class="font-tt">waitpid</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">waitpid</span></span></td><td class="c011">can only wait for a given PID, not any child process </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getppid</span></span></td><td class="c011">not implemented (meaningless under Windows) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">nice</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">truncate</span></span>, <span class="machine"><span class="font-tt">ftruncate</span></span></td><td class="c011">implemented (since 4.10.0) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">link</span></span></td><td class="c011">implemented (since 3.02) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">fchmod</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">chown</span></span>, <span class="machine"><span class="font-tt">fchown</span></span></td><td class="c011">not implemented (make no sense on a DOS
file system) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">umask</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">access</span></span></td><td class="c011">execute permission <span class="machine"><span class="font-tt">X_OK</span></span> cannot be tested,
it just tests for read permission instead </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">chroot</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">mkfifo</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">symlink</span></span>, <span class="machine"><span class="font-tt">readlink</span></span></td><td class="c011">implemented (since 4.03.0) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">kill</span></span></td><td class="c011">partially implemented (since 4.00.0): only the <span class="machine"><span class="font-tt">sigkill</span></span> signal
is implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">sigprocmask</span></span>, <span class="machine"><span class="font-tt">sigpending</span></span>, <span class="machine"><span class="font-tt">sigsuspend</span></span></td><td class="c011">not implemented (no inter-process signals on Windows </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">pause</span></span></td><td class="c011">not implemented (no inter-process signals in Windows) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">alarm</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">times</span></span></td><td class="c011">partially implemented, will not report timings for child
processes </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getitimer</span></span>, <span class="machine"><span class="font-tt">setitimer</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getuid</span></span>, <span class="machine"><span class="font-tt">geteuid</span></span>, <span class="machine"><span class="font-tt">getgid</span></span>, <span class="machine"><span class="font-tt">getegid</span></span></td><td class="c011">always return 1 </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">setuid</span></span>, <span class="machine"><span class="font-tt">setgid</span></span>, <span class="machine"><span class="font-tt">setgroups</span></span>, <span class="machine"><span class="font-tt">initgroups</span></span></td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getgroups</span></span></td><td class="c011">always returns <span class="machine"><span class="font-tt">[|1|]</span></span> (since 2.00) </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getpwnam</span></span>, <span class="machine"><span class="font-tt">getpwuid</span></span></td><td class="c011">always raise <span class="machine"><span class="font-tt">Not_found</span></span> </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">getgrnam</span></span>, <span class="machine"><span class="font-tt">getgrgid</span></span></td><td class="c011">always raise <span class="machine"><span class="font-tt">Not_found</span></span> </td></tr>
<tr><td class="c012">type <span class="machine"><span class="font-tt">socket_domain</span></span></td><td class="c011"><span class="machine"><span class="font-tt">PF_INET</span></span> is fully supported;
<span class="machine"><span class="font-tt">PF_INET6</span></span> is fully supported (since 4.01.0); <span class="machine"><span class="font-tt">PF_UNIX</span></span> is supported since 4.14.0, but only works on Windows 10 1803 and later. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">establish_server</span></span></td><td class="c011">not implemented; use threads </td></tr>
<tr><td class="c012">terminal functions (<span class="machine"><span class="font-tt">tc*</span></span>)</td><td class="c011">not implemented </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">setsid</span></span></td><td class="c011">not implemented </td></tr>
</table></div></div>
<!--TOC chapter id="sec636" ChapterÂ 31â€ƒThe str library: regular expressions and string processing-->
<h1 class="chapter" id="sec636">ChapterÂ 31â€ƒThe str library: regular expressions and string processing</h1><!--SEC END --><!--NAME libstr.html-->
<p>The <span class="machine"><span class="font-tt">str</span></span> library provides high-level string processing functions,
some based on regular expressions. It is intended to support the kind
of file processing that is usually performed with scripting languages
such as <span class="machine"><span class="font-tt">awk</span></span>, <span class="machine"><span class="font-tt">perl</span></span> or <span class="machine"><span class="font-tt">sed</span></span>.</p><p>Programs that use the <span class="machine"><span class="font-tt">str</span></span> library must be linked as follows:
</p><pre>
        ocamlc <span class="font-it">other options</span> -I +str str.cma <span class="font-it">other files</span>
        ocamlopt <span class="font-it">other options</span>  -I +str str.cmxa <span class="font-it">other files</span>
</pre><p>
For interactive use of the <span class="machine"><span class="font-tt">str</span></span> library, do:
</p><pre>
        ocamlmktop -o mytop str.cma
        ./mytop
</pre><p>
or (if dynamic linking of C libraries is supported on your platform),
start <span class="machine"><span class="font-tt">ocaml</span></span> and type

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> #directory <span class="ocamlstring">"+str"</span>;;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> #load  <span class="ocamlstring">"str.cma"</span>;;</div></div>

</div><ul class="ftoc2"><li class="li-links"><a href="libref/Str.html">Module <span class="font-tt">Str</span></a>: regular expressions and string processing
</li></ul>
<!--TOC chapter id="sec637" ChapterÂ 32â€ƒThe runtime_events library-->
<h1 class="chapter" id="sec637">ChapterÂ 32â€ƒThe runtime_events library</h1><!--SEC END --><p>
<a id="c:runtime_events"></a></p><!--NAME runtime_events.html-->
<!--NAME runtime_events.html-->
<p>The <span class="machine"><span class="font-tt">runtime_events</span></span> library provides an API for consuming runtime tracing and
metrics information from the runtime. See chapterÂ <a href="#c%3Aruntime-tracing">25</a> for
more information.</p><p>Programs that use runtime_events must be linked as follows:
</p><pre>
        ocamlc -I +runtime_events <span class="font-it">other options</span> unix.cma runtime_events.cma <span class="font-it">other files</span>
        ocamlopt -I +runtime_events <span class="font-it">other options</span> unix.cmxa runtime_events.cmxa <span class="font-it">other files</span>
</pre><p>
Compilation units that use the runtime_events library must also be compiled with
the <span class="machine"><span class="font-tt">-I +runtime_events</span></span> option (see chapterÂ <a href="#c%3Acamlc">13</a>).</p><ul class="ftoc2"><li class="li-links"><a href="libref/Runtime_events.html">Module <span class="font-tt">Runtime_events</span></a>: tracing system
</li></ul>
<!--TOC chapter id="sec638" ChapterÂ 33â€ƒThe threads library-->
<h1 class="chapter" id="sec638">ChapterÂ 33â€ƒThe threads library</h1><!--SEC END --><p>
<a id="c:threads"></a></p><!--NAME threads.html-->
<!--NAME libthreads.html-->
<p>The <span class="machine"><span class="font-tt">threads</span></span> library allows concurrent programming in OCaml. It provides
multiple threads of control (also called lightweight processes) that execute
concurrently in the same memory space. Threads communicate by in-place
modification of shared data structures, or by sending and receiving data on
communication channels.</p><p>The <span class="machine"><span class="font-tt">threads</span></span> library is implemented on top of the threading facilities
provided by the operating system: POSIX 1003.1c threads for Linux, MacOS, and
other Unix-like systems; Win32 threads for Windows. Only one thread at a time
is allowed to run OCaml code on a particular
domainÂ <a href="#s%3Apar_systhread_interaction">9.5.1</a>. Hence, opportunities for parallelism
are limited to the parts of the program that run system or C library code.
However, threads provide concurrency and can be used to structure programs as
several communicating processes. Threads also efficiently support concurrent,
overlapping I/O operations.</p><p>Programs that use threads must be linked as follows:
</p><pre>
        ocamlc -I +unix -I +threads <span class="font-it">other options</span> unix.cma threads.cma <span class="font-it">other files</span>
        ocamlopt -I +unix -I +threads <span class="font-it">other options</span> unix.cmxa threads.cmxa <span class="font-it">other files</span>
</pre><p>
Compilation units that use the <span class="machine"><span class="font-tt">threads</span></span> library must also be compiled with
the <span class="machine"><span class="font-tt">-I +threads</span></span> option (see chapterÂ <a href="#c%3Acamlc">13</a>).</p><ul class="ftoc2"><li class="li-links"><a href="libref/Thread.html">Module <span class="font-tt">Thread</span></a>: lightweight threads
</li><li class="li-links"><a href="libref/Event.html">Module <span class="font-tt">Event</span></a>: first-class synchronous communication
</li></ul>
<!--TOC chapter id="sec639" ChapterÂ 34â€ƒThe dynlink library: dynamic loading and linking of object files-->
<h1 class="chapter" id="sec639">ChapterÂ 34â€ƒThe dynlink library: dynamic loading and linking of object files</h1><!--SEC END --><!--NAME libdynlink.html-->
<p>The <span class="machine"><span class="font-tt">dynlink</span></span> library supports type-safe dynamic loading and linking
of bytecode object files (<span class="machine"><span class="font-tt">.cmo</span></span> and <span class="machine"><span class="font-tt">.cma</span></span> files) in a running
bytecode program, or of native plugins (usually <span class="machine"><span class="font-tt">.cmxs</span></span> files) in a
running native program. Type safety is ensured by limiting the set of
modules from the running program that the loaded object file can
access, and checking that the running program and the loaded object
file have been compiled against the same interfaces for these modules.
In native code, there are also some compatibility checks on the
implementations (to avoid errors with cross-module optimizations); it
might be useful to hide <span class="machine"><span class="font-tt">.cmx</span></span> files when building native plugins so
that they remain independent of the implementation of modules in the
main program.</p><p>Programs that use the <span class="machine"><span class="font-tt">dynlink</span></span> library simply need to include
the dynlink library directory with <span class="machine"><span class="font-tt">-I +dynlink</span></span> and link
<span class="machine"><span class="font-tt">dynlink.cma</span></span> or <span class="machine"><span class="font-tt">dynlink.cmxa</span></span> with their object files and other libraries.</p><p><span class="font-bold">Note:</span> in order to insure that the dynamically-loaded modules have
access to all the libraries that are visible to the main program (and not just
to the parts of those libraries that are actually used in the main program),
programs using the <span class="machine"><span class="font-tt">dynlink</span></span> library should be linked with <span class="machine"><span class="font-tt">-linkall</span></span>.</p><ul class="ftoc2"><li class="li-links"><a href="libref/Dynlink.html">Module <span class="font-tt">Dynlink</span></a>: dynamic loading of bytecode object files
</li></ul>
<!--TOC chapter id="sec640" ChapterÂ 35â€ƒRecently removed or moved libraries (Graphics, Bigarray, Num, LablTk)-->
<h1 class="chapter" id="sec640">ChapterÂ 35â€ƒRecently removed or moved libraries (Graphics, Bigarray, Num, LablTk)</h1><!--SEC END --><!--NAME old.html-->
<p>This chapter describes three libraries which were formerly part of the OCaml
distribution (Graphics, Num, and LablTk), and a library which has now become
part of OCamlâ€™s standard library, and is documented there (Bigarray).</p>
<!--TOC section id="s:graphics-removed" 35.1â€ƒThe Graphics Library-->
<h2 class="section" id="s:graphics-removed"><a class="section-anchor" href="#s:graphics-removed" aria-hidden="true">ï»¿</a>35.1â€ƒThe Graphics Library</h2><!--SEC END --><p>Since OCaml 4.09, the <span class="machine"><span class="font-tt">graphics</span></span> library is distributed as an external
package. Its new home is:</p><p><a href="https://github.com/ocaml/graphics"><span class="font-tt">https://github.com/ocaml/graphics</span></a></p><p>If you are using the opam package manager, you should install the
corresponding <span class="machine"><span class="font-tt">graphics</span></span> package:</p><pre>
        opam install graphics
</pre><p>Before OCaml 4.09, this package simply ensures that the <span class="machine"><span class="font-tt">graphics</span></span>
library was installed by the compiler, and starting from OCaml 4.09
this package effectively provides the <span class="machine"><span class="font-tt">graphics</span></span> library.</p>
<!--TOC section id="s:bigarray-moved" 35.2â€ƒThe Bigarray Library-->
<h2 class="section" id="s:bigarray-moved"><a class="section-anchor" href="#s:bigarray-moved" aria-hidden="true">ï»¿</a>35.2â€ƒThe Bigarray Library</h2><!--SEC END --><p>As of OCaml 4.07, the <span class="machine"><span class="font-tt">bigarray</span></span> library has been integrated into OCamlâ€™s
standard library.</p><p>The <span class="machine"><span class="font-tt">bigarray</span></span> functionality may now be found in the standard library
<a href="libref/Bigarray.html"><span class="font-tt">Bigarray</span> module</a>,
except for the <span class="machine"><span class="font-tt">map_file</span></span> function which is now
part of the <a href="#c%3Aunix">Unix library</a>. The documentation has
been integrated into the documentation for the standard library.</p><p>The legacy <span class="machine"><span class="font-tt">bigarray</span></span> library bundled with the compiler is a
compatibility library with exactly the same interface as before,
i.e. with <span class="machine"><span class="font-tt">map_file</span></span> included.</p><p>We strongly recommend that you port your code to use the standard
library version instead, as the changes required are minimal.</p><p>If you choose to use the compatibility library, you must link your
programs as follows:
</p><pre>
        ocamlc <span class="font-it">other options</span> bigarray.cma <span class="font-it">other files</span>
        ocamlopt <span class="font-it">other options</span> bigarray.cmxa <span class="font-it">other files</span>
</pre><p>
For interactive use of the <span class="machine"><span class="font-tt">bigarray</span></span> compatibility library, do:
</p><pre>
        ocamlmktop -o mytop bigarray.cma
        ./mytop
</pre><p>
or (if dynamic linking of C libraries is supported on your platform),
start <span class="machine"><span class="font-tt">ocaml</span></span> and type <span class="machine"><span class="font-tt">#load "bigarray.cma";;</span></span>.</p>
<!--TOC section id="sec643" 35.3â€ƒThe Num Library-->
<h2 class="section" id="sec643"><a class="section-anchor" href="#sec643" aria-hidden="true">ï»¿</a>35.3â€ƒThe Num Library</h2><!--SEC END --><p>The <span class="machine"><span class="font-tt">num</span></span> library implements integer arithmetic and rational
arithmetic in arbitrary precision. It was split off the core
OCaml distribution starting with the 4.06.0 release, and can now be found
at <a href="https://github.com/ocaml/num"><span class="font-tt">https://github.com/ocaml/num</span></a>.</p><p>New applications that need arbitrary-precision arithmetic should use the
<span class="machine"><span class="font-tt">Zarith</span></span> library (<a href="https://github.com/ocaml/Zarith"><span class="font-tt">https://github.com/ocaml/Zarith</span></a>) instead of the <span class="machine"><span class="font-tt">Num</span></span>
library, and older applications that already use <span class="machine"><span class="font-tt">Num</span></span> are encouraged to
switch to <span class="machine"><span class="font-tt">Zarith</span></span>. <span class="machine"><span class="font-tt">Zarith</span></span> delivers much better performance than <span class="machine"><span class="font-tt">Num</span></span>
and has a nicer API.</p>
<!--TOC section id="s:labltk-removed" 35.4â€ƒThe Labltk Library and OCamlBrowser-->
<h2 class="section" id="s:labltk-removed"><a class="section-anchor" href="#s:labltk-removed" aria-hidden="true">ï»¿</a>35.4â€ƒThe Labltk Library and OCamlBrowser</h2><!--SEC END --><p>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library
are distributed separately from the OCaml compiler. The project is now
hosted at <a href="https://github.com/garrigue/labltk"><span class="font-tt">https://github.com/garrigue/labltk</span></a>.
</p>
<!--TOC part id="sec645" PartÂ Vâ€ƒIndexes-->
<table class="center"><tr><td><h1 class="part" id="sec645">PartÂ V<br>
Indexes</h1></td></tr>
</table><!--SEC END --><p>
<a id="p:indexes"></a></p><ul class="ftoc2"><li class="li-links"><a href="libref/index_modules.html">Index of modules</a>
</li><li class="li-links"><a href="libref/index_module_types.html">Index of module types</a>
</li><li class="li-links"><a href="libref/index_types.html">Index of types</a>
</li><li class="li-links"><a href="libref/index_exceptions.html">Index of exceptions</a>
</li><li class="li-links"><a href="libref/index_values.html">Index of values</a>
</li></ul><p>
<a id="section@the@hevea@index@manual.kwd"></a></p><!--TOC chapter id="sec646" Index of keywords-->
<h1 class="chapter" id="sec646">Index of keywords</h1><!--SEC END --><div class="theindex"><table class="c001 cellpading0"><tr><td class="c010">
<ul class="indexenv"><li class="li-indexenv"><span class="font-tt">and</span>, <a href="#hevea_manual.kwd21">11.7</a>, <a href="#hevea_manual.kwd93">11.8.1</a>, <a href="#hevea_manual.kwd122">11.9.2</a>, <a href="#hevea_manual.kwd144">11.9.3</a>, <a href="#hevea_manual.kwd146">11.9.4</a>, <a href="#hevea_manual.kwd149">11.9.5</a>, <a href="#hevea_manual.kwd154">11.10</a>, <a href="#hevea_manual.kwd183">11.11</a>, <a href="#hevea_manual.kwd207">12.2</a>, <a href="#hevea_manual.kwd215">12.5</a>
</li><li class="li-indexenv"><span class="font-tt">as</span>, <a href="#hevea_manual.kwd7">11.4</a>, <a href="#hevea_manual.kwd8">11.4</a>, <a href="#hevea_manual.kwd9">11.4</a>, <a href="#hevea_manual.kwd15">11.6</a>, <a href="#hevea_manual.kwd16">11.6</a>, <a href="#hevea_manual.kwd17">11.6</a>, <a href="#hevea_manual.kwd124">11.9.2</a>, <a href="#hevea_manual.kwd132">11.9.2</a>
</li><li class="li-indexenv"><span class="font-tt">asr</span>, <a href="#hevea_manual.kwd6">11.3</a>, <a href="#hevea_manual.kwd57">11.7.1</a>, <a href="#hevea_manual.kwd76">11.7.5</a>, <a href="#hevea_manual.kwd83">11.7.5</a>
</li><li class="li-indexenv"><span class="font-tt">assert</span>, <a href="#hevea_manual.kwd86">11.7.8</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">begin</span>, <a href="#hevea_manual.kwd13">11.5</a>, <a href="#hevea_manual.kwd38">11.7</a>, <a href="#hevea_manual.kwd58">11.7.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">class</span>, <a href="#hevea_manual.kwd143">11.9.3</a>, <a href="#hevea_manual.kwd145">11.9.4</a>, <a href="#hevea_manual.kwd147">11.9.5</a>, <a href="#hevea_manual.kwd159">11.10</a>, <a href="#hevea_manual.kwd169">11.10.2</a>, <a href="#hevea_manual.kwd170">11.10.2</a>, <a href="#hevea_manual.kwd187">11.11</a>, <a href="#hevea_manual.kwd197">11.11.2</a>, <a href="#hevea_manual.kwd198">11.11.2</a>
</li><li class="li-indexenv"><span class="font-tt">constraint</span>, <a href="#hevea_manual.kwd97">11.8.1</a>, <a href="#hevea_manual.kwd99">11.8.1</a>, <a href="#hevea_manual.kwd109">11.9.1</a>, <a href="#hevea_manual.kwd117">11.9.1</a>, <a href="#hevea_manual.kwd129">11.9.2</a>, <a href="#hevea_manual.kwd141">11.9.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">do</span>, see <span class="font-it"><span class="font-tt">while</span>, <span class="font-tt">for</span></span>
</li><li class="li-indexenv"><span class="font-tt">done</span>, see <span class="font-it"><span class="font-tt">while</span>, <span class="font-tt">for</span></span>
</li><li class="li-indexenv"><span class="font-tt">downto</span>, see <span class="font-it"><span class="font-tt">for</span></span>
<br>
</li><li class="li-indexenv"><span class="font-tt">else</span>, see <span class="font-it"><span class="font-tt">if</span></span>
</li><li class="li-indexenv"><span class="font-tt">end</span>, <a href="#hevea_manual.kwd14">11.5</a>, <a href="#hevea_manual.kwd39">11.7</a>, <a href="#hevea_manual.kwd59">11.7.2</a>, <a href="#hevea_manual.kwd102">11.9.1</a>, <a href="#hevea_manual.kwd119">11.9.2</a>, <a href="#hevea_manual.kwd151">11.10</a>, <a href="#hevea_manual.kwd164">11.10.2</a>, <a href="#hevea_manual.kwd180">11.11</a>, <a href="#hevea_manual.kwd192">11.11.2</a>
</li><li class="li-indexenv"><span class="font-tt">exception</span>, <a href="#hevea_manual.kwd100">11.8.2</a>, <a href="#hevea_manual.kwd158">11.10</a>, <a href="#hevea_manual.kwd168">11.10.2</a>, <a href="#hevea_manual.kwd186">11.11</a>, <a href="#hevea_manual.kwd196">11.11.2</a>
</li><li class="li-indexenv"><span class="font-tt">external</span>, <a href="#hevea_manual.kwd156">11.10</a>, <a href="#hevea_manual.kwd166">11.10.2</a>, <a href="#hevea_manual.kwd184">11.11</a>, <a href="#hevea_manual.kwd194">11.11.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">false</span>, <a href="#hevea_manual.kwd11">11.5</a>
</li><li class="li-indexenv"><span class="font-tt">for</span>, <a href="#hevea_manual.kwd32">11.7</a>, <a href="#hevea_manual.kwd68">11.7.3</a>
</li><li class="li-indexenv"><span class="font-tt">fun</span>, <a href="#hevea_manual.kwd26">11.7</a>, <a href="#hevea_manual.kwd46">11.7.1</a>, <a href="#hevea_manual.kwd61">11.7.2</a>, <a href="#hevea_manual.kwd120">11.9.2</a>, <a href="#hevea_manual.kwd211">12.4</a>
</li><li class="li-indexenv"><span class="font-tt">function</span>, <a href="#hevea_manual.kwd25">11.7</a>, <a href="#hevea_manual.kwd47">11.7.1</a>, <a href="#hevea_manual.kwd60">11.7.2</a>
</li><li class="li-indexenv"><span class="font-tt">functor</span>, <a href="#hevea_manual.kwd152">11.10</a>, <a href="#hevea_manual.kwd177">11.10.3</a>, <a href="#hevea_manual.kwd181">11.11</a>, <a href="#hevea_manual.kwd205">11.11.3</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">if</span>, <a href="#hevea_manual.kwd35">11.7</a>, <a href="#hevea_manual.kwd45">11.7.1</a>, <a href="#hevea_manual.kwd64">11.7.3</a>
</li><li class="li-indexenv"><span class="font-tt">in</span>, see <span class="font-it"><span class="font-tt">let</span></span>
</li><li class="li-indexenv"><span class="font-tt">include</span>, <a href="#hevea_manual.kwd162">11.10</a>, <a href="#hevea_manual.kwd176">11.10.2</a>, <a href="#hevea_manual.kwd190">11.11</a>, <a href="#hevea_manual.kwd204">11.11.2</a>, <a href="#hevea_manual.kwd219">12.6</a>
</li><li class="li-indexenv"><span class="font-tt">inherit</span>, <a href="#hevea_manual.kwd103">11.9.1</a>, <a href="#hevea_manual.kwd110">11.9.1</a>, <a href="#hevea_manual.kwd123">11.9.2</a>, <a href="#hevea_manual.kwd131">11.9.2</a>
</li><li class="li-indexenv"><span class="font-tt">initializer</span>, <a href="#hevea_manual.kwd130">11.9.2</a>, <a href="#hevea_manual.kwd142">11.9.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">land</span>, <a href="#hevea_manual.kwd1">11.3</a>, <a href="#hevea_manual.kwd52">11.7.1</a>, <a href="#hevea_manual.kwd71">11.7.5</a>, <a href="#hevea_manual.kwd78">11.7.5</a>
</li><li class="li-indexenv"><span class="font-tt">lazy</span>, <a href="#hevea_manual.kwd18">11.6</a>, <a href="#hevea_manual.kwd43">11.7</a>, <a href="#hevea_manual.kwd87">11.7.8</a>
</li><li class="li-indexenv"><span class="font-tt">let</span>, <a href="#hevea_manual.kwd23">11.7</a>, <a href="#hevea_manual.kwd50">11.7.1</a>, <a href="#hevea_manual.kwd63">11.7.2</a>, <a href="#hevea_manual.kwd88">11.7.8</a>, <a href="#hevea_manual.kwd90">11.7.8</a>, <a href="#hevea_manual.kwd121">11.9.2</a>, <a href="#hevea_manual.kwd182">11.11</a>, <a href="#hevea_manual.kwd193">11.11.2</a>
</li><li class="li-indexenv"><span class="font-tt">lor</span>, <a href="#hevea_manual.kwd2">11.3</a>, <a href="#hevea_manual.kwd53">11.7.1</a>, <a href="#hevea_manual.kwd72">11.7.5</a>, <a href="#hevea_manual.kwd79">11.7.5</a>
</li><li class="li-indexenv"><span class="font-tt">lsl</span>, <a href="#hevea_manual.kwd4">11.3</a>, <a href="#hevea_manual.kwd55">11.7.1</a>, <a href="#hevea_manual.kwd74">11.7.5</a>, <a href="#hevea_manual.kwd81">11.7.5</a>
</li><li class="li-indexenv"><span class="font-tt">lsr</span>, <a href="#hevea_manual.kwd5">11.3</a>, <a href="#hevea_manual.kwd56">11.7.1</a>, <a href="#hevea_manual.kwd75">11.7.5</a>, <a href="#hevea_manual.kwd82">11.7.5</a>
</li></ul></td><td class="c010"><ul class="indexenv"><li class="li-indexenv"><span class="font-tt">lxor</span>, <a href="#hevea_manual.kwd3">11.3</a>, <a href="#hevea_manual.kwd54">11.7.1</a>, <a href="#hevea_manual.kwd73">11.7.5</a>, <a href="#hevea_manual.kwd80">11.7.5</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">match</span>, <a href="#hevea_manual.kwd37">11.7</a>, <a href="#hevea_manual.kwd48">11.7.1</a>, <a href="#hevea_manual.kwd65">11.7.3</a>, <a href="#hevea_manual.kwd226">12.10</a>
</li><li class="li-indexenv"><span class="font-tt">method</span>, <a href="#hevea_manual.kwd106">11.9.1</a>, <a href="#hevea_manual.kwd113">11.9.1</a>, <a href="#hevea_manual.kwd115">11.9.1</a>, <a href="#hevea_manual.kwd127">11.9.2</a>, <a href="#hevea_manual.kwd137">11.9.2</a>, <a href="#hevea_manual.kwd139">11.9.2</a>
</li><li class="li-indexenv"><span class="font-tt">mod</span>, <a href="#hevea_manual.kwd0">11.3</a>, <a href="#hevea_manual.kwd51">11.7.1</a>, <a href="#hevea_manual.kwd70">11.7.5</a>, <a href="#hevea_manual.kwd77">11.7.5</a>
</li><li class="li-indexenv"><span class="font-tt">module</span>, <a href="#hevea_manual.kwd89">11.7.8</a>, <a href="#hevea_manual.kwd160">11.10</a>, <a href="#hevea_manual.kwd172">11.10.2</a>, <a href="#hevea_manual.kwd174">11.10.2</a>, <a href="#hevea_manual.kwd188">11.11</a>, <a href="#hevea_manual.kwd200">11.11.2</a>, <a href="#hevea_manual.kwd202">11.11.2</a>, <a href="#hevea_manual.kwd206">12.2</a>, <a href="#hevea_manual.kwd212">12.5</a>, <a href="#hevea_manual.kwd216">12.6</a>, <a href="#hevea_manual.kwd221">12.7</a>, <a href="#hevea_manual.kwd223">12.8</a>
</li><li class="li-indexenv"><span class="font-tt">open</span>, <a href="#hevea_manual.kwd91">11.7.8</a>
</li><li class="li-indexenv"><span class="font-tt">mutable</span>, <a href="#hevea_manual.kwd96">11.8.1</a>, <a href="#hevea_manual.kwd98">11.8.1</a>, <a href="#hevea_manual.kwd105">11.9.1</a>, <a href="#hevea_manual.kwd112">11.9.1</a>, <a href="#hevea_manual.kwd126">11.9.2</a>, <a href="#hevea_manual.kwd134">11.9.2</a>, <a href="#hevea_manual.kwd136">11.9.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">new</span>, <a href="#hevea_manual.kwd41">11.7</a>, <a href="#hevea_manual.kwd84">11.7.6</a>
</li><li class="li-indexenv"><span class="font-tt">nonrec</span>, <a href="#hevea_manual.kwd94">11.8.1</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">object</span>, <a href="#hevea_manual.kwd42">11.7</a>, <a href="#hevea_manual.kwd85">11.7.6</a>, <a href="#hevea_manual.kwd101">11.9.1</a>, <a href="#hevea_manual.kwd118">11.9.2</a>
</li><li class="li-indexenv"><span class="font-tt">of</span>, <a href="#hevea_manual.kwd10">11.4</a>, <a href="#hevea_manual.kwd95">11.8.1</a>, <a href="#hevea_manual.kwd218">12.6</a>
</li><li class="li-indexenv"><span class="font-tt">open</span>, <a href="#hevea_manual.kwd19">11.6</a>, <a href="#hevea_manual.kwd161">11.10</a>, <a href="#hevea_manual.kwd175">11.10.2</a>, <a href="#hevea_manual.kwd189">11.11</a>, <a href="#hevea_manual.kwd203">11.11.2</a>
</li><li class="li-indexenv"><span class="font-tt">open!</span>, <a href="#hevea_manual.kwd224">12.9</a>
</li><li class="li-indexenv"><span class="font-tt">or</span>, <a href="#hevea_manual.kwd36">11.7</a>, <a href="#hevea_manual.kwd44">11.7.1</a>, <a href="#hevea_manual.kwd66">11.7.3</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">private</span>, <a href="#hevea_manual.kwd107">11.9.1</a>, <a href="#hevea_manual.kwd114">11.9.1</a>, <a href="#hevea_manual.kwd116">11.9.1</a>, <a href="#hevea_manual.kwd128">11.9.2</a>, <a href="#hevea_manual.kwd138">11.9.2</a>, <a href="#hevea_manual.kwd140">11.9.2</a>, <a href="#hevea_manual.kwd208">12.3</a>, <a href="#hevea_manual.kwd209">12.3.3</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">rec</span>, see <span class="font-it"><span class="font-tt">let</span>, <span class="font-tt">module</span></span>
<br>
</li><li class="li-indexenv"><span class="font-tt">sig</span>, <a href="#hevea_manual.kwd150">11.10</a>, <a href="#hevea_manual.kwd163">11.10.2</a>
</li><li class="li-indexenv"><span class="font-tt">struct</span>, <a href="#hevea_manual.kwd179">11.11</a>, <a href="#hevea_manual.kwd191">11.11.2</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">then</span>, see <span class="font-it"><span class="font-tt">if</span></span>
</li><li class="li-indexenv"><span class="font-tt">to</span>, see <span class="font-it"><span class="font-tt">for</span></span>
</li><li class="li-indexenv"><span class="font-tt">true</span>, <a href="#hevea_manual.kwd12">11.5</a>
</li><li class="li-indexenv"><span class="font-tt">try</span>, <a href="#hevea_manual.kwd24">11.7</a>, <a href="#hevea_manual.kwd49">11.7.1</a>, <a href="#hevea_manual.kwd69">11.7.3</a>
</li><li class="li-indexenv"><span class="font-tt">type</span>, <a href="#hevea_manual.kwd92">11.8.1</a>, <a href="#hevea_manual.kwd148">11.9.5</a>, <a href="#hevea_manual.kwd157">11.10</a>, <a href="#hevea_manual.kwd167">11.10.2</a>, <a href="#hevea_manual.kwd171">11.10.2</a>, <a href="#hevea_manual.kwd173">11.10.2</a>, <a href="#hevea_manual.kwd185">11.11</a>, <a href="#hevea_manual.kwd195">11.11.2</a>, <a href="#hevea_manual.kwd199">11.11.2</a>, <a href="#hevea_manual.kwd201">11.11.2</a>, <a href="#hevea_manual.kwd210">12.4</a>, <a href="#hevea_manual.kwd217">12.6</a>, <a href="#hevea_manual.kwd222">12.7</a>, <a href="#hevea_manual.kwd225">12.10</a>
<br>
</li><li class="li-indexenv"><span class="font-tt">val</span>, <a href="#hevea_manual.kwd104">11.9.1</a>, <a href="#hevea_manual.kwd111">11.9.1</a>, <a href="#hevea_manual.kwd125">11.9.2</a>, <a href="#hevea_manual.kwd133">11.9.2</a>, <a href="#hevea_manual.kwd135">11.9.2</a>, <a href="#hevea_manual.kwd155">11.10</a>, <a href="#hevea_manual.kwd165">11.10.2</a>, <a href="#hevea_manual.kwd213">12.5</a>
</li><li class="li-indexenv"><span class="font-tt">virtual</span>, see <span class="font-it"><span class="font-tt">val</span>, <span class="font-tt">method</span>, <span class="font-tt">class</span></span>
<br>
</li><li class="li-indexenv"><span class="font-tt">when</span>, <a href="#hevea_manual.kwd40">11.7</a>, <a href="#hevea_manual.kwd62">11.7.2</a>, <a href="#hevea_manual.kwd227">12.12</a>
</li><li class="li-indexenv"><span class="font-tt">while</span>, <a href="#hevea_manual.kwd67">11.7.3</a>
</li><li class="li-indexenv"><span class="font-tt">with</span>, <a href="#hevea_manual.kwd27">11.7</a>, <a href="#hevea_manual.kwd153">11.10</a>, <a href="#hevea_manual.kwd178">11.10.4</a>, <a href="#hevea_manual.kwd214">12.5</a>, <a href="#hevea_manual.kwd220">12.7</a>
</li></ul></td></tr>
</table>
</div><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr class="horizontal-rule" style="height:2px"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H<span style="font-size:small"><sup>E</sup></span>V<span style="font-size:small"><sup>E</sup></span>A</em></a><em>.</em></blockquote></body>
</html>

<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - Memory model: The hard bits</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu"><li><a href="coreexamples.html">The core language</a></li><li><a href="moduleexamples.html">The module system</a></li><li><a href="objectexamples.html">Objects in OCaml</a></li><li><a href="lablexamples.html">Labeled arguments</a></li><li><a href="polyvariant.html">Polymorphic variants</a></li><li><a href="polymorphism.html">Polymorphism and its limitations</a></li><li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li><li><a href="advexamples.html">Advanced examples with classes and modules</a></li><li><a href="parallelism.html">Parallel programming</a></li><li class="active"><a href="memorymodel.html">Memory model: The hard bits</a></li></ul>




<h1 class="chapter" id="sec92"><span class="chapter-number">Chapter 10</span> Memory model: The hard bits</h1>
<header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.1</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">Memory model: The hard bits</a></li>
<li><a href="memorymodel.html#s%3Awhy_relaxed_memory"><span class="number">1</span> Why weakly consistent memory?</a>
</li><li><a href="memorymodel.html#s%3Adrf_sc"><span class="number">2</span> Data race freedom implies sequential consistency</a>
</li><li><a href="memorymodel.html#s%3Adrf_reasoning"><span class="number">3</span> Reasoning with DRF-SC</a>
</li><li><a href="memorymodel.html#s%3Alocal_drf"><span class="number">4</span> Local data race freedom</a>
</li><li><a href="memorymodel.html#s%3Amm_semantics"><span class="number">5</span> An operational view of the memory model</a>
</li><li><a href="memorymodel.html#s%3Amm_tearing"><span class="number">6</span> Non-compliant operations</a>
</li></ul></nav></header>
<p>
<a id="c:memorymodel"></a></p><p>This chapter describes the details of OCaml relaxed memory model. The relaxed
memory model describes what values an OCaml program is allowed to witness when
reading a memory location. If you are interested in high-level parallel
programming in OCaml, please have a look at the parallel programming chapter
<a href="parallelism.html#c%3Aparallelism">9</a>.</p><p>This chapter is aimed at experts who would like to understand the details of
the OCaml memory model from a practitioner’s perspective. For a formal
definition of the OCaml memory model, its guarantees and the compilation to
hardware memory models, please have a look at the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>. The memory model presented in this chapter is an extension of the one
presented in the PLDI 2018 paper. This chapter also covers some pragmatic
aspects of the memory model that are not covered in the paper.</p>
<h2 class="section" id="s:why_relaxed_memory"><a class="section-anchor" href="#s:why_relaxed_memory" aria-hidden="true"></a><span class="number">1</span> Why weakly consistent memory?</h2>
<p>The simplest memory model that we could give to our programs is sequential
consistency. Under sequential consistency, the values observed by the program
can be explained through some interleaving of the operations from different
domains in the program. For example, consider the following program with two
domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> executing in parallel:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> b = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 a b <span class="ocamlkeyword">in</span>
    Printf.printf <span class="ocamlstring">"r1 = %d, r2 = %d, r3 = %d\n"</span> r1 r2 r3)
  <span class="ocamlkeyword">in</span>
  d2 b;
  Domain.join h</div></div>

</div><p>The reference cells <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are initially <span class="machine"><span class="font-tt">1</span></span>. The user may observe <span class="machine"><span class="font-tt">r1 = 2, r2 = 0, r3 = 2</span></span> if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurred before the read of <span class="machine"><span class="font-tt">b</span></span>
in <span class="machine"><span class="font-tt">d1</span></span>. Here, the observed behaviour can be explained in terms of interleaving
of the operations from different domains.</p><p>Let us now assume that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases of each other.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> ab = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 ab ab <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 ab;
  Domain.join h</div></div>

</div><p>In the above program, the variables <span class="machine"><span class="font-tt">ab</span></span>, <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> refer to the same
reference cell. One would expect that the assertion in the main function will
never fail. The reasoning is that if <span class="machine"><span class="font-tt">r2</span></span> is <span class="machine"><span class="font-tt">0</span></span>, then the write in <span class="machine"><span class="font-tt">d2</span></span>
occurred before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>. Given that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases,
the second read of <span class="machine"><span class="font-tt">a</span></span> in <span class="machine"><span class="font-tt">d1</span></span> should also return <span class="machine"><span class="font-tt">0</span></span>.</p>
<h3 class="subsection" id="ss:mm_comp_opt"><a class="section-anchor" href="#ss:mm_comp_opt" aria-hidden="true">﻿</a><span class="number">1.1</span> Compiler optimisations</h3>
<p>Surprisingly, this assertion may fail in OCaml due to compiler optimisations.
The OCaml compiler observes the common sub-expression <span class="machine"><span class="font-tt">!a * 2</span></span> in <span class="machine"><span class="font-tt">d1</span></span> and
optimises the program to:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = r1 <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* CSE: !a * 2 ==&gt; r1 *)</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> ab = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 ab ab <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 ab;
  Domain.join h</div></div>

</div><p>This optimisation is known as the common sub-expression elimination (CSE). Such
optimisations are valid and necessary for good performance, and do not change
the sequential meaning of the program. However, CSE breaks sequential
reasoning.</p><p>In the optimized program above, even if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurs between
the first and the second reads in <span class="machine"><span class="font-tt">d1</span></span>, the program will observe the value <span class="machine"><span class="font-tt">2</span></span>
for <span class="machine"><span class="font-tt">r3</span></span>, causing the assertion to fail. The observed behaviour cannot be
explained by interleaving of operations from different domains in the source
program. Thus, CSE optimization is said to be invalid under sequential
consistency.</p><p>One way to explain the observed behaviour is as if the operations performed on
a domain were reordered. For example, if the second and the third reads from
<span class="machine"><span class="font-tt">d2</span></span> were reordered,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>then we can explain the observed behaviour <span class="machine"><span class="font-tt">(2,0,2)</span></span> returned by
<span class="machine"><span class="font-tt">d1</span></span>.</p>
<h3 class="subsection" id="ss:mm_hw_opt"><a class="section-anchor" href="#ss:mm_hw_opt" aria-hidden="true">﻿</a><span class="number">1.2</span> Hardware optimisations</h3>
<p>The other source of reordering is by the hardware. Modern hardware
architectures have complex cache hierarchies with multiple levels of cache.
While cache coherence ensures that reads and writes to a single memory
location respect sequential consistency, the guarantees on programs that
operate on different memory locations are much weaker. Consider the following
program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>Under sequential consistency, we would never expect the assertion to fail.
However, even on x86, which offers much stronger guarantees than ARM, the
writes performed at a CPU core are not immediately published to all of the
other cores. Since <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are different memory locations, the reads of <span class="machine"><span class="font-tt">a</span></span>
and <span class="machine"><span class="font-tt">b</span></span> may both witness the initial values, leading to the assertion failure.</p><p>This behaviour can be explained if a load is allowed to be reordered before a
preceding store to a different memory location. This reordering can happen due
to the presence of in-core store-buffers on modern processors. Each core
effectively has a FIFO buffer of pending writes to avoid the need to block
while a write completes. The writes to <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> may be in the store-buffers
of cores <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> running the domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span>, respectively. The
reads of <span class="machine"><span class="font-tt">b</span></span> and <span class="machine"><span class="font-tt">a</span></span> running on the cores <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span>, respectively, will not
see the writes if the writes have not propagated from the buffers to the main
memory.</p>
<h2 class="section" id="s:drf_sc"><a class="section-anchor" href="#s:drf_sc" aria-hidden="true">﻿</a><span class="number">2</span> Data race freedom implies sequential consistency</h2>
<p>The aim of the OCaml relaxed memory model is to precisely describe which orders
are preserved by the OCaml program. The compiler and the hardware are free to
optimize the program as long as they respect the ordering guarantees of the
memory model. While programming directly under the relaxed memory model is
difficult, the memory model also describes the conditions under which a program
will only exhibit sequentially consistent behaviours. This guarantee is known
as <em>data race freedom implies sequential consistency</em> (DRF-SC). In this
section, we shall describe this guarantee. In order to do this, we first need a
number of definitions.</p>
<h3 class="subsection" id="s:atomics"><a class="section-anchor" href="#s:atomics" aria-hidden="true">﻿</a><span class="number">2.1</span> Memory locations</h3>
<p>OCaml classifies memory locations into <em>atomic</em> and <em>non-atomic</em>
locations. Reference cells, array fields and mutable record fields are
non-atomic memory locations. Immutable objects are non-atomic locations with an
initialising write but no further updates. Atomic memory locations are those
that are created using the <a href="../api/Atomic.html"><span class="font-tt">Atomic</span></a> module.</p>
<h3 class="subsection" id="s:happens_before"><a class="section-anchor" href="#s:happens_before" aria-hidden="true">﻿</a><span class="number">2.2</span> Happens-before relation</h3>
<p>Let us imagine that the OCaml programs are executed by an abstract machine that
executes one action at a time, arbitrarily picking one of the available domains
at each step. We classify actions into two: <em>inter-domain</em> and
<em>intra-domain</em>. An inter-domain action is one which can be observed and be
influenced by actions on other domains. There are several inter-domain actions:</p><ul class="itemize"><li class="li-itemize">
Reads and writes of atomic and non-atomic locations.
</li><li class="li-itemize">Spawn and join of domains.
</li><li class="li-itemize">Operations on mutexes.
</li></ul><p>On the other hand, intra-domain actions can neither be observed nor influence
the execution of other domains. Examples include evaluating an arithmetic
expression, calling a function, etc. The memory model specification ignores
such intra-domain actions. In the sequel, we use the term action to indicate
inter-domain actions.</p><p>A totally ordered list of actions executed by the abstract machine is called an
<em>execution trace</em>. There might be several possible execution traces for a
given program due to non-determinism.</p><p>For a given execution trace, we define an irreflexive, transitive
<em>happens-before relation</em> that captures the causality between actions in
the OCaml program. The happens-before relation is defined as the smallest
transitive relation satisfying the following properties:</p><ul class="itemize"><li class="li-itemize">
We define the order in which a domain executes its actions as the
<em>program order</em>. If an action <span class="machine"><span class="font-tt">x</span></span> precedes another action <span class="machine"><span class="font-tt">y</span></span> in
program order, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is a write to an atomic location and <span class="machine"><span class="font-tt">y</span></span> is a subsequent read or
write to that memory location in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span>
in happens-before order. For atomic locations, <span class="machine"><span class="font-tt">compare_and_set</span></span>,
<span class="machine"><span class="font-tt">fetch_and_add</span></span>, <span class="machine"><span class="font-tt">exchange</span></span>, <span class="machine"><span class="font-tt">incr</span></span> and <span class="machine"><span class="font-tt">decr</span></span> are considered to perform
both a read and a write.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is <span class="machine"><span class="font-tt">Domain.spawn f</span></span> and <span class="machine"><span class="font-tt">y</span></span> is the first action in the newly
spawned domain executing <span class="machine"><span class="font-tt">f</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before
order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is the last action in a domain <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">y</span></span> is <span class="machine"><span class="font-tt">Domain.join     d</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an unlock operation on a mutex, and <span class="machine"><span class="font-tt">y</span></span> is any subsequent
operation on the mutex in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in
happens-before order.
</li></ul>
<h3 class="subsection" id="s:datarace"><a class="section-anchor" href="#s:datarace" aria-hidden="true">﻿</a><span class="number">2.3</span> Data race</h3>
<p>In a given trace, two actions are said to be <em>conflicting</em> if they access
the same non-atomic location, at least one is a write and neither is an
initialising write to that location.</p><p>We say that a program has a <em>data race</em> if there exists some execution
trace of the program with two conflicting actions and there does not exist a
happens-before relationship between the conflicting accesses. A program without
data races is said to be <em>correctly synchronised</em>.</p>
<h3 class="subsection" id="ss:drf_sc"><a class="section-anchor" href="#ss:drf_sc" aria-hidden="true">﻿</a><span class="number">2.4</span> DRF-SC</h3>
<p><span class="font-bold">DRF-SC guarantee:</span> A program without data races will only exhibit
sequentially consistent behaviours.</p><p>DRF-SC is a strong guarantee for the programmers. Programmers can use
<em>sequential reasoning</em> i.e., reasoning by executing one inter-domain
action after the other, to identify whether their program has a data race. In
particular, they do not need to reason about reorderings described in
section ‍<a href="#s%3Awhy_relaxed_memory">10.1</a> in order to determine whether their program
has a data race. Once the determination that a particular program is data race
free is made, they do not need to worry about reorderings in their code.</p>
<h2 class="section" id="s:drf_reasoning"><a class="section-anchor" href="#s:drf_reasoning" aria-hidden="true">﻿</a><span class="number">3</span> Reasoning with DRF-SC</h2>
<p>In this section, we will look at examples of using DRF-SC for program
reasoning. In this section, we will use the functions with names <span class="machine"><span class="font-tt">dN</span></span> to
represent domains executing in parallel with other domains. That is, we assume
that there is a <span class="machine"><span class="font-tt">main</span></span> function that runs the <span class="machine"><span class="font-tt">dN</span></span> functions in parallel as
follows:</p><pre>let main () =
  let h1 = Domain.spawn d1 in
  let h2 = Domain.spawn d2 in
  ...
  ignore @@ Domain.join h1;
  ignore @@ Domain.join h2
</pre><p>
Here is a simple example with a data race:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* Has data race *)</span>
<span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> d1 () = r := 1
<span class="ocamlkeyword">let</span> d2 () = !r</div></div>

</div><p><span class="machine"><span class="font-tt">r</span></span> is a non-atomic reference. The two domains race to access the reference,
and <span class="machine"><span class="font-tt">d1</span></span> is a write. Since there is no happens-before relationship between the
conflicting accesses, there is a data race.</p><p>Both of the programs that we had seen in the section ‍<a href="#s%3Awhy_relaxed_memory">10.1</a>
have data races. It is no surprise that they exhibit non sequentially
consistent behaviours.</p><p>Accessing disjoint array indices and fields of a record in parallel is not a
data race. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> a = [| 0; 1 |]
<span class="ocamlkeyword">let</span> d1 () = a.(0) &lt;- 42
<span class="ocamlkeyword">let</span> d2 () = a.(1) &lt;- 42</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">type</span> t = {
  <span class="ocamlkeyword">mutable</span> a : int;
  <span class="ocamlkeyword">mutable</span> b : int
}
<span class="ocamlkeyword">let</span> r = {a = 0; b = 1}
<span class="ocamlkeyword">let</span> d1 () = r.a &lt;- 42
<span class="ocamlkeyword">let</span> d2 () = r.b &lt;- 42</div></div>

</div><p>do not have data races.</p><p>Races on atomic locations do not lead to a data race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> r = Atomic.make 0
<span class="ocamlkeyword">let</span> d1 () = Atomic.set r 1
<span class="ocamlkeyword">let</span> d2 () = Atomic.get r</div></div>

</div>
<h4 class="subsubsection" id="s:mm_msg_passing"><a class="section-anchor" href="#s:mm_msg_passing" aria-hidden="true">﻿</a>Message-passing</h4>
<p>Atomic variables may be used for implementing non-blocking communication
between domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">if</span> Atomic.get flag <span class="ocamlcomment">(* c *)</span> <span class="ocamlkeyword">then</span>
    !msg <span class="ocamlcomment">(* d *)</span>
  <span class="ocamlkeyword">else</span> 0</div></div>

</div><p>Observe that the actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> write and read from the same non-atomic
location <span class="machine"><span class="font-tt">msg</span></span>, respectively, and hence are conflicting. We need to establish
that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> have a happens-before relationship in order to show that this
program does not have a data race.</p><p>The action <span class="machine"><span class="font-tt">a</span></span> precedes <span class="machine"><span class="font-tt">b</span></span> in program order, and hence, <span class="machine"><span class="font-tt">a</span></span> happens-before
<span class="machine"><span class="font-tt">b</span></span>. Similarly, <span class="machine"><span class="font-tt">c</span></span> happens-before <span class="machine"><span class="font-tt">d</span></span>. If <span class="machine"><span class="font-tt">d2</span></span> observes the atomic variable
<span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">true</span></span>, then <span class="machine"><span class="font-tt">b</span></span> precedes <span class="machine"><span class="font-tt">c</span></span> in happens-before order. Since
happens-before is transitive, the conflicting actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> are in
happens-before order. If <span class="machine"><span class="font-tt">d2</span></span> observes the <span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">false</span></span>, then the read
of <span class="machine"><span class="font-tt">msg</span></span> is not done. Hence, there is no conflicting access in this execution
trace. Hence, the program does not have a data race.</p><p>The following modified version of the message passing program does have a data
race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* Has data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  ignore (Atomic.get flag); <span class="ocamlcomment">(* c *)</span>
  !msg <span class="ocamlcomment">(* d *)</span></div></div>

</div><p>The domain <span class="machine"><span class="font-tt">d2</span></span> now unconditionally reads the non-atomic reference <span class="machine"><span class="font-tt">msg</span></span>.
Consider the execution trace:</p><pre>Atomic.get flag; (* c *)
!msg; (* d *)
msg := 42; (* a *)
Atomic.set flag true (* b *)
</pre><p>
In this trace, <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">a</span></span> are conflicting operations. But there is no
happens-before relationship between them. Hence, this program has a data race.</p>
<h2 class="section" id="s:local_drf"><a class="section-anchor" href="#s:local_drf" aria-hidden="true">﻿</a><span class="number">4</span> Local data race freedom</h2>
<p>The OCaml memory model offers strong guarantees even for programs with data
races. It offers what is known as <em>local data race freedom sequential
consistency (LDRF-SC)</em> guarantee. A formal definition of this property is beyond
the scope of this manual chapter. Interested readers are encouraged to read the
PLDI 2018 paper on <a href="https://doi.org/10.1145/3192366.3192421">Bounding Data
Races in Space and Time</a>.</p><p>Informally, LDRF-SC says that the data race free parts of the program remain
sequentially consistent. That is, even if the program has data races, those
parts of the program that are disjoint from the parts with data races are
amenable to sequential reasoning.</p><p>Consider the following snippet:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> snippet () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  (a, c)</div></div>

</div><p>Observe that <span class="machine"><span class="font-tt">c</span></span> is a newly allocated reference. Can the read of <span class="machine"><span class="font-tt">c</span></span> return a
value which is not 42? That is, can <span class="machine"><span class="font-tt">a</span></span> ever be not <span class="machine"><span class="font-tt">42</span></span>? Surprisingly, in the
C++ and Java memory models, the answer is yes. With the C++ memory model, if
the program has a data race, even in unrelated parts, then the semantics is
undefined. If this snippet were linked with a library that had a data race,
then, under the C++ memory model, the read may return any value. Since data
races on unrelated locations can affect program behaviour, we say that C++
memory model is not bounded in space.</p><p>Unlike C++, Java memory model is bounded in space. But Java memory model is not
bounded in time; data races in the future will affect the past behaviour. For
example, consider the translation of this example to Java. We assume a prior
definition of <span class="machine"><span class="font-tt">Class c {int x;}</span></span> and a shared <em>non-volatile</em> variable <span class="machine"><span class="font-tt">C g</span></span>. Now the snippet may be part of a larger program with parallel threads:</p><pre>(* Thread 1 *)
C c = new C();
c.x = 42;
a = c.x;
g = c;

(* Thread 2 *)
g.x = 7;
</pre><p>
The read of <span class="machine"><span class="font-tt">c.x</span></span> and the write of <span class="machine"><span class="font-tt">g</span></span> in the first thread are done on separate
memory locations. Hence, the Java memory model allows them to be reordered. As
a result, the write in the second thread may occur before the read of <span class="machine"><span class="font-tt">c.x</span></span>,
and hence, <span class="machine"><span class="font-tt">c.x</span></span> returns <span class="machine"><span class="font-tt">7</span></span>.</p><p>The OCaml equivalent of the Java code above is:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> g = <span class="ocamlkeyword">ref</span> None

<span class="ocamlkeyword">let</span> snippet () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  (a, c)

<span class="ocamlkeyword">let</span> d1 () =
  <span class="ocamlkeyword">let</span> (a,c) = snippet () <span class="ocamlkeyword">in</span>
  g := Some c;
  a

<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">match</span> !g <span class="ocamlkeyword">with</span>
  | None -&gt; ()
  | Some c -&gt; c := 7</div></div>

</div><p>Observe that there is a data race on both <span class="machine"><span class="font-tt">g</span></span> and <span class="machine"><span class="font-tt">c</span></span>. Consider only the first
three instructions in <span class="machine"><span class="font-tt">snippet</span></span>:</p><pre>let c = ref 0 in
c := 42;
let a = !c in
...
</pre><p>
The OCaml memory model is bounded both in space and time. The only memory
location here is <span class="machine"><span class="font-tt">c</span></span>. Reasoning only about this snippet, there is neither the
data race in space (the race on <span class="machine"><span class="font-tt">g</span></span>) nor in time (the future race on <span class="machine"><span class="font-tt">c</span></span>).
Hence, the snippet will have sequentially consistent behaviour, and the value
returned by <span class="machine"><span class="font-tt">!c</span></span> will be <span class="machine"><span class="font-tt">42</span></span>.</p><p>The OCaml memory model guarantees that even for programs with data races,
memory safety is preserved. While programs with data races may observe
non-sequentially consistent behaviours, they will not crash.</p>
<h2 class="section" id="s:mm_semantics"><a class="section-anchor" href="#s:mm_semantics" aria-hidden="true">﻿</a><span class="number">5</span> An operational view of the memory model</h2>
<p>In this section, we describe the semantics of the OCaml memory model. A formal
definition of the operational view of the memory model is presented in section
3 of the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>. This section presents an informal description of the memory model with
the help of an example.</p><p>Given an OCaml program, which may possibly contain data races, the operational
semantics tells you the values that may be observed by the read of a memory
location. For simplicity, we restrict the intra-thread actions to just the
accesses to atomic and non-atomic locations, ignoring domain spawn and join
operations, and the operations on mutexes.</p><p>We describe the semantics of the OCaml memory model in a straightforward
small-step operational manner. That is, the semantics is described by an
abstract machine that executes one action at a time, arbitrarily picking one of
the available domains at each step. This is similar to the abstract machine
that we had used to describe the happens-before relationship in
section ‍<a href="#s%3Ahappens_before">10.2.2</a>.</p>
<h3 class="subsection" id="ss:mm_non_atomic"><a class="section-anchor" href="#ss:mm_non_atomic" aria-hidden="true">﻿</a><span class="number">5.1</span> Non-atomic locations</h3>
<p>In the semantics, we model non-atomic locations as finite maps from timestamps
<span class="machine"><span class="font-tt">t</span></span> to values <span class="machine"><span class="font-tt">v</span></span>. We take timestamps to be rational numbers. The timestamps
are totally ordered but dense; there is a timestamp between any two others.</p><p>For example,</p><pre>a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t8 -&gt; 7]
</pre><p>
represents three non-atomic locations <span class="machine"><span class="font-tt">a</span></span>, <span class="machine"><span class="font-tt">b</span></span> and <span class="machine"><span class="font-tt">c</span></span> and their
histories. The location <span class="machine"><span class="font-tt">a</span></span> has two writes at timestamps <span class="machine"><span class="font-tt">t1</span></span> and <span class="machine"><span class="font-tt">t2</span></span> with
values <span class="machine"><span class="font-tt">1</span></span> and <span class="machine"><span class="font-tt">2</span></span>, respectively. When we write <span class="machine"><span class="font-tt">a: [t1 -&gt; 1; t2 -&gt; 2]</span></span>, we
assume that <span class="machine"><span class="font-tt">t1 &lt; t2</span></span>. We assume that the locations are initialised with a
history that has a single entry at timestamp 0 that maps to the initial value.</p>
<h3 class="subsection" id="ss:mm_domains"><a class="section-anchor" href="#ss:mm_domains" aria-hidden="true">﻿</a><span class="number">5.2</span> Domains</h3>
<p>Each domain is equipped with a <em>frontier</em>, which is a map from non-atomic
locations to timestamps. Intuitively, each domain’s frontier records, for each
non-atomic location, the latest write known to the thread. More recent writes
may have occurred, but are not guaranteed to be visible.</p><p>For example,</p><pre>d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t7]
</pre><p>
represents two domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> and their frontiers.</p>
<h3 class="subsection" id="ss:mm_na_access"><a class="section-anchor" href="#ss:mm_na_access" aria-hidden="true">﻿</a><span class="number">5.3</span> Non-atomic accesses</h3>
<p>Let us now define the semantics of non-atomic reads and writes. Suppose domain
<span class="machine"><span class="font-tt">d1</span></span> performs the read of <span class="machine"><span class="font-tt">b</span></span>. For non-atomic reads, the domains may read an
arbitrary element of the history for that location, as long as it is not older
than the timestamp in the domains’s frontier. In this case, since <span class="machine"><span class="font-tt">d1</span></span> frontier
at <span class="machine"><span class="font-tt">b</span></span> is at <span class="machine"><span class="font-tt">t3</span></span>, the read may return the value <span class="machine"><span class="font-tt">3</span></span>, <span class="machine"><span class="font-tt">4</span></span> or <span class="machine"><span class="font-tt">5</span></span>. A non-atomic
read does not change the frontier of the current domain.</p><p>Suppose domain <span class="machine"><span class="font-tt">d2</span></span> writes the value <span class="machine"><span class="font-tt">10</span></span> to <span class="machine"><span class="font-tt">c</span></span> (<span class="machine"><span class="font-tt">c := 10</span></span>). We pick a new
timestamp <span class="machine"><span class="font-tt">t9</span></span> for this write such that it is later than <span class="machine"><span class="font-tt">d2</span></span>’s frontier at
<span class="machine"><span class="font-tt">c</span></span>. Note a subtlety here: this new timestamp might not be later than everything
else in the history, but merely later than any other write known to the writing
domain. Hence, <span class="machine"><span class="font-tt">t9</span></span> may be inserted in <span class="machine"><span class="font-tt">c</span></span>’s history either (a) between <span class="machine"><span class="font-tt">t7</span></span>
and <span class="machine"><span class="font-tt">t8</span></span> or (b) after <span class="machine"><span class="font-tt">t8</span></span>. Let us pick the former option for our discussion.
Since the new write appears after all the writes known by the domain <span class="machine"><span class="font-tt">d2</span></span> to
the location <span class="machine"><span class="font-tt">c</span></span>, <span class="machine"><span class="font-tt">d2</span></span>’s frontier at <span class="machine"><span class="font-tt">c</span></span> is also updated. The new state of the
abstract machine is:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7] (* new write at t9 *)

(* Domains *)
d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9] (* frontier updated at c *)
</pre>
<h3 class="subsection" id="ss:mm_at_access"><a class="section-anchor" href="#ss:mm_at_access" aria-hidden="true">﻿</a><span class="number">5.4</span> Atomic accesses</h3>
<p>Atomic locations carry not only values but also synchronization information. We
model atomic locations as a pair of the value held by that location and a
frontier. The frontier models the synchronization information, which is merged
with the frontiers of threads that operate on the location. In this way,
non-atomic writes made by one thread can become known to another by
communicating via an atomic location.</p><p>For example,</p><pre>(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
shows two atomic variables <span class="machine"><span class="font-tt">A</span></span> and <span class="machine"><span class="font-tt">B</span></span> with values <span class="machine"><span class="font-tt">10</span></span> and <span class="machine"><span class="font-tt">5</span></span>,
respectively, and frontiers of their own. We use upper-case variable names to
indicate atomic locations.</p><p>During atomic reads, the frontier of the location is merged into that of the
domain performing the read. For example, suppose <span class="machine"><span class="font-tt">d1</span></span> reads <span class="machine"><span class="font-tt">B</span></span>. The read
returns <span class="machine"><span class="font-tt">5</span></span>, and <span class="machine"><span class="font-tt">d1</span></span>’s frontier updated by merging it with <span class="machine"><span class="font-tt">B</span></span>’s frontier,
choosing the later timestamp for each location. The abstract machine state
before the atomic read is:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t1; b -&gt; t3; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9]

(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
As a result of the atomic read, the abstract machine state is updated to:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t4; c -&gt; t7] (* frontier updated at a and b *)
d2: [a -&gt; t1; b -&gt; t4; c -&gt; t9]

(* Atomic locations *)
A: 10, [a -&gt; t1; b -&gt; t5; c -&gt; t7]
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre><p>
During atomic writes, the value held by the atomic location is updated. The
frontiers of both the writing domain and that of the location being written to
are updated to the merge of the two frontiers. For example, if <span class="machine"><span class="font-tt">d2</span></span> writes <span class="machine"><span class="font-tt">20</span></span>
to <span class="machine"><span class="font-tt">A</span></span> in the current machine state, the machine state is updated to:</p><pre>(* Non-atomic locations *)
a: [t1 -&gt; 1; t2 -&gt; 2]
b: [t3 -&gt; 3; t4 -&gt; 4; t5 -&gt; 5]
c: [t6 -&gt; 5; t7 -&gt; 6; t9 -&gt; 10; t8 -&gt; 7]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t4; c -&gt; t7]
d2: [a -&gt; t1; b -&gt; t5; c -&gt; t9] (* frontier updated at b *)

(* Atomic locations *)
A: 20, [a -&gt; t1; b -&gt; t5; c -&gt; t9] (* value updated. frontier updated at c. *)
B: 5,  [a -&gt; t2; b -&gt; t4; c -&gt; t6]
</pre>
<h3 class="subsection" id="s:mm_semantics_reasoning"><a class="section-anchor" href="#s:mm_semantics_reasoning" aria-hidden="true">﻿</a><span class="number">5.5</span> Reasoning with the semantics</h3>
<p>Let us revisit an example from earlier (section <a href="#s%3Awhy_relaxed_memory">10.1</a>).</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>This program has a data race on <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span>, and hence, the program may exhibit
non sequentially consistent behaviour. Let us use the semantics to show that
the program may exhibit <span class="machine"><span class="font-tt">r1 = 0 &amp;&amp; r2 = 0</span></span>.</p><p>The initial state of the abstract machine is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0]
b: [t1 -&gt; 0]

(* Domains *)
d1: [a -&gt; t0; b -&gt; t1]
d2: [a -&gt; t0; b -&gt; t1]
</pre><p>
There are several possible schedules for executing this program. Let us
consider the following schedule:</p><pre>1: a := 1 @ d1
2: b := 1 @ d2
3: !b     @ d1
4: !a     @ d2
</pre><p>
After the first action <span class="machine"><span class="font-tt">a:=1</span></span> by <span class="machine"><span class="font-tt">d1</span></span>, the machine state is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0; t2 -&gt; 1] (* new write at t2 *)
b: [t1 -&gt; 0]

(* Domains *)
d1: [a -&gt; t2; b -&gt; t1] (* frontier updated at a *)
d2: [a -&gt; t0; b -&gt; t1]
</pre><p>
After the second action <span class="machine"><span class="font-tt">b:=1</span></span> by <span class="machine"><span class="font-tt">d2</span></span>, the machine state is:</p><pre>(* Non-atomic locations *)
a: [t0 -&gt; 0; t2 -&gt; 1]
b: [t1 -&gt; 0; t3 -&gt; 1] (* new write at t3 *)

(* Domains *)
d1: [a -&gt; t2; b -&gt; t1]
d2: [a -&gt; t0; b -&gt; t3] (* frontier updated at b *)
</pre><p>
Now, for the third action <span class="machine"><span class="font-tt">!b</span></span> by <span class="machine"><span class="font-tt">d1</span></span>, observe that <span class="machine"><span class="font-tt">d1</span></span>’s frontier at <span class="machine"><span class="font-tt">b</span></span>
is at <span class="machine"><span class="font-tt">t1</span></span>. Hence, the read may return either <span class="machine"><span class="font-tt">0</span></span> or <span class="machine"><span class="font-tt">1</span></span>. Let us assume that it
returns <span class="machine"><span class="font-tt">0</span></span>. The machine state is not updated by the non-atomic read.</p><p>Similarly, for the fourth action <span class="machine"><span class="font-tt">!a</span></span> by <span class="machine"><span class="font-tt">d2</span></span>, <span class="machine"><span class="font-tt">d2</span></span>’s frontier at <span class="machine"><span class="font-tt">a</span></span> is at
<span class="machine"><span class="font-tt">t0</span></span>. Hence, this read may also return either <span class="machine"><span class="font-tt">0</span></span> or <span class="machine"><span class="font-tt">1</span></span>. Let us assume that it
returns <span class="machine"><span class="font-tt">0</span></span>. Hence, the assertion in the original program, <span class="machine"><span class="font-tt">assert (not (r1 = 0 &amp;&amp; r2 = 0))</span></span>, will fail for this particular execution.</p>
<h2 class="section" id="s:mm_tearing"><a class="section-anchor" href="#s:mm_tearing" aria-hidden="true">﻿</a><span class="number">6</span> Non-compliant operations</h2>
<p>There are certain operations which are not memory model compliant.</p><ul class="itemize"><li class="li-itemize">
<span class="machine"><span class="font-tt">Array.blit</span></span> function on float arrays may cause <em>tearing</em>. When an
unsynchronized blit operation runs concurrently with some overlapping write
to the fields of the same float array, the field may end up with bits from
either of the writes.
</li><li class="li-itemize">With flat-float arrays or records with only float fields on 32-bit
architectures, getting or setting a field involves two separate memory
accesses. In the presence of data races, the user may observe tearing.
</li><li class="li-itemize">The <span class="machine"><span class="font-tt">Bytes</span></span> module ‍<a href="../api/Bytes.html"><span class="font-tt">Bytes</span></a> permits mixed-mode accesses
where reads and writes may be of different sizes. Unsynchronized mixed-mode
accesses lead to tearing.
</li></ul>
<hr>
<div class="bottom-navigation"><a class="previous" href="parallelism.html">« Parallel programming</a><a class="next" href="language.html">The OCaml language »</a></div>




<div class="copyright">Copyright © 2023 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>
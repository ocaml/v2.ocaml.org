<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.36">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - The OCaml language</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>The OCaml language</nav><ul id="part-menu"><li class="active"><a href="language.html">The OCaml language</a></li><li><a href="extn.html">Language extensions</a></li></ul>




<h1 class="chapter" id="sec112"><span class="chapter-number">Chapter 11</span> The OCaml language</h1><header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.1</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">The OCaml language</a></li>
<li><a href="lex.html#start-section"><span class="number">1</span> Lexical conventions</a>
</li><li><a href="values.html#start-section"><span class="number">2</span> Values</a>
</li><li><a href="names.html#start-section"><span class="number">3</span> Names</a>
</li><li><a href="types.html#start-section"><span class="number">4</span> Type expressions</a>
</li><li><a href="const.html#start-section"><span class="number">5</span> Constants</a>
</li><li><a href="patterns.html#start-section"><span class="number">6</span> Patterns</a>
</li><li><a href="expr.html#start-section"><span class="number">7</span> Expressions</a>
</li><li><a href="typedecl.html#start-section"><span class="number">8</span> Type and exception definitions</a>
</li><li><a href="classes.html#start-section"><span class="number">9</span> Classes</a>
</li><li><a href="modtypes.html#start-section"><span class="number">10</span> Module types (module specifications)</a>
</li><li><a href="modules.html#start-section"><span class="number">11</span> Module expressions (module implementations)</a>
</li><li><a href="compunit.html#start-section"><span class="number">12</span> Compilation units</a>
</li></ul></nav></header><a id="start-section"></a><section id="section">




<h2 class="section" id="s:value-expr"><a class="section-anchor" href="#s:value-expr" aria-hidden="true"></a><span class="number">7</span> Expressions</h2>
<ul>
<li><a href="expr.html#ss%3Aprecedence-and-associativity"><span class="number">7.1</span> Precedence and associativity</a>
</li><li><a href="expr.html#ss%3Aexpr-basic"><span class="number">7.2</span> Basic expressions</a>
</li><li><a href="expr.html#ss%3Aexpr-control"><span class="number">7.3</span> Control structures</a>
</li><li><a href="expr.html#ss%3Aexpr-ops-on-data"><span class="number">7.4</span> Operations on data structures</a>
</li><li><a href="expr.html#ss%3Aexpr-operators"><span class="number">7.5</span> Operators</a>
</li><li><a href="expr.html#ss%3Aexpr-obj"><span class="number">7.6</span> Objects</a>
</li><li><a href="expr.html#ss%3Aexpr-coercions"><span class="number">7.7</span> Coercions</a>
</li><li><a href="expr.html#ss%3Aexpr-other"><span class="number">7.8</span> Other</a>
</li></ul>
<p>
<a id="hevea_manual.kwd20"></a>
<a id="hevea_manual.kwd21"></a>
<a id="hevea_manual.kwd22"></a>
<a id="hevea_manual.kwd23"></a>
<a id="hevea_manual.kwd24"></a>
<a id="hevea_manual.kwd25"></a>
<a id="hevea_manual.kwd26"></a>
<a id="hevea_manual.kwd27"></a>
<a id="hevea_manual.kwd28"></a>
<a id="hevea_manual.kwd29"></a>
<a id="hevea_manual.kwd30"></a>
<a id="hevea_manual.kwd31"></a>
<a id="hevea_manual.kwd32"></a>
<a id="hevea_manual.kwd33"></a>
<a id="hevea_manual.kwd34"></a>
<a id="hevea_manual.kwd35"></a>
<a id="hevea_manual.kwd36"></a>
<a id="hevea_manual.kwd37"></a>
<a id="hevea_manual.kwd38"></a>
<a id="hevea_manual.kwd39"></a>
<a id="hevea_manual.kwd40"></a>
<a id="hevea_manual.kwd41"></a>
<a id="hevea_manual.kwd42"></a>
<a id="hevea_manual.kwd43"></a></p><div class="syntax"><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><a class="syntax" id="expr"><span class="nonterminal">expr</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="names.html#value-path"><span class="nonterminal">value-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="const.html#constant"><span class="nonterminal">constant</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">begin</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> { <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> }<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">::</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> } [<span class="syntax-token">;</span>] <span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> } [<span class="syntax-token">;</span>] <span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]{ <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] } [<span class="syntax-token">;</span>] <span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>]{ <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] } [<span class="syntax-token">;</span>] <span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> { <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a> }<sup>+</sup>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="lex.html#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">-.</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <a class="syntax" href="names.html#infix-op"><span class="nonterminal">infix-op</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">]</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">then</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> [ <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> ]
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">while</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">done</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">for</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> ( <span class="syntax-token">to</span> ∣ <span class="syntax-token">downto</span> ) <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">done</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">match</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">function</span> <a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">fun</span> { <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a> }<sup>+</sup> [ <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> ] <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">try</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="#pattern-matching"><span class="nonterminal">pattern-matching</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">let</span> [<span class="syntax-token">rec</span>] <a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#let-binding"><span class="nonterminal">let-binding</span></a> } <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">let</span> <span class="syntax-token">exception</span> <a class="syntax" href="typedecl.html#constr-decl"><span class="nonterminal">constr-decl</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">let</span> <span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> { <span class="syntax-token">(</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> <span class="syntax-token">)</span> }
[ <span class="syntax-token">:</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> ]  <span class="syntax-token">=</span> <a class="syntax" href="modules.html#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">assert</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">lazy</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#local-open"><span class="nonterminal">local-open</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#object-expr"><span class="nonterminal">object-expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
</tbody></table></td></tr>
</tbody></table></div><div class="syntax"><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><a class="syntax" id="argument"><span class="nonterminal">argument</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">~</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">~</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="pattern-matching"><span class="nonterminal">pattern-matching</span></a></td><td class="c005">::=</td><td class="c007">
[ <span class="syntax-token">|</span> ] <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> [<span class="syntax-token">when</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
{ <span class="syntax-token">|</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> [<span class="syntax-token">when</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> }
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="let-binding"><span class="nonterminal">let-binding</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> { <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a> } [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#poly-typexpr"><span class="nonterminal">poly-typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> </td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="parameter"><span class="nonterminal">parameter</span></a></td><td class="c005">::=</td><td class="c007">
<a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">~</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">~</span> <span class="syntax-token">(</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">~</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <span class="syntax-token">(</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">label-name</span></a> <span class="syntax-token">:</span> <span class="syntax-token">(</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="local-open"><span class="nonterminal">local-open</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">let</span> <span class="syntax-token">open</span> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">|]</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.{&lt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">&gt;}</span>
</td></tr>
<tr><td class="c008">&nbsp;</td></tr>
<tr><td class="c008">
<a class="syntax" id="object-expr"><span class="nonterminal">object-expr</span></a></td><td class="c005">::=</td><td class="c007">&nbsp;</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">new</span> <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">object</span> <a class="syntax" href="classes.html#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">#</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">method-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</td></tr>
<tr><td class="c008">&nbsp;</td><td class="c005">∣</td><td class="c007"> <span class="syntax-token">{&lt;</span> [ <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] { <span class="syntax-token">;</span> <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] } [<span class="syntax-token">;</span>] ] <span class="syntax-token">&gt;}</span>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div><p>
See also the following language extensions:
<a href="firstclassmodules.html#s%3Afirst-class-modules">first-class modules</a>,
<a href="overridingopen.html#s%3Aexplicit-overriding-open">overriding in open statements</a>,
<a href="bigarray.html#s%3Abigarray-access">syntax for Bigarray access</a>,
<a href="attributes.html#s%3Aattributes">attributes</a>,
<a href="extensionnodes.html#s%3Aextension-nodes">extension nodes</a> and
<a href="indexops.html#s%3Aindex-operators">extended indexing operators</a>.</p>
<h3 class="subsection" id="ss:precedence-and-associativity"><a class="section-anchor" href="#ss:precedence-and-associativity" aria-hidden="true">﻿</a><span class="number">7.1</span> Precedence and associativity</h3>
<p>
The table below shows the relative precedences and associativity of
operators and non-closed constructions. The constructions with higher
precedence come first. For infix and prefix symbols, we write
“<span class="machine"><span class="font-tt">*</span></span>…” to mean “any symbol starting with <span class="machine"><span class="font-tt">*</span></span>”.
<a id="hevea_manual.kwd44"></a><a id="hevea_manual.kwd45"></a><a id="hevea_manual.kwd46"></a><a id="hevea_manual.kwd47"></a><a id="hevea_manual.kwd48"></a><a id="hevea_manual.kwd49"></a><a id="hevea_manual.kwd50"></a><a id="hevea_manual.kwd51"></a>
<a id="hevea_manual.kwd52"></a>
<a id="hevea_manual.kwd53"></a>
<a id="hevea_manual.kwd54"></a>
<a id="hevea_manual.kwd55"></a>
<a id="hevea_manual.kwd56"></a>
<a id="hevea_manual.kwd57"></a>
</p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border="1"><tbody><tr><td class="c004"><span class="font-bold">Construction or operator</span></td><td class="c004"><span class="font-bold">Associativity</span> </td></tr>
<tr><td class="c006">
prefix-symbol</td><td class="c006">– </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">.   .(   .[   .{</span></span> (see section&nbsp;<a href="bigarray.html#s%3Abigarray-access">12.11</a>)</td><td class="c006">– </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">#</span></span>…</td><td class="c006">left </td></tr>
<tr><td class="c006">function application, constructor application, tag
application, <span class="machine"><span class="font-tt">assert</span></span>,
<span class="machine"><span class="font-tt">lazy</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">-   -.</span></span> (prefix)</td><td class="c006">– </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">**</span></span>…<span class="machine"><span class="font-tt">   lsl   lsr   asr</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">*</span></span>…<span class="machine"><span class="font-tt">   /</span></span>…<span class="machine"><span class="font-tt">   %</span></span>…<span class="machine"><span class="font-tt">   mod   land   lor   lxor</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"> <span class="machine"><span class="font-tt">+</span></span>…<span class="machine"><span class="font-tt">   -</span></span>…</td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">::</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="font-tt">@</span>…<span class="machine"><span class="font-tt">   ^</span></span>…</td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">=</span></span>…<span class="machine"><span class="font-tt">   &lt;</span></span>…<span class="machine"><span class="font-tt">   &gt;</span></span>…<span class="machine"><span class="font-tt">   |</span></span>…<span class="machine"><span class="font-tt">   &amp;</span></span>…<span class="machine"><span class="font-tt">   $</span></span>…<span class="machine"><span class="font-tt">   !=</span></span></td><td class="c006">left </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">&amp;   &amp;&amp;</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">or  ||</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">,</span></span></td><td class="c006">– </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">&lt;-   :=</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">if</span></span></td><td class="c006">– </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">;</span></span></td><td class="c006">right </td></tr>
<tr><td class="c006"><span class="machine"><span class="font-tt">let  match  fun  function  try</span></span></td><td class="c006">– </td></tr>
</tbody></table></div></div><p>It is simple to test or refresh one’s understanding:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> 3 + 3 <span class="ocamlkeyword">mod</span> 2, 3 + (3 <span class="ocamlkeyword">mod</span> 2), (3 + 3) <span class="ocamlkeyword">mod</span> 2;;</div>



<div class="pre caml-output ok">- : int * int * int = (4, 4, 0)</div></div>

</div>
<h3 class="subsection" id="ss:expr-basic"><a class="section-anchor" href="#ss:expr-basic" aria-hidden="true">﻿</a><span class="number">7.2</span> Basic expressions</h3>
<h4 class="subsubsection" id="sss:expr-constants"><a class="section-anchor" href="#sss:expr-constants" aria-hidden="true">﻿</a>Constants</h4>
<p>An expression consisting in a constant evaluates to this constant. For example,
<span class="font-tt">3.14</span> or <span class="font-tt">[||]</span>.</p><h4 class="subsubsection" id="sss:expr-var"><a class="section-anchor" href="#sss:expr-var" aria-hidden="true">﻿</a>Value paths</h4>
<p>An expression consisting in an access path evaluates to the value bound to
this path in the current evaluation environment. The path can
be either a value name or an access path to a value component of a module.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Float.ArrayLabels.to_list;;</div>



<div class="pre caml-output ok">- : Float.ArrayLabels.t -&gt; float list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-parenthesized"><a class="section-anchor" href="#sss:expr-parenthesized" aria-hidden="true">﻿</a>Parenthesized expressions</h4>
<p>
<a id="hevea_manual.kwd58"></a>
<a id="hevea_manual.kwd59"></a></p><p>The expressions <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">)</span> and <span class="syntax-token">begin</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">end</span> have the same
value as <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. The two constructs are semantically equivalent, but it
is good style to use <span class="syntax-token">begin</span> … <span class="syntax-token">end</span> inside control structures:
</p><pre>        if … then begin … ; … end else begin … ; … end
</pre><p>
and <span class="syntax-token">(</span> … <span class="syntax-token">)</span> for the other grouping situations.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> x = 1 + 2 * 3
  <span class="ocamlkeyword">let</span> y = (1 + 2) * 3;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> x : int = 7
<span class="ocamlkeyword">val</span> y : int = 9</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f a b =
    <span class="ocamlkeyword">if</span> a = b <span class="ocamlkeyword">then</span>
      print_endline <span class="ocamlstring">"Equal"</span>
    <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">begin</span>
        print_string <span class="ocamlstring">"Not Equal: "</span>;
        print_int a;
        print_string <span class="ocamlstring">" and "</span>;
        print_int b;
        print_newline ()
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Parenthesized expressions can contain a type constraint, as in <span class="syntax-token">(</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>. This constraint forces the type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> to be
compatible with <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>.</p><p>Parenthesized expressions can also contain coercions
<span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] <span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><span class="syntax-token">)</span> (see
subsection&nbsp;<a href="#ss%3Aexpr-coercions">11.7.7</a> below).</p><h4 class="subsubsection" id="sss:expr-functions-application"><a class="section-anchor" href="#sss:expr-functions-application" aria-hidden="true">﻿</a>Function application</h4>
<p>Function application is denoted by juxtaposition of (possibly labeled)
expressions. The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub> … <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>
evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and those appearing in <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>
to <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>. The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> must evaluate to a
functional value <span class="font-it">f</span>, which is then applied to the values of
<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>, …, <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub>.</p><p>The order in which the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, <a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub>1</sub>, …,
<a class="syntax" href="#argument"><span class="nonterminal">argument</span></a><sub><span class="font-it">n</span></sub> are evaluated is not specified.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> List.fold_left ( + ) 0 [1; 2; 3; 4; 5];;</div>



<div class="pre caml-output ok">- : int = 15</div></div>

</div><p>Arguments and parameters are matched according to their respective
labels. Argument order is irrelevant, except among arguments with the
same label, or no label.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> ListLabels.fold_left ~f:( @ ) ~init:[] [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]];;</div>



<div class="pre caml-output ok">- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]</div></div>

</div><p>If a parameter is specified as optional (label prefixed by <span class="syntax-token">?</span>) in the
type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the corresponding argument will be automatically
wrapped with the constructor <span class="machine"><span class="font-tt">Some</span></span>, except if the argument itself is
also prefixed by <span class="syntax-token">?</span>, in which case it is passed as is.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fullname ?title first second =
    <span class="ocamlkeyword">match</span> title <span class="ocamlkeyword">with</span>
    | Some t -&gt; t ^ <span class="ocamlstring">" "</span> ^ first ^ <span class="ocamlstring">" "</span> ^ second
    | None -&gt; first ^ <span class="ocamlstring">" "</span> ^ second

  <span class="ocamlkeyword">let</span> name = fullname ~title:<span class="ocamlstring">"Mrs"</span> <span class="ocamlstring">"Jane"</span> <span class="ocamlstring">"Fisher"</span>

  <span class="ocamlkeyword">let</span> address ?title first second town =
    fullname ?title first second ^ <span class="ocamlstring">"\n"</span> ^ town;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fullname : ?title:string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> name : string = <span class="ocamlstring">"Mrs Jane Fisher"</span>
<span class="ocamlkeyword">val</span> address : ?title:string -&gt; string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>If a non-labeled argument is passed, and its corresponding parameter
is preceded by one or several optional parameters, then these
parameters are <em>defaulted</em>, <em>i.e.</em> the value <span class="machine"><span class="font-tt">None</span></span> will be
passed for them.
All other missing parameters (without corresponding argument), both
optional and non-optional, will be kept, and the result of the
function will still be a function of these missing parameters to the
body of <span class="font-it">f</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> fullname ?title first second =
    <span class="ocamlkeyword">match</span> title <span class="ocamlkeyword">with</span>
    | Some t -&gt; t ^ <span class="ocamlstring">" "</span> ^ first ^ <span class="ocamlstring">" "</span> ^ second
    | None -&gt; first ^ <span class="ocamlstring">" "</span> ^ second

  <span class="ocamlkeyword">let</span> name = fullname <span class="ocamlstring">"Jane"</span> <span class="ocamlstring">"Fisher"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> fullname : ?title:string -&gt; string -&gt; string -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> name : string = <span class="ocamlstring">"Jane Fisher"</span></div></div>

</div><p>In all cases but exact match of order and labels, without optional
parameters, the function type should be known at the application
point. This can be ensured by adding a type constraint. Principality
of the derivation can be checked in the <span class="machine"><span class="font-tt">-principal</span></span> mode.</p><p>As a special case, OCaml supports <span class="machine"><span class="font-tt">labels-omitted</span></span> full applications:
if the function has a known arity, all the arguments are unlabeled,
and their number matches the number of non-optional parameters, then
labels are ignored and non-optional parameters are matched in their
definition order. Optional arguments are defaulted. This omission of
labels is discouraged and results in a warning, see <a href="comp.html#ss%3Awarn6">13.5.1</a>.</p><h4 class="subsubsection" id="sss:expr-function-definition"><a class="section-anchor" href="#sss:expr-function-definition" aria-hidden="true">﻿</a>Function definition</h4>
<p>Two syntactic forms are provided to define functions. The first form
is introduced by the keyword <span class="machine"><span class="font-tt">function</span></span>:
<a id="hevea_manual.kwd60"></a></p><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><span class="syntax-token">function</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub> </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">… </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>
This expression evaluates to a functional value with one argument.
When this function is applied to a value <span class="font-it">v</span>, this value is
matched against each pattern <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>.
If one of these matchings succeeds, that is, if the value <span class="font-it">v</span>
matches the pattern <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> for some <span class="font-it">i</span>,
then the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> associated to the selected pattern
is evaluated, and its value becomes the value of the function
application. The evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an
environment enriched by the bindings performed during the matching.</p><p>If several patterns match the argument <span class="font-it">v</span>, the one that occurs
first in the function definition is selected. If none of the patterns
matches the argument, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual2"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (<span class="ocamlkeyword">function</span> (0, 0) -&gt; <span class="ocamlstring">"both zero"</span>
          | (0, _) -&gt; <span class="ocamlstring">"first only zero"</span>
          | (_, 0) -&gt; <span class="ocamlstring">"second only zero"</span>
          | (_, _) -&gt; <span class="ocamlstring">"neither zero"</span>)
  (7, 0);;</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"second only zero"</span></div></div>

</div><p>The other form of function definition is introduced by the keyword <span class="machine"><span class="font-tt">fun</span></span>:
<a id="hevea_manual.kwd61"></a>
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
This expression is equivalent to:
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> … <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = (<span class="ocamlkeyword">fun</span> a -&gt; <span class="ocamlkeyword">fun</span> b -&gt; <span class="ocamlkeyword">fun</span> c -&gt; a + b + c)
  <span class="ocamlkeyword">let</span> g = (<span class="ocamlkeyword">fun</span> a b c -&gt; a + b + c);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> g : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>An optional type constraint <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> can be added before <span class="machine"><span class="font-tt">-&gt;</span></span> to enforce
the type of the result to be compatible with the constraint <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>:
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
is equivalent to
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> … <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> (<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> )
</div><p>Beware of the small syntactic difference between a type constraint on
the last parameter
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … (<a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">:</span><a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>)<span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><p>
and one on the result
</p><div class="center">
<span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> eq = <span class="ocamlkeyword">fun</span> (a : int) (b : int) -&gt; a = b
  <span class="ocamlkeyword">let</span> eq2 = <span class="ocamlkeyword">fun</span> a b : bool -&gt; a = b
  <span class="ocamlkeyword">let</span> eq3 = <span class="ocamlkeyword">fun</span> (a : int) (b : int) : bool -&gt; a = b;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> eq : int -&gt; int -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eq2 : 'a -&gt; 'a -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> eq3 : int -&gt; int -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The parameter patterns <span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> and <span class="syntax-token">~(</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>]<span class="syntax-token">)</span>
are shorthands for respectively <span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a><span class="syntax-token">:</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> and
<span class="syntax-token">~</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a><span class="syntax-token">:(</span><a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>]<span class="syntax-token">)</span>, and similarly for their optional
counterparts.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> bool_map ~cmp:(cmp : int -&gt; int -&gt; bool) l =
    List.map cmp l

  <span class="ocamlkeyword">let</span> bool_map' ~(cmp : int -&gt; int -&gt; bool) l =
    List.map cmp l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> bool_map : cmp:(int -&gt; int -&gt; bool) -&gt; int list -&gt; (int -&gt; bool) list =
  &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> bool_map' : cmp:(int -&gt; int -&gt; bool) -&gt; int list -&gt; (int -&gt; bool) list =
  &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>A function of the form <span class="syntax-token">fun</span> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> <span class="syntax-token">:(</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> <span class="syntax-token">)</span> <span class="syntax-token">-&gt;</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is equivalent to
</p><div class="center">
<span class="syntax-token">fun</span> <span class="syntax-token">?</span> <a class="syntax" href="lex.html#label-name"><span class="nonterminal">lab</span></a> <span class="syntax-token">:</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">-&gt;</span>
<span class="syntax-token">let</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">=</span>
<span class="syntax-token">match</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">with</span> <span class="syntax-token">Some</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">-&gt;</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">|</span> <span class="syntax-token">None</span> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
where <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a>
is a fresh variable, except that it is unspecified when <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>0</sub> is evaluated.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> open_file_for_input ?binary filename =
    <span class="ocamlkeyword">match</span> binary <span class="ocamlkeyword">with</span>
    | Some <span class="ocamlkeyword">true</span> -&gt; open_in_bin filename
    | Some <span class="ocamlkeyword">false</span> | None -&gt; open_in filename

  <span class="ocamlkeyword">let</span> open_file_for_input' ?(binary=<span class="ocamlkeyword">false</span>) filename =
    <span class="ocamlkeyword">if</span> binary <span class="ocamlkeyword">then</span> open_in_bin filename <span class="ocamlkeyword">else</span> open_in filename;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> open_file_for_input : ?binary:bool -&gt; string -&gt; in_channel = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> open_file_for_input' : ?binary:bool -&gt; string -&gt; in_channel = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>After these two transformations, expressions are of the form
</p><div class="center">
<span class="syntax-token">fun</span> [<a class="syntax" href="lex.html#label"><span class="nonterminal">label</span></a><sub>1</sub>] <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> … <span class="syntax-token">fun</span> [<a class="syntax" href="lex.html#label"><span class="nonterminal">label</span></a><sub><span class="font-it">n</span></sub>] <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
If we ignore labels, which will only be meaningful at function
application, this is equivalent to
</p><div class="center">
<span class="syntax-token">function</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> … <span class="syntax-token">function</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
That is, the <span class="syntax-token">fun</span> expression above evaluates to a curried function
with <span class="font-it">n</span> arguments: after applying this function <span class="font-it">n</span> times to the
values <span class="nonterminal">v</span><sub>1</sub> … <span class="nonterminal">v</span><sub><span class="font-it">n</span></sub>, the values will be matched
in parallel against the patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> … <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>.
If the matching succeeds, the function returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> in
an environment enriched by the bindings performed during the matchings.
If the matching fails, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.</p><h4 class="subsubsection" id="sss:guards-in-pattern-matchings"><a class="section-anchor" href="#sss:guards-in-pattern-matchings" aria-hidden="true">﻿</a>Guards in pattern-matchings</h4>
<p><a id="hevea_manual.kwd62"></a>
The cases of a pattern matching (in the <span class="syntax-token">function</span>, <span class="syntax-token">match</span> and
<span class="syntax-token">try</span> constructs) can include guard expressions, which are
arbitrary boolean expressions that must evaluate to <span class="machine"><span class="font-tt">true</span></span> for the
match case to be selected. Guards occur just before the <span class="syntax-token">-&gt;</span> token and
are introduced by the <span class="syntax-token">when</span> keyword:</p><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><span class="syntax-token">function</span></td><td class="c007"><span class="nonterminal">pattern</span><sub>1</sub>   [<span class="syntax-token">when</span>   <span class="nonterminal">cond</span><sub>1</sub>]</td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="nonterminal">expr</span><sub>1</sub> </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">… </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="nonterminal">pattern</span><sub><span class="font-it">n</span></sub>    [<span class="syntax-token">when</span>   <span class="nonterminal">cond</span><sub><span class="font-it">n</span></sub>]</td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="nonterminal">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Matching proceeds as described before, except that if the value
matches some pattern <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> which has a guard <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub>, then the
expression <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> is evaluated (in an environment enriched by the
bindings performed during matching). If <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> evaluates to <span class="machine"><span class="font-tt">true</span></span>,
then <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated and its value returned as the result of the
matching, as usual. But if <span class="nonterminal">cond</span><sub><span class="font-it">i</span></sub> evaluates to <span class="machine"><span class="font-tt">false</span></span>, the matching
is resumed against the patterns following <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> repeat f = <span class="ocamlkeyword">function</span>
    | 0 -&gt; ()
    | n <span class="ocamlkeyword">when</span> n &gt; 0 -&gt; f (); repeat f (n - 1)
    | _ -&gt; raise (Invalid_argument <span class="ocamlstring">"repeat"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> repeat : (unit -&gt; 'a) -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-localdef"><a class="section-anchor" href="#sss:expr-localdef" aria-hidden="true">﻿</a>Local definitions</h4>
<p><a id="hevea_manual.kwd63"></a></p><p>The <span class="syntax-token">let</span> and <span class="syntax-token">let</span> <span class="syntax-token">rec</span> constructs bind value names locally.
The construct
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> … <span class="syntax-token">and</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> … <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> in some unspecified order and matches
their values against the patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> … <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the
matchings succeed, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is evaluated in the environment enriched by
the bindings performed during matching, and the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
returned as the value of the whole <span class="syntax-token">let</span> expression. If one of the
matchings fails, the exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual3"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> v =
    <span class="ocamlkeyword">let</span> x = 1 <span class="ocamlkeyword">in</span> [x; x; x]

  <span class="ocamlkeyword">let</span> v' =
    <span class="ocamlkeyword">let</span> a, b = (1, 2) <span class="ocamlkeyword">in</span> a + b

  <span class="ocamlkeyword">let</span> v'' =
    <span class="ocamlkeyword">let</span> a = 1 <span class="ocamlkeyword">and</span> b = 2 <span class="ocamlkeyword">in</span> a + b;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> v : int list = [1; 1; 1]
<span class="ocamlkeyword">val</span> v' : int = 3
<span class="ocamlkeyword">val</span> v'' : int = 3</div></div>

</div><p>An alternate syntax is provided to bind variables to functional
values: instead of writing
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
in a <span class="syntax-token">let</span> expression, one may instead write
</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub>1</sub> … <a class="syntax" href="#parameter"><span class="nonterminal">parameter</span></a><sub><span class="font-it">m</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f = <span class="ocamlkeyword">fun</span> x -&gt; <span class="ocamlkeyword">fun</span> y -&gt; <span class="ocamlkeyword">fun</span> z -&gt; x + y + z

  <span class="ocamlkeyword">let</span> f' = <span class="ocamlkeyword">fun</span> x y z -&gt; x + y + z

  <span class="ocamlkeyword">let</span> f'' x y z = x + y + z;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> f' : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> f'' : int -&gt; int -&gt; int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Recursive definitions of names are introduced by <span class="syntax-token">let</span> <span class="syntax-token">rec</span>:
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">and</span> … <span class="syntax-token">and</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>The only difference with the <span class="syntax-token">let</span> construct described above is
that the bindings of names to values performed by the
pattern-matching are considered already performed when the expressions
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are evaluated. That is, the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>
to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> can reference identifiers that are bound by one of the
patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>, …, <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>, and expect them to have the
same value as in <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the body of the <span class="syntax-token">let</span> <span class="syntax-token">rec</span> construct.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> even =
    <span class="ocamlkeyword">function</span> 0 -&gt; <span class="ocamlkeyword">true</span> | n -&gt; odd (n - 1)
  <span class="ocamlkeyword">and</span> odd =
    <span class="ocamlkeyword">function</span> 0 -&gt; <span class="ocamlkeyword">false</span> | n -&gt; even (n - 1)
  <span class="ocamlkeyword">in</span>
    even 1000;;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div><p>The recursive definition is guaranteed to behave as described above if
the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are function definitions
(<span class="syntax-token">fun</span> … or <span class="syntax-token">function</span> …), and the patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>
… <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> are just value names, as in:
</p><div class="center">
<span class="syntax-token">let</span> <span class="syntax-token">rec</span> <span class="nonterminal">name</span><sub>1</sub> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> …
<span class="syntax-token">and</span> …
<span class="syntax-token">and</span> <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <span class="syntax-token">fun</span> …
<span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
</div><p>
This defines <span class="nonterminal">name</span><sub>1</sub> … <span class="nonterminal">name</span><sub><span class="font-it">n</span></sub> as mutually recursive functions
local to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><p>The behavior of other forms of <span class="syntax-token">let</span> <span class="syntax-token">rec</span> definitions is
implementation-dependent. The current implementation also supports
a certain class of recursive definitions of non-functional values,
as explained in section&nbsp;<a href="letrecvalues.html#s%3Aletrecvalues">12.1</a>.</p>
<h4 class="subsubsection" id="sss:expr-let-exception"><a class="section-anchor" href="#sss:expr-let-exception" aria-hidden="true">﻿</a>Local exceptions</h4>
<p>
(Introduced in OCaml 4.04)</p><p>It is possible to define local exceptions in expressions:
 <span class="syntax-token">let</span> <span class="nonterminal">exception</span> <a class="syntax" href="typedecl.html#constr-decl"><span class="nonterminal">constr-decl</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>  .</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> map_empty_on_negative f l =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">exception</span> Negative <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> aux x = <span class="ocamlkeyword">if</span> x &lt; 0 <span class="ocamlkeyword">then</span> raise Negative <span class="ocamlkeyword">else</span> f x <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">try</span> List.map aux l <span class="ocamlkeyword">with</span> Negative -&gt; [];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map_empty_on_negative : (int -&gt; 'a) -&gt; int list -&gt; 'a list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The syntactic scope of the exception constructor is the inner
expression, but nothing prevents exception values created with this
constructor from escaping this scope. Two executions of the definition
above result in two incompatible exception constructors (as for any
exception definition). For instance:</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> gen () = <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">exception</span> A <span class="ocamlkeyword">in</span> A

  <span class="ocamlkeyword">let</span> () = <span class="ocamlkeyword">assert</span>(gen () = gen ());;</div>



<div class="pre caml-output ok">Exception: Assert_failure (<span class="ocamlstring">"expr.etex"</span>, 3, 9).</div></div>

</div>
<h4 class="subsubsection" id="sss:expr-explicit-polytype"><a class="section-anchor" href="#sss:expr-explicit-polytype" aria-hidden="true">﻿</a>Explicit polymorphic type annotations</h4>
<p>
(Introduced in OCaml 3.12)</p><p>Polymorphic type annotations in <span class="syntax-token">let</span>-definitions behave in a way
similar to polymorphic methods:</p><div class="center">
<span class="syntax-token">let</span> <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> … <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">.</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> 
</div><p>These annotations explicitly require the defined value to be polymorphic,
and allow one to use this polymorphism in recursive occurrences
(when using <span class="syntax-token">let</span> <span class="syntax-token">rec</span>). Note however that this is a normal polymorphic
type, unifiable with any instance of itself.</p>
<h3 class="subsection" id="ss:expr-control"><a class="section-anchor" href="#ss:expr-control" aria-hidden="true">﻿</a><span class="number">7.3</span> Control structures</h3>
<h4 class="subsubsection" id="sss:expr-sequence"><a class="section-anchor" href="#sss:expr-sequence" aria-hidden="true">﻿</a>Sequence</h4>
<p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> first, then
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, and returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> print_pair (a, b) =
    print_string <span class="ocamlstring">"("</span>;
    print_string (string_of_int a);
    print_string <span class="ocamlstring">","</span>;
    print_string (string_of_int b);
    print_endline <span class="ocamlstring">")"</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> print_pair : int * int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-conditional"><a class="section-anchor" href="#sss:expr-conditional" aria-hidden="true">﻿</a>Conditional</h4>
<p>
<a id="hevea_manual.kwd64"></a></p><p>The expression <span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> evaluates to
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to the boolean <span class="syntax-token">true</span>,
and to the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to the boolean
<span class="syntax-token">false</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> factorial x =
    <span class="ocamlkeyword">if</span> x &lt;= 1 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> x * factorial (x - 1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> factorial : int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> part can be omitted, in which case it defaults to
<span class="syntax-token">else</span> <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> debug = <span class="ocamlkeyword">ref</span> <span class="ocamlkeyword">false</span>

  <span class="ocamlkeyword">let</span> log msg =
    <span class="ocamlkeyword">if</span> !debug <span class="ocamlkeyword">then</span> prerr_endline msg;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> debug : bool <span class="ocamlkeyword">ref</span> = {contents = <span class="ocamlkeyword">false</span>}
<span class="ocamlkeyword">val</span> log : string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-case"><a class="section-anchor" href="#sss:expr-case" aria-hidden="true">﻿</a>Case expression</h4>
<p><a id="hevea_manual.kwd65"></a></p><p>The expression
</p><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><span class="syntax-token">match</span></td><td class="c007"><span class="font-sl">expr</span> </td></tr>
<tr><td class="c008"><span class="syntax-token">with</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub> </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">… </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>
matches the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> against the patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to
<a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the matching against <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> succeeds, the
associated expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated, and its value becomes the
value of the whole <span class="syntax-token">match</span> expression. The evaluation of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an environment enriched by the bindings
performed during matching. If several patterns match the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the one that occurs first in the <span class="syntax-token">match</span> expression is
selected.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> sum l =
    <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
    | [] -&gt; 0
    | h :: t -&gt; h + sum t;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> sum : int list -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>If none of the patterns match the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the
exception <span class="machine"><span class="font-tt">Match_failure</span></span> is raised.
<a id="hevea_manual4"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> unoption o =
    <span class="ocamlhighlight">match o with
    | Some x -&gt; x</span> ;;</div>



<div class="pre caml-output warn"><span class="ocamlwarning">Warning</span> 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None

val unoption : 'a option -&gt; 'a = &lt;fun&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> l = List.map unoption [Some 1; Some 10; None; Some 2];;</div>



<div class="pre caml-output ok">Exception: Match_failure (<span class="ocamlstring">"expr.etex"</span>, 2, 2).</div></div>

</div><h4 class="subsubsection" id="sss:expr-boolean-operators"><a class="section-anchor" href="#sss:expr-boolean-operators" aria-hidden="true">﻿</a>Boolean operators</h4>
<p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">&amp;&amp;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span> if both
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluate to <span class="syntax-token">true</span>; otherwise, it evaluates to
<span class="syntax-token">false</span>. The first component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, is evaluated first. The
second component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, is not evaluated if the first component
evaluates to <span class="syntax-token">false</span>. Hence, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">&amp;&amp;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> behaves
exactly as
</p><div class="center">
<span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">else</span> <span class="syntax-token">false</span>.
</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">||</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span> if one of
the expressions
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to <span class="syntax-token">true</span>; otherwise, it evaluates to
<span class="syntax-token">false</span>. The first component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, is evaluated first. The
second component, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>, is not evaluated if the first component
evaluates to <span class="syntax-token">true</span>. Hence, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">||</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> behaves
exactly as
</p><div class="center">
<span class="syntax-token">if</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">then</span> <span class="syntax-token">true</span> <span class="syntax-token">else</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.
</div><p><a id="hevea_manual.kwd66"></a>
The boolean operators <span class="syntax-token">&amp;</span> and <span class="syntax-token">or</span> are deprecated synonyms for
(respectively) <span class="syntax-token">&amp;&amp;</span> and <span class="syntax-token">||</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> xor a b =
    (a || b) &amp;&amp; not (a &amp;&amp; b);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> xor : bool -&gt; bool -&gt; bool = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-loops"><a class="section-anchor" href="#sss:expr-loops" aria-hidden="true">﻿</a>Loops</h4>
<p><a id="hevea_manual.kwd67"></a>
The expression <span class="syntax-token">while</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">done</span> repeatedly
evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> while <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> evaluates to <span class="syntax-token">true</span>. The loop
condition <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> is evaluated and tested at the beginning of each
iteration. The whole <span class="syntax-token">while</span> … <span class="syntax-token">done</span> expression evaluates to
the unit value <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> i = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> chars = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">while</span> !i &lt; String.length s <span class="ocamlkeyword">do</span>
        chars := s.[!i] :: !chars;
        i := !i + 1
      <span class="ocamlkeyword">done</span>;
      List.rev !chars;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p><a id="hevea_manual.kwd68"></a>
The expression <span class="syntax-token">for</span> <span class="nonterminal">name</span> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">to</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> <span class="syntax-token">done</span>
first evaluates the expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> (the boundaries)
into integer values <span class="font-it">n</span> and <span class="font-it">p</span>. Then, the loop body <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> is
repeatedly evaluated in an environment where <span class="nonterminal">name</span> is successively
bound to the values
<span class="font-it">n</span>, <span class="font-it">n</span>+1, …, <span class="font-it">p</span>−1, <span class="font-it">p</span>.
The loop body is never evaluated if <span class="font-it">n</span> &gt; <span class="font-it">p</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">for</span> p = 0 <span class="ocamlkeyword">to</span> String.length s - 1 <span class="ocamlkeyword">do</span>
        l := s.[p] :: !l
      <span class="ocamlkeyword">done</span>;
      List.rev !l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <span class="syntax-token">for</span> <span class="nonterminal">name</span> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">downto</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">do</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> <span class="syntax-token">done</span>
evaluates similarly, except that <span class="nonterminal">name</span> is successively bound to the values
<span class="font-it">n</span>, <span class="font-it">n</span>−1, …, <span class="font-it">p</span>+1, <span class="font-it">p</span>.
The loop body is never evaluated if <span class="font-it">n</span> &lt; <span class="font-it">p</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> chars_of_string s =
    <span class="ocamlkeyword">let</span> l = <span class="ocamlkeyword">ref</span> [] <span class="ocamlkeyword">in</span>
      <span class="ocamlkeyword">for</span> p = String.length s - 1 <span class="ocamlkeyword">downto</span> 0 <span class="ocamlkeyword">do</span>
        l := s.[p] :: !l
      <span class="ocamlkeyword">done</span>;
      !l;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> chars_of_string : string -&gt; char list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>In both cases, the whole <span class="syntax-token">for</span> expression evaluates to the unit
value <span class="syntax-token">()</span>.</p><h4 class="subsubsection" id="sss:expr-exception-handling"><a class="section-anchor" href="#sss:expr-exception-handling" aria-hidden="true">﻿</a>Exception handling</h4>
<p>
<a id="hevea_manual.kwd69"></a></p><p>The expression
</p><table class="display dcenter"><tbody><tr class="c009"><td class="dcell"><table class="c001 cellpading0"><tbody><tr><td class="c008"><span class="syntax-token">try&nbsp;</span></td><td class="c007"><span class="font-sl">expr</span> </td></tr>
<tr><td class="c008"><span class="syntax-token">with</span></td><td class="c007"><span class="font-sl">pattern</span><sub>1</sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub>1</sub> </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007">… </td></tr>
<tr><td class="c008"><span class="syntax-token">|</span></td><td class="c007"><span class="font-sl">pattern</span><sub><span class="font-it">n</span></sub></td><td class="c007"><span class="syntax-token">-&gt;</span></td><td class="c007"><span class="font-sl">expr</span><sub><span class="font-it">n</span></sub>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>
evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and returns its value if the
evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> does not raise any exception. If the evaluation
of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> raises an exception, the exception value is matched against
the patterns <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to <a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. If the matching against
<a class="syntax" href="patterns.html#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> succeeds, the associated expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> is evaluated,
and its value becomes the value of the whole <span class="syntax-token">try</span> expression. The
evaluation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> takes place in an environment enriched by the
bindings performed during matching. If several patterns match the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the one that occurs first in the <span class="syntax-token">try</span> expression is
selected. If none of the patterns matches the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, the
exception value is raised again, thereby transparently “passing
through” the <span class="syntax-token">try</span> construct.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> find_opt p l =
    <span class="ocamlkeyword">try</span> Some (List.find p l) <span class="ocamlkeyword">with</span> Not_found -&gt; None;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div>
<h3 class="subsection" id="ss:expr-ops-on-data"><a class="section-anchor" href="#ss:expr-ops-on-data" aria-hidden="true">﻿</a><span class="number">7.4</span> Operations on data structures</h3>
<h4 class="subsubsection" id="sss:expr-products"><a class="section-anchor" href="#sss:expr-products" aria-hidden="true">﻿</a>Products</h4>
<p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> … <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> evaluates to the
<span class="font-it">n</span>-tuple of the values of expressions <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>. The
evaluation order of the subexpressions is not specified.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (1 + 2 * 3, (1 + 2) * 3, 1 + (2 * 3));;</div>



<div class="pre caml-output ok">- : int * int * int = (7, 9, 7)</div></div>

</div><h4 class="subsubsection" id="sss:expr-variants"><a class="section-anchor" href="#sss:expr-variants" aria-hidden="true">﻿</a>Variants</h4>
<p>The expression <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to the unary variant value
whose constructor is <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a>, and whose argument is the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Similarly, the expression <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> … <span class="syntax-token">,</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> evaluates to the n-ary variant value whose constructor is
<a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> and whose arguments are the values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, …,
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><p>The expression <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, …, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">)</span> evaluates to the
variant value whose constructor is <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a>, and whose arguments are
the values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> … <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = Var <span class="ocamlkeyword">of</span> string | Not <span class="ocamlkeyword">of</span> t | And <span class="ocamlkeyword">of</span> t * t | Or <span class="ocamlkeyword">of</span> t * t

  <span class="ocamlkeyword">let</span> test = And (Var <span class="ocamlstring">"x"</span>, Not (Or (Var <span class="ocamlstring">"y"</span>, Var <span class="ocamlstring">"z"</span>)));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = Var <span class="ocamlkeyword">of</span> string | Not <span class="ocamlkeyword">of</span> t | And <span class="ocamlkeyword">of</span> t * t | Or <span class="ocamlkeyword">of</span> t * t
<span class="ocamlkeyword">val</span> test : t = And (Var <span class="ocamlstring">"x"</span>, Not (Or (Var <span class="ocamlstring">"y"</span>, Var <span class="ocamlstring">"z"</span>)))</div></div>

</div><p>For lists, some syntactic sugar is provided. The expression
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">::</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> stands for the constructor <span class="syntax-token">(</span> <span class="syntax-token">::</span> <span class="syntax-token">)</span> 
applied to the arguments <span class="syntax-token">(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">,</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span>, and therefore
evaluates to the list whose head is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> and whose tail
is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>. The expression <span class="syntax-token">[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> is equivalent to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">::</span> … <span class="syntax-token">::</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">::</span>
<span class="syntax-token">[]</span>, and therefore evaluates to the list whose elements are the
values of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> 0 :: [1; 2; 3] = 0 :: 1 :: 2 :: 3 :: [];;</div>



<div class="pre caml-output ok">- : bool = <span class="ocamlkeyword">true</span></div></div>

</div><h4 class="subsubsection" id="sss:expr-polyvars"><a class="section-anchor" href="#sss:expr-polyvars" aria-hidden="true">﻿</a>Polymorphic variants</h4>
<p>The expression <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to the polymorphic variant
value whose tag is <a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a>, and whose argument is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> with_counter x = `V (x, <span class="ocamlkeyword">ref</span> 0);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> with_counter : 'a -&gt; [&gt; `V <span class="ocamlkeyword">of</span> 'a * int <span class="ocamlkeyword">ref</span> ] = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-records"><a class="section-anchor" href="#sss:expr-records" aria-hidden="true">﻿</a>Records</h4>
<p>The expression <span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>] <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]}</span> evaluates to the record value
{ <span class="font-it">field</span><sub>1</sub> = <span class="font-it">v</span><sub>1</sub>; …; <span class="font-it">field</span><sub><span class="font-it">n</span></sub> = <span class="font-it">v</span><sub><span class="font-it">n</span></sub> }
where <span class="font-it">v</span><sub><span class="font-it">i</span></sub> is the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">i</span></sub> for <span class="font-it">i</span> = 1,… , <span class="font-it">n</span>.
A single identifier <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>,
and a qualified identifier <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>.
The fields <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> to <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> must all belong to the same record
type; each field of this record type must appear exactly
once in the record expression, though they can appear in any
order. The order in which <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> are evaluated is not
specified. Optional type constraints can be added after each field
<span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span>… <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span>
to force the type of <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> to be compatible with <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">k</span></sub>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {house_no : int; street : string; town : string; postcode : string}

  <span class="ocamlkeyword">let</span> address x =
    Printf.sprintf <span class="ocamlstring">"The occupier\n%i %s\n%s\n%s"</span>
      x.house_no x.street x.town x.postcode;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = {
  house_no : int;
  street : string;
  town : string;
  postcode : string;
}
<span class="ocamlkeyword">val</span> address : t -&gt; string = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression
<span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>] <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>] <span class="syntax-token">}</span>
builds a fresh record with fields <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> … <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> equal to
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> … <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>, and all other fields having the same value as
in the record <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. In other terms, it returns a shallow copy of
the record <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>, except for the fields <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> … <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>,
which are initialized to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> … <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub>. As previously,
single identifier <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub>,
a qualified identifier <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> and it is
possible to add an optional type constraint on each field being updated
with
<span class="syntax-token">{</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">with</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {house_no : int; street : string; town : string; postcode : string}

  <span class="ocamlkeyword">let</span> uppercase_town address =
    {address <span class="ocamlkeyword">with</span> town = String.uppercase_ascii address.town};;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = {
  house_no : int;
  street : string;
  town : string;
  postcode : string;
}
<span class="ocamlkeyword">val</span> uppercase_town : t -&gt; t = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to a record
value, and returns the value associated to <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> in this record
value.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to a record
value, which is then modified in-place by replacing the value
associated to <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> in this record by the value of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>. This operation is permitted only if <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> has been
declared <span class="syntax-token">mutable</span> in the definition of the record type. The whole
expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> evaluates to the unit value
<span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">type</span> t = {<span class="ocamlkeyword">mutable</span> upper : int; <span class="ocamlkeyword">mutable</span> lower : int; <span class="ocamlkeyword">mutable</span> other : int}

  <span class="ocamlkeyword">let</span> stats = {upper = 0; lower = 0; other = 0}

  <span class="ocamlkeyword">let</span> collect =
    String.iter
      (<span class="ocamlkeyword">function</span>
       | 'A'..'Z' -&gt; stats.upper &lt;- stats.upper + 1
       | 'a'..'z' -&gt; stats.lower &lt;- stats.lower + 1
       | _ -&gt; stats.other &lt;- stats.other + 1);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">type</span> t = { <span class="ocamlkeyword">mutable</span> upper : int; <span class="ocamlkeyword">mutable</span> lower : int; <span class="ocamlkeyword">mutable</span> other : int; }
<span class="ocamlkeyword">val</span> stats : t = {upper = 0; lower = 0; other = 0}
<span class="ocamlkeyword">val</span> collect : string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-arrays"><a class="section-anchor" href="#sss:expr-arrays" aria-hidden="true">﻿</a>Arrays</h4>
<p>The expression <span class="syntax-token">[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span> evaluates to
a <span class="font-it">n</span>-element array, whose elements are initialized with the values of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> to <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub><span class="font-it">n</span></sub> respectively. The order in which these
expressions are evaluated is unspecified.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span> returns the value of element
number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> in the array denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>. The first element
has number 0; the last element has number <span class="font-it">n</span>−1, where <span class="font-it">n</span> is the
size of the array. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if the
access is out of bounds.</p><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.(</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">)</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> modifies in-place
the array denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, replacing element number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> by
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub>. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if
the access is out of bounds. The value of the whole expression is <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> scale arr n =
    <span class="ocamlkeyword">for</span> x = 0 <span class="ocamlkeyword">to</span> Array.length arr - 1 <span class="ocamlkeyword">do</span>
      arr.(x) &lt;- arr.(x) * n
    <span class="ocamlkeyword">done</span>

  <span class="ocamlkeyword">let</span> x = [|1; 10; 100|]
  <span class="ocamlkeyword">let</span> _ = scale x 2;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> scale : int array -&gt; int -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> x : int array = [|2; 20; 200|]</div></div>

</div><h4 class="subsubsection" id="sss:expr-strings"><a class="section-anchor" href="#sss:expr-strings" aria-hidden="true">﻿</a>Strings</h4>
<p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">]</span> returns the value of character
number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> in the string denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>. The first character
has number 0; the last character has number <span class="font-it">n</span>−1, where <span class="font-it">n</span> is the
length of the string. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if the
access is out of bounds.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> iter f s =
    <span class="ocamlkeyword">for</span> x = 0 <span class="ocamlkeyword">to</span> String.length s - 1 <span class="ocamlkeyword">do</span> f s.[x] <span class="ocamlkeyword">done</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> iter : (char -&gt; 'a) -&gt; string -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <span class="syntax-token">.[</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> <span class="syntax-token">]</span> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub> modifies in-place
the string denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub>, replacing character number <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> by
the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>3</sub>. The exception <span class="machine"><span class="font-tt">Invalid_argument</span></span> is raised if
the access is out of bounds. The value of the whole expression is <span class="syntax-token">()</span>.
<span class="font-bold">Note:</span> this possibility is offered only for backward
compatibility with older versions of OCaml and will be removed in a
future version. New code should use byte sequences and the <span class="machine"><span class="font-tt">Bytes.set</span></span>
function.</p>
<h3 class="subsection" id="ss:expr-operators"><a class="section-anchor" href="#ss:expr-operators" aria-hidden="true">﻿</a><span class="number">7.5</span> Operators</h3>
<p>
<a id="hevea_manual.kwd70"></a>
<a id="hevea_manual.kwd71"></a>
<a id="hevea_manual.kwd72"></a>
<a id="hevea_manual.kwd73"></a>
<a id="hevea_manual.kwd74"></a>
<a id="hevea_manual.kwd75"></a>
<a id="hevea_manual.kwd76"></a></p><p>Symbols from the class <a class="syntax" href="lex.html#infix-symbol"><span class="nonterminal">infix-symbol</span></a>, as well as the keywords
<span class="syntax-token">*</span>, <span class="syntax-token">+</span>, <span class="syntax-token">-</span>, <span class="syntax-token">-.</span>, <span class="syntax-token">=</span>, <span class="syntax-token">!=</span>, <span class="syntax-token">&lt;</span>, <span class="syntax-token">&gt;</span>, <span class="syntax-token">or</span>, <span class="syntax-token">||</span>,
<span class="syntax-token">&amp;</span>, <span class="syntax-token">&amp;&amp;</span>, <span class="syntax-token">:=</span>, <span class="syntax-token">mod</span>, <span class="syntax-token">land</span>, <span class="syntax-token">lor</span>, <span class="syntax-token">lxor</span>, <span class="syntax-token">lsl</span>, <span class="syntax-token">lsr</span>,
and <span class="syntax-token">asr</span> can appear in infix position (between two
expressions). Symbols from the class <a class="syntax" href="lex.html#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a>, as well as
the keywords <span class="syntax-token">-</span> and <span class="syntax-token">-.</span>
can appear in prefix position (in front of an expression).</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> (( * ), ( := ), ( || ));;</div>



<div class="pre caml-output ok">- : (int -&gt; int -&gt; int) * ('a <span class="ocamlkeyword">ref</span> -&gt; 'a -&gt; unit) * (bool -&gt; bool -&gt; bool) =
(&lt;<span class="ocamlkeyword">fun</span>&gt;, &lt;<span class="ocamlkeyword">fun</span>&gt;, &lt;<span class="ocamlkeyword">fun</span>&gt;)</div></div>

</div><p>Infix and prefix symbols do not have a fixed meaning: they are simply
interpreted as applications of functions bound to the names
corresponding to the symbols. The expression <a class="syntax" href="lex.html#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is
interpreted as the application <span class="syntax-token">(</span> <a class="syntax" href="lex.html#prefix-symbol"><span class="nonterminal">prefix-symbol</span></a> <span class="syntax-token">)</span>
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Similarly, the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="lex.html#infix-symbol"><span class="nonterminal">infix-symbol</span></a> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub> is
interpreted as the application <span class="syntax-token">(</span> <a class="syntax" href="lex.html#infix-symbol"><span class="nonterminal">infix-symbol</span></a> <span class="syntax-token">)</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>1</sub> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><sub>2</sub>.</p><p>The table below lists the symbols defined in the initial environment
and their initial meaning. (See the description of the core
library module <span class="machine"><span class="font-tt">Stdlib</span></span> in chapter&nbsp;<a href="core.html#c%3Acorelib">27</a> for more
details). Their meaning may be changed at any time using
<span class="syntax-token">let</span> <span class="syntax-token">(</span> <a class="syntax" href="names.html#infix-op"><span class="nonterminal">infix-op</span></a> <span class="syntax-token">)</span> <span class="nonterminal">name</span><sub>1</sub> <span class="nonterminal">name</span><sub>2</sub> <span class="syntax-token">=</span> …</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> ( + ), ( - ), ( * ), ( / ) = Int64.(add, sub, mul, div);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> ( + ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( - ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( * ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> ( / ) : int64 -&gt; int64 -&gt; int64 = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>Note: the operators <span class="syntax-token">&amp;&amp;</span>, <span class="syntax-token">||</span>, and <span class="syntax-token">~-</span> are handled specially
and it is not advisable to change their meaning.</p><p>The keywords <span class="syntax-token">-</span> and <span class="syntax-token">-.</span> can appear both as infix and
prefix operators. When they appear as prefix operators, they are
interpreted respectively as the functions <span class="syntax-token">(~-)</span> and <span class="syntax-token">(~-.)</span>.</p><p><a id="hevea_manual.kwd77"></a><a id="hevea_manual.kwd78"></a><a id="hevea_manual.kwd79"></a><a id="hevea_manual.kwd80"></a><a id="hevea_manual.kwd81"></a><a id="hevea_manual.kwd82"></a><a id="hevea_manual.kwd83"></a></p><div class="tableau">
<div class="center"><table class="c000 cellpadding1" border="1"><tbody><tr><td class="c004"><span class="font-bold">Operator</span></td><td class="c004"><span class="font-bold">Initial meaning</span> </td></tr>
<tr><td class="c012">
<span class="machine"><span class="font-tt">+</span></span></td><td class="c011">Integer addition. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">-</span></span> (infix)</td><td class="c011">Integer subtraction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">~-   -</span></span> (prefix)</td><td class="c011">Integer negation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">*</span></span></td><td class="c011">Integer multiplication. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">/</span></span></td><td class="c011">Integer division.
Raise <span class="machine"><span class="font-tt">Division_by_zero</span></span> if second argument is zero. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">mod</span></span></td><td class="c011">Integer modulus. Raise
<span class="machine"><span class="font-tt">Division_by_zero</span></span> if second argument is zero. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">land</span></span></td><td class="c011">Bitwise logical “and” on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lor</span></span></td><td class="c011">Bitwise logical “or” on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lxor</span></span></td><td class="c011">Bitwise logical “exclusive or” on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lsl</span></span></td><td class="c011">Bitwise logical shift left on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">lsr</span></span></td><td class="c011">Bitwise logical shift right on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">asr</span></span></td><td class="c011">Bitwise arithmetic shift right on integers. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">+.</span></span></td><td class="c011">Floating-point addition. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">-.</span></span> (infix)</td><td class="c011">Floating-point subtraction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">~-.   -.</span></span> (prefix)</td><td class="c011">Floating-point negation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">*.</span></span></td><td class="c011">Floating-point multiplication. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">/.</span></span></td><td class="c011">Floating-point division. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">**</span></span></td><td class="c011">Floating-point exponentiation. </td></tr>
<tr><td class="c012"><span class="font-tt">@</span> </td><td class="c011">List concatenation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">^</span></span> </td><td class="c011">String concatenation. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">!</span></span> </td><td class="c011">Dereferencing (return the current
contents of a reference). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">:=</span></span></td><td class="c011">Reference assignment (update the
reference given as first argument with the value of the second
argument). </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">=</span></span> </td><td class="c011">Structural equality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;&gt;</span></span> </td><td class="c011">Structural inequality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">==</span></span> </td><td class="c011">Physical equality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">!=</span></span> </td><td class="c011">Physical inequality test. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;</span></span> </td><td class="c011">Test “less than”. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&lt;=</span></span> </td><td class="c011">Test “less than or equal”. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&gt;</span></span> </td><td class="c011">Test “greater than”. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&gt;=</span></span> </td><td class="c011">Test “greater than or equal”. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">&amp;&amp;   &amp;</span></span></td><td class="c011">Boolean conjunction. </td></tr>
<tr><td class="c012"><span class="machine"><span class="font-tt">||   or</span></span></td><td class="c011">Boolean disjunction. </td></tr>
</tbody></table></div></div>
<h3 class="subsection" id="ss:expr-obj"><a class="section-anchor" href="#ss:expr-obj" aria-hidden="true">﻿</a><span class="number">7.6</span> Objects</h3>
<p> <a id="s:objects"></a></p><h4 class="subsubsection" id="sss:expr-obj-creation"><a class="section-anchor" href="#sss:expr-obj-creation" aria-hidden="true">﻿</a>Object creation</h4>
<p><a id="hevea_manual.kwd84"></a></p><p>When <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a> evaluates to a class body, <span class="syntax-token">new</span> <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a>
evaluates to a new object containing the instance variables and
methods of this class.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">new</span> of_list [1; 1; 2; 3; 5; 8; 13]

  <span class="ocamlkeyword">let</span> b = <span class="ocamlkeyword">new</span> of_list;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">val</span> a : of_list = &lt;obj&gt;
<span class="ocamlkeyword">val</span> b : int list -&gt; of_list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>When <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a> evaluates to a class function, <span class="syntax-token">new</span> <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a>
evaluates to a function expecting the same number of arguments and
returning a new object of this class.</p><h4 class="subsubsection" id="sss:expr-obj-immediate"><a class="section-anchor" href="#sss:expr-obj-immediate" aria-hidden="true">﻿</a>Immediate object creation</h4>
<p><a id="hevea_manual.kwd85"></a></p><p>Creating directly an object through the <span class="syntax-token">object</span> <a class="syntax" href="classes.html#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span>
construct is operationally equivalent to defining locally a <span class="syntax-token">class</span>
<a class="syntax" href="names.html#class-name"><span class="nonterminal">class-name</span></a> <span class="syntax-token">=</span> <span class="syntax-token">object</span> <a class="syntax" href="classes.html#class-body"><span class="nonterminal">class-body</span></a> <span class="syntax-token">end</span> —see sections
<a href="classes.html#sss%3Aclass-body">11.9.2</a> and following for the syntax of <a class="syntax" href="classes.html#class-body"><span class="nonterminal">class-body</span></a>—
and immediately creating a single object from it by <span class="syntax-token">new</span> <a class="syntax" href="names.html#class-name"><span class="nonterminal">class-name</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> o =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> secret = 99
      <span class="ocamlkeyword">val</span> password = <span class="ocamlstring">"unlock"</span>
      <span class="ocamlkeyword">method</span> get guess = <span class="ocamlkeyword">if</span> guess &lt;&gt; password <span class="ocamlkeyword">then</span> None <span class="ocamlkeyword">else</span> Some secret
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> o : &lt; get : string -&gt; int option &gt; = &lt;obj&gt;</div></div>

</div><p>The typing of immediate objects is slightly different from explicitly
defining a class in two respects. First, the inferred object type may
contain free type variables. Second, since the class body of an
immediate object will never be extended, its self type can be unified
with a closed object type.</p><h4 class="subsubsection" id="sss:expr-method"><a class="section-anchor" href="#sss:expr-method" aria-hidden="true">﻿</a>Method invocation</h4>
<p>The expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">#</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">method-name</span></a> invokes the method
<a class="syntax" href="names.html#method-name"><span class="nonterminal">method-name</span></a> of the object denoted by <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h
  <span class="ocamlkeyword">end</span>

  <span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">new</span> of_list [1; 1; 2; 3; 5; 8; 13]

  <span class="ocamlkeyword">let</span> third = ignore a#next; ignore a#next; a#next;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span>
<span class="ocamlkeyword">val</span> a : of_list = &lt;obj&gt;
<span class="ocamlkeyword">val</span> third : int = 2</div></div>

</div><p>If <a class="syntax" href="names.html#method-name"><span class="nonterminal">method-name</span></a> is a polymorphic method, its type should be known at
the invocation site. This is true for instance if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is the name
of a fresh object (<span class="syntax-token">let</span> <a class="syntax" href="lex.html#ident"><span class="nonterminal">ident</span></a> = <span class="syntax-token">new</span> <a class="syntax" href="names.html#class-path"><span class="nonterminal">class-path</span></a> … ) or if
there is a type constraint. Principality of the derivation can be
checked in the <span class="machine"><span class="font-tt">-principal</span></span> mode.</p><h4 class="subsubsection" id="sss:expr-obj-variables"><a class="section-anchor" href="#sss:expr-obj-variables" aria-hidden="true">﻿</a>Accessing and modifying instance variables</h4>
<p>The instance variables of a class are visible only in the body of the
methods defined in the same class or a class that inherits from the
class defining the instance variables. The expression <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a>
evaluates to the value of the given instance variable. The expression
<a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> assigns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> to the instance
variable <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a>, which must be mutable. The whole expression
<a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> <span class="syntax-token">&lt;-</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to <span class="syntax-token">()</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">class</span> of_list (lst : int list) = <span class="ocamlkeyword">object</span>
    <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l = lst
    <span class="ocamlkeyword">method</span> next =
      <span class="ocamlkeyword">match</span> l <span class="ocamlkeyword">with</span>                            <span class="ocamlcomment">(* access instance variable *)</span>
      | [] -&gt; raise (Failure <span class="ocamlstring">"empty list"</span>);
      | h::t -&gt; l &lt;- t; h                     <span class="ocamlcomment">(* modify instance variable *)</span>
  <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">class</span> of_list :
  int list -&gt; <span class="ocamlkeyword">object</span> <span class="ocamlkeyword">val</span> <span class="ocamlkeyword">mutable</span> l : int list <span class="ocamlkeyword">method</span> next : int <span class="ocamlkeyword">end</span></div></div>

</div><h4 class="subsubsection" id="sss:expr-obj-duplication"><a class="section-anchor" href="#sss:expr-obj-duplication" aria-hidden="true">﻿</a>Object duplication</h4>
<p>An object can be duplicated using the library function <span class="machine"><span class="font-tt">Oo.copy</span></span>
(see module <a href="../api/Oo.html"><span class="font-tt">Oo</span></a>). Inside a method, the expression
 <span class="syntax-token">{&lt;</span> [<a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] { <span class="syntax-token">;</span> <a class="syntax" href="names.html#inst-var-name"><span class="nonterminal">inst-var-name</span></a> [<span class="syntax-token">=</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>] }] <span class="syntax-token">&gt;}</span>
returns a copy of self with the given instance variables replaced by
the values of the associated expressions. A single instance variable
name <span class="nonterminal">id</span> stands for <span class="nonterminal">id</span> <span class="syntax-token">=</span> <span class="nonterminal">id</span>. Other instance variables have the same
value in the returned object as in self.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> o =
    <span class="ocamlkeyword">object</span>
      <span class="ocamlkeyword">val</span> secret = 99
      <span class="ocamlkeyword">val</span> password = <span class="ocamlstring">"unlock"</span>
      <span class="ocamlkeyword">method</span> get guess = <span class="ocamlkeyword">if</span> guess &lt;&gt; password <span class="ocamlkeyword">then</span> None <span class="ocamlkeyword">else</span> Some secret
      <span class="ocamlkeyword">method</span> with_new_secret s = {&lt; secret = s &gt;}
    <span class="ocamlkeyword">end</span>;;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> o : &lt; get : string -&gt; int option; with_new_secret : int -&gt; 'a &gt; <span class="ocamlkeyword">as</span> 'a =
  &lt;obj&gt;</div></div>

</div>
<h3 class="subsection" id="ss:expr-coercions"><a class="section-anchor" href="#ss:expr-coercions" aria-hidden="true">﻿</a><span class="number">7.7</span> Coercions</h3>
<p>Expressions whose type contains object or polymorphic variant types
can be explicitly coerced (weakened) to a supertype.
The expression <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><span class="syntax-token">)</span> coerces the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
to type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>.
The expression <span class="syntax-token">(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">:&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub><span class="syntax-token">)</span> coerces the
expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> from type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> to type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>2</sub>.</p><p>The former operator will sometimes fail to coerce an expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
from a type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> to a type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>
even if type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype of type
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>: in the current implementation it only expands two levels of
type abbreviations containing objects and/or polymorphic variants,
keeping only recursion when it is explicit in the class type (for objects).
As an exception to the above algorithm, if both the inferred type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
and <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a> are ground (<em>i.e.</em> do not contain type variables), the
former operator behaves as the latter one, taking the inferred type of
<a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> as <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub>. In case of failure with the former operator,
the latter one should be used.</p><p>It is only possible to coerce an expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> from type
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> to type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>, if the type of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is an instance of
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> (like for a type annotation), and <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype
of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. The type of the coerced expression is an
instance of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. If the types contain variables,
they may be instantiated by the subtyping algorithm, but this is only
done after determining whether <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a potential subtype of
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>. This means that typing may fail during this latter
unification step, even if some instance of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a subtype of
some instance of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub>.
In the following paragraphs we describe the subtyping relation used.</p><h4 class="subsubsection" id="sss:expr-obj-types"><a class="section-anchor" href="#sss:expr-obj-types" aria-hidden="true">﻿</a>Object types</h4>
<p>A fixed object type admits as subtype any object type that includes all
its methods. The types of the methods shall be subtypes of those in
the supertype. Namely,
</p><div class="center">
 <span class="syntax-token">&lt;</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">&gt;</span> 
</div><p>
is a supertype of
</p><div class="center">
 <span class="syntax-token">&lt;</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span></sub> <span class="syntax-token">;</span>
<a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#method-name"><span class="nonterminal">met</span></a><sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span>+<span class="font-it">m</span></sub>
&nbsp;[<span class="syntax-token">;</span> <span class="syntax-token">..</span>] <span class="syntax-token">&gt;</span> 
</div><p>
which may contain an ellipsis <span class="machine"><span class="font-tt">..</span></span> if every <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">i</span></sub> is a supertype of
the corresponding <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">i</span></sub>.</p><p>A monomorphic method type can be a supertype of a polymorphic method
type. Namely, if <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a> is an instance of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′, then  <span class="syntax-token">'</span><span class="nonterminal">a</span><sub>1</sub>
… <span class="syntax-token">'</span><span class="nonterminal">a</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">.</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′ is a subtype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>.</p><p>Inside a class definition, newly defined types are not available for
subtyping, as the type abbreviations are not yet completely
defined. There is an exception for coercing <span class="nonterminal">self</span> to the (exact)
type of its class: this is allowed if the type of <span class="nonterminal">self</span> does not
appear in a contravariant position in the class type, <em>i.e.</em> if
there are no binary methods.</p><h4 class="subsubsection" id="sss:expr-polyvar-types"><a class="section-anchor" href="#sss:expr-polyvar-types" aria-hidden="true">﻿</a>Polymorphic variant types</h4>
<p>A polymorphic variant type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a> is a subtype of another polymorphic
variant type <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′ if the upper bound of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a> (<em>i.e.</em> the
maximum set of constructors that may appear in an instance of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>)
is included in the lower bound of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′, and the types of arguments
for the constructors of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a> are subtypes of those in
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′. Namely,
</p><div class="center">
 <span class="syntax-token">[</span>[<span class="syntax-token">&lt;</span>] <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub>1</sub> <span class="syntax-token">of</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">of</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> 
</div><p>
which may be a shrinkable type, is a subtype of
</p><div class="center">
 <span class="syntax-token">[</span>[<span class="syntax-token">&gt;</span>] <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub>1</sub> <span class="syntax-token">of</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">of</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span></sub>
<span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">of</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span>+1</sub> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#constr-name"><span class="nonterminal">C</span></a><sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">of</span>
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">n</span>+<span class="font-it">m</span></sub> <span class="syntax-token">]</span> 
</div><p>
which may be an extensible type, if every <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub><span class="font-it">i</span></sub> is a subtype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub><span class="font-it">i</span></sub>.</p><h4 class="subsubsection" id="sss:expr-variance"><a class="section-anchor" href="#sss:expr-variance" aria-hidden="true">﻿</a>Variance</h4>
<p>Other types do not introduce new subtyping, but they may propagate the
subtyping of their arguments. For instance, <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">*</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a
subtype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub> <span class="syntax-token">*</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>2</sub> when <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> and <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> are
respectively subtypes of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub> and <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>2</sub>.
For function types, the relation is more subtle:
<a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> <span class="syntax-token">-&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a subtype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub>&nbsp;<span class="syntax-token">-&gt;</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>2</sub>
if <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>1</sub> is a supertype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>1</sub> and <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a><sub>2</sub> is a
subtype of <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typ</span></a>′<sub>2</sub>. For this reason, function types are covariant in
their second argument (like tuples), but contravariant in their first
argument. Mutable types, like <span class="machine"><span class="font-tt">array</span></span> or <span class="machine"><span class="font-tt">ref</span></span> are neither covariant
nor contravariant, they are nonvariant, that is they do not propagate
subtyping.</p><p>For user-defined types, the variance is automatically inferred: a
parameter is covariant if it has only covariant occurrences,
contravariant if it has only contravariant occurrences,
variance-free if it has no occurrences, and nonvariant otherwise.
A variance-free parameter may change freely through subtyping, it does
not have to be a subtype or a supertype.
For abstract and private types, the variance must be given explicitly
(see section&nbsp;<a href="typedecl.html#ss%3Atypedefs">11.8.1</a>),
otherwise the default is nonvariant. This is also the case for
constrained arguments in type definitions.</p>
<h3 class="subsection" id="ss:expr-other"><a class="section-anchor" href="#ss:expr-other" aria-hidden="true">﻿</a><span class="number">7.8</span> Other</h3>
<h4 class="subsubsection" id="sss:expr-assertion"><a class="section-anchor" href="#sss:expr-assertion" aria-hidden="true">﻿</a>Assertion checking</h4>
<p><a id="hevea_manual.kwd86"></a></p><p>OCaml supports the <span class="syntax-token">assert</span> construct to check debugging assertions.
The expression <span class="syntax-token">assert</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and
returns <span class="syntax-token">()</span> if <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> evaluates to <span class="syntax-token">true</span>. If it evaluates to
<span class="syntax-token">false</span> the exception
<span class="machine"><span class="font-tt">Assert_failure</span></span> is raised with the source file name and the
location of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> as arguments. Assertion
checking can be turned off with the <span class="machine"><span class="font-tt">-noassert</span></span> compiler option. In
this case, <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is not evaluated at all.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> f a b c =
    <span class="ocamlkeyword">assert</span> (a &lt;= b &amp;&amp; b &lt;= c);
    (b -. a) /. (c -. b);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> f : float -&gt; float -&gt; float -&gt; float = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>As a special case, <span class="syntax-token">assert false</span> is reduced to
<span class="syntax-token">raise</span> <span class="syntax-token">(</span><span class="machine"><span class="font-tt">Assert_failure ...</span></span><span class="syntax-token">)</span>, which gives it a polymorphic
type. This means that it can be used in place of any expression (for
example as a branch of any pattern-matching). It also means that
the <span class="syntax-token">assert false</span> “assertions” cannot be turned off by the
<span class="machine"><span class="font-tt">-noassert</span></span> option.
<a id="hevea_manual5"></a></p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> min_known_nonempty = <span class="ocamlkeyword">function</span>
    | [] -&gt; <span class="ocamlkeyword">assert</span> <span class="ocamlkeyword">false</span>
    | l -&gt; List.hd (List.sort compare l);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> min_known_nonempty : 'a list -&gt; 'a = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:expr-lazy"><a class="section-anchor" href="#sss:expr-lazy" aria-hidden="true">﻿</a>Lazy expressions</h4>
<p>
<a id="hevea_manual.kwd87"></a></p><p>The expression <span class="syntax-token">lazy</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> returns a value <span class="font-it">v</span> of type <span class="machine"><span class="font-tt">Lazy.t</span></span> that
encapsulates the computation of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. The argument <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> is not
evaluated at this point in the program. Instead, its evaluation will
be performed the first time the function <span class="machine"><span class="font-tt">Lazy.force</span></span> is applied to the value
<span class="font-it">v</span>, returning the actual value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. Subsequent applications
of <span class="machine"><span class="font-tt">Lazy.force</span></span> to <span class="font-it">v</span> do not evaluate <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> again. Applications
of <span class="machine"><span class="font-tt">Lazy.force</span></span> may be implicit through pattern matching (see&nbsp;<a href="patterns.html#sss%3Apat-lazy">11.6</a>).</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> lazy_greeter = <span class="ocamlkeyword">lazy</span> (print_string <span class="ocamlstring">"Hello, World!\n"</span>);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> lazy_greeter : unit lazy_t = &lt;<span class="ocamlkeyword">lazy</span>&gt;</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> Lazy.force lazy_greeter;;</div>



<div class="pre caml-output ok">Hello, World!
- : unit = ()</div></div>

</div><h4 class="subsubsection" id="sss:expr-local-modules"><a class="section-anchor" href="#sss:expr-local-modules" aria-hidden="true">﻿</a>Local modules</h4>
<p>
<a id="hevea_manual.kwd88"></a>
<a id="hevea_manual.kwd89"></a></p><p>The expression
<span class="syntax-token">let</span> <span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">=</span> <a class="syntax" href="modules.html#module-expr"><span class="nonterminal">module-expr</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>
locally binds the module expression <a class="syntax" href="modules.html#module-expr"><span class="nonterminal">module-expr</span></a> to the identifier
<a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> during the evaluation of the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.
It then returns the value of <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>. For example:

</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> remove_duplicates comparison_fun string_list =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> StringSet =
      Set.Make(<span class="ocamlkeyword">struct</span> <span class="ocamlkeyword">type</span> t = string
                      <span class="ocamlkeyword">let</span> compare = comparison_fun <span class="ocamlkeyword">end</span>)
    <span class="ocamlkeyword">in</span>
      StringSet.elements
        (List.fold_right StringSet.add string_list StringSet.empty);;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> remove_duplicates :
  (string -&gt; string -&gt; int) -&gt; string list -&gt; string list = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><h4 class="subsubsection" id="sss:local-opens"><a class="section-anchor" href="#sss:local-opens" aria-hidden="true">﻿</a>Local opens</h4>
<p>
<a id="hevea_manual.kwd90"></a>
<a id="hevea_manual.kwd91"></a></p><p>The expressions <span class="syntax-token">let</span> <span class="syntax-token">open</span> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">in</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> and
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.(</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">)</span> are strictly equivalent. These
constructions locally open the module referred to by the module path
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> in the respective scope of the expression <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> map_3d_matrix f m =
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">open</span> Array <span class="ocamlkeyword">in</span>
      map (map (map f)) m

  <span class="ocamlkeyword">let</span> map_3d_matrix' f =
    Array.(map (map (map f)));;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> map_3d_matrix :
  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> map_3d_matrix' :
  ('a -&gt; 'b) -&gt; 'a array array array -&gt; 'b array array array = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><p>When the body of a local open expression is delimited by
<span class="syntax-token">[</span> <span class="syntax-token">]</span>, <span class="syntax-token">[|</span> <span class="syntax-token">|]</span>, or <span class="syntax-token">{</span> <span class="syntax-token">}</span>, the parentheses can be omitted.
For expression, parentheses can also be omitted for <span class="syntax-token">{&lt;</span> <span class="syntax-token">&gt;}</span>.
For example, <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">]</span> is equivalent to
<a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([</span><a class="syntax" href="#expr"><span class="nonterminal">expr</span></a><span class="syntax-token">])</span>, and <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">|]</span> is
equivalent to <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([|</span> <a class="syntax" href="#expr"><span class="nonterminal">expr</span></a> <span class="syntax-token">|])</span>.</p><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> <span class="ocamlkeyword">let</span> vector = Random.[|int 255; int 255; int 255; int 255|];;</div>



<div class="pre caml-output ok"><span class="ocamlkeyword">val</span> vector : int array = [|220; 90; 247; 144|]</div></div>

</div>

<div class="bottom-navigation"><a class="previous" href="patterns.html">« Patterns</a><a class="next" href="typedecl.html">Type and exception definitions »</a></div>




</section><div class="copyright">Copyright © 2023 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>
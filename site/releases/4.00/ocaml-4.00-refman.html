<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>The OCaml system, release 4.00
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.center{text-align:center;margin-left:auto;margin-right:auto;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
a:link{color:#00A000;text-decoration:underline;}
a:visited{color:#006000;text-decoration:underline;}
a:hover{color:black;text-decoration:none;background-color:#7FFF7F}
.li-links{margin:0ex 0ex;}
a.syntax:link{color:maroon;text-decoration:underline}
a.syntax:visited{color:maroon;text-decoration:underline}
a.syntax:hover{color:black;text-decoration:none;background-color:#FF6060}
BODY{background:white;}
.part{padding:1ex;background:#00CC00;}
.section{padding:.5ex;background:#66FF66;}
.subsection{padding:0.3ex;background:#7FFF7F;}
.subsubsection{padding:0.5ex;background:#99FF99;}
.chapter{padding:0.5ex;background:#2DE52D;}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background:#00CC00;}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00CC00;}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DE52D;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66FF66;}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #7FFF7F;}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -fix -exec xxdate.exe -O -I .. -I ../refman -I ../library -I ../cmds -I ../tutorials -I ../../styles -I ../texstuff manual.hva -e macros.tex ../manual.tex -->
<!--CUT DEF chapter 1 --><DIV CLASS="center">
&#XA0;<FONT SIZE=7>The OCaml system<BR>
 release 4.00<BR>
</FONT><FONT SIZE=5>Documentation and user&#X2019;s manual<BR>
</FONT><FONT SIZE=4>Xavier Leroy,<BR>
 Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&#XE9;my and J&#XE9;r&#XF4;me Vouillon<BR>
 July&#XA0;26, 2012<BR>
 &#XA0;
</FONT><FONT SIZE=3>Copyright &#XA9; 2012 Institut National de
Recherche en Informatique et en Automatique
</FONT></DIV><BLOCKQUOTE CLASS="quote">
<HR SIZE=2>
This manual is also available in
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.pdf">PDF</A>.
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.ps.gz">Postscript</A>,
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.dvi.gz">DVI</A>,
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.txt">plain text</A>,
as a
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.html.tar.gz">bundle of HTML files</A>,
and as a
<A HREF="http://caml.inria.fr/distrib/ocaml-4.00/ocaml-4.00-refman.info.tar.gz">bundle of Emacs Info files</A>.
<HR SIZE=2>
</BLOCKQUOTE><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">Part&#XA0;I&#XA0;&#XA0;An introduction to OCaml</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc2">Chapter&#XA0;1&#XA0;&#XA0;The core language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc3">1.1&#XA0;&#XA0;Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.2&#XA0;&#XA0;Data types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.3&#XA0;&#XA0;Functions as values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.4&#XA0;&#XA0;Records and variants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">1.5&#XA0;&#XA0;Imperative features</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.6&#XA0;&#XA0;Exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.7&#XA0;&#XA0;Symbolic processing of expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.8&#XA0;&#XA0;Pretty-printing and parsing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">1.9&#XA0;&#XA0;Standalone OCaml programs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">Chapter&#XA0;2&#XA0;&#XA0;The module system</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc13">2.1&#XA0;&#XA0;Structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.2&#XA0;&#XA0;Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.3&#XA0;&#XA0;Functors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">2.4&#XA0;&#XA0;Functors and type abstraction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">2.5&#XA0;&#XA0;Modules and separate compilation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">Chapter&#XA0;3&#XA0;&#XA0;Objects in OCaml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc19">3.1&#XA0;&#XA0;Classes and objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.2&#XA0;&#XA0;Immediate objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.3&#XA0;&#XA0;Reference to self</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.4&#XA0;&#XA0;Initializers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.5&#XA0;&#XA0;Virtual methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.6&#XA0;&#XA0;Private methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.7&#XA0;&#XA0;Class interfaces</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">3.8&#XA0;&#XA0;Inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.9&#XA0;&#XA0;Multiple inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.10&#XA0;&#XA0;Parameterized classes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">3.11&#XA0;&#XA0;Polymorphic methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.12&#XA0;&#XA0;Using coercions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">3.13&#XA0;&#XA0;Functional objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.14&#XA0;&#XA0;Cloning objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.15&#XA0;&#XA0;Recursive classes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">3.16&#XA0;&#XA0;Binary methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">3.17&#XA0;&#XA0;Friends</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">Chapter&#XA0;4&#XA0;&#XA0;Labels and variants</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc37">4.1&#XA0;&#XA0;Labels</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc38">4.1.1&#XA0;&#XA0;Optional arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4.1.2&#XA0;&#XA0;Labels and type inference</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.1.3&#XA0;&#XA0;Suggestions for labeling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">4.2&#XA0;&#XA0;Polymorphic variants</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc42">4.2.1&#XA0;&#XA0;Weaknesses of polymorphic variants</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">Chapter&#XA0;5&#XA0;&#XA0;Advanced examples with classes and modules</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc44">5.1&#XA0;&#XA0;Extended example: bank accounts</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">5.2&#XA0;&#XA0;Simple modules as classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc46">5.2.1&#XA0;&#XA0;Strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">5.2.2&#XA0;&#XA0;Hashtbl</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.2.3&#XA0;&#XA0;Sets</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">5.3&#XA0;&#XA0;The subject/observer pattern</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">Part&#XA0;II&#XA0;&#XA0;The OCaml language</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc51">Chapter&#XA0;6&#XA0;&#XA0;The OCaml language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc52">6.1&#XA0;&#XA0;Lexical conventions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">6.2&#XA0;&#XA0;Values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc54">6.2.1&#XA0;&#XA0;Base values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">6.2.2&#XA0;&#XA0;Tuples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">6.2.3&#XA0;&#XA0;Records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">6.2.4&#XA0;&#XA0;Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">6.2.5&#XA0;&#XA0;Variant values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">6.2.6&#XA0;&#XA0;Polymorphic variants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">6.2.7&#XA0;&#XA0;Functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">6.2.8&#XA0;&#XA0;Objects</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">6.3&#XA0;&#XA0;Names</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">6.4&#XA0;&#XA0;Type expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">6.5&#XA0;&#XA0;Constants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">6.6&#XA0;&#XA0;Patterns</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">6.7&#XA0;&#XA0;Expressions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc67">6.7.1&#XA0;&#XA0;Basic expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">6.7.2&#XA0;&#XA0;Control structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">6.7.3&#XA0;&#XA0;Operations on data structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">6.7.4&#XA0;&#XA0;Operators</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">6.7.5&#XA0;&#XA0;Objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">6.7.6&#XA0;&#XA0;Coercions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">6.8&#XA0;&#XA0;Type and exception definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc74">6.8.1&#XA0;&#XA0;Type definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">6.8.2&#XA0;&#XA0;Exception definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">6.9&#XA0;&#XA0;Classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc77">6.9.1&#XA0;&#XA0;Class types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">6.9.2&#XA0;&#XA0;Class expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">6.9.3&#XA0;&#XA0;Class definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">6.9.4&#XA0;&#XA0;Class specification</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">6.9.5&#XA0;&#XA0;Class type definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">6.10&#XA0;&#XA0;Module types (module specifications)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc83">6.10.1&#XA0;&#XA0;Simple module types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">6.10.2&#XA0;&#XA0;Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">6.10.3&#XA0;&#XA0;Functor types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">6.10.4&#XA0;&#XA0;The <TT>with</TT> operator</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">6.11&#XA0;&#XA0;Module expressions (module implementations)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc88">6.11.1&#XA0;&#XA0;Simple module expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">6.11.2&#XA0;&#XA0;Structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">6.11.3&#XA0;&#XA0;Functors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">6.12&#XA0;&#XA0;Compilation units</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">Chapter&#XA0;7&#XA0;&#XA0;Language extensions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc93">7.1&#XA0;&#XA0;Integer literals for types <TT>int32</TT>, <TT>int64</TT>
and <TT>nativeint</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">7.2&#XA0;&#XA0;Streams and stream parsers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">7.3&#XA0;&#XA0;Recursive definitions of values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">7.4&#XA0;&#XA0;Range patterns</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">7.5&#XA0;&#XA0;Assertion checking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">7.6&#XA0;&#XA0;Lazy evaluation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">7.7&#XA0;&#XA0;Local modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">7.8&#XA0;&#XA0;Recursive modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">7.9&#XA0;&#XA0;Private types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc102">7.9.1&#XA0;&#XA0;Private variant and record types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">7.9.2&#XA0;&#XA0;Private type abbreviations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">7.9.3&#XA0;&#XA0;Private row types</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">7.10&#XA0;&#XA0;Local opens</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">7.11&#XA0;&#XA0;Record notations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">7.12&#XA0;&#XA0;Explicit polymorphic type annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">7.13&#XA0;&#XA0;Locally abstract types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">7.14&#XA0;&#XA0;First-class modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">7.15&#XA0;&#XA0;Recovering the type of a module</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">7.16&#XA0;&#XA0;Substituting inside a signature</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">7.17&#XA0;&#XA0;Explicit overriding in class definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">7.18&#XA0;&#XA0;Generalized algebraic datatypes</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">Part&#XA0;III&#XA0;&#XA0;The OCaml tools</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc115">Chapter&#XA0;8&#XA0;&#XA0;Batch compilation (ocamlc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc116">8.1&#XA0;&#XA0;Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">8.2&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">8.3&#XA0;&#XA0;Modules and the file system</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">8.4&#XA0;&#XA0;Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">Chapter&#XA0;9&#XA0;&#XA0;The toplevel system (ocaml)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc121">9.1&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">9.2&#XA0;&#XA0;Toplevel directives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">9.3&#XA0;&#XA0;The toplevel and the module system</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">9.4&#XA0;&#XA0;Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">9.5&#XA0;&#XA0;Building custom toplevel systems: <TT>ocamlmktop</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">9.6&#XA0;&#XA0;Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">Chapter&#XA0;10&#XA0;&#XA0;The runtime system (ocamlrun)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc128">10.1&#XA0;&#XA0;Overview</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">10.2&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">10.3&#XA0;&#XA0;Dynamic loading of shared libraries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">10.4&#XA0;&#XA0;Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">Chapter&#XA0;11&#XA0;&#XA0;Native-code compilation (ocamlopt)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc133">11.1&#XA0;&#XA0;Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">11.2&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">11.3&#XA0;&#XA0;Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">11.4&#XA0;&#XA0;Running executables produced by ocamlopt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">11.5&#XA0;&#XA0;Compatibility with the bytecode compiler</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc138">Chapter&#XA0;12&#XA0;&#XA0;Lexer and parser generators (ocamllex, ocamlyacc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc139">12.1&#XA0;&#XA0;Overview of <TT>ocamllex</TT></A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc140">12.1.1&#XA0;&#XA0;Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">12.2&#XA0;&#XA0;Syntax of lexer definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc142">12.2.1&#XA0;&#XA0;Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">12.2.2&#XA0;&#XA0;Naming regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">12.2.3&#XA0;&#XA0;Entry points</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">12.2.4&#XA0;&#XA0;Regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">12.2.5&#XA0;&#XA0;Actions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">12.2.6&#XA0;&#XA0;Variables in regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">12.2.7&#XA0;&#XA0;Reserved identifiers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">12.3&#XA0;&#XA0;Overview of <TT>ocamlyacc</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">12.4&#XA0;&#XA0;Syntax of grammar definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc151">12.4.1&#XA0;&#XA0;Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">12.4.2&#XA0;&#XA0;Declarations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">12.4.3&#XA0;&#XA0;Rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc154">12.4.4&#XA0;&#XA0;Error handling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">12.5&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">12.6&#XA0;&#XA0;A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">12.7&#XA0;&#XA0;Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc158">Chapter&#XA0;13&#XA0;&#XA0;Dependency generator (ocamldep)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc159">13.1&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">13.2&#XA0;&#XA0;A typical Makefile</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">Chapter&#XA0;14&#XA0;&#XA0;The browser/editor (ocamlbrowser)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc162">14.1&#XA0;&#XA0;Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">14.2&#XA0;&#XA0;Viewer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">14.3&#XA0;&#XA0;Module browsing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">14.4&#XA0;&#XA0;File editor</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc166">14.5&#XA0;&#XA0;Shell</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc167">Chapter&#XA0;15&#XA0;&#XA0;The documentation generator (ocamldoc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc168">15.1&#XA0;&#XA0;Usage</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc169">15.1.1&#XA0;&#XA0;Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">15.1.2&#XA0;&#XA0;Merging of module information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">15.1.3&#XA0;&#XA0;Coding rules</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc172">15.2&#XA0;&#XA0;Syntax of documentation comments</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc173">15.2.1&#XA0;&#XA0;Placement of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">15.2.2&#XA0;&#XA0;The Stop special comment</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">15.2.3&#XA0;&#XA0;Syntax of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">15.2.4&#XA0;&#XA0;Text formatting</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">15.2.5&#XA0;&#XA0;Documentation tags (@-tags)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc178">15.3&#XA0;&#XA0;Custom generators</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc179">15.3.1&#XA0;&#XA0;The generator modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc180">15.3.2&#XA0;&#XA0;Handling custom tags</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc181">15.4&#XA0;&#XA0;Adding command line options</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc182">15.4.1&#XA0;&#XA0;Compilation and usage</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">Chapter&#XA0;16&#XA0;&#XA0;The debugger (ocamldebug)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc184">16.1&#XA0;&#XA0;Compiling for debugging</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc185">16.2&#XA0;&#XA0;Invocation</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc186">16.2.1&#XA0;&#XA0;Starting the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc187">16.2.2&#XA0;&#XA0;Exiting the debugger</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc188">16.3&#XA0;&#XA0;Commands</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc189">16.3.1&#XA0;&#XA0;Getting help</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">16.3.2&#XA0;&#XA0;Accessing the debugger state</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc191">16.4&#XA0;&#XA0;Executing a program</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc192">16.4.1&#XA0;&#XA0;Events</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">16.4.2&#XA0;&#XA0;Starting the debugged program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">16.4.3&#XA0;&#XA0;Running the program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">16.4.4&#XA0;&#XA0;Time travel</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc196">16.4.5&#XA0;&#XA0;Killing the program</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">16.5&#XA0;&#XA0;Breakpoints</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">16.6&#XA0;&#XA0;The call stack</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">16.7&#XA0;&#XA0;Examining variable values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc200">16.8&#XA0;&#XA0;Controlling the debugger</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc201">16.8.1&#XA0;&#XA0;Setting the program name and arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">16.8.2&#XA0;&#XA0;How programs are loaded</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">16.8.3&#XA0;&#XA0;Search path for files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">16.8.4&#XA0;&#XA0;Working directory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">16.8.5&#XA0;&#XA0;Turning reverse execution on and off</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc206">16.8.6&#XA0;&#XA0;Communication between the debugger and the program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">16.8.7&#XA0;&#XA0;Fine-tuning the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">16.8.8&#XA0;&#XA0;User-defined printers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc209">16.9&#XA0;&#XA0;Miscellaneous commands</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">16.10&#XA0;&#XA0;Running the debugger under Emacs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc211">Chapter&#XA0;17&#XA0;&#XA0;Profiling (ocamlprof)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc212">17.1&#XA0;&#XA0;Compiling for profiling</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">17.2&#XA0;&#XA0;Profiling an execution</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">17.3&#XA0;&#XA0;Printing profiling information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc215">17.4&#XA0;&#XA0;Time profiling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc216">Chapter&#XA0;18&#XA0;&#XA0;The ocamlbuild compilation manager</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc217">18.1&#XA0;&#XA0;Features of <TT>ocamlbuild</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc218">18.2&#XA0;&#XA0;Limitations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc219">18.3&#XA0;&#XA0;Using <TT>ocamlbuild</TT></A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc220">18.3.1&#XA0;&#XA0;Hygiene &amp; where is my code ?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc221">18.3.2&#XA0;&#XA0;Hello, world !</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc222">18.3.3&#XA0;&#XA0;Executing my code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc223">18.3.4&#XA0;&#XA0;The log file, verbosity and debugging</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc224">18.3.5&#XA0;&#XA0;Cleaning</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc225">18.3.6&#XA0;&#XA0;Where and how to run <TT>ocamlbuild</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc226">18.3.7&#XA0;&#XA0;Dependencies</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc227">18.3.8&#XA0;&#XA0;Native and byte-code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc228">18.3.9&#XA0;&#XA0;Compile flags</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc229">18.3.10&#XA0;&#XA0;Link flags</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc230">18.3.11&#XA0;&#XA0;Linking with external libraries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc231">18.3.12&#XA0;&#XA0;The <TT>_tags</TT> files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc232">18.3.13&#XA0;&#XA0;Glob patterns and expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc233">18.3.14&#XA0;&#XA0;Subdirectories</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc234">18.3.15&#XA0;&#XA0;Grouping targets with <TT>.itarget</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc235">18.3.16&#XA0;&#XA0;Packing subdirectories into modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc236">18.3.17&#XA0;&#XA0;Making an OCaml library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc237">18.3.18&#XA0;&#XA0;Making an OCaml toplevel</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc238">18.3.19&#XA0;&#XA0;Preprocessor options and tags</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc239">18.3.20&#XA0;&#XA0;Debugging byte code and profiling native code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc240">18.3.21&#XA0;&#XA0;Generating documentation using <TT>ocamldoc</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc241">18.3.22&#XA0;&#XA0;The display line</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc242">18.3.23&#XA0;&#XA0;<TT>ocamllex</TT>, <TT>ocamlyacc</TT> and <TT>menhir</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc243">18.3.24&#XA0;&#XA0;Changing the compilers or tools</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc244">18.3.25&#XA0;&#XA0;Interaction with version control systems</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc245">18.3.26&#XA0;&#XA0;A shell script for driving it all?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc246">18.4&#XA0;&#XA0;Appendix: Motivations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc247">18.5&#XA0;&#XA0;Appendix: Summary of default rules</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc248">Chapter&#XA0;19&#XA0;&#XA0;Interfacing C with OCaml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc249">19.1&#XA0;&#XA0;Overview and compilation information</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc250">19.1.1&#XA0;&#XA0;Declaring primitives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc251">19.1.2&#XA0;&#XA0;Implementing primitives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc252">19.1.3&#XA0;&#XA0;Statically linking C code with OCaml code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc253">19.1.4&#XA0;&#XA0;Dynamically linking C code with OCaml code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc254">19.1.5&#XA0;&#XA0;Choosing between static linking and dynamic linking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc255">19.1.6&#XA0;&#XA0;Building standalone custom runtime systems</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc256">19.2&#XA0;&#XA0;The <TT>value</TT> type</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc257">19.2.1&#XA0;&#XA0;Integer values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc258">19.2.2&#XA0;&#XA0;Blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc259">19.2.3&#XA0;&#XA0;Pointers outside the heap</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc260">19.3&#XA0;&#XA0;Representation of OCaml data types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc261">19.3.1&#XA0;&#XA0;Atomic types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc262">19.3.2&#XA0;&#XA0;Tuples and records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc263">19.3.3&#XA0;&#XA0;Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc264">19.3.4&#XA0;&#XA0;Concrete data types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc265">19.3.5&#XA0;&#XA0;Objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc266">19.3.6&#XA0;&#XA0;Polymorphic variants</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc267">19.4&#XA0;&#XA0;Operations on values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc268">19.4.1&#XA0;&#XA0;Kind tests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc269">19.4.2&#XA0;&#XA0;Operations on integers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc270">19.4.3&#XA0;&#XA0;Accessing blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc271">19.4.4&#XA0;&#XA0;Allocating blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc272">19.4.5&#XA0;&#XA0;Raising exceptions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc273">19.5&#XA0;&#XA0;Living in harmony with the garbage collector</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc274">19.5.1&#XA0;&#XA0;Simple interface</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc275">19.5.2&#XA0;&#XA0;Low-level interface</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc276">19.6&#XA0;&#XA0;A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc277">19.7&#XA0;&#XA0;Advanced topic: callbacks from C to OCaml</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc278">19.7.1&#XA0;&#XA0;Applying OCaml closures from C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc279">19.7.2&#XA0;&#XA0;Obtaining or registering OCaml closures for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc280">19.7.3&#XA0;&#XA0;Registering OCaml exceptions for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc281">19.7.4&#XA0;&#XA0;Main program in C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc282">19.7.5&#XA0;&#XA0;Embedding the OCaml code in the C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc283">19.8&#XA0;&#XA0;Advanced example with callbacks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc284">19.9&#XA0;&#XA0;Advanced topic: custom blocks</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc285">19.9.1&#XA0;&#XA0;The <TT>struct custom_operations</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc286">19.9.2&#XA0;&#XA0;Allocating custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc287">19.9.3&#XA0;&#XA0;Accessing custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc288">19.9.4&#XA0;&#XA0;Writing custom serialization and deserialization functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc289">19.9.5&#XA0;&#XA0;Choosing identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc290">19.9.6&#XA0;&#XA0;Finalized blocks</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc291">19.10&#XA0;&#XA0;Advanced topic: multithreading</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc292">19.10.1&#XA0;&#XA0;Registering threads created from C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc293">19.10.2&#XA0;&#XA0;Parallel execution of long-running C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc294">19.11&#XA0;&#XA0;Building mixed C/OCaml libraries: <TT>ocamlmklib</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc295">Part&#XA0;IV&#XA0;&#XA0;The OCaml library</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc296">Chapter&#XA0;20&#XA0;&#XA0;The core library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc297">20.1&#XA0;&#XA0;Built-in types and predefined exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc298">20.2&#XA0;&#XA0;Module <TT>Pervasives</TT>: the initially opened module</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc299">Chapter&#XA0;21&#XA0;&#XA0;The standard library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc300">Chapter&#XA0;22&#XA0;&#XA0;The unix library: Unix system calls</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc301">Chapter&#XA0;23&#XA0;&#XA0;The num library: arbitrary-precision rational arithmetic</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc302">Chapter&#XA0;24&#XA0;&#XA0;The str library: regular expressions and string processing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc303">Chapter&#XA0;25&#XA0;&#XA0;The threads library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc304">Chapter&#XA0;26&#XA0;&#XA0;The graphics library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc305">Chapter&#XA0;27&#XA0;&#XA0;The dynlink library: dynamic loading and linking of object files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc306">Chapter&#XA0;28&#XA0;&#XA0;The LablTk library: Tcl/Tk GUI interface</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc307">Chapter&#XA0;29&#XA0;&#XA0;The bigarray library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc308">29.1&#XA0;&#XA0;Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc309">29.2&#XA0;&#XA0;Big arrays in the OCaml-C interface</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc310">29.2.1&#XA0;&#XA0;Include file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc311">29.2.2&#XA0;&#XA0;Accessing an OCaml bigarray from C or Fortran</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc312">29.2.3&#XA0;&#XA0;Wrapping a C or Fortran array as an OCaml big array</A>
</LI></UL>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc313">Part&#XA0;V&#XA0;&#XA0;Appendix</A>
</LI></UL><!--TOC chapter Foreword-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Foreword</H1><!--SEC END --><P>This manual documents the release 4.00 of the OCaml
system. It is organized as follows.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Part&#XA0;<A HREF="#p:tutorials">I</A>, &#X201C;An introduction to OCaml&#X201D;,
gives an overview of the language.
</LI><LI CLASS="li-itemize">Part&#XA0;<A HREF="#p:refman">II</A>, &#X201C;The OCaml language&#X201D;, is the
reference description of the language.
</LI><LI CLASS="li-itemize">Part&#XA0;<A HREF="#p:commands">III</A>, &#X201C;The OCaml tools&#X201D;, documents
the compilers, toplevel system, and programming utilities.
</LI><LI CLASS="li-itemize">Part&#XA0;<A HREF="#p:library">IV</A>, &#X201C;The OCaml library&#X201D;, describes the
modules provided in the standard library.

</LI></UL><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>OCaml runs on several operating systems. The parts of
this manual that are specific to one operating system are presented as
shown below:</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0; This is material specific to the Unix family of operating
systems, including Linux and MacOS&#XA0;X.
</BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0; This is material specific to Microsoft Windows (2000,
XP, Vista, Seven).
</BLOCKQUOTE><!--TOC section License-->
<H2 CLASS="section"><!--SEC ANCHOR -->License</H2><!--SEC END --><P>The OCaml system is copyright &#XA9; 1996&#X2013;2012
Institut National de Recherche en Informatique et en
Automatique (INRIA).
INRIA holds all ownership rights to the OCaml system.</P><P>The OCaml system is open source and can be freely
redistributed. See the file <TT>LICENSE</TT> in the distribution for
licensing information.</P><P>The present documentation is copyright &#XA9; 2012
Institut National de Recherche en Informatique et en
Automatique (INRIA). The OCaml documentation and user&#X2019;s
manual may be reproduced and distributed in whole or
in part, subject to the following conditions:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The copyright notice above and this permission notice must be
preserved complete on all complete or partial copies.
</LI><LI CLASS="li-itemize">Any translation or derivative work of the OCaml
documentation and user&#X2019;s manual must be approved by the authors in
writing before distribution.
</LI><LI CLASS="li-itemize">If you distribute the OCaml
documentation and user&#X2019;s manual in part, instructions for obtaining
the complete version of this manual must be included, and a
means for obtaining a complete version provided.
</LI><LI CLASS="li-itemize">Small portions may be reproduced as illustrations for reviews or
quotes in other works without this permission notice if proper
citation is given.
</LI></UL><!--TOC section Availability-->
<H2 CLASS="section"><!--SEC ANCHOR -->Availability</H2><!--SEC END --><P>
The complete OCaml distribution can be accessed via the
<TT><A HREF="http://caml.inria.fr/">http://caml.inria.fr/</A></TT>Caml Web site.
The <TT><A HREF="http://caml.inria.fr/">http://caml.inria.fr/</A></TT>Caml Web site
contains a lot of additional information on OCaml.

</P><!--TOC part An introduction to OCaml-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc1">Part&#XA0;I</A><BR>
An introduction to OCaml</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:tutorials"></A>
</P><!--TOC chapter The core language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc2">Chapter&#XA0;1</A>&#XA0;&#XA0;The core language</H1><!--SEC END --><P> <A NAME="c:core-xamples"></A>
</P><P>This part of the manual is a tutorial introduction to the
OCaml language. A good familiarity with programming in a conventional
languages (say, Pascal or C) is assumed, but no prior exposure to
functional languages is required. The present chapter introduces the
core language. Chapter&#XA0;<A HREF="#c:moduleexamples">2</A> deals with the
module system, chapter&#XA0;<A HREF="#c:objectexamples">3</A> with the
object-oriented features, chapter&#XA0;<A HREF="#c:labl-examples">4</A> with
extensions to the core language (labeled arguments and polymorphic
variants), and chapter&#XA0;<A HREF="#c:advexamples">5</A> gives some advanced examples.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.1</A>&#XA0;&#XA0;Basics</H2><!--SEC END --><P>For this overview of OCaml, we use the interactive system, which
is started by running <TT>ocaml</TT> from the Unix shell, or by launching the
<TT>OCamlwin.exe</TT> application under Windows. This tutorial is presented
as the transcript of a session with the interactive system:
lines starting with <TT>#</TT> represent user input; the system responses are
printed below, without a leading <TT>#</TT>.</P><P>Under the interactive system, the user types OCaml phrases terminated
by <TT>;;</TT> in response to the <TT>#</TT> prompt, and the system compiles them
on the fly, executes them, and prints the outcome of evaluation.
Phrases are either simple expressions, or <TT>let</TT> definitions of
identifiers (either values or functions).
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> 1+2*3;;
<FONT COLOR=maroon>- : int = 7

</FONT><FONT COLOR=black>#</FONT> let pi = 4.0 *. atan 1.0;;
<FONT COLOR=maroon>val pi : float = 3.14159265358979312

</FONT><FONT COLOR=black>#</FONT> let square x = x *. x;;
<FONT COLOR=maroon>val square : float -&gt; float = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> square(sin pi) +. square(cos pi);;
</FONT><FONT COLOR=maroon>- : float = 1.
</FONT></PRE><P>
The OCaml system computes both the value and the type for
each phrase. Even function parameters need no explicit type declaration:
the system infers their types from their usage in the
function. Notice also that integers and floating-point numbers are
distinct types, with distinct operators: <TT>+</TT> and <TT>*</TT> operate on
integers, but <TT>+.</TT> and <TT>*.</TT> operate on floats.
</P><PRE><FONT COLOR=black>#</FONT> <FONT COLOR="#006000"><U>1.0</U> * 2;;
</FONT><FONT COLOR=maroon>Error: This expression has type float but an expression was expected of type
         int
</FONT></PRE><P>Recursive functions are defined with the <TT>let rec</TT> binding:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec fib n =
    if n &lt; 2 then n else fib(n-1) + fib(n-2);;
<FONT COLOR=maroon>val fib : int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> fib 10;;
</FONT><FONT COLOR=maroon>- : int = 55
</FONT></PRE><!--TOC section Data types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.2</A>&#XA0;&#XA0;Data types</H2><!--SEC END --><P>In addition to integers and floating-point numbers, OCaml offers the
usual basic data types: booleans, characters, and character strings.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> (1 &lt; 2) = false;;
<FONT COLOR=maroon>- : bool = false

</FONT><FONT COLOR=black>#</FONT> 'a';;
<FONT COLOR=maroon>- : char = 'a'

</FONT><FONT COLOR=black>#</FONT> "Hello world";;
</FONT><FONT COLOR=maroon>- : string = "Hello world"
</FONT></PRE><P>Predefined data structures include tuples, arrays, and lists. General
mechanisms for defining your own data structures are also provided.
They will be covered in more details later; for now, we concentrate on lists.
Lists are either given in extension as a bracketed list of
semicolon-separated elements, or built from the empty list <TT>[]</TT>
(pronounce &#X201C;nil&#X201D;) by adding elements in front using the <TT>::</TT>
(&#X201C;cons&#X201D;) operator.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let l = ["is"; "a"; "tale"; "told"; "etc."];;
<FONT COLOR=maroon>val l : string list = ["is"; "a"; "tale"; "told"; "etc."]

</FONT><FONT COLOR=black>#</FONT> "Life" :: l;;
</FONT><FONT COLOR=maroon>- : string list = ["Life"; "is"; "a"; "tale"; "told"; "etc."]
</FONT></PRE><P>
As with all other OCaml data structures, lists do not need to be
explicitly allocated and deallocated from memory: all memory
management is entirely automatic in OCaml. Similarly, there is no
explicit handling of pointers: the OCaml compiler silently introduces
pointers where necessary.</P><P>As with most OCaml data structures, inspecting and destructuring lists
is performed by pattern-matching. List patterns have the exact same
shape as list expressions, with identifier representing unspecified
parts of the list. As an example, here is insertion sort on a list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec sort lst =
    match lst with
      [] -&gt; []
    | head :: tail -&gt; insert head (sort tail)
  and insert elt lst =
    match lst with
      [] -&gt; [elt]
    | head :: tail -&gt; if elt &lt;= head then elt :: lst else head :: insert elt tail
  ;;
<FONT COLOR=maroon>val sort : 'a list -&gt; 'a list = &lt;fun&gt;
val insert : 'a -&gt; 'a list -&gt; 'a list = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> sort l;;
</FONT><FONT COLOR=maroon>- : string list = ["a"; "etc."; "is"; "tale"; "told"]
</FONT></PRE><P>The type inferred for <TT>sort</TT>, <TT>'a list -&gt; 'a list</TT>, means that <TT>sort</TT>
can actually apply to lists of any type, and returns a list of the
same type. The type <TT>'a</TT> is a <EM>type variable</EM>, and stands for any
given type. The reason why <TT>sort</TT> can apply to lists of any type is
that the comparisons (<TT>=</TT>, <TT>&lt;=</TT>, etc.) are <EM>polymorphic</EM> in OCaml:
they operate between any two values of the same type. This makes
<TT>sort</TT> itself polymorphic over all list types.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> sort [6;2;5;3];;
<FONT COLOR=maroon>- : int list = [2; 3; 5; 6]

</FONT><FONT COLOR=black>#</FONT> sort [3.14; 2.718];;
</FONT><FONT COLOR=maroon>- : float list = [2.718; 3.14]
</FONT></PRE><P>The <TT>sort</TT> function above does not modify its input list: it builds
and returns a new list containing the same elements as the input list,
in ascending order. There is actually no way in OCaml to modify
in-place a list once it is built: we say that lists are <EM>immutable</EM>
data structures. Most OCaml data structures are immutable, but a few
(most notably arrays) are <EM>mutable</EM>, meaning that they can be
modified in-place at any time.</P><!--TOC section Functions as values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.3</A>&#XA0;&#XA0;Functions as values</H2><!--SEC END --><P>OCaml is a functional language: functions in the full mathematical
sense are supported and can be passed around freely just as any other
piece of data. For instance, here is a <TT>deriv</TT> function that takes any
float function as argument and returns an approximation of its
derivative function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let deriv f dx = function x -&gt; (f(x +. dx) -. f(x)) /. dx;;
<FONT COLOR=maroon>val deriv : (float -&gt; float) -&gt; float -&gt; float -&gt; float = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let sin' = deriv sin 1e-6;;
<FONT COLOR=maroon>val sin' : float -&gt; float = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> sin' pi;;
</FONT><FONT COLOR=maroon>- : float = -1.00000000013961143
</FONT></PRE><P>
Even function composition is definable:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let compose f g = function x -&gt; f(g(x));;
<FONT COLOR=maroon>val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let cos2 = compose square cos;;
</FONT><FONT COLOR=maroon>val cos2 : float -&gt; float = &lt;fun&gt;
</FONT></PRE><P>Functions that take other functions as arguments are called
&#X201C;functionals&#X201D;, or &#X201C;higher-order functions&#X201D;. Functionals are
especially useful to provide iterators or similar generic operations
over a data structure. For instance, the standard OCaml library
provides a <TT>List.map</TT> functional that applies a given function to each
element of a list, and returns the list of the results:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> List.map (function n -&gt; n * 2 + 1) [0;1;2;3;4];;
</FONT><FONT COLOR=maroon>- : int list = [1; 3; 5; 7; 9]
</FONT></PRE><P>
This functional, along with a number of other list and array
functionals, is predefined because it is often useful, but there is
nothing magic with it: it can easily be defined as follows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec map f l =
    match l with
      [] -&gt; []
    | hd :: tl -&gt; f hd :: map f tl;;
</FONT><FONT COLOR=maroon>val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
</FONT></PRE><!--TOC section Records and variants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.4</A>&#XA0;&#XA0;Records and variants</H2><!--SEC END --><P>

<A NAME="s:tut-recvariants"></A></P><P>User-defined data structures include records and variants. Both are
defined with the <TT>type</TT> declaration. Here, we declare a record type to
represent rational numbers.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type ratio = {num: int; denom: int};;
<FONT COLOR=maroon>type ratio = { num : int; denom : int; }

</FONT><FONT COLOR=black>#</FONT> let add_ratio r1 r2 =
    {num = r1.num * r2.denom + r2.num * r1.denom;
     denom = r1.denom * r2.denom};;
<FONT COLOR=maroon>val add_ratio : ratio -&gt; ratio -&gt; ratio = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> add_ratio {num=1; denom=3} {num=2; denom=5};;
</FONT><FONT COLOR=maroon>- : ratio = {num = 11; denom = 15}
</FONT></PRE><P>The declaration of a variant type lists all possible shapes for values
of that type. Each case is identified by a name, called a constructor,
which serves both for constructing values of the variant type and
inspecting them by pattern-matching. Constructor names are capitalized
to distinguish them from variable names (which must start with a
lowercase letter). For instance, here is a variant
type for doing mixed arithmetic (integers and floats):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type number = Int of int | Float of float | Error;;
</FONT><FONT COLOR=maroon>type number = Int of int | Float of float | Error
</FONT></PRE><P>
This declaration expresses that a value of type <TT>number</TT> is either an
integer, a floating-point number, or the constant <TT>Error</TT> representing
the result of an invalid operation (e.g. a division by zero).</P><P>Enumerated types are a special case of variant types, where all
alternatives are constants:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type sign = Positive | Negative;;
<FONT COLOR=maroon>type sign = Positive | Negative

</FONT><FONT COLOR=black>#</FONT> let sign_int n = if n &gt;= 0 then Positive else Negative;;
</FONT><FONT COLOR=maroon>val sign_int : int -&gt; sign = &lt;fun&gt;
</FONT></PRE><P>To define arithmetic operations for the <TT>number</TT> type, we use
pattern-matching on the two numbers involved:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let add_num n1 n2 =
    match (n1, n2) with
      (Int i1, Int i2) -&gt;
        (* Check for overflow of integer addition *)
        if sign_int i1 = sign_int i2 &amp;&amp; sign_int(i1 + i2) &lt;&gt; sign_int i1
        then Float(float i1 +. float i2)
        else Int(i1 + i2)
    | (Int i1, Float f2) -&gt; Float(float i1 +. f2)
    | (Float f1, Int i2) -&gt; Float(f1 +. float i2)
    | (Float f1, Float f2) -&gt; Float(f1 +. f2)
    | (Error, _) -&gt; Error
    | (_, Error) -&gt; Error;;
<FONT COLOR=maroon>val add_num : number -&gt; number -&gt; number = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> add_num (Int 123) (Float 3.14159);;
</FONT><FONT COLOR=maroon>- : number = Float 126.14159
</FONT></PRE><P>The most common usage of variant types is to describe recursive data
structures. Consider for example the type of binary trees:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a btree = Empty | Node of 'a * 'a btree * 'a btree;;
</FONT><FONT COLOR=maroon>type 'a btree = Empty | Node of 'a * 'a btree * 'a btree
</FONT></PRE><P>
This definition reads as follow: a binary tree containing values of
type <TT>'a</TT> (an arbitrary type) is either empty, or is a node containing
one value of type <TT>'a</TT> and two subtrees containing also values of type
<TT>'a</TT>, that is, two <TT>'a btree</TT>.</P><P>Operations on binary trees are naturally expressed as recursive functions
following the same structure as the type definition itself. For
instance, here are functions performing lookup and insertion in
ordered binary trees (elements increase from left to right):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec member x btree =
    match btree with
      Empty -&gt; false
    | Node(y, left, right) -&gt;
        if x = y then true else
        if x &lt; y then member x left else member x right;;
<FONT COLOR=maroon>val member : 'a -&gt; 'a btree -&gt; bool = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let rec insert x btree =
    match btree with
      Empty -&gt; Node(x, Empty, Empty)
    | Node(y, left, right) -&gt;
        if x &lt;= y then Node(y, insert x left, right)
                  else Node(y, left, insert x right);;
</FONT><FONT COLOR=maroon>val insert : 'a -&gt; 'a btree -&gt; 'a btree = &lt;fun&gt;
</FONT></PRE><!--TOC section Imperative features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">1.5</A>&#XA0;&#XA0;Imperative features</H2><!--SEC END --><P>Though all examples so far were written in purely applicative style,
OCaml is also equipped with full imperative features. This includes the
usual <TT>while</TT> and <TT>for</TT> loops, as well as mutable data structures such
as arrays. Arrays are either given in extension between <TT>[|</TT> and <TT>|]</TT>
brackets, or allocated and initialized with the <TT>Array.create</TT>
function, then filled up later by assignments. For instance, the
function below sums two vectors (represented as float arrays) componentwise.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let add_vect v1 v2 =
    let len = min (Array.length v1) (Array.length v2) in
    let res = Array.create len 0.0 in
    for i = 0 to len - 1 do
      res.(i) &lt;- v1.(i) +. v2.(i)
    done;
    res;;
<FONT COLOR=maroon>val add_vect : float array -&gt; float array -&gt; float array = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> add_vect [| 1.0; 2.0 |] [| 3.0; 4.0 |];;
</FONT><FONT COLOR=maroon>- : float array = [|4.; 6.|]
</FONT></PRE><P>Record fields can also be modified by assignment, provided they are
declared <TT>mutable</TT> in the definition of the record type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type mutable_point = { mutable x: float; mutable y: float };;
<FONT COLOR=maroon>type mutable_point = { mutable x : float; mutable y : float; }

</FONT><FONT COLOR=black>#</FONT> let translate p dx dy =
    p.x &lt;- p.x +. dx; p.y &lt;- p.y +. dy;;
<FONT COLOR=maroon>val translate : mutable_point -&gt; float -&gt; float -&gt; unit = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let mypoint = { x = 0.0; y = 0.0 };;
<FONT COLOR=maroon>val mypoint : mutable_point = {x = 0.; y = 0.}

</FONT><FONT COLOR=black>#</FONT> translate mypoint 1.0 2.0;;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> mypoint;;
</FONT><FONT COLOR=maroon>- : mutable_point = {x = 1.; y = 2.}
</FONT></PRE><P>OCaml has no built-in notion of variable &#X2013; identifiers whose current
value can be changed by assignment. (The <TT>let</TT> binding is not an
assignment, it introduces a new identifier with a new scope.)
However, the standard library provides references, which are mutable
indirection cells (or one-element arrays), with operators <TT>!</TT> to fetch
the current contents of the reference and <TT>:=</TT> to assign the contents.
Variables can then be emulated by <TT>let</TT>-binding a reference. For
instance, here is an in-place insertion sort over arrays:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let insertion_sort a =
    for i = 1 to Array.length a - 1 do
      let val_i = a.(i) in
      let j = ref i in
      while !j &gt; 0 &amp;&amp; val_i &lt; a.(!j - 1) do
        a.(!j) &lt;- a.(!j - 1);
        j := !j - 1
      done;
      a.(!j) &lt;- val_i
    done;;
</FONT><FONT COLOR=maroon>val insertion_sort : 'a array -&gt; unit = &lt;fun&gt;
</FONT></PRE><P>References are also useful to write functions that maintain a current
state between two calls to the function. For instance, the following
pseudo-random number generator keeps the last returned number in a
reference:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let current_rand = ref 0;;
<FONT COLOR=maroon>val current_rand : int ref = {contents = 0}

</FONT><FONT COLOR=black>#</FONT> let random () =
    current_rand := !current_rand * 25713 + 1345;
    !current_rand;;
</FONT><FONT COLOR=maroon>val random : unit -&gt; int = &lt;fun&gt;
</FONT></PRE><P>Again, there is nothing magical with references: they are implemented as
a single-field mutable record, as follows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a ref = { mutable contents: 'a };;
<FONT COLOR=maroon>type 'a ref = { mutable contents : 'a; }

</FONT><FONT COLOR=black>#</FONT> let (!) r = r.contents;;
<FONT COLOR=maroon>val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let (:=) r newval = r.contents &lt;- newval;;
</FONT><FONT COLOR=maroon>val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
</FONT></PRE><P>In some special cases, you may need to store a polymorphic function in
a data structure, keeping its polymorphism. Without user-provided
type annotations, this is not allowed, as polymorphism is only
introduced on a global level. However, you can give explicitly
polymorphic types to record fields.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type idref = { mutable id: 'a. 'a -&gt; 'a };;
<FONT COLOR=maroon>type idref = { mutable id : 'a. 'a -&gt; 'a; }

</FONT><FONT COLOR=black>#</FONT> let r = {id = fun x -&gt; x};;
<FONT COLOR=maroon>val r : idref = {id = &lt;fun&gt;}

</FONT><FONT COLOR=black>#</FONT> let g s = (s.id 1, s.id true);;
<FONT COLOR=maroon>val g : idref -&gt; int * bool = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> r.id &lt;- (fun x -&gt; print_string "called id\n"; x);;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> g r;;
</FONT><FONT COLOR=maroon>called id
called id
- : int * bool = (1, true)
</FONT></PRE><!--TOC section Exceptions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">1.6</A>&#XA0;&#XA0;Exceptions</H2><!--SEC END --><P>OCaml provides exceptions for signalling and handling exceptional
conditions. Exceptions can also be used as a general-purpose non-local
control structure. Exceptions are declared with the <TT>exception</TT>
construct, and signalled with the <TT>raise</TT> operator. For instance, the
function below for taking the head of a list uses an exception to
signal the case where an empty list is given.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> exception Empty_list;;
<FONT COLOR=maroon>exception Empty_list

</FONT><FONT COLOR=black>#</FONT> let head l =
    match l with
      [] -&gt; raise Empty_list
    | hd :: tl -&gt; hd;;
<FONT COLOR=maroon>val head : 'a list -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> head [1;2];;
<FONT COLOR=maroon>- : int = 1

</FONT><FONT COLOR=black>#</FONT> head [];;
</FONT><FONT COLOR=maroon>Exception: Empty_list.
</FONT></PRE><P>Exceptions are used throughout the standard library to signal cases
where the library functions cannot complete normally. For instance,
the <TT>List.assoc</TT> function, which returns the data associated with a
given key in a list of (key, data) pairs, raises the predefined
exception <TT>Not_found</TT> when the key does not appear in the list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> List.assoc 1 [(0, "zero"); (1, "one")];;
<FONT COLOR=maroon>- : string = "one"

</FONT><FONT COLOR=black>#</FONT> List.assoc 2 [(0, "zero"); (1, "one")];;
</FONT><FONT COLOR=maroon>Exception: Not_found.
</FONT></PRE><P>Exceptions can be trapped with the <TT>try</TT>&#X2026;<TT>with</TT> construct:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let name_of_binary_digit digit =
    try
      List.assoc digit [0, "zero"; 1, "one"]
    with Not_found -&gt;
      "not a binary digit";;
<FONT COLOR=maroon>val name_of_binary_digit : int -&gt; string = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> name_of_binary_digit 0;;
<FONT COLOR=maroon>- : string = "zero"

</FONT><FONT COLOR=black>#</FONT> name_of_binary_digit (-1);;
</FONT><FONT COLOR=maroon>- : string = "not a binary digit"
</FONT></PRE><P>The <TT>with</TT> part is actually a regular pattern-matching on the
exception value. Thus, several exceptions can be caught by one
<TT>try</TT>&#X2026;<TT>with</TT> construct. Also, finalization can be performed by
trapping all exceptions, performing the finalization, then raising
again the exception:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let temporarily_set_reference ref newval funct =
    let oldval = !ref in
    try
      ref := newval;
      let res = funct () in
      ref := oldval;
      res
    with x -&gt;
      ref := oldval;
      raise x;;
</FONT><FONT COLOR=maroon>val temporarily_set_reference : 'a ref -&gt; 'a -&gt; (unit -&gt; 'b) -&gt; 'b = &lt;fun&gt;
</FONT></PRE><!--TOC section Symbolic processing of expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">1.7</A>&#XA0;&#XA0;Symbolic processing of expressions</H2><!--SEC END --><P>We finish this introduction with a more complete example
representative of the use of OCaml for symbolic processing: formal
manipulations of arithmetic expressions containing variables. The
following variant type describes the expressions we shall manipulate:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type expression =
      Const of float
    | Var of string
    | Sum of expression * expression    (* e1 + e2 *)
    | Diff of expression * expression   (* e1 - e2 *)
    | Prod of expression * expression   (* e1 * e2 *)
    | Quot of expression * expression   (* e1 / e2 *)
  ;;
</FONT><FONT COLOR=maroon>type expression =
    Const of float
  | Var of string
  | Sum of expression * expression
  | Diff of expression * expression
  | Prod of expression * expression
  | Quot of expression * expression
</FONT></PRE><P>We first define a function to evaluate an expression given an
environment that maps variable names to their values. For simplicity,
the environment is represented as an association list.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> exception Unbound_variable of string;;
<FONT COLOR=maroon>exception Unbound_variable of string

</FONT><FONT COLOR=black>#</FONT> let rec eval env exp =
    match exp with
      Const c -&gt; c
    | Var v -&gt;
        (try List.assoc v env with Not_found -&gt; raise(Unbound_variable v))
    | Sum(f, g) -&gt; eval env f +. eval env g
    | Diff(f, g) -&gt; eval env f -. eval env g
    | Prod(f, g) -&gt; eval env f *. eval env g
    | Quot(f, g) -&gt; eval env f /. eval env g;;
<FONT COLOR=maroon>val eval : (string * float) list -&gt; expression -&gt; float = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> eval [("x", 1.0); ("y", 3.14)] (Prod(Sum(Var "x", Const 2.0), Var "y"));;
</FONT><FONT COLOR=maroon>- : float = 9.42
</FONT></PRE><P>Now for a real symbolic processing, we define the derivative of an
expression with respect to a variable <TT>dv</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec deriv exp dv =
    match exp with
      Const c -&gt; Const 0.0
    | Var v -&gt; if v = dv then Const 1.0 else Const 0.0
    | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)
    | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)
    | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
    | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                         Prod(g, g))
  ;;
<FONT COLOR=maroon>val deriv : expression -&gt; string -&gt; expression = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> deriv (Quot(Const 1.0, Var "x")) "x";;
</FONT><FONT COLOR=maroon>- : expression =
Quot (Diff (Prod (Const 0., Var "x"), Prod (Const 1., Const 1.)),
 Prod (Var "x", Var "x"))
</FONT></PRE><!--TOC section Pretty-printing and parsing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">1.8</A>&#XA0;&#XA0;Pretty-printing and parsing</H2><!--SEC END --><P>As shown in the examples above, the internal representation (also
called <EM>abstract syntax</EM>) of expressions quickly becomes hard to
read and write as the expressions get larger. We need a printer and a
parser to go back and forth between the abstract syntax and the <EM>concrete syntax</EM>, which in the case of expressions is the familiar
algebraic notation (e.g. <TT>2*x+1</TT>).</P><P>For the printing function, we take into account the usual precedence
rules (i.e. <TT>*</TT> binds tighter than <TT>+</TT>) to avoid printing unnecessary
parentheses. To this end, we maintain the current operator precedence
and print parentheses around an operator only if its precedence is
less than the current precedence.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let print_expr exp =
    (* Local function definitions *)
    let open_paren prec op_prec =
      if prec &gt; op_prec then print_string "(" in
    let close_paren prec op_prec =
      if prec &gt; op_prec then print_string ")" in
    let rec print prec exp =     (* prec is the current precedence *)
      match exp with
        Const c -&gt; print_float c
      | Var v -&gt; print_string v
      | Sum(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string " + "; print 0 g;
          close_paren prec 0
      | Diff(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string " - "; print 1 g;
          close_paren prec 0
      | Prod(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string " * "; print 2 g;
          close_paren prec 2
      | Quot(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string " / "; print 3 g;
          close_paren prec 2
    in print 0 exp;;
<FONT COLOR=maroon>val print_expr : expression -&gt; unit = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let e = Sum(Prod(Const 2.0, Var "x"), Const 1.0);;
<FONT COLOR=maroon>val e : expression = Sum (Prod (Const 2., Var "x"), Const 1.)

</FONT><FONT COLOR=black>#</FONT> print_expr e; print_newline();;
<FONT COLOR=maroon>2. * x + 1.
- : unit = ()

</FONT><FONT COLOR=black>#</FONT> print_expr (deriv e "x"); print_newline();;
</FONT><FONT COLOR=maroon>2. * 1. + 0. * x + 0.
- : unit = ()
</FONT></PRE><P>Parsing (transforming concrete syntax into abstract syntax) is usually
more delicate. OCaml offers several tools to help write parsers:
on the one hand, OCaml versions of the lexer generator Lex and the
parser generator Yacc (see chapter&#XA0;<A HREF="#c:ocamlyacc">12</A>), which handle
LALR(1) languages using push-down automata; on the other hand, a
predefined type of streams (of characters or tokens) and
pattern-matching over streams, which facilitate the writing of
recursive-descent parsers for LL(1) languages. An example using
<TT>ocamllex</TT> and <TT>ocamlyacc</TT> is given in
chapter&#XA0;<A HREF="#c:ocamlyacc">12</A>. Here, we will use stream parsers.
The syntactic support for stream parsers is provided by the Camlp4
preprocessor, which can be loaded into the interactive toplevel via
the <TT>#load</TT> directives below.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> #load "dynlink.cma";;

  #load "camlp4o.cma";;
<FONT COLOR=maroon>	Camlp4 Parsing version 4.00.0


</FONT><FONT COLOR=black>#</FONT> open Genlex;;

  let lexer = make_lexer ["("; ")"; "+"; "-"; "*"; "/"];;
</FONT><FONT COLOR=maroon>val lexer : char Stream.t -&gt; Genlex.token Stream.t = &lt;fun&gt;
</FONT></PRE><P>
For the lexical analysis phase (transformation of the input text into
a stream of tokens), we use a &#X201C;generic&#X201D; lexer provided in the
standard library module <TT>Genlex</TT>. The <TT>make_lexer</TT> function takes a
list of keywords and returns a lexing function that &#X201C;tokenizes&#X201D; an
input stream of characters. Tokens are either identifiers, keywords,
or literals (integer, floats, characters, strings). Whitespace and
comments are skipped.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let token_stream = lexer(Stream.of_string "1.0 +x");;
<FONT COLOR=maroon>val token_stream : Genlex.token Stream.t = &lt;abstr&gt;

</FONT><FONT COLOR=black>#</FONT> Stream.next token_stream;;
<FONT COLOR=maroon>- : Genlex.token = Float 1.

</FONT><FONT COLOR=black>#</FONT> Stream.next token_stream;;
<FONT COLOR=maroon>- : Genlex.token = Kwd "+"

</FONT><FONT COLOR=black>#</FONT> Stream.next token_stream;;
</FONT><FONT COLOR=maroon>- : Genlex.token = Ident "x"
</FONT></PRE><P>The parser itself operates by pattern-matching on the stream of
tokens. As usual with recursive descent parsers, we use several
intermediate parsing functions to reflect the precedence and
associativity of operators. Pattern-matching over streams is more
powerful than on regular data structures, as it allows recursive calls
to parsing functions inside the patterns, for matching sub-components of
the input stream. See the Camlp4 documentation for more details.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec parse_expr = parser
      [&lt; e1 = parse_mult; e = parse_more_adds e1 &gt;] -&gt; e
  and parse_more_adds e1 = parser
      [&lt; 'Kwd "+"; e2 = parse_mult; e = parse_more_adds (Sum(e1, e2)) &gt;] -&gt; e
    | [&lt; 'Kwd "-"; e2 = parse_mult; e = parse_more_adds (Diff(e1, e2)) &gt;] -&gt; e
    | [&lt; &gt;] -&gt; e1
  and parse_mult = parser
      [&lt; e1 = parse_simple; e = parse_more_mults e1 &gt;] -&gt; e
  and parse_more_mults e1 = parser
      [&lt; 'Kwd "*"; e2 = parse_simple; e = parse_more_mults (Prod(e1, e2)) &gt;] -&gt; e
    | [&lt; 'Kwd "/"; e2 = parse_simple; e = parse_more_mults (Quot(e1, e2)) &gt;] -&gt; e
    | [&lt; &gt;] -&gt; e1
  and parse_simple = parser
      [&lt; 'Ident s &gt;] -&gt; Var s
    | [&lt; 'Int i &gt;] -&gt; Const(float i)
    | [&lt; 'Float f &gt;] -&gt; Const f
    | [&lt; 'Kwd "("; e = parse_expr; 'Kwd ")" &gt;] -&gt; e;;
<FONT COLOR=maroon>val parse_expr : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
val parse_more_adds : expression -&gt; Genlex.token Stream.t -&gt; expression =
  &lt;fun&gt;
val parse_mult : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
val parse_more_mults : expression -&gt; Genlex.token Stream.t -&gt; expression =
  &lt;fun&gt;
val parse_simple : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let parse_expression = parser [&lt; e = parse_expr; _ = Stream.empty &gt;] -&gt; e;;
</FONT><FONT COLOR=maroon>val parse_expression : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
</FONT></PRE><P>Composing the lexer and parser, we finally obtain a function to read
an expression from a character string:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let read_expression s = parse_expression(lexer(Stream.of_string s));;
<FONT COLOR=maroon>val read_expression : string -&gt; expression = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> read_expression "2*(x+y)";;
</FONT><FONT COLOR=maroon>- : expression = Prod (Const 2., Sum (Var "x", Var "y"))
</FONT></PRE><P>
A small puzzle: why do we get different results in the following two
examples?
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> read_expression "x - 1";;
<FONT COLOR=maroon>- : expression = Diff (Var "x", Const 1.)

</FONT><FONT COLOR=black>#</FONT> read_expression "x-1";;
</FONT><FONT COLOR=maroon>Exception: Stream.Error "".
</FONT></PRE><P>
Answer: the generic lexer provided by <TT>Genlex</TT> recognizes negative
integer literals as one integer token. Hence, <TT>x-1</TT> is read as
the token <TT>Ident "x"</TT> followed by the token <TT>Int(-1)</TT>; this sequence
does not match any of the parser rules. On the other hand,
the second space in <TT>x - 1</TT> causes the lexer to return the three
expected tokens: <TT>Ident "x"</TT>, then <TT>Kwd "-"</TT>, then <TT>Int(1)</TT>.</P><!--TOC section Standalone OCaml programs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">1.9</A>&#XA0;&#XA0;Standalone OCaml programs</H2><!--SEC END --><P>All examples given so far were executed under the interactive system.
OCaml code can also be compiled separately and executed
non-interactively using the batch compilers <TT>ocamlc</TT> and <TT>ocamlopt</TT>.
The source code must be put in a file with extension <TT>.ml</TT>. It
consists of a sequence of phrases, which will be evaluated at runtime
in their order of appearance in the source file. Unlike in interactive
mode, types and values are not printed automatically; the program must
call printing functions explicitly to produce some output. Here is a
sample standalone program to print Fibonacci numbers:
</P><PRE>(* File fib.ml *)
let rec fib n =
  if n &lt; 2 then 1 else fib(n-1) + fib(n-2);;
let main () =
  let arg = int_of_string Sys.argv.(1) in
  print_int(fib arg);
  print_newline();
  exit 0;;
main ();;
</PRE><P><TT>Sys.argv</TT> is an array of strings containing the command-line
parameters. <TT>Sys.argv.(1)</TT> is thus the first command-line parameter.
The program above is compiled and executed with the following shell
commands:
</P><PRE>$ ocamlc -o fib fib.ml
$ ./fib 10
89
$ ./fib 20
10946
</PRE><P>
More complex standalone OCaml programs are typically composed of
multiple source files, and can link with precompiled libraries.
Chapters&#XA0;<A HREF="#c:camlc">8</A> and&#XA0;<A HREF="#c:nativecomp">11</A> explain how to use the
batch compilers <TT>ocamlc</TT> and <TT>ocamlopt</TT>. Recompilation of
multi-file OCaml projects can be automated using the <TT>ocamlbuild</TT>
compilation manager, documented in chapter&#XA0;<A HREF="#c:ocamlbuild">18</A>.

</P><!--TOC chapter The module system-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc12">Chapter&#XA0;2</A>&#XA0;&#XA0;The module system</H1><!--SEC END --><P> <A NAME="c:moduleexamples"></A>
</P><P>This chapter introduces the module system of OCaml.</P><!--TOC section Structures-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc13">2.1</A>&#XA0;&#XA0;Structures</H2><!--SEC END --><P>A primary motivation for modules is to package together related
definitions (such as the definitions of a data type and associated
operations over that type) and enforce a consistent naming scheme for
these definitions. This avoids running out of names or accidentally
confusing names. Such a package is called a <EM>structure</EM> and
is introduced by the <TT>struct</TT>&#X2026;<TT>end</TT> construct, which contains an
arbitrary sequence of definitions. The structure is usually given a
name with the <TT>module</TT> binding. Here is for instance a structure
packaging together a type of priority queues and their operations:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module PrioQueue =
    struct
      type priority = int
      type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue
      let empty = Empty
      let rec insert queue prio elt =
        match queue with
          Empty -&gt; Node(prio, elt, Empty, Empty)
        | Node(p, e, left, right) -&gt;
            if prio &lt;= p
            then Node(prio, elt, insert right p e, left)
            else Node(p, e, insert right prio elt, left)
      exception Queue_is_empty
      let rec remove_top = function
          Empty -&gt; raise Queue_is_empty
        | Node(prio, elt, left, Empty) -&gt; left
        | Node(prio, elt, Empty, right) -&gt; right
        | Node(prio, elt, (Node(lprio, lelt, _, _) as left),
                          (Node(rprio, relt, _, _) as right)) -&gt;
            if lprio &lt;= rprio
            then Node(lprio, lelt, remove_top left, right)
            else Node(rprio, relt, left, remove_top right)
      let extract = function
          Empty -&gt; raise Queue_is_empty
        | Node(prio, elt, _, _) as queue -&gt; (prio, elt, remove_top queue)
    end;;
</FONT><FONT COLOR=maroon>module PrioQueue :
  sig
    type priority = int
    type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue
    val empty : 'a queue
    val insert : 'a queue -&gt; priority -&gt; 'a -&gt; 'a queue
    exception Queue_is_empty
    val remove_top : 'a queue -&gt; 'a queue
    val extract : 'a queue -&gt; priority * 'a * 'a queue
  end
</FONT></PRE><P>
Outside the structure, its components can be referred to using the
&#X201C;dot notation&#X201D;, that is, identifiers qualified by a structure name.
For instance, <TT>PrioQueue.insert</TT> is the function <TT>insert</TT> defined
inside the structure <TT>PrioQueue</TT> and <TT>PrioQueue.queue</TT> is the type
<TT>queue</TT> defined in <TT>PrioQueue</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> PrioQueue.insert PrioQueue.empty 1 "hello";;
</FONT><FONT COLOR=maroon>- : string PrioQueue.queue =
PrioQueue.Node (1, "hello", PrioQueue.Empty, PrioQueue.Empty)
</FONT></PRE><!--TOC section Signatures-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">2.2</A>&#XA0;&#XA0;Signatures</H2><!--SEC END --><P>Signatures are interfaces for structures. A signature specifies
which components of a structure are accessible from the outside, and
with which type. It can be used to hide some components of a structure
(e.g. local function definitions) or export some components with a
restricted type. For instance, the signature below specifies the three
priority queue operations <TT>empty</TT>, <TT>insert</TT> and <TT>extract</TT>, but not the
auxiliary function <TT>remove_top</TT>. Similarly, it makes the <TT>queue</TT> type
abstract (by not providing its actual representation as a concrete type).
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type PRIOQUEUE =
    sig
      type priority = int         (* still concrete *)
      type 'a queue               (* now abstract *)
      val empty : 'a queue
      val insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue
      val extract : 'a queue -&gt; int * 'a * 'a queue
      exception Queue_is_empty
    end;;
</FONT><FONT COLOR=maroon>module type PRIOQUEUE =
  sig
    type priority = int
    type 'a queue
    val empty : 'a queue
    val insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue
    val extract : 'a queue -&gt; int * 'a * 'a queue
    exception Queue_is_empty
  end
</FONT></PRE><P>
Restricting the <TT>PrioQueue</TT> structure by this signature results in
another view of the <TT>PrioQueue</TT> structure where the <TT>remove_top</TT>
function is not accessible and the actual representation of priority
queues is hidden:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;
<FONT COLOR=maroon>module AbstractPrioQueue : PRIOQUEUE

</FONT><FONT COLOR=black>#</FONT> <U>AbstractPrioQueue.remove_top</U>;;
<FONT COLOR=maroon>Error: Unbound value AbstractPrioQueue.remove_top

</FONT><FONT COLOR=black>#</FONT> AbstractPrioQueue.insert AbstractPrioQueue.empty 1 "hello";;
</FONT><FONT COLOR=maroon>- : string AbstractPrioQueue.queue = &lt;abstr&gt;
</FONT></PRE><P>
The restriction can also be performed during the definition of the
structure, as in
</P><PRE>module PrioQueue = (struct ... end : PRIOQUEUE);;
</PRE><P>An alternate syntax is provided for the above:
</P><PRE>module PrioQueue : PRIOQUEUE = struct ... end;;
</PRE><!--TOC section Functors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">2.3</A>&#XA0;&#XA0;Functors</H2><!--SEC END --><P>Functors are &#X201C;functions&#X201D; from structures to structures. They are used to
express parameterized structures: a structure <I>A</I> parameterized by a
structure <I>B</I> is simply a functor <I>F</I> with a formal parameter
<I>B</I> (along with the expected signature for <I>B</I>) which returns
the actual structure <I>A</I> itself. The functor <I>F</I> can then be
applied to one or several implementations <I>B</I><SUB>1</SUB> &#X2026;<I>B<SUB>n</SUB></I>
of <I>B</I>, yielding the corresponding structures
<I>A</I><SUB>1</SUB> &#X2026;<I>A<SUB>n</SUB></I>.</P><P>For instance, here is a structure implementing sets as sorted lists,
parameterized by a structure providing the type of the set elements
and an ordering function over this type (used to keep the sets
sorted):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type comparison = Less | Equal | Greater;;
<FONT COLOR=maroon>type comparison = Less | Equal | Greater

</FONT><FONT COLOR=black>#</FONT> module type ORDERED_TYPE =
    sig
      type t
      val compare: t -&gt; t -&gt; comparison
    end;;
<FONT COLOR=maroon>module type ORDERED_TYPE = sig type t val compare : t -&gt; t -&gt; comparison end

</FONT><FONT COLOR=black>#</FONT> module Set =
    functor (Elt: ORDERED_TYPE) -&gt;
      struct
        type element = Elt.t
        type set = element list
        let empty = []
        let rec add x s =
          match s with
            [] -&gt; [x]
          | hd::tl -&gt;
             match Elt.compare x hd with
               Equal   -&gt; s         (* x is already in s *)
             | Less    -&gt; x :: s    (* x is smaller than all elements of s *)
             | Greater -&gt; hd :: add x tl
        let rec member x s =
          match s with
            [] -&gt; false
          | hd::tl -&gt;
              match Elt.compare x hd with
                Equal   -&gt; true     (* x belongs to s *)
              | Less    -&gt; false    (* x is smaller than all elements of s *)
              | Greater -&gt; member x tl
      end;;
</FONT><FONT COLOR=maroon>module Set :
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set = element list
      val empty : 'a list
      val add : Elt.t -&gt; Elt.t list -&gt; Elt.t list
      val member : Elt.t -&gt; Elt.t list -&gt; bool
    end
</FONT></PRE><P>
By applying the <TT>Set</TT> functor to a structure implementing an ordered
type, we obtain set operations for this type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module OrderedString =
    struct
      type t = string
      let compare x y = if x = y then Equal else if x &lt; y then Less else Greater
    end;;
<FONT COLOR=maroon>module OrderedString :
  sig type t = string val compare : 'a -&gt; 'a -&gt; comparison end

</FONT><FONT COLOR=black>#</FONT> module StringSet = Set(OrderedString);;
<FONT COLOR=maroon>module StringSet :
  sig
    type element = OrderedString.t
    type set = element list
    val empty : 'a list
    val add : OrderedString.t -&gt; OrderedString.t list -&gt; OrderedString.t list
    val member : OrderedString.t -&gt; OrderedString.t list -&gt; bool
  end

</FONT><FONT COLOR=black>#</FONT> StringSet.member "bar" (StringSet.add "foo" StringSet.empty);;
</FONT><FONT COLOR=maroon>- : bool = false
</FONT></PRE><!--TOC section Functors and type abstraction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">2.4</A>&#XA0;&#XA0;Functors and type abstraction</H2><!--SEC END --><P>As in the <TT>PrioQueue</TT> example, it would be good style to hide the
actual implementation of the type <TT>set</TT>, so that users of the
structure will not rely on sets being lists, and we can switch later
to another, more efficient representation of sets without breaking
their code. This can be achieved by restricting <TT>Set</TT> by a suitable
functor signature:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type SETFUNCTOR =
    functor (Elt: ORDERED_TYPE) -&gt;
      sig
        type element = Elt.t      (* concrete *)
        type set                  (* abstract *)
        val empty : set
        val add : element -&gt; set -&gt; set
        val member : element -&gt; set -&gt; bool
      end;;
<FONT COLOR=maroon>module type SETFUNCTOR =
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set
      val empty : set
      val add : element -&gt; set -&gt; set
      val member : element -&gt; set -&gt; bool
    end

</FONT><FONT COLOR=black>#</FONT> module AbstractSet = (Set : SETFUNCTOR);;
<FONT COLOR=maroon>module AbstractSet : SETFUNCTOR

</FONT><FONT COLOR=black>#</FONT> module AbstractStringSet = AbstractSet(OrderedString);;
<FONT COLOR=maroon>module AbstractStringSet :
  sig
    type element = OrderedString.t
    type set = AbstractSet(OrderedString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end

</FONT><FONT COLOR=black>#</FONT> AbstractStringSet.add "gee" AbstractStringSet.empty;;
</FONT><FONT COLOR=maroon>- : AbstractStringSet.set = &lt;abstr&gt;
</FONT></PRE><P>In an attempt to write the type constraint above more elegantly,
one may wish to name the signature of the structure
returned by the functor, then use that signature in the constraint:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type SET =
    sig
      type element
      type set
      val empty : set
      val add : element -&gt; set -&gt; set
      val member : element -&gt; set -&gt; bool
    end;;
<FONT COLOR=maroon>module type SET =
  sig
    type element
    type set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end

</FONT><FONT COLOR=black>#</FONT> module WrongSet = (Set : functor(Elt: ORDERED_TYPE) -&gt; SET);;
<FONT COLOR=maroon>module WrongSet : functor (Elt : ORDERED_TYPE) -&gt; SET

</FONT><FONT COLOR=black>#</FONT> module WrongStringSet = WrongSet(OrderedString);;
<FONT COLOR=maroon>module WrongStringSet :
  sig
    type element = WrongSet(OrderedString).element
    type set = WrongSet(OrderedString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end

</FONT><FONT COLOR=black>#</FONT> WrongStringSet.add <U>"gee"</U> WrongStringSet.empty;;
</FONT><FONT COLOR=maroon>Error: This expression has type string but an expression was expected of type
         WrongStringSet.element = WrongSet(OrderedString).element
</FONT></PRE><P>
The problem here is that <TT>SET</TT> specifies the type <TT>element</TT>
abstractly, so that the type equality between <TT>element</TT> in the result
of the functor and <TT>t</TT> in its argument is forgotten. Consequently,
<TT>WrongStringSet.element</TT> is not the same type as <TT>string</TT>, and the
operations of <TT>WrongStringSet</TT> cannot be applied to strings.
As demonstrated above, it is important that the type <TT>element</TT> in the
signature <TT>SET</TT> be declared equal to <TT>Elt.t</TT>; unfortunately, this is
impossible above since <TT>SET</TT> is defined in a context where <TT>Elt</TT> does
not exist. To overcome this difficulty, OCaml provides a
<TT>with type</TT> construct over signatures that allows enriching a signature
with extra type equalities:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module AbstractSet2 =
    (Set : functor(Elt: ORDERED_TYPE) -&gt; (SET with type element = Elt.t));;
</FONT><FONT COLOR=maroon>module AbstractSet2 :
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set
      val empty : set
      val add : element -&gt; set -&gt; set
      val member : element -&gt; set -&gt; bool
    end
</FONT></PRE><P>As in the case of simple structures, an alternate syntax is provided
for defining functors and restricting their result:
</P><PRE>module AbstractSet2(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
</PRE><P>
Abstracting a type component in a functor result is a powerful
technique that provides a high degree of type safety, as we now
illustrate. Consider an ordering over character strings that is
different from the standard ordering implemented in the
<TT>OrderedString</TT> structure. For instance, we compare strings without
distinguishing upper and lower case.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module NoCaseString =
    struct
      type t = string
      let compare s1 s2 =
        OrderedString.compare (String.lowercase s1) (String.lowercase s2)
    end;;
<FONT COLOR=maroon>module NoCaseString :
  sig type t = string val compare : string -&gt; string -&gt; comparison end

</FONT><FONT COLOR=black>#</FONT> module NoCaseStringSet = AbstractSet(NoCaseString);;
<FONT COLOR=maroon>module NoCaseStringSet :
  sig
    type element = NoCaseString.t
    type set = AbstractSet(NoCaseString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end

</FONT><FONT COLOR=black>#</FONT> NoCaseStringSet.add "FOO" <U>AbstractStringSet.empty</U>;;
</FONT><FONT COLOR=maroon>Error: This expression has type
         AbstractStringSet.set = AbstractSet(OrderedString).set
       but an expression was expected of type
         NoCaseStringSet.set = AbstractSet(NoCaseString).set
</FONT></PRE><P>
Note that the two types <TT>AbstractStringSet.set</TT> and
<TT>NoCaseStringSet.set</TT> are not compatible, and values of these
two types do not match. This is the correct behavior: even though both
set types contain elements of the same type (strings), they are built
upon different orderings of that type, and different invariants need
to be maintained by the operations (being strictly increasing for the
standard ordering and for the case-insensitive ordering). Applying
operations from <TT>AbstractStringSet</TT> to values of type
<TT>NoCaseStringSet.set</TT> could give incorrect results, or build
lists that violate the invariants of <TT>NoCaseStringSet</TT>.</P><!--TOC section Modules and separate compilation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">2.5</A>&#XA0;&#XA0;Modules and separate compilation</H2><!--SEC END --><P>All examples of modules so far have been given in the context of the
interactive system. However, modules are most useful for large,
batch-compiled programs. For these programs, it is a practical
necessity to split the source into several files, called compilation
units, that can be compiled separately, thus minimizing recompilation
after changes.</P><P>In OCaml, compilation units are special cases of structures
and signatures, and the relationship between the units can be
explained easily in terms of the module system. A compilation unit <I>A</I>
comprises two files:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the implementation file <I>A</I><TT>.ml</TT>, which contains a sequence
of definitions, analogous to the inside of a <TT>struct</TT>&#X2026;<TT>end</TT>
construct;
</LI><LI CLASS="li-itemize">the interface file <I>A</I><TT>.mli</TT>, which contains a sequence of
specifications, analogous to the inside of a <TT>sig</TT>&#X2026;<TT>end</TT>
construct.
</LI></UL><P>
These two files together define a structure named <I>A</I> as if
the following definition was entered at top-level:
</P><PRE>
module <I>A</I>: sig (* contents of file <I>A</I>.mli *) end
        = struct (* contents of file <I>A</I>.ml *) end;;
</PRE><P>
The files that define the compilation units can be compiled separately
using the <TT>ocamlc -c</TT> command (the <TT>-c</TT> option means &#X201C;compile only, do
not try to link&#X201D;); this produces compiled interface files (with
extension <TT>.cmi</TT>) and compiled object code files (with extension
<TT>.cmo</TT>). When all units have been compiled, their <TT>.cmo</TT> files are
linked together using the <TT>ocamlc</TT> command. For instance, the following
commands compile and link a program composed of two compilation units
<TT>Aux</TT> and <TT>Main</TT>:
</P><PRE>$ ocamlc -c Aux.mli                     # produces aux.cmi
$ ocamlc -c Aux.ml                      # produces aux.cmo
$ ocamlc -c Main.mli                    # produces main.cmi
$ ocamlc -c Main.ml                     # produces main.cmo
$ ocamlc -o theprogram Aux.cmo Main.cmo
</PRE><P>The program behaves exactly as if the following phrases were entered
at top-level:
</P><PRE>
module Aux: sig (* contents of Aux.mli *) end
          = struct (* contents of Aux.ml *) end;;
module Main: sig (* contents of Main.mli *) end
           = struct (* contents of Main.ml *) end;;
</PRE><P>
In particular, <TT>Main</TT> can refer to <TT>Aux</TT>: the definitions and
declarations contained in <TT>Main.ml</TT> and <TT>Main.mli</TT> can refer to
definition in <TT>Aux.ml</TT>, using the <TT>Aux.</TT><I>ident</I> notation, provided
these definitions are exported in <TT>Aux.mli</TT>.</P><P>The order in which the <TT>.cmo</TT> files are given to <TT>ocamlc</TT> during the
linking phase determines the order in which the module definitions
occur. Hence, in the example above, <TT>Aux</TT> appears first and <TT>Main</TT> can
refer to it, but <TT>Aux</TT> cannot refer to <TT>Main</TT>.</P><P>Note that only top-level structures can be mapped to
separately-compiled files, but neither functors nor module types.
However, all module-class objects can appear as components of a
structure, so the solution is to put the functor or module type
inside a structure, which can then be mapped to a file.

</P><!--TOC chapter Objects in OCaml-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc18">Chapter&#XA0;3</A>&#XA0;&#XA0;Objects in OCaml</H1><!--SEC END --><P>
<A NAME="c:objectexamples"></A>
</P><P><I>(Chapter written by J&#XE9;r&#XF4;me Vouillon, Didier R&#XE9;my and Jacques Garrigue)</I></P><P><BR>
<BR>
</P><P>This chapter gives an overview of the object-oriented features of
OCaml. Note that the relation between object, class and type
in OCaml is very different from that in mainstream
object-oriented languages like Java or C++, so that you should not
assume that similar keywords mean the same thing.</P><P><A HREF="#ss:classes-and-objects">3.1</A> Classes and objects<BR>
<A HREF="#ss:immediate-objects">3.2</A> Immediate objects<BR>
<A HREF="#ss:reference-to-self">3.3</A> Reference to self<BR>
<A HREF="#ss:initializers">3.4</A> Initializers<BR>
<A HREF="#ss:virtual-methods">3.5</A> Virtual methods<BR>
<A HREF="#ss:private-methods">3.6</A> Private methods<BR>
<A HREF="#ss:class-interfaces">3.7</A> Class interfaces<BR>
<A HREF="#ss:inheritance">3.8</A> Inheritance<BR>
<A HREF="#ss:multiple-inheritance">3.9</A> Multiple inheritance<BR>
<A HREF="#ss:parameterized-classes">3.10</A> Parameterized classes<BR>
<A HREF="#ss:polymorphic-methods">3.11</A> Polymorphic methods<BR>
<A HREF="#ss:using-coercions">3.12</A> Using coercions<BR>
<A HREF="#ss:functional-objects">3.13</A> Functional objects<BR>
<A HREF="#ss:cloning-objects">3.14</A> Cloning objects<BR>
<A HREF="#ss:recursive-classes">3.15</A> Recursive classes<BR>
<A HREF="#ss:binary-methods">3.16</A> Binary methods<BR>
<A HREF="#ss:friends">3.17</A> Friends<BR>

</P><!--TOC section Classes and objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">3.1</A>&#XA0;&#XA0;Classes and objects</H2><!--SEC END --><P>

<A NAME="ss:classes-and-objects"></A></P><P>The class <TT>point</TT> below defines one instance variable <TT>x</TT> and two methods
<TT>get_x</TT> and <TT>move</TT>. The initial value of the instance variable is <TT>0</TT>.
The variable <TT>x</TT> is declared mutable, so the method <TT>move</TT> can change
its value.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point =
    object
      val mutable x = 0
      method get_x = x
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>We now create a new point <TT>p</TT>, instance of the <TT>point</TT> class.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let p = new point;;
</FONT><FONT COLOR=maroon>val p : point = &lt;obj&gt;
</FONT></PRE><P>
Note that the type of <TT>p</TT> is <TT>point</TT>. This is an abbreviation
automatically defined by the class definition above. It stands for the
object type <TT>&lt;get_x : int; move : int -&gt; unit&gt;</TT>, listing the methods
of class <TT>point</TT> along with their types.</P><P>We now invoke some methods to <TT>p</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> p#get_x;;
<FONT COLOR=maroon>- : int = 0

</FONT><FONT COLOR=black>#</FONT> p#move 3;;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> p#get_x;;
</FONT><FONT COLOR=maroon>- : int = 3
</FONT></PRE><P>The evaluation of the body of a class only takes place at object
creation time. Therefore, in the following example, the instance
variable <TT>x</TT> is initialized to different values for two different
objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let x0 = ref 0;;
<FONT COLOR=maroon>val x0 : int ref = {contents = 0}

</FONT><FONT COLOR=black>#</FONT> class point =
    object
      val mutable x = incr x0; !x0
      method get_x = x
      method move d = x &lt;- x + d
    end;;
<FONT COLOR=maroon>class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end

</FONT><FONT COLOR=black>#</FONT> new point#get_x;;
<FONT COLOR=maroon>- : int = 1

</FONT><FONT COLOR=black>#</FONT> new point#get_x;;
</FONT><FONT COLOR=maroon>- : int = 2
</FONT></PRE><P>The class <TT>point</TT> can also be abstracted over the initial values of
the <TT>x</TT> coordinate.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point = fun x_init -&gt;
    object
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>
Like in function definitions, the definition above can be
abbreviated as:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>
An instance of the class <TT>point</TT> is now a function that expects an
initial parameter to create a point object:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> new point;;
<FONT COLOR=maroon>- : int -&gt; point = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let p = new point 7;;
</FONT><FONT COLOR=maroon>val p : point = &lt;obj&gt;
</FONT></PRE><P>
The parameter <TT>x_init</TT> is, of course, visible in the whole body of the
definition, including methods. For instance, the method <TT>get_offset</TT>
in the class below returns the position of the object relative to its
initial position.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method get_offset = x - x_init
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
Expressions can be evaluated and bound before defining the object body
of the class. This is useful to enforce invariants. For instance,
points can be automatically adjusted to the nearest point on a grid,
as follows:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class adjusted_point x_init =
    let origin = (x_init / 10) * 10 in
    object
      val mutable x = origin
      method get_x = x
      method get_offset = x - origin
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class adjusted_point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
(One could also raise an exception if the <TT>x_init</TT> coordinate is not
on the grid.) In fact, the same effect could here be obtained by
calling the definition of class <TT>point</TT> with the value of the
<TT>origin</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class adjusted_point x_init =  point ((x_init / 10) * 10);;
</FONT><FONT COLOR=maroon>class adjusted_point : int -&gt; point
</FONT></PRE><P>
An alternate solution would have been to define the adjustment in
a special allocation function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
</FONT><FONT COLOR=maroon>val new_adjusted_point : int -&gt; point = &lt;fun&gt;
</FONT></PRE><P>
However, the former pattern is generally more appropriate, since
the code for adjustment is part of the definition of the class and will be
inherited.</P><P>This ability provides class constructors as can be found in other
languages. Several constructors can be defined this way to build objects of
the same class but with different initialization patterns; an
alternative is to use initializers, as decribed below in section
<A HREF="#ss:initializers">3.4</A>.</P><!--TOC section Immediate objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">3.2</A>&#XA0;&#XA0;Immediate objects</H2><!--SEC END --><P>

<A NAME="ss:immediate-objects"></A></P><P>There is another, more direct way to create an object: create it
without going through a class.</P><P>The syntax is exactly the same as for class expressions, but the
result is a single object rather than a class. All the constructs
described in the rest of this section also apply to immediate objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let p =
    object
      val mutable x = 0
      method get_x = x
      method move d = x &lt;- x + d
    end;;
<FONT COLOR=maroon>val p : &lt; get_x : int; move : int -&gt; unit &gt; = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p#get_x;;
<FONT COLOR=maroon>- : int = 0

</FONT><FONT COLOR=black>#</FONT> p#move 3;;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> p#get_x;;
</FONT><FONT COLOR=maroon>- : int = 3
</FONT></PRE><P>Unlike classes, which cannot be defined inside an expression,
immediate objects can appear anywhere, using variables from their
environment.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let minmax x y =
    if x &lt; y then object method min = x method max = y end
    else object method min = y method max = x end;;
</FONT><FONT COLOR=maroon>val minmax : 'a -&gt; 'a -&gt; &lt; max : 'a; min : 'a &gt; = &lt;fun&gt;
</FONT></PRE><P>Immediate objects have two weaknesses compared to classes: their types
are not abbreviated, and you cannot inherit from them. But these two
weaknesses can be advantages in some situations, as we will see
in sections <A HREF="#ss:reference-to-self">3.3</A> and <A HREF="#ss:parameterized-classes">3.10</A>.</P><!--TOC section Reference to self-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">3.3</A>&#XA0;&#XA0;Reference to self</H2><!--SEC END --><P>

<A NAME="ss:reference-to-self"></A></P><P>A method or an initializer can send messages to self (that is,
the current object). For that, self must be explicitly bound, here to
the variable <TT>s</TT> (<TT>s</TT> could be any identifier, even though we will
often choose the name <TT>self</TT>.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class printable_point x_init =
    object (s)
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
      method print = print_int s#get_x
    end;;
<FONT COLOR=maroon>class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end

</FONT><FONT COLOR=black>#</FONT> let p = new printable_point 7;;
<FONT COLOR=maroon>val p : printable_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p#print;;
</FONT><FONT COLOR=maroon>7- : unit = ()
</FONT></PRE><P>
Dynamically, the variable <TT>s</TT> is bound at the invocation of a method. In
particular, when the class <TT>printable_point</TT> is inherited, the variable
<TT>s</TT> will be correctly bound to the object of the subclass.</P><P>A common problem with self is that, as its type may be extended in
subclasses, you cannot fix it in advance. Here is a simple example.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let ints = ref [];;
<FONT COLOR=maroon>val ints : '_a list ref = {contents = []}

</FONT><FONT COLOR=black>#</FONT> class my_int =
    object (self)
      method n = 1
      method register = ints := <U>self</U> :: !ints
    end;;
</FONT><FONT COLOR=maroon>Error: This expression has type &lt; n : int; register : 'b; .. &gt; as 'a
       but an expression was expected of type 'a
       This instance of &lt; n : int; register : 'b; .. &gt; is ambiguous:
       it would escape the scope of its equation
</FONT></PRE><P>
You can ignore the first two lines of the error message. What matters
is the last one: putting self into an external reference would make it
impossible to extend it through inheritance.
We will see in section <A HREF="#ss:using-coercions">3.12</A> a workaround to this
problem.
Note however that, since immediate objects are not extensible, the
problem does not occur with them.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let my_int =
    object (self)
      method n = 1
      method register = ints := self :: !ints
    end;;
</FONT><FONT COLOR=maroon>val my_int : &lt; n : int; register : unit &gt; = &lt;obj&gt;
</FONT></PRE><!--TOC section Initializers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">3.4</A>&#XA0;&#XA0;Initializers</H2><!--SEC END --><P>

<A NAME="ss:initializers"></A></P><P>Let-bindings within class definitions are evaluated before the object
is constructed. It is also possible to evaluate an expression
immediately after the object has been built. Such code is written as
an anonymous hidden method called an initializer. Therefore, it can
access self and the instance variables.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class printable_point x_init =
    let origin = (x_init / 10) * 10 in
    object (self)
      val mutable x = origin
      method get_x = x
      method move d = x &lt;- x + d
      method print = print_int self#get_x
      initializer print_string "new point at "; self#print; print_newline()
    end;;
<FONT COLOR=maroon>class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end

</FONT><FONT COLOR=black>#</FONT> let p = new printable_point 17;;
</FONT><FONT COLOR=maroon>new point at 10
val p : printable_point = &lt;obj&gt;
</FONT></PRE><P>
Initializers cannot be overridden. On the contrary, all initializers are
evaluated sequentially.
Initializers are particularly useful to enforce invariants.
Another example can be seen in section <A HREF="#ss:bank-accounts">5.1</A>.</P><!--TOC section Virtual methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">3.5</A>&#XA0;&#XA0;Virtual methods</H2><!--SEC END --><P>

<A NAME="ss:virtual-methods"></A></P><P>It is possible to declare a method without actually defining it, using
the keyword <TT>virtual</TT>. This method will be provided later in
subclasses. A class containing virtual methods must be flagged
<TT>virtual</TT>, and cannot be instantiated (that is, no object of this class
can be created). It still defines type abbreviations (treating virtual methods
as other methods.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class virtual abstract_point x_init =
    object (self)
      method virtual get_x : int
      method get_offset = self#get_x - x_init
      method virtual move : int -&gt; unit
    end;;
<FONT COLOR=maroon>class virtual abstract_point :
  int -&gt;
  object
    method get_offset : int
    method virtual get_x : int
    method virtual move : int -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> class point x_init =
    object
      inherit abstract_point x_init
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>Instance variables can also be declared as virtual, with the same effect
as with methods.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class virtual abstract_point2 =
    object
      val mutable virtual x : int
      method move d = x &lt;- x + d
    end;;
<FONT COLOR=maroon>class virtual abstract_point2 :
  object val mutable virtual x : int method move : int -&gt; unit end

</FONT><FONT COLOR=black>#</FONT> class point2 x_init =
    object
      inherit abstract_point2
      val mutable x = x_init
      method get_offset = x - x_init
    end;;
</FONT><FONT COLOR=maroon>class point2 :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method move : int -&gt; unit
  end
</FONT></PRE><!--TOC section Private methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.6</A>&#XA0;&#XA0;Private methods</H2><!--SEC END --><P>

<A NAME="ss:private-methods"></A></P><P>Private methods are methods that do not appear in object interfaces.
They can only be invoked from other methods of the same object.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class restricted_point x_init =
    object (self)
      val mutable x = x_init
      method get_x = x
      method private move d = x &lt;- x + d
      method bump = self#move 1
    end;;
<FONT COLOR=maroon>class restricted_point :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method private move : int -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> let p = new restricted_point 0;;
<FONT COLOR=maroon>val p : restricted_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> <U>p</U>#move 10;;
<FONT COLOR=maroon>Error: This expression has type restricted_point
       It has no method move

</FONT><FONT COLOR=black>#</FONT> p#bump;;
</FONT><FONT COLOR=maroon>- : unit = ()
</FONT></PRE><P>
Note that this is not the same thing as private and protected methods
in Java or C++, which can be called from other objects of the same
class. This is a direct consequence of the independence between types
and classes in OCaml: two unrelated classes may produce
objects of the same type, and there is no way at the type level to
ensure that an object comes from a specific class. However a possible
encoding of friend methods is given in section <A HREF="#ss:friends">3.17</A>.</P><P>Private methods are inherited (they are by default visible in subclasses),
unless they are hidden by signature matching, as described below.</P><P>Private methods can be made public in a subclass.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point_again x =
    object (self)
      inherit restricted_point x
      method virtual move : _
    end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
The annotation <TT>virtual</TT> here is only used to mention a method without
providing its definition. Since we didn&#X2019;t add the <TT>private</TT>
annotation, this makes the method public, keeping the original
definition.</P><P>An alternative definition is
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point_again x =
    object (self : &lt; move : _; ..&gt; )
      inherit restricted_point x
    end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
The constraint on self&#X2019;s type is requiring a public <TT>move</TT> method, and
this is sufficient to override <TT>private</TT>.</P><P>One could think that a private method should remain private in a subclass.
However, since the method is visible in a subclass, it is always possible
to pick its code and define a method of the same name that runs that
code, so yet another (heavier) solution would be:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class point_again x =
    object
      inherit restricted_point x as super
      method move = super#move
    end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>Of course, private methods can also be virtual. Then, the keywords must
appear in this order <TT>method private virtual</TT>.</P><!--TOC section Class interfaces-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.7</A>&#XA0;&#XA0;Class interfaces</H2><!--SEC END --><P>

<A NAME="ss:class-interfaces"></A></P><P>Class interfaces are inferred from class definitions. They may also
be defined directly and used to restrict the type of a class. Like class
declarations, they also define a new type abbreviation.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type restricted_point_type =
    object
      method get_x : int
      method bump : unit
  end;;
<FONT COLOR=maroon>class type restricted_point_type =
  object method bump : unit method get_x : int end

</FONT><FONT COLOR=black>#</FONT> fun (x : restricted_point_type) -&gt; x;;
</FONT><FONT COLOR=maroon>- : restricted_point_type -&gt; restricted_point_type = &lt;fun&gt;
</FONT></PRE><P>
In addition to program documentation, class interfaces can be used to
constrain the type of a class. Both concrete instance variables and concrete
private methods can be hidden by a class type constraint. Public
methods and virtual members, however, cannot.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class restricted_point' x = (restricted_point x : restricted_point_type);;
</FONT><FONT COLOR=maroon>class restricted_point' : int -&gt; restricted_point_type
</FONT></PRE><P>
Or, equivalently:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class restricted_point' = (restricted_point : int -&gt; restricted_point_type);;
</FONT><FONT COLOR=maroon>class restricted_point' : int -&gt; restricted_point_type
</FONT></PRE><P>
The interface of a class can also be specified in a module
signature, and used to restrict the inferred signature of a module.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type POINT = sig
    class restricted_point' : int -&gt;
      object
        method get_x : int
        method bump : unit
      end
  end;;
<FONT COLOR=maroon>module type POINT =
  sig
    class restricted_point' :
      int -&gt; object method bump : unit method get_x : int end
  end

</FONT><FONT COLOR=black>#</FONT> module Point : POINT = struct
    class restricted_point' = restricted_point
  end;;
</FONT><FONT COLOR=maroon>module Point : POINT
</FONT></PRE><!--TOC section Inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">3.8</A>&#XA0;&#XA0;Inheritance</H2><!--SEC END --><P>

<A NAME="ss:inheritance"></A></P><P>We illustrate inheritance by defining a class of colored points that
inherits from the class of points. This class has all instance
variables and all methods of class <TT>point</TT>, plus a new instance
variable <TT>c</TT> and a new method <TT>color</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class colored_point x (c : string) =
    object
      inherit point x
      val c = c
      method color = c
    end;;
<FONT COLOR=maroon>class colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> let p' = new colored_point 5 "red";;
<FONT COLOR=maroon>val p' : colored_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p'#get_x, p'#color;;
</FONT><FONT COLOR=maroon>- : int * string = (5, "red")
</FONT></PRE><P>
A point and a colored point have incompatible types, since a point has
no method <TT>color</TT>. However, the function <TT>get_x</TT> below is a generic
function applying method <TT>get_x</TT> to any object <TT>p</TT> that has this
method (and possibly some others, which are represented by an ellipsis
in the type). Thus, it applies to both points and colored points.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let get_succ_x p = p#get_x + 1;;
<FONT COLOR=maroon>val get_succ_x : &lt; get_x : int; .. &gt; -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> get_succ_x p + get_succ_x p';;
</FONT><FONT COLOR=maroon>- : int = 8
</FONT></PRE><P>
Methods need not be declared previously, as shown by the example:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let set_x p = p#set_x;;
<FONT COLOR=maroon>val set_x : &lt; set_x : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let incr p = set_x p (get_succ_x p);;
</FONT><FONT COLOR=maroon>val incr : &lt; get_x : int; set_x : int -&gt; 'a; .. &gt; -&gt; 'a = &lt;fun&gt;
</FONT></PRE><!--TOC section Multiple inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">3.9</A>&#XA0;&#XA0;Multiple inheritance</H2><!--SEC END --><P>

<A NAME="ss:multiple-inheritance"></A></P><P>Multiple inheritance is allowed. Only the last definition of a method
is kept: the redefinition in a subclass of a method that was visible in
the parent class overrides the definition in the parent class.
Previous definitions of a method can be reused by binding the related
ancestor. Below, <TT>super</TT> is bound to the ancestor <TT>printable_point</TT>.
The name <TT>super</TT> is a pseudo value identifier that can only be used to
invoke a super-class method, as in <TT>super#print</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class printable_colored_point y c =
    object (self)
      val c = c
      method color = c
      inherit printable_point y as super
      method print =
        print_string "(";
        super#print;
        print_string ", ";
        print_string (self#color);
        print_string ")"
    end;;
<FONT COLOR=maroon>class printable_colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end

</FONT><FONT COLOR=black>#</FONT> let p' = new printable_colored_point 17 "red";;
<FONT COLOR=maroon>new point at (10, red)
val p' : printable_colored_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p'#print;;
</FONT><FONT COLOR=maroon>(10, red)- : unit = ()
</FONT></PRE><P>
A private method that has been hidden in the parent class is no longer
visible, and is thus not overridden. Since initializers are treated as
private methods, all initializers along the class hierarchy are evaluated,
in the order they are introduced.</P><!--TOC section Parameterized classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3.10</A>&#XA0;&#XA0;Parameterized classes</H2><!--SEC END --><P>

<A NAME="ss:parameterized-classes"></A></P><P>Reference cells can be implemented as objects.
The naive definition fails to typecheck:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class <U>ref x_init =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end</U>;;
</FONT><FONT COLOR=maroon>Error: Some type variables are unbound in this type:
         class ref :
           'a -&gt;
           object
             val mutable x : 'a
             method get : 'a
             method set : 'a -&gt; unit
           end
       The method get has type 'a where 'a is unbound
</FONT></PRE><P>
The reason is that at least one of the methods has a polymorphic type
(here, the type of the value stored in the reference cell), thus
either the class should be parametric, or the method type should be
constrained to a monomorphic type. A monomorphic instance of the class could
be defined by:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ref (x_init:int) =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end;;
</FONT><FONT COLOR=maroon>class ref :
  int -&gt;
  object val mutable x : int method get : int method set : int -&gt; unit end
</FONT></PRE><P>
Note that since immediate objects do not define a class type, they have
no such restriction.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let new_ref x_init =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end;;
</FONT><FONT COLOR=maroon>val new_ref : 'a -&gt; &lt; get : 'a; set : 'a -&gt; unit &gt; = &lt;fun&gt;
</FONT></PRE><P>
On the other hand, a class for polymorphic references must explicitly
list the type parameters in its declaration. Class type parameters are
listed between <TT>[</TT> and <TT>]</TT>. The type parameters must also be
bound somewhere in the class body by a type constraint.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] ref x_init =
    object
      val mutable x = (x_init : 'a)
      method get = x
      method set y = x &lt;- y
    end;;
<FONT COLOR=maroon>class ['a] ref :
  'a -&gt; object val mutable x : 'a method get : 'a method set : 'a -&gt; unit end

</FONT><FONT COLOR=black>#</FONT> let r = new ref 1 in r#set 2; (r#get);;
</FONT><FONT COLOR=maroon>- : int = 2
</FONT></PRE><P>
The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the <TT>constraint</TT> clause.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] ref_succ (x_init:'a) =
    object
      val mutable x = x_init + 1
      method get = x
      method set y = x &lt;- y
    end;;
</FONT><FONT COLOR=maroon>class ['a] ref_succ :
  'a -&gt;
  object
    constraint 'a = int
    val mutable x : int
    method get : int
    method set : int -&gt; unit
  end
</FONT></PRE><P>
Let us consider a more complex example: define a circle, whose center
may be any kind of point. We put an additional type
constraint in method <TT>move</TT>, since no free variables must remain
unaccounted for by the class type parameters.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] circle (c : 'a) =
    object
      val mutable center = c
      method center = center
      method set_center c = center &lt;- c
      method move = (center#move : int -&gt; unit)
    end;;
</FONT><FONT COLOR=maroon>class ['a] circle :
  'a -&gt;
  object
    constraint 'a = &lt; move : int -&gt; unit; .. &gt;
    val mutable center : 'a
    method center : 'a
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end
</FONT></PRE><P>
An alternate definition of <TT>circle</TT>, using a <TT>constraint</TT> clause in
the class definition, is shown below. The type <TT>#point</TT> used below in
the <TT>constraint</TT> clause is an abbreviation produced by the definition
of class <TT>point</TT>. This abbreviation unifies with the type of any
object belonging to a subclass of class <TT>point</TT>. It actually expands to
<TT>&lt; get_x : int; move : int -&gt; unit; .. &gt;</TT>. This leads to the following
alternate definition of <TT>circle</TT>, which has slightly stronger
constraints on its argument, as we now expect <TT>center</TT> to have a
method <TT>get_x</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] circle (c : 'a) =
    object
      constraint 'a = #point
      val mutable center = c
      method center = center
      method set_center c = center &lt;- c
      method move = center#move
    end;;
</FONT><FONT COLOR=maroon>class ['a] circle :
  'a -&gt;
  object
    constraint 'a = #point
    val mutable center : 'a
    method center : 'a
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end
</FONT></PRE><P>
The class <TT>colored_circle</TT> is a specialized version of class
<TT>circle</TT> that requires the type of the center to unify with
<TT>#colored_point</TT>, and adds a method <TT>color</TT>. Note that when specializing a
parameterized class, the instance of type parameter must always be
explicitly given. It is again written between <TT>[</TT> and <TT>]</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] colored_circle c =
    object
      constraint 'a = #colored_point
      inherit ['a] circle c
      method color = center#color
    end;;
</FONT><FONT COLOR=maroon>class ['a] colored_circle :
  'a -&gt;
  object
    constraint 'a = #colored_point
    val mutable center : 'a
    method center : 'a
    method color : string
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end
</FONT></PRE><!--TOC section Polymorphic methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.11</A>&#XA0;&#XA0;Polymorphic methods</H2><!--SEC END --><P>

<A NAME="ss:polymorphic-methods"></A></P><P>While parameterized classes may be polymorphic in their contents, they
are not enough to allow polymorphism of method use.</P><P>A classical example is defining an iterator.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> List.fold_left;;
<FONT COLOR=maroon>- : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> class ['a] intlist (l : int list) =
    object
      method empty = (l = [])
      method fold f (accu : 'a) = List.fold_left f accu l
    end;;
</FONT><FONT COLOR=maroon>class ['a] intlist :
  int list -&gt;
  object method empty : bool method fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a end
</FONT></PRE><P>
At first look, we seem to have a polymorphic iterator, however this
does not work in practice.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let l = new intlist [1; 2; 3];;
<FONT COLOR=maroon>val l : '_a intlist = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> l#fold (fun x y -&gt; x+y) 0;;
<FONT COLOR=maroon>- : int = 6

</FONT><FONT COLOR=black>#</FONT> l;;
<FONT COLOR=maroon>- : int intlist = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> l#fold (fun s x -&gt; <U>s</U> ^ string_of_int x ^ " ") "";;
</FONT><FONT COLOR=maroon>Error: This expression has type int but an expression was expected of type
         string
</FONT></PRE><P>
Our iterator works, as shows its first use for summation. However,
since objects themselves are not polymorphic (only their constructors
are), using the <TT>fold</TT> method fixes its type for this individual object.
Our next attempt to use it as a string iterator fails.</P><P>The problem here is that quantification was wrongly located: it is
not the class we want to be polymorphic, but the <TT>fold</TT> method.
This can be achieved by giving an explicitly polymorphic type in the
method definition.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class intlist (l : int list) =
    object
      method empty = (l = [])
      method fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a =
        fun f accu -&gt; List.fold_left f accu l
    end;;
<FONT COLOR=maroon>class intlist :
  int list -&gt;
  object method empty : bool method fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a end

</FONT><FONT COLOR=black>#</FONT> let l = new intlist [1; 2; 3];;
<FONT COLOR=maroon>val l : intlist = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> l#fold (fun x y -&gt; x+y) 0;;
<FONT COLOR=maroon>- : int = 6

</FONT><FONT COLOR=black>#</FONT> l#fold (fun s x -&gt; s ^ string_of_int x ^ " ") "";;
</FONT><FONT COLOR=maroon>- : string = "1 2 3 "
</FONT></PRE><P>
As you can see in the class type shown by the compiler, while
polymorphic method types must be fully explicit in class definitions
(appearing immediately after the method name), quantified type
variables can be left implicit in class descriptions. Why require types
to be explicit? The problem is that <TT>(int -&gt; int -&gt; int) -&gt; int -&gt; int</TT> would also be a valid type for <TT>fold</TT>, and it happens to be
incompatible with the polymorphic type we gave (automatic
instantiation only works for toplevel types variables, not for inner
quantifiers, where it becomes an undecidable problem.) So the compiler
cannot choose between those two types, and must be helped.</P><P>However, the type can be completely omitted in the class definition if
it is already known, through inheritance or type constraints on self.
Here is an example of method overriding.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class intlist_rev l =
    object
      inherit intlist l
      method fold f accu = List.fold_left f accu (List.rev l)
    end;;
</FONT></PRE><P>
The following idiom separates description and definition.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type ['a] iterator =
    object method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b end;;

  class intlist l =
    object (self : int #iterator)
      method empty = (l = [])
      method fold f accu = List.fold_left f accu l
    end;;
</FONT></PRE><P>
Note here the <TT>(self : int #iterator)</TT> idiom, which ensures that this
object implements the interface <TT>iterator</TT>.</P><P>Polymorphic methods are called in exactly the same way as normal
methods, but you should be aware of some limitations of type
inference. Namely, a polymorphic method can only be called if its
type is known at the call site. Otherwise, the method will be assumed
to be monomorphic, and given an incompatible type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let sum lst = lst#fold (fun x y -&gt; x+y) 0;;
<FONT COLOR=maroon>val sum : &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> sum <U>l</U>;;
</FONT><FONT COLOR=maroon>Error: This expression has type intlist
       but an expression was expected of type
         &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'a; .. &gt;
       Types for method fold are incompatible
</FONT></PRE><P>
The workaround is easy: you should put a type constraint on the
parameter.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let sum (lst : _ #iterator) = lst#fold (fun x y -&gt; x+y) 0;;
</FONT><FONT COLOR=maroon>val sum : int #iterator -&gt; int = &lt;fun&gt;
</FONT></PRE><P>
Of course the constraint may also be an explicit method type.
Only occurences of quantified variables are required.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let sum lst =
    (lst : &lt; fold : 'a. ('a -&gt; _ -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt;)#fold (+) 0;;
</FONT><FONT COLOR=maroon>val sum : &lt; fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt; -&gt; int = &lt;fun&gt;
</FONT></PRE><P>Another use of polymorphic methods is to allow some form of implicit
subtyping in method arguments. We have already seen in section
<A HREF="#ss:inheritance">3.8</A> how some functions may be polymorphic in the
class of their argument. This can be extended to methods.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type point0 = object method get_x : int end;;
<FONT COLOR=maroon>class type point0 = object method get_x : int end

</FONT><FONT COLOR=black>#</FONT> class distance_point x =
    object
      inherit point x
      method distance : 'a. (#point0 as 'a) -&gt; int =
        fun other -&gt; abs (other#get_x - x)
    end;;
<FONT COLOR=maroon>class distance_point :
  int -&gt;
  object
    val mutable x : int
    method distance : #point0 -&gt; int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> let p = new distance_point 3 in
  (p#distance (new point 8), p#distance (new colored_point 1 "blue"));;
</FONT><FONT COLOR=maroon>- : int * int = (5, 2)
</FONT></PRE><P>
Note here the special syntax <TT>(#point0 as 'a)</TT> we have to use to
quantify the extensible part of <TT>#point0</TT>. As for the variable binder,
it can be omitted in class specifications. If you want polymorphism
inside object field it must be quantified independently.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class multi_poly =
    object
      method m1 : 'a. (&lt; n1 : 'b. 'b -&gt; 'b; .. &gt; as 'a) -&gt; _ =
        fun o -&gt; o#n1 true, o#n1 "hello"
      method m2 : 'a 'b. (&lt; n2 : 'b -&gt; bool; .. &gt; as 'a) -&gt; 'b -&gt; _ =
        fun o x -&gt; o#n2 x
    end;;
</FONT><FONT COLOR=maroon>class multi_poly :
  object
    method m1 : &lt; n1 : 'b. 'b -&gt; 'b; .. &gt; -&gt; bool * string
    method m2 : &lt; n2 : 'b -&gt; bool; .. &gt; -&gt; 'b -&gt; bool
  end
</FONT></PRE><P>
In method <TT>m1</TT>, <TT>o</TT> must be an object with at least a method <TT>n1</TT>,
itself polymorphic. In method <TT>m2</TT>, the argument of <TT>n2</TT> and <TT>x</TT> must
have the same type, which is quantified at the same level as <TT>'a</TT>.</P><!--TOC section Using coercions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">3.12</A>&#XA0;&#XA0;Using coercions</H2><!--SEC END --><P>

<A NAME="ss:using-coercions"></A></P><P>Subtyping is never implicit. There are, however, two ways to perform
subtyping. The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.</P><P>We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its <TT>color</TT> method:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let colored_point_to_point cp = (cp : colored_point :&gt; point);;
<FONT COLOR=maroon>val colored_point_to_point : colored_point -&gt; point = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let p = new point 3 and q = new colored_point 4 "blue";;
<FONT COLOR=maroon>val p : point = &lt;obj&gt;
val q : colored_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> let l = [p; (colored_point_to_point q)];;
</FONT><FONT COLOR=maroon>val l : point list = [&lt;obj&gt;; &lt;obj&gt;]
</FONT></PRE><P>
An object of type <TT>t</TT> can be seen as an object of type <TT>t'</TT>
only if <TT>t</TT> is a subtype of <TT>t'</TT>. For instance, a point cannot be
seen as a colored point.
</P><PRE><FONT COLOR=black>#</FONT> <FONT COLOR="#006000"><U>(p : point :&gt; colored_point)</U>;;
</FONT><FONT COLOR=maroon>Error: Type point = &lt; get_offset : int; get_x : int; move : int -&gt; unit &gt;
       is not a subtype of
         colored_point =
           &lt; color : string; get_offset : int; get_x : int;
             move : int -&gt; unit &gt; 
</FONT></PRE><P>
Indeed, narrowing coercions without runtime checks would be unsafe.
Runtime type checks might raise exceptions, and they would require
the presence of type information at runtime, which is not the case in
the OCaml system.
For these reasons, there is no such operation available in the language.</P><P>Be aware that subtyping and inheritance are not related. Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types. For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
</P><P>The domain of a coercion can often be omitted. For instance, one can
define:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let to_point cp = (cp :&gt; point);;
</FONT><FONT COLOR=maroon>val to_point : #point -&gt; point = &lt;fun&gt;
</FONT></PRE><P>
In this case, the function <TT>colored_point_to_point</TT> is an instance of the
function <TT>to_point</TT>. This is not always true, however. The fully
explicit coercion is more precise and is sometimes unavoidable.
Consider, for example, the following class:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class c0 = object method m = {&lt; &gt;} method n = 0 end;;
</FONT><FONT COLOR=maroon>class c0 : object ('a) method m : 'a method n : int end
</FONT></PRE><P>
The object type <TT>c0</TT> is an abbreviation for <TT>&lt;m : 'a; n : int&gt; as 'a</TT>.
Consider now the type declaration:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type c1 =  object method m : c1 end;;
</FONT><FONT COLOR=maroon>class type c1 = object method m : c1 end
</FONT></PRE><P>
The object type <TT>c1</TT> is an abbreviation for the type <TT>&lt;m : 'a&gt; as 'a</TT>.
The coercion from an object of type <TT>c0</TT> to an object of type <TT>c1</TT> is
correct:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> fun (x:c0) -&gt; (x : c0 :&gt; c1);;
</FONT><FONT COLOR=maroon>- : c0 -&gt; c1 = &lt;fun&gt;
</FONT></PRE><P>
However, the domain of the coercion cannot always be omitted.
In that case, the solution is to use the explicit form.
Sometimes, a change in the class-type definition can also solve the problem
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type c2 = object ('a) method m : 'a end;;
<FONT COLOR=maroon>class type c2 = object ('a) method m : 'a end

</FONT><FONT COLOR=black>#</FONT> fun (x:c0) -&gt; (x :&gt; c2);;
</FONT><FONT COLOR=maroon>- : c0 -&gt; c2 = &lt;fun&gt;
</FONT></PRE><P>
While class types <TT>c1</TT> and <TT>c2</TT> are different, both object types
<TT>c1</TT> and <TT>c2</TT> expand to the same object type (same method names and types).
Yet, when the domain of a coercion is left implicit and its co-domain
is an abbreviation of a known class type, then the class type, rather
than the object type, is used to derive the coercion function. This
allows leaving the domain implicit in most cases when coercing form a
subclass to its superclass.
The type of a coercion can always be seen as below:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let to_c1 x = (x :&gt; c1);;
<FONT COLOR=maroon>val to_c1 : &lt; m : #c1; .. &gt; -&gt; c1 = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let to_c2 x = (x :&gt; c2);;
</FONT><FONT COLOR=maroon>val to_c2 : #c2 -&gt; c2 = &lt;fun&gt;
</FONT></PRE><P>
Note the difference between these two coercions: in the case of <TT>to_c2</TT>,
the type
<TT>#c2 = &lt; m : 'a; .. &gt; as 'a</TT> is polymorphically recursive (according
to the explicit recursion in the class type of <TT>c2</TT>); hence the
success of applying this coercion to an object of class <TT>c0</TT>.
On the other hand, in the first case, <TT>c1</TT> was only expanded and
unrolled twice to obtain <TT>&lt; m : &lt; m : c1; .. &gt;; .. &gt;</TT> (remember <TT>#c1 = &lt; m : c1; .. &gt;</TT>), without introducing recursion.
You may also note that the type of <TT>to_c2</TT> is <TT>#c2 -&gt; c2</TT> while
the type of <TT>to_c1</TT> is more general than <TT>#c1 -&gt; c1</TT>. This is not always true,
since there are class types for which some instances of <TT>#c</TT> are not subtypes
of <TT>c</TT>, as explained in section&#XA0;<A HREF="#ss:binary-methods">3.16</A>. Yet, for
parameterless classes the coercion <TT>(_ :&gt; c)</TT> is always more general than
<TT>(_ : #c :&gt; c)</TT>.
</P><P>A common problem may occur when one tries to define a coercion to a
class <TT>c</TT> while defining class <TT>c</TT>. The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known. Then, a coercion <TT>(_ :&gt; c)</TT> or <TT>(_ : #c :&gt; c)</TT> is taken to be
the identity function, as in
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> function x -&gt; (x :&gt; 'a);;
</FONT><FONT COLOR=maroon>- : 'a -&gt; 'a = &lt;fun&gt;
</FONT></PRE><P>
As a consequence, if the coercion is applied to <TT>self</TT>, as in the
following example, the type of <TT>self</TT> is unified with the closed type
<TT>c</TT> (a closed object type is an object type without ellipsis). This
would constrain the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class c = object method m = 1 end
  and d = object (self)
    inherit c
    method n = 2
    method as_c = (<U>self</U> :&gt; c)
  end;;
</FONT><FONT COLOR=maroon>Error: This expression cannot be coerced to type c = &lt; m : int &gt;; it has type
         &lt; as_c : c; m : int; n : int; .. &gt;
       but is here used with type c
       Self type cannot be unified with a closed object type
</FONT></PRE><P>
However, the most common instance of this problem, coercing self to
its current class, is detected as a special case by the type checker,
and properly typed.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class c = object (self) method m = (self :&gt; c) end;;
</FONT><FONT COLOR=maroon>class c : object method m : c end
</FONT></PRE><P>
This allows the following idiom, keeping a list of all objects
belonging to a class or its subclasses:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let all_c = ref [];;
<FONT COLOR=maroon>val all_c : '_a list ref = {contents = []}

</FONT><FONT COLOR=black>#</FONT> class c (m : int) =
    object (self)
      method m = m
      initializer all_c := (self :&gt; c) :: !all_c
    end;;
</FONT><FONT COLOR=maroon>class c : int -&gt; object method m : int end
</FONT></PRE><P>
This idiom can in turn be used to retrieve an object whose type has
been weakened:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let rec lookup_obj obj = function [] -&gt; raise Not_found
    | obj' :: l -&gt;
       if (obj :&gt; &lt; &gt;) = (obj' :&gt; &lt; &gt;) then obj' else lookup_obj obj l ;;
<FONT COLOR=maroon>val lookup_obj : &lt; .. &gt; -&gt; (&lt; .. &gt; as 'a) list -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let lookup_c obj = lookup_obj obj !all_c;;
</FONT><FONT COLOR=maroon>val lookup_c : &lt; .. &gt; -&gt; &lt; m : int &gt; = &lt;fun&gt;
</FONT></PRE><P>
The type <TT>&lt; m : int &gt;</TT> we see here is just the expansion of <TT>c</TT>, due
to the use of a reference; we have succeeded in getting back an object
of type <TT>c</TT>.</P><P><BR>
The previous coercion problem can often be avoided by first
defining the abbreviation, using a class type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type c' = object method m : int end;;
<FONT COLOR=maroon>class type c' = object method m : int end

</FONT><FONT COLOR=black>#</FONT> class c : c' = object method m = 1 end
  and d = object (self)
    inherit c
    method n = 2
    method as_c = (self :&gt; c')
  end;;
</FONT><FONT COLOR=maroon>class c : c'
and d : object method as_c : c' method m : int method n : int end
</FONT></PRE><P>
It is also possible to use a virtual class. Inheriting from this class
simultaneously forces all methods of <TT>c</TT> to have the same
type as the methods of <TT>c'</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class virtual c' = object method virtual m : int end;;
<FONT COLOR=maroon>class virtual c' : object method virtual m : int end

</FONT><FONT COLOR=black>#</FONT> class c = object (self) inherit c' method m = 1 end;;
</FONT><FONT COLOR=maroon>class c : object method m : int end
</FONT></PRE><P>
One could think of defining the type abbreviation directly:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type c' = &lt;m : int&gt;;;
</FONT></PRE><P>
However, the abbreviation <TT>#c'</TT> cannot be defined directly in a similar way.
It can only be defined by a class or a class-type definition.
This is because a <TT>#</TT>-abbreviation carries an implicit anonymous
variable <TT>..</TT> that cannot be explicitly named.
The closer you get to it is:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a c'_class = 'a constraint 'a = &lt; m : int; .. &gt;;;
</FONT></PRE><P>
with an extra type variable capturing the open object type.</P><!--TOC section Functional objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">3.13</A>&#XA0;&#XA0;Functional objects</H2><!--SEC END --><P>

<A NAME="ss:functional-objects"></A></P><P>It is possible to write a version of class <TT>point</TT> without assignments
on the instance variables. The override construct <TT>{&lt; ... &gt;}</TT> returns a copy of
&#X201C;self&#X201D; (that is, the current object), possibly changing the value of
some instance variables.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class functional_point y =
    object
      val x = y
      method get_x = x
      method move d = {&lt; x = x + d &gt;}
    end;;
<FONT COLOR=maroon>class functional_point :
  int -&gt;
  object ('a) val x : int method get_x : int method move : int -&gt; 'a end

</FONT><FONT COLOR=black>#</FONT> let p = new functional_point 7;;
<FONT COLOR=maroon>val p : functional_point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p#get_x;;
<FONT COLOR=maroon>- : int = 7

</FONT><FONT COLOR=black>#</FONT> (p#move 3)#get_x;;
<FONT COLOR=maroon>- : int = 10

</FONT><FONT COLOR=black>#</FONT> p#get_x;;
</FONT><FONT COLOR=maroon>- : int = 7
</FONT></PRE><P>
Note that the type abbreviation <TT>functional_point</TT> is recursive, which can
be seen in the class type of <TT>functional_point</TT>: the type of self is <TT>'a</TT>
and <TT>'a</TT> appears inside the type of the method <TT>move</TT>.</P><P>The above definition of <TT>functional_point</TT> is not equivalent
to the following:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class bad_functional_point y =
    object
      val x = y
      method get_x = x
      method move d = new bad_functional_point (x+d)
    end;;
</FONT><FONT COLOR=maroon>class bad_functional_point :
  int -&gt;
  object
    val x : int
    method get_x : int
    method move : int -&gt; bad_functional_point
  end
</FONT></PRE><P>
While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of <TT>bad_functional_point</TT>,
the method <TT>move</TT> will
keep returning an object of the parent class. On the contrary, in a
subclass of <TT>functional_point</TT>, the method <TT>move</TT> will return an
object of the subclass.</P><P>Functional update is often used in conjunction with binary methods
as illustrated in section <A HREF="#module:string">5.2.1</A>.</P><!--TOC section Cloning objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">3.14</A>&#XA0;&#XA0;Cloning objects</H2><!--SEC END --><P>

<A NAME="ss:cloning-objects"></A></P><P>Objects can also be cloned, whether they are functional or imperative.
The library function <TT>Oo.copy</TT> makes a shallow copy of an object. That is,
it returns a new object that has the same methods and instance
variables as its argument. The
instance variables are copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely.
A deeper assignment (for example if the instance variable is a reference cell)
will of course affect both the original and the copy.</P><P>The type of <TT>Oo.copy</TT> is the following:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> Oo.copy;;
</FONT><FONT COLOR=maroon>- : (&lt; .. &gt; as 'a) -&gt; 'a = &lt;fun&gt;
</FONT></PRE><P>
The keyword <TT>as</TT> in that type binds the type variable <TT>'a</TT> to
the object type <TT>&lt; .. &gt;</TT>. Therefore, <TT>Oo.copy</TT> takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of <TT>Oo.copy</TT> is different from type <TT>&lt; .. &gt; -&gt; &lt; .. &gt;</TT> as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let p = new point 5;;
<FONT COLOR=maroon>val p : point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> let q = Oo.copy p;;
<FONT COLOR=maroon>val q : point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> q#move 7; (p#get_x, q#get_x);;
</FONT><FONT COLOR=maroon>- : int * int = (5, 12)
</FONT></PRE><P>
In fact, <TT>Oo.copy p</TT> will behave as <TT>p#copy</TT> assuming that a public
method <TT>copy</TT> with body <TT>{&lt; &gt;}</TT> has been defined in the class of <TT>p</TT>.</P><P>Objects can be compared using the generic comparison functions <TT>=</TT> and <TT>&lt;&gt;</TT>.
Two objects are equal if and only if they are physically equal. In
particular, an object and its copy are not equal.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let q = Oo.copy p;;
<FONT COLOR=maroon>val q : point = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> p = q, p = p;;
</FONT><FONT COLOR=maroon>- : bool * bool = (false, true)
</FONT></PRE><P>
Other generic comparisons such as (<TT>&lt;</TT>, <TT>&lt;=</TT>, ...) can also be used on
objects. The
relation <TT>&lt;</TT> defines an unspecified but strict ordering on objets. The
ordering relationship between two objects is fixed once for all after the
two objects have been created and it is not affected by mutation of fields.</P><P>Cloning and override have a non empty intersection.
They are interchangeable when used within an object and without
overriding any field:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class copy =
    object
      method copy = {&lt; &gt;}
    end;;
<FONT COLOR=maroon>class copy : object ('a) method copy : 'a end

</FONT><FONT COLOR=black>#</FONT> class copy =
    object (self)
      method copy = Oo.copy self
    end;;
</FONT><FONT COLOR=maroon>class copy : object ('a) method copy : 'a end
</FONT></PRE><P>
Only the override can be used to actually override fields, and
only the <TT>Oo.copy</TT> primitive can be used externally.</P><P>Cloning can also be used to provide facilities for saving and
restoring the state of objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class backup =
    object (self : 'mytype)
      val mutable copy = None
      method save = copy &lt;- Some {&lt; copy = None &gt;}
      method restore = match copy with Some x -&gt; x | None -&gt; self
    end;;
</FONT><FONT COLOR=maroon>class backup :
  object ('a)
    val mutable copy : 'a option
    method restore : 'a
    method save : unit
  end
</FONT></PRE><P>
The above definition will only backup one level.
The backup facility can be added to any class by using multiple inheritance.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] backup_ref x = object inherit ['a] ref x inherit backup end;;
<FONT COLOR=maroon>class ['a] backup_ref :
  'a -&gt;
  object ('b)
    val mutable copy : 'b option
    val mutable x : 'a
    method get : 'a
    method restore : 'b
    method save : unit
    method set : 'a -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;
<FONT COLOR=maroon>val get : (&lt; get : 'b; restore : 'a; .. &gt; as 'a) -&gt; int -&gt; 'b = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let p = new backup_ref 0  in
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;
</FONT><FONT COLOR=maroon>- : int list = [2; 1; 1; 1; 1]
</FONT></PRE><P>
We can define a variant of backup that retains all copies. (We also
add a method <TT>clear</TT> to manually erase all copies.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class backup =
    object (self : 'mytype)
      val mutable copy = None
      method save = copy &lt;- Some {&lt; &gt;}
      method restore = match copy with Some x -&gt; x | None -&gt; self
      method clear = copy &lt;- None
    end;;
</FONT><FONT COLOR=maroon>class backup :
  object ('a)
    val mutable copy : 'a option
    method clear : unit
    method restore : 'a
    method save : unit
  end
</FONT></PRE><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] backup_ref x = object inherit ['a] ref x inherit backup end;;
<FONT COLOR=maroon>class ['a] backup_ref :
  'a -&gt;
  object ('b)
    val mutable copy : 'b option
    val mutable x : 'a
    method clear : unit
    method get : 'a
    method restore : 'b
    method save : unit
    method set : 'a -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> let p = new backup_ref 0  in
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;
</FONT><FONT COLOR=maroon>- : int list = [2; 1; 0; 0; 0]
</FONT></PRE><!--TOC section Recursive classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">3.15</A>&#XA0;&#XA0;Recursive classes</H2><!--SEC END --><P>

<A NAME="ss:recursive-classes"></A></P><P>Recursive classes can be used to define objects whose types are
mutually recursive.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class window =
    object
      val mutable top_widget = (None : widget option)
      method top_widget = top_widget
    end
  and widget (w : window) =
    object
      val window = w
      method window = window
    end;;
</FONT><FONT COLOR=maroon>class window :
  object
    val mutable top_widget : widget option
    method top_widget : widget option
  end
and widget : window -&gt; object val window : window method window : window end
</FONT></PRE><P>
Although their types are mutually recursive, the classes <TT>widget</TT> and
<TT>window</TT> are themselves independent.</P><!--TOC section Binary methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">3.16</A>&#XA0;&#XA0;Binary methods</H2><!--SEC END --><P>

<A NAME="ss:binary-methods"></A></P><P>A binary method is a method which takes an argument of the same type
as self. The class <TT>comparable</TT> below is a template for classes with a
binary method <TT>leq</TT> of type <TT>'a -&gt; bool</TT> where the type variable <TT>'a</TT>
is bound to the type of self. Therefore, <TT>#comparable</TT> expands to <TT>&lt; leq : 'a -&gt; bool; .. &gt; as 'a</TT>. We see here that the binder <TT>as</TT> also
allows writing recursive types.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class virtual comparable =
    object (_ : 'a)
      method virtual leq : 'a -&gt; bool
    end;;
</FONT><FONT COLOR=maroon>class virtual comparable : object ('a) method virtual leq : 'a -&gt; bool end
</FONT></PRE><P>
We then define a subclass <TT>money</TT> of <TT>comparable</TT>. The class <TT>money</TT>
simply wraps floats as comparable objects. We will extend it below with
more operations. We have to use a type constraint on the class parameter <TT>x</TT>
because the primitive <TT>&lt;=</TT> is a polymorphic function in
OCaml. The <TT>inherit</TT> clause ensures that the type of objects
of this class is an instance of <TT>#comparable</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class money (x : float) =
    object
      inherit comparable
      val repr = x
      method value = repr
      method leq p = repr &lt;= p#value
    end;;
</FONT><FONT COLOR=maroon>class money :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method value : float
  end
</FONT></PRE><P>
Note that the type <TT>money</TT> is not a subtype of type
<TT>comparable</TT>, as the self type appears in contravariant position
in the type of method <TT>leq</TT>.
Indeed, an object <TT>m</TT> of class <TT>money</TT> has a method <TT>leq</TT>
that expects an argument of type <TT>money</TT> since it accesses
its <TT>value</TT> method. Considering <TT>m</TT> of type <TT>comparable</TT> would allow a
call to method <TT>leq</TT> on <TT>m</TT> with an argument that does not have a method
<TT>value</TT>, which would be an error.</P><P>Similarly, the type <TT>money2</TT> below is not a subtype of type <TT>money</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class money2 x =
    object
      inherit money x
      method times k = {&lt; repr = k *. repr &gt;}
    end;;
</FONT><FONT COLOR=maroon>class money2 :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method times : float -&gt; 'a
    method value : float
  end
</FONT></PRE><P>
It is however possible to define functions that manipulate objects of
type either <TT>money</TT> or <TT>money2</TT>: the function <TT>min</TT>
will return the minimum of any two objects whose type unifies with
<TT>#comparable</TT>. The type of <TT>min</TT> is not the same as <TT>#comparable -&gt; #comparable -&gt; #comparable</TT>, as the abbreviation <TT>#comparable</TT> hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let min (x : #comparable) y =
    if x#leq y then x else y;;
</FONT><FONT COLOR=maroon>val min : (#comparable as 'a) -&gt; 'a -&gt; 'a = &lt;fun&gt;
</FONT></PRE><P>
This function can be applied to objects of type <TT>money</TT>
or <TT>money2</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> (min (new money  1.3) (new money 3.1))#value;;
<FONT COLOR=maroon>- : float = 1.3

</FONT><FONT COLOR=black>#</FONT> (min (new money2 5.0) (new money2 3.14))#value;;
</FONT><FONT COLOR=maroon>- : float = 3.14
</FONT></PRE><P>More examples of binary methods can be found in sections
<A HREF="#module:string">5.2.1</A> and <A HREF="#module:set">5.2.3</A>.</P><P>Note the use of override for method <TT>times</TT>.
Writing <TT>new money2 (k *. repr)</TT> instead of <TT>{&lt; repr = k *. repr &gt;}</TT>
would not behave well with inheritance: in a subclass <TT>money3</TT> of <TT>money2</TT>
the <TT>times</TT> method would return an object of class <TT>money2</TT> but not of class
<TT>money3</TT> as would be expected.</P><P>The class <TT>money</TT> could naturally carry another binary method. Here is a
direct definition:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class money x =
    object (self : 'a)
      val repr = x
      method value = repr
      method print = print_float repr
      method times k = {&lt; repr = k *. x &gt;}
      method leq (p : 'a) = repr &lt;= p#value
      method plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
    end;;
</FONT><FONT COLOR=maroon>class money :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method plus : 'a -&gt; 'a
    method print : unit
    method times : float -&gt; 'a
    method value : float
  end
</FONT></PRE><!--TOC section Friends-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">3.17</A>&#XA0;&#XA0;Friends</H2><!--SEC END --><P>

<A NAME="ss:friends"></A></P><P>The above class <TT>money</TT> reveals a problem that often occurs with binary
methods. In order to interact with other objects of the same class, the
representation of <TT>money</TT> objects must be revealed, using a method such as
<TT>value</TT>. If we remove all binary methods (here <TT>plus</TT> and <TT>leq</TT>),
the representation can easily be hidden inside objects by removing the method
<TT>value</TT> as well. However, this is not possible as soon as some binary
method requires access to the representation of objects of the same
class (other than self).
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class safe_money x =
    object (self : 'a)
      val repr = x
      method print = print_float repr
      method times k = {&lt; repr = k *. x &gt;}
    end;;
</FONT><FONT COLOR=maroon>class safe_money :
  float -&gt;
  object ('a)
    val repr : float
    method print : unit
    method times : float -&gt; 'a
  end
</FONT></PRE><P>
Here, the representation of the object is known only to a particular object.
To make it available to other objects of the same class, we are forced to
make it available to the whole world. However we can easily restrict the
visibility of the representation using the module system.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type MONEY =
    sig
      type t
      class c : float -&gt;
        object ('a)
          val repr : t
          method value : t
          method print : unit
          method times : float -&gt; 'a
          method leq : 'a -&gt; bool
          method plus : 'a -&gt; 'a
        end
    end;;

  module Euro : MONEY =
    struct
      type t = float
      class c x =
        object (self : 'a)
          val repr = x
          method value = repr
          method print = print_float repr
          method times k = {&lt; repr = k *. x &gt;}
          method leq (p : 'a) = repr &lt;= p#value
          method plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
        end
    end;;
</FONT></PRE><P>
Another example of friend functions may be found in section
<A HREF="#module:set">5.2.3</A>. These examples occur when a group of objects (here
objects of the same class) and functions should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside the module.</P><!--TOC chapter Labels and variants-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc36">Chapter&#XA0;4</A>&#XA0;&#XA0;Labels and variants</H1><!--SEC END --><P> <A NAME="c:labl-examples"></A>
</P><P><I>(Chapter written by Jacques Garrigue)</I></P><P><BR>
<BR>
</P><P>This chapter gives an overview of the new features in
OCaml 3: labels, and polymorphic variants.</P><!--TOC section Labels-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">4.1</A>&#XA0;&#XA0;Labels</H2><!--SEC END --><P>If you have a look at modules ending in <TT>Labels</TT> in the standard
library, you will see that function types have annotations you did not
have in the functions you defined yourself.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> ListLabels.map;;
<FONT COLOR=maroon>- : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> StringLabels.sub;;
</FONT><FONT COLOR=maroon>- : string -&gt; pos:int -&gt; len:int -&gt; string = &lt;fun&gt;
</FONT></PRE><P>Such annotations of the form <TT>name:</TT> are called <EM>labels</EM>. They are
meant to document the code, allow more checking, and give more
flexibility to function application.
You can give such names to arguments in your programs, by prefixing them
with a tilde <TT>~</TT>.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f ~x ~y = x - y;;
<FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let x = 3 and y = 2 in f ~x ~y;;
</FONT><FONT COLOR=maroon>- : int = 1
</FONT></PRE><P>When you want to use distinct names for the variable and the label
appearing in the type, you can use a naming label of the form
<TT>~name:</TT>. This also applies when the argument is not a variable.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f ~x:x1 ~y:y1 = x1 - y1;;
<FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> f ~x:3 ~y:2;;
</FONT><FONT COLOR=maroon>- : int = 1
</FONT></PRE><P>Labels obey the same rules as other identifiers in OCaml, that is you
cannot use a reserved keyword (like <TT>in</TT> or <TT>to</TT>) as label.</P><P>Formal parameters and arguments are matched according to their
respective labels<SUP><A NAME="text1" HREF="#note1">1</A></SUP>, the absence of label
being interpreted as the empty label.
This allows commuting arguments in applications. One can also
partially apply a function on any argument, creating a new function of
the remaining parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f ~x ~y = x - y;;
<FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> f ~y:2 ~x:3;;
<FONT COLOR=maroon>- : int = 1

</FONT><FONT COLOR=black>#</FONT> ListLabels.fold_left;;
<FONT COLOR=maroon>- : f:('a -&gt; 'b -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> ListLabels.fold_left [1;2;3] ~init:0 ~f:(+);;
<FONT COLOR=maroon>- : int = 6

</FONT><FONT COLOR=black>#</FONT> ListLabels.fold_left ~init:0;;
</FONT><FONT COLOR=maroon>- : f:(int -&gt; 'a -&gt; int) -&gt; 'a list -&gt; int = &lt;fun&gt;
</FONT></PRE><P>If several arguments of a function bear the same label (or no label),
they will not commute among themselves, and order matters. But they
can still commute with other arguments.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let hline ~x:x1 ~x:x2 ~y = (x1, x2, y);;
<FONT COLOR=maroon>val hline : x:'a -&gt; x:'b -&gt; y:'c -&gt; 'a * 'b * 'c = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> hline ~x:3 ~y:2 ~x:5;;
</FONT><FONT COLOR=maroon>- : int * int * int = (3, 5, 2)
</FONT></PRE><P>As an exception to the above parameter matching rules, if an
application is total (omitting all optional arguments), labels may be
omitted.
In practice, many applications are total, so that labels can often be
omitted.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> f 3 2;;
<FONT COLOR=maroon>- : int = 1

</FONT><FONT COLOR=black>#</FONT> ListLabels.map succ [1;2;3];;
</FONT><FONT COLOR=maroon>- : int list = [2; 3; 4]
</FONT></PRE><P>
But beware that functions like <TT>ListLabels.fold_left</TT> whose result
type is a type variable will never be considered as totally applied.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> ListLabels.fold_left <U>(+)</U> 0 [1;2;3];;
</FONT><FONT COLOR=maroon>Error: This expression has type int -&gt; int -&gt; int
       but an expression was expected of type 'a list
</FONT></PRE><P>When a function is passed as an argument to a higher-order function,
labels must match in both types. Neither adding nor removing labels
are allowed.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let h g = g ~x:3 ~y:2;;
<FONT COLOR=maroon>val h : (x:int -&gt; y:int -&gt; 'a) -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> h f;;
<FONT COLOR=maroon>- : int = 1

</FONT><FONT COLOR=black>#</FONT> h <U>(+)</U>;;
</FONT><FONT COLOR=maroon>Error: This expression has type int -&gt; int -&gt; int
       but an expression was expected of type x:int -&gt; y:int -&gt; 'a
</FONT></PRE><P>
Note that when you don&#X2019;t need an argument, you can still use a wildcard
pattern, but you must prefix it with the label.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> h (fun ~x:_ ~y -&gt; y+1);;
</FONT><FONT COLOR=maroon>- : int = 3
</FONT></PRE><!--TOC subsection Optional arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">4.1.1</A>&#XA0;&#XA0;Optional arguments</H3><!--SEC END --><P>An interesting feature of labeled arguments is that they can be made
optional. For optional parameters, the question mark <TT>?</TT> replaces the
tilde <TT>~</TT> of non-optional ones, and the label is also prefixed by <TT>?</TT>
in the function type.
Default values may be given for such optional parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let bump ?(step = 1) x = x + step;;
<FONT COLOR=maroon>val bump : ?step:int -&gt; int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> bump 2;;
<FONT COLOR=maroon>- : int = 3

</FONT><FONT COLOR=black>#</FONT> bump ~step:3 2;;
</FONT><FONT COLOR=maroon>- : int = 5
</FONT></PRE><P>A function taking some optional arguments must also take at least one
non-optional argument. The criterion for deciding whether an optional
argument has been omitted is the non-labeled application of an
argument appearing after this optional argument in the function type.
Note that if that argument is labeled, you will only be able to
eliminate optional arguments through the special case for total
applications.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let test ?(x = 0) ?(y = 0) () ?(z = 0) () = (x, y, z);;
<FONT COLOR=maroon>val test : ?x:int -&gt; ?y:int -&gt; unit -&gt; ?z:int -&gt; unit -&gt; int * int * int =
  &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> test ();;
<FONT COLOR=maroon>- : ?z:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> test ~x:2 () ~z:3 ();;
</FONT><FONT COLOR=maroon>- : int * int * int = (2, 0, 3)
</FONT></PRE><P>Optional parameters may also commute with non-optional or unlabeled
ones, as long as they are applied simultaneously. By nature, optional
arguments do not commute with unlabeled arguments applied
independently.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> test ~y:2 ~x:3 () ();;
<FONT COLOR=maroon>- : int * int * int = (3, 2, 0)

</FONT><FONT COLOR=black>#</FONT> test () () ~z:1 ~y:2 ~x:3;;
<FONT COLOR=maroon>- : int * int * int = (3, 2, 1)

</FONT><FONT COLOR=black>#</FONT> <U>(test () ())</U> ~z:1;;
</FONT><FONT COLOR=maroon>Error: This expression is not a function; it cannot be applied
</FONT></PRE><P>
Here <TT>(test () ())</TT> is already <TT>(0,0,0)</TT> and cannot be further
applied.</P><P>Optional arguments are actually implemented as option types. If
you do not give a default value, you have access to their internal
representation, <TT>type 'a option = None | Some of 'a</TT>. You can then
provide different behaviors when an argument is present or not.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let bump ?step x =
    match step with
    | None -&gt; x * 2
    | Some y -&gt; x + y
  ;;
</FONT><FONT COLOR=maroon>val bump : ?step:int -&gt; int -&gt; int = &lt;fun&gt;
</FONT></PRE><P>It may also be useful to relay an optional argument from a function
call to another. This can be done by prefixing the applied argument
with <TT>?</TT>. This question mark disables the wrapping of optional
argument in an option type.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let test2 ?x ?y () = test ?x ?y () ();;
<FONT COLOR=maroon>val test2 : ?x:int -&gt; ?y:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> test2 ?x:None;;
</FONT><FONT COLOR=maroon>- : ?y:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Labels and type inference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">4.1.2</A>&#XA0;&#XA0;Labels and type inference</H3><!--SEC END --><P>
<A NAME="ss:label-inference"></A></P><P>While they provide an increased comfort for writing function
applications, labels and optional arguments have the pitfall that they
cannot be inferred as completely as the rest of the language.</P><P>You can see it in the following two examples.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let h' g = g ~y:2 ~x:3;;
<FONT COLOR=maroon>val h' : (y:int -&gt; x:int -&gt; 'a) -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> h' <U>f</U>;;
<FONT COLOR=maroon>Error: This expression has type x:int -&gt; y:int -&gt; int
       but an expression was expected of type y:int -&gt; x:int -&gt; 'a

</FONT><FONT COLOR=black>#</FONT> let bump_it bump x =
    bump ~step:2 x;;
<FONT COLOR=maroon>val bump_it : (step:int -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> bump_it <U>bump</U> 1;;
</FONT><FONT COLOR=maroon>Error: This expression has type ?step:int -&gt; int -&gt; int
       but an expression was expected of type step:int -&gt; 'a -&gt; 'b
</FONT></PRE><P>
The first case is simple: <TT>g</TT> is passed <TT>~y</TT> and then <TT>~x</TT>, but <TT>f</TT>
expects <TT>~x</TT> and then <TT>~y</TT>. This is correctly handled if we know the
type of <TT>g</TT> to be <TT>x:int -&gt; y:int -&gt; int</TT> in advance, but otherwise
this causes the above type clash. The simplest workaround is to apply
formal parameters in a standard order.</P><P>The second example is more subtle: while we intended the argument
<TT>bump</TT> to be of type <TT>?step:int -&gt; int -&gt; int</TT>, it is inferred as
<TT>step:int -&gt; int -&gt; 'a</TT>.
These two types being incompatible (internally normal and optional
arguments are different), a type error occurs when applying <TT>bump_it</TT>
to the real <TT>bump</TT>.</P><P>We will not try here to explain in detail how type inference works.
One must just understand that there is not enough information in the
above program to deduce the correct type of <TT>g</TT> or <TT>bump</TT>. That is,
there is no way to know whether an argument is optional or not, or
which is the correct order, by looking only at how a function is
applied. The strategy used by the compiler is to assume that there are
no optional arguments, and that applications are done in the right
order.</P><P>The right way to solve this problem for optional parameters is to add
a type annotation to the argument <TT>bump</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let bump_it (bump : ?step:int -&gt; int -&gt; int) x =
    bump ~step:2 x;;
<FONT COLOR=maroon>val bump_it : (?step:int -&gt; int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> bump_it bump 1;;
</FONT><FONT COLOR=maroon>- : int = 3
</FONT></PRE><P>
In practice, such problems appear mostly when using objects whose
methods have optional arguments, so that writing the type of object
arguments is often a good idea.</P><P>Normally the compiler generates a type error if you attempt to pass to
a function a parameter whose type is different from the expected one.
However, in the specific case where the expected type is a non-labeled
function type, and the argument is a function expecting optional
parameters, the compiler will attempt to transform the argument to
have it match the expected type, by passing <TT>None</TT> for all optional
parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let twice f (x : int) = f(f x);;
<FONT COLOR=maroon>val twice : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> twice bump 2;;
</FONT><FONT COLOR=maroon>- : int = 8
</FONT></PRE><P>This transformation is coherent with the intended semantics,
including side-effects. That is, if the application of optional
parameters shall produce side-effects, these are delayed until the
received function is really applied to an argument.</P><!--TOC subsection Suggestions for labeling-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.1.3</A>&#XA0;&#XA0;Suggestions for labeling</H3><!--SEC END --><P>Like for names, choosing labels for functions is not an easy task. A
good labeling is a labeling which</P><UL CLASS="itemize"><LI CLASS="li-itemize">
makes programs more readable,
</LI><LI CLASS="li-itemize">is easy to remember,
</LI><LI CLASS="li-itemize">when possible, allows useful partial applications.
</LI></UL><P>We explain here the rules we applied when labeling OCaml
libraries.</P><P>To speak in an &#X201C;object-oriented&#X201D; way, one can consider that each
function has a main argument, its <EM>object</EM>, and other arguments
related with its action, the <EM>parameters</EM>. To permit the
combination of functions through functionals in commuting label mode, the
object will not be labeled. Its role is clear from the function
itself. The parameters are labeled with names reminding of
their nature or their role. The best labels combine nature and
role. When this is not possible the role is to be preferred, since the
nature will
often be given by the type itself. Obscure abbreviations should be
avoided.
</P><PRE>
<TT>ListLabels.map : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</TT>
UnixLabels.write : file_descr -&gt; buf:string -&gt; pos:int -&gt; len:int -&gt; unit
</PRE><P>When there are several objects of same nature and role, they are all
left unlabeled.
</P><PRE>
<TT>ListLabels.iter2 : f:('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; unit</TT>
</PRE><P>When there is no preferable object, all arguments are labeled.
</P><PRE>
StringLabels.blit :
  src:string -&gt; src_pos:int -&gt; dst:string -&gt; dst_pos:int -&gt; len:int -&gt; unit
</PRE><P>However, when there is only one argument, it is often left unlabeled.
</P><PRE>
StringLabels.create : int -&gt; string
</PRE><P>
This principle also applies to functions of several arguments whose
return type is a type variable, as long as the role of each argument
is not ambiguous. Labeling such functions may lead to awkward error
messages when one attempts to omit labels in an application, as we
have seen with <TT>ListLabels.fold_left</TT>.</P><P>Here are some of the label names you will find throughout the
libraries.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Label</B></TD><TD ALIGN=center NOWRAP><B>Meaning</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>f:</TT></TD><TD ALIGN=left NOWRAP>a function to be applied</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>pos:</TT></TD><TD ALIGN=left NOWRAP>a position in a string or array</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>len:</TT></TD><TD ALIGN=left NOWRAP>a length</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>buf:</TT></TD><TD ALIGN=left NOWRAP>a string used as buffer</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>src:</TT></TD><TD ALIGN=left NOWRAP>the source of an operation</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>dst:</TT></TD><TD ALIGN=left NOWRAP>the destination of an operation</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>init:</TT></TD><TD ALIGN=left NOWRAP>the initial value for an iterator</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>cmp:</TT></TD><TD ALIGN=left NOWRAP>a comparison function, <I>e.g.</I> <TT>Pervasives.compare</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>mode:</TT></TD><TD ALIGN=left NOWRAP>an operation mode or a flag list</TD></TR>
</TABLE></DIV><P>All these are only suggestions, but keep in mind that the
choice of labels is essential for readability. Bizarre choices will
make the program harder to maintain.</P><P>In the ideal, the right function name with right labels sould be
enough to understand the function&#X2019;s meaning. Since one can get this
information with OCamlBrowser or the <TT>ocaml</TT> toplevel, the documentation
is only used when a more detailed specification is needed.</P><!--TOC section Polymorphic variants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">4.2</A>&#XA0;&#XA0;Polymorphic variants</H2><!--SEC END --><P>Variants as presented in section&#XA0;<A HREF="#s:tut-recvariants">1.4</A> are a
powerful tool to build data structures and algorithms. However they
sometimes lack flexibility when used in modular programming. This is
due to the fact every constructor reserves a name to be used with a
unique type. One cannot use the same name in another type, or consider
a value of some type to belong to some other type with more
constructors.</P><P>With polymorphic variants, this original assumption is removed. That
is, a variant tag does not belong to any type in particular, the type
system will just check that it is an admissible value according to its
use. You need not define a type before using a variant tag. A variant
type will be inferred independently for each of its uses.</P><!--TOC subsection Basic use-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Basic use</H3><!--SEC END --><P>In programs, polymorphic variants work like usual ones. You just have
to prefix their names with a backquote character <TT>`</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> [`On; `Off];;
<FONT COLOR=maroon>- : [&gt; `Off | `On ] list = [`On; `Off]

</FONT><FONT COLOR=black>#</FONT> `Number 1;;
<FONT COLOR=maroon>- : [&gt; `Number of int ] = `Number 1

</FONT><FONT COLOR=black>#</FONT> let f = function `On -&gt; 1 | `Off -&gt; 0 | `Number n -&gt; n;;
<FONT COLOR=maroon>val f : [&lt; `Number of int | `Off | `On ] -&gt; int = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> List.map f [`On; `Off];;
</FONT><FONT COLOR=maroon>- : int list = [1; 0]
</FONT></PRE><P>
<TT>[&gt;`Off|`On] list</TT> means that to match this list, you should at
least be able to match <TT>`Off</TT> and <TT>`On</TT>, without argument.
<TT>[&lt;`On|`Off|`Number of int]</TT> means that <TT>f</TT> may be applied to <TT>`Off</TT>,
<TT>`On</TT> (both without argument), or <TT>`Number</TT> <I>n</I> where
<I>n</I> is an integer.
The <TT>&gt;</TT> and <TT>&lt;</TT> inside the variant types show that they may still be
refined, either by defining more tags or by allowing less. As such, they
contain an implicit type variable. Because each of the variant types
appears only once in the whole type, their implicit type variables are
not shown.</P><P>The above variant types were polymorphic, allowing further refinement.
When writing type annotations, one will most often describe fixed
variant types, that is types that cannot be refined. This is
also the case for type abbreviations. Such types do not contain <TT>&lt;</TT> or
<TT>&gt;</TT>, but just an enumeration of the tags and their associated types,
just like in a normal datatype definition.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a vlist = [`Nil | `Cons of 'a * 'a vlist];;
<FONT COLOR=maroon>type 'a vlist = [ `Cons of 'a * 'a vlist | `Nil ]

</FONT><FONT COLOR=black>#</FONT> let rec map f : 'a vlist -&gt; 'b vlist = function
    | `Nil -&gt; `Nil
    | `Cons(a, l) -&gt; `Cons(f a, map f l)
  ;;
</FONT><FONT COLOR=maroon>val map : ('a -&gt; 'b) -&gt; 'a vlist -&gt; 'b vlist = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Advanced use-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Advanced use</H3><!--SEC END --><P>Type-checking polymorphic variants is a subtle thing, and some
expressions may result in more complex type information.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f = function `A -&gt; `C | `B -&gt; `D | x -&gt; x;;
<FONT COLOR=maroon>val f : ([&gt; `A | `B | `C | `D ] as 'a) -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> f `E;;
</FONT><FONT COLOR=maroon>- : [&gt; `A | `B | `C | `D | `E ] = `E
</FONT></PRE><P>
Here we are seeing two phenomena. First, since this matching is open
(the last case catches any tag), we obtain the type <TT>[&gt; `A | `B]</TT>
rather than <TT>[&lt; `A | `B]</TT> in a closed matching. Then, since <TT>x</TT> is
returned as is, input and return types are identical. The notation <TT>as 'a</TT> denotes such type sharing. If we apply <TT>f</TT> to yet another tag
<TT>`E</TT>, it gets added to the list.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f1 = function `A x -&gt; x = 1 | `B -&gt; true | `C -&gt; false
  let f2 = function `A x -&gt; x = "a" | `B -&gt; true ;;
<FONT COLOR=maroon>val f1 : [&lt; `A of int | `B | `C ] -&gt; bool = &lt;fun&gt;
val f2 : [&lt; `A of string | `B ] -&gt; bool = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let f x = f1 x &amp;&amp; f2 x;;
</FONT><FONT COLOR=maroon>val f : [&lt; `A of string &amp; int | `B ] -&gt; bool = &lt;fun&gt;
</FONT></PRE><P>
Here <TT>f1</TT> and <TT>f2</TT> both accept the variant tags <TT>`A</TT> and <TT>`B</TT>, but the
argument of <TT>`A</TT> is <TT>int</TT> for <TT>f1</TT> and <TT>string</TT> for <TT>f2</TT>. In <TT>f</TT>&#X2019;s
type <TT>`C</TT>, only accepted by <TT>f1</TT>, disappears, but both argument types
appear for <TT>`A</TT> as <TT>int &amp; string</TT>. This means that if we
pass the variant tag <TT>`A</TT> to <TT>f</TT>, its argument should be <EM>both</EM>
<TT>int</TT> and <TT>string</TT>. Since there is no such value, <TT>f</TT> cannot be
applied to <TT>`A</TT>, and <TT>`B</TT> is the only accepted input.</P><P>Even if a value has a fixed variant type, one can still give it a
larger type through coercions. Coercions are normally written with
both the source type and the destination type, but in simple cases the
source type may be omitted.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a wlist = [`Nil | `Cons of 'a * 'a wlist | `Snoc of 'a wlist * 'a];;
<FONT COLOR=maroon>type 'a wlist = [ `Cons of 'a * 'a wlist | `Nil | `Snoc of 'a wlist * 'a ]

</FONT><FONT COLOR=black>#</FONT> let wlist_of_vlist  l = (l : 'a vlist :&gt; 'a wlist);;
<FONT COLOR=maroon>val wlist_of_vlist : 'a vlist -&gt; 'a wlist = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let open_vlist l = (l : 'a vlist :&gt; [&gt; 'a vlist]);;
<FONT COLOR=maroon>val open_vlist : 'a vlist -&gt; [&gt; 'a vlist ] = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> fun x -&gt; (x :&gt; [`A|`B|`C]);;
</FONT><FONT COLOR=maroon>- : [&lt; `A | `B | `C ] -&gt; [ `A | `B | `C ] = &lt;fun&gt;
</FONT></PRE><P>You may also selectively coerce values through pattern matching.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let split_cases = function
    | `Nil | `Cons _ as x -&gt; `A x
    | `Snoc _ as x -&gt; `B x
  ;;
</FONT><FONT COLOR=maroon>val split_cases :
  [&lt; `Cons of 'a | `Nil | `Snoc of 'b ] -&gt;
  [&gt; `A of [&gt; `Cons of 'a | `Nil ] | `B of [&gt; `Snoc of 'b ] ] = &lt;fun&gt;
</FONT></PRE><P>
When an or-pattern composed of variant tags is wrapped inside an
alias-pattern, the alias is given a type containing only the tags
enumerated in the or-pattern. This allows for many useful idioms, like
incremental definition of functions.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let num x = `Num x
  let eval1 eval (`Num x) = x
  let rec eval x = eval1 eval x ;;
<FONT COLOR=maroon>val num : 'a -&gt; [&gt; `Num of 'a ] = &lt;fun&gt;
val eval1 : 'a -&gt; [&lt; `Num of 'b ] -&gt; 'b = &lt;fun&gt;
val eval : [&lt; `Num of 'a ] -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let plus x y = `Plus(x,y)
  let eval2 eval = function
    | `Plus(x,y) -&gt; eval x + eval y
    | `Num _ as x -&gt; eval1 eval x
  let rec eval x = eval2 eval x ;;
</FONT><FONT COLOR=maroon>val plus : 'a -&gt; 'b -&gt; [&gt; `Plus of 'a * 'b ] = &lt;fun&gt;
val eval2 : ('a -&gt; int) -&gt; [&lt; `Num of int | `Plus of 'a * 'a ] -&gt; int = &lt;fun&gt;
val eval : ([&lt; `Num of int | `Plus of 'a * 'a ] as 'a) -&gt; int = &lt;fun&gt;
</FONT></PRE><P>To make this even more comfortable, you may use type definitions as
abbreviations for or-patterns. That is, if you have defined <TT>type myvariant = [`Tag1 int | `Tag2 bool]</TT>, then the pattern <TT>#myvariant</TT> is
equivalent to writing <TT>(`Tag1(_ : int) | `Tag2(_ : bool))</TT>.</P><P>Such abbreviations may be used alone,
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f = function
    | #myvariant -&gt; "myvariant"
    | `Tag3 -&gt; "Tag3";;
</FONT><FONT COLOR=maroon>val f : [&lt; `Tag1 of int | `Tag2 of bool | `Tag3 ] -&gt; string = &lt;fun&gt;
</FONT></PRE><P>
or combined with with aliases.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let g1 = function `Tag1 _ -&gt; "Tag1" | `Tag2 _ -&gt; "Tag2";;
<FONT COLOR=maroon>val g1 : [&lt; `Tag1 of 'a | `Tag2 of 'b ] -&gt; string = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let g = function
    | #myvariant as x -&gt; g1 x
    | `Tag3 -&gt; "Tag3";;
</FONT><FONT COLOR=maroon>val g : [&lt; `Tag1 of int | `Tag2 of bool | `Tag3 ] -&gt; string = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Weaknesses of polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.2.1</A>&#XA0;&#XA0;Weaknesses of polymorphic variants</H3><!--SEC END --><P>After seeing the power of polymorphic variants, one may wonder why
they were added to core language variants, rather than replacing them.</P><P>The answer is twofold. One first aspect is that while being pretty
efficient, the lack of static type information allows for less
optimizations, and makes polymorphic variants slightly heavier than
core language ones. However noticeable differences would only
appear on huge data structures.</P><P>More important is the fact that polymorphic variants, while being
type-safe, result in a weaker type discipline. That is, core language
variants do actually much more than ensuring type-safety, they also
check that you use only declared constructors, that all constructors
present in a data-structure are compatible, and they enforce typing
constraints to their parameters.</P><P>For this reason, you must be more careful about making types explicit
when you use polymorphic variants. When you write a library, this is
easy since you can describe exact types in interfaces, but for simple
programs you are probably better off with core language variants.</P><P>Beware also that some idioms make trivial errors very hard to find.
For instance, the following code is probably wrong but the compiler
has no way to see it.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type abc = [`A | `B | `C] ;;
<FONT COLOR=maroon>type abc = [ `A | `B | `C ]

</FONT><FONT COLOR=black>#</FONT> let f = function
    | `As -&gt; "A"
    | #abc -&gt; "other" ;;
<FONT COLOR=maroon>val f : [&lt; `A | `As | `B | `C ] -&gt; string = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let f : abc -&gt; string = f ;;
</FONT><FONT COLOR=maroon>val f : abc -&gt; string = &lt;fun&gt;
</FONT></PRE><P>
You can avoid such risks by annotating the definition itself.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let f : abc -&gt; string = function
    | <U>`As</U> -&gt; "A"
    | #abc -&gt; "other" ;;
</FONT><FONT COLOR=maroon>Warning 11: this match case is unused.
val f : abc -&gt; string = &lt;fun&gt;
</FONT></PRE><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">This correspond to the commuting label mode
of Objective Caml 3.00 through 3.02, with some additional flexibility
on total applications. The so-called classic mode (<TT>-nolabels</TT>
options) is now deprecated for normal use.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Advanced examples with classes and modules-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc43">Chapter&#XA0;5</A>&#XA0;&#XA0;Advanced examples with classes and modules</H1><!--SEC END --><P>

<A NAME="c:advexamples"></A></P><P><I>(Chapter written by Didier R&#XE9;my)</I></P><P><BR>
<BR>
</P><P>In this chapter, we show some larger examples using objects, classes
and modules. We review many of the object features simultaneously on
the example of a bank account. We show how modules taken from the
standard library can be expressed as classes. Lastly, we describe a
programming pattern know of as <EM>virtual types</EM> through the example
of window managers.</P><!--TOC section Extended example: bank accounts-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">5.1</A>&#XA0;&#XA0;Extended example: bank accounts</H2><!--SEC END --><P>

<A NAME="ss:bank-accounts"></A></P><P>In this section, we illustrate most aspects of Object and inheritance
by refining, debugging, and specializing the following
initial naive definition of a simple bank account. (We reuse the
module <TT>Euro</TT> defined at the end of chapter&#XA0;<A HREF="#c:objectexamples">3</A>.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let euro = new Euro.c;;
<FONT COLOR=maroon>val euro : float -&gt; Euro.c = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let zero = euro 0.;;
<FONT COLOR=maroon>val zero : Euro.c = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> let neg x = x#times (-1.);;
<FONT COLOR=maroon>val neg : &lt; times : float -&gt; 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> class account =
    object
      val mutable balance = zero
      method balance = balance
      method deposit x = balance &lt;- balance # plus x
      method withdraw x =
        if x#leq balance then (balance &lt;- balance # plus (neg x); x) else zero
    end;;
<FONT COLOR=maroon>class account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end

</FONT><FONT COLOR=black>#</FONT> let c = new account in c # deposit (euro 100.); c # withdraw (euro 50.);;
</FONT><FONT COLOR=maroon>- : Euro.c = &lt;obj&gt;
</FONT></PRE><P>
We now refine this definition with a method to compute interest.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class account_with_interests =
    object (self)
      inherit account
      method private interest = self # deposit (self # balance # times 0.03)
    end;;
</FONT><FONT COLOR=maroon>class account_with_interests :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method private interest : unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
We make the method <TT>interest</TT> private, since clearly it should not be
called freely from the outside. Here, it is only made accessible to subclasses
that will manage monthly or yearly updates of the account.</P><P>We should soon fix a bug in the current definition: the deposit method can
be used for withdrawing money by depositing negative amounts. We can
fix this directly:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class safe_account =
    object
      inherit account
      method deposit x = if zero#leq x then balance &lt;- balance#plus x
    end;;
</FONT><FONT COLOR=maroon>class safe_account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
However, the bug might be fixed more safely by the following definition:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class safe_account =
    object
      inherit account as unsafe
      method deposit x =
        if zero#leq x then unsafe # deposit x
        else raise (Invalid_argument "deposit")
    end;;
</FONT><FONT COLOR=maroon>class safe_account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
In particular, this does not require the knowledge of the implementation of
the method <TT>deposit</TT>.</P><P>To keep track of operations, we extend the class with a mutable field
<TT>history</TT> and a private method <TT>trace</TT> to add an operation in the
log. Then each method to be traced is redefined.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type 'a operation = Deposit of 'a | Retrieval of 'a;;
<FONT COLOR=maroon>type 'a operation = Deposit of 'a | Retrieval of 'a

</FONT><FONT COLOR=black>#</FONT> class account_with_history =
    object (self)
      inherit safe_account as super
      val mutable history = []
      method private trace x = history &lt;- x :: history
      method deposit x = self#trace (Deposit x);  super#deposit x
      method withdraw x = self#trace (Retrieval x); super#withdraw x
      method history = List.rev history
    end;;
</FONT><FONT COLOR=maroon>class account_with_history :
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
One may wish to open an account and simultaneously deposit some initial
amount. Although the initial implementation did not address this
requirement, it can be achieved by using an initializer.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class account_with_deposit x =
    object
      inherit account_with_history
      initializer balance &lt;- x
    end;;
</FONT><FONT COLOR=maroon>class account_with_deposit :
  Euro.c -&gt;
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
A better alternative is:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class account_with_deposit x =
    object (self)
      inherit account_with_history
      initializer self#deposit x
    end;;
</FONT><FONT COLOR=maroon>class account_with_deposit :
  Euro.c -&gt;
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
Indeed, the latter is safer since the call to <TT>deposit</TT> will automatically
benefit from safety checks and from the trace.
Let&#X2019;s test it:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let ccp = new account_with_deposit (euro 100.) in
  let _balance = ccp#withdraw (euro 50.) in
  ccp#history;;
</FONT><FONT COLOR=maroon>- : Euro.c operation list = [Deposit &lt;obj&gt;; Retrieval &lt;obj&gt;]
</FONT></PRE><P>
Closing an account can be done with the following polymorphic function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let close c = c#withdraw (c#balance);;
</FONT><FONT COLOR=maroon>val close : &lt; balance : 'a; withdraw : 'a -&gt; 'b; .. &gt; -&gt; 'b = &lt;fun&gt;
</FONT></PRE><P>
Of course, this applies to all sorts of accounts.</P><P>Finally, we gather several versions of the account into a module <TT>Account</TT>
abstracted over some currency.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let today () = (01,01,2000) (* an approximation *)
  module Account (M:MONEY) =
    struct
      type m = M.c
      let m = new M.c
      let zero = m 0.

      class bank =
        object (self)
          val mutable balance = zero
          method balance = balance
          val mutable history = []
          method private trace x = history &lt;- x::history
          method deposit x =
            self#trace (Deposit x);
            if zero#leq x then balance &lt;- balance # plus x
            else raise (Invalid_argument "deposit")
          method withdraw x =
            if x#leq balance then
              (balance &lt;- balance # plus (neg x); self#trace (Retrieval x); x)
            else zero
          method history = List.rev history
        end

      class type client_view =
        object
          method deposit : m -&gt; unit
          method history : m operation list
          method withdraw : m -&gt; m
          method balance : m
        end

      class virtual check_client x =
        let y = if (m 100.)#leq x then x
        else raise (Failure "Insufficient initial deposit") in
        object (self) initializer <U>self#deposit</U> y end

      module Client (B : sig class bank : client_view end) =
        struct
          class account x : client_view =
            object
              inherit B.bank
              inherit check_client x
            end

          let discount x =
            let c = new account x in
            if today() &lt; (1998,10,30) then c # deposit (m 100.); c
        end
    end;;
</FONT></PRE><P>
This shows the use of modules to group several class definitions that can in
fact be thought of as a single unit. This unit would be provided by a bank
for both internal and external uses.
This is implemented as a functor that abstracts over the currency so that
the same code can be used to provide accounts in different currencies.</P><P>The class <TT>bank</TT> is the <EM>real</EM> implementation of the bank account (it
could have been inlined). This is the one that will be used for further
extensions, refinements, etc. Conversely, the client will only be given the client view.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module Euro_account = Account(Euro);;

  module Client = Euro_account.Client (Euro_account);;

  new Client.account (new Euro.c 100.);;
</FONT></PRE><P>
Hence, the clients do not have direct access to the <TT>balance</TT>, nor the
<TT>history</TT> of their own accounts. Their only way to change their balance is
to deposit or withdraw money. It is important to give the clients
a class and not just the ability to create accounts (such as the
promotional <TT>discount</TT> account), so that they can
personalize their account.
For instance, a client may refine the <TT>deposit</TT> and <TT>withdraw</TT> methods
so as to do his own financial bookkeeping, automatically. On the
other hand, the function <TT>discount</TT> is given as such, with no
possibility for further personalization.</P><P>It is important to provide the client&#X2019;s view as a functor
<TT>Client</TT> so that client accounts can still be built after a possible
specialization of the <TT>bank</TT>.
The functor <TT>Client</TT> may remain unchanged and be passed
the new definition to initialize a client&#X2019;s view of the extended account.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module Investment_account (M : MONEY) =
    struct
      type m = M.c
      module A = Account(M)

      class bank =
        object
          inherit A.bank as super
          method deposit x =
            if (new M.c 1000.)#leq x then
              print_string "Would you like to invest?";
            super#deposit x
        end

      module Client = A.Client
    end;;
</FONT></PRE><P>
The functor <TT>Client</TT> may also be redefined when some new features of the
account can be given to the client.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module Internet_account (M : MONEY) =
    struct
      type m = M.c
      module A = Account(M)

      class bank =
        object
          inherit A.bank
          method mail s = print_string s
        end

      class type client_view =
        object
          method deposit : m -&gt; unit
          method history : m operation list
          method withdraw : m -&gt; m
          method balance : m
          method mail : string -&gt; unit
        end

      module Client (B : sig class bank : client_view end) =
        struct
          class account x : client_view =
            object
              inherit B.bank
              inherit A.check_client x
            end
        end
    end;;
</FONT></PRE><!--TOC section Simple modules as classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">5.2</A>&#XA0;&#XA0;Simple modules as classes</H2><!--SEC END --><P>

<A NAME="ss:modules-as-classes"></A></P><P>One may wonder whether it is possible to treat primitive types such as
integers and strings as objects. Although this is usually uninteresting
for integers or strings, there may be some situations where
this is desirable. The class <TT>money</TT> above is such an example.
We show here how to do it for strings.</P><!--TOC subsection Strings-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">5.2.1</A>&#XA0;&#XA0;Strings</H3><!--SEC END --><P>
<A NAME="module:string"></A></P><P>A naive definition of strings as objects could be:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ostring s =
    object
       method get n = String.get s n
       method set n c = String.set s n c
       method print = print_string s
       method copy = new ostring (String.copy s)
    end;;
</FONT><FONT COLOR=maroon>class ostring :
  string -&gt;
  object
    method copy : ostring
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
  end
</FONT></PRE><P>
However, the method <TT>copy</TT> returns an object of the class <TT>ostring</TT>,
and not an objet of the current class. Hence, if the class is further
extended, the method <TT>copy</TT> will only return an object of the parent
class.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class sub_string s =
    object
       inherit ostring s
       method sub start len = new sub_string (String.sub s  start len)
    end;;
</FONT><FONT COLOR=maroon>class sub_string :
  string -&gt;
  object
    method copy : ostring
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; sub_string
  end
</FONT></PRE><P>
As seen in section <A HREF="#ss:binary-methods">3.16</A>, the solution is to use
functional update instead. We need to create an instance variable
containing the representation <TT>s</TT> of the string.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class better_string s =
    object
       val repr = s
       method get n = String.get repr n
       method set n c = String.set repr n c
       method print = print_string repr
       method copy = {&lt; repr = String.copy repr &gt;}
       method sub start len = {&lt; repr = String.sub s  start len &gt;}
    end;;
</FONT><FONT COLOR=maroon>class better_string :
  string -&gt;
  object ('a)
    val repr : string
    method copy : 'a
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; 'a
  end
</FONT></PRE><P>
As shown in the inferred type, the methods <TT>copy</TT> and <TT>sub</TT> now return
objects of the same type as the one of the class.</P><P>Another difficulty is the implementation of the method <TT>concat</TT>.
In order to concatenate a string with another string of the same class,
one must be able to access the instance variable externally. Thus, a method
<TT>repr</TT> returning s must be defined. Here is the correct definition of
strings:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ostring s =
    object (self : 'mytype)
       val repr = s
       method repr = repr
       method get n = String.get repr n
       method set n c = String.set repr n c
       method print = print_string repr
       method copy = {&lt; repr = String.copy repr &gt;}
       method sub start len = {&lt; repr = String.sub s start len &gt;}
       method concat (t : 'mytype) = {&lt; repr = repr ^ t#repr &gt;}
    end;;
</FONT><FONT COLOR=maroon>class ostring :
  string -&gt;
  object ('a)
    val repr : string
    method concat : 'a -&gt; 'a
    method copy : 'a
    method get : int -&gt; char
    method print : unit
    method repr : string
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; 'a
  end
</FONT></PRE><P>
Another constructor of the class string can be defined to return an
uninitialized string of a given length:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class cstring n = ostring (String.create n);;
</FONT><FONT COLOR=maroon>class cstring : int -&gt; ostring
</FONT></PRE><P>
Here, exposing the representation of strings is probably harmless. We do
could also hide the representation of strings as we hid the currency in the
class <TT>money</TT> of section&#XA0;<A HREF="#ss:friends">3.17</A>.</P><!--TOC subsubsection Stacks-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Stacks</H4><!--SEC END --><P>
<A NAME="module:stack"></A></P><P>There is sometimes an alternative between using modules or classes for
parametric data types.
Indeed, there are situations when the two approaches are quite similar.
For instance, a stack can be straightforwardly implemented as a class:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> exception Empty;;
<FONT COLOR=maroon>exception Empty

</FONT><FONT COLOR=black>#</FONT> class ['a] stack =
    object
      val mutable l = ([] : 'a list)
      method push x = l &lt;- x::l
      method pop = match l with [] -&gt; raise Empty | a::l' -&gt; l &lt;- l'; a
      method clear = l &lt;- []
      method length = List.length l
    end;;
</FONT><FONT COLOR=maroon>class ['a] stack :
  object
    val mutable l : 'a list
    method clear : unit
    method length : int
    method pop : 'a
    method push : 'a -&gt; unit
  end
</FONT></PRE><P>
However, writing a method for iterating over a stack is more
problematic. A method <TT>fold</TT> would have type
<TT>('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</TT>. Here <TT>'a</TT> is the parameter of the stack.
The parameter <TT>'b</TT> is not related to the class <TT>'a stack</TT> but to the
argument that will be passed to the method <TT>fold</TT>.
A naive approach is to make <TT>'b</TT> an extra parameter of class <TT>stack</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a, 'b] stack2 =
    object
      inherit ['a] stack
      method fold f (x : 'b) = List.fold_left f x l
    end;;
</FONT><FONT COLOR=maroon>class ['a, 'b] stack2 :
  object
    val mutable l : 'a list
    method clear : unit
    method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
    method length : int
    method pop : 'a
    method push : 'a -&gt; unit
  end
</FONT></PRE><P>
However, the method <TT>fold</TT> of a given object can only be
applied to functions that all have the same type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let s = new stack2;;
<FONT COLOR=maroon>val s : ('_a, '_b) stack2 = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> s#fold (+) 0;;
<FONT COLOR=maroon>- : int = 0

</FONT><FONT COLOR=black>#</FONT> s;;
</FONT><FONT COLOR=maroon>- : (int, int) stack2 = &lt;obj&gt;
</FONT></PRE><P>
A better solution is to use polymorphic methods, which were
introduced in OCaml version 3.05. Polymorphic methods makes
it possible to treat the type variable <TT>'b</TT> in the type of <TT>fold</TT> as
universally quantified, giving <TT>fold</TT> the polymorphic type
<TT>Forall 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</TT>.
An explicit type declaration on the method <TT>fold</TT> is required, since
the type checker cannot infer the polymorphic type by itself.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a] stack3 =
    object
      inherit ['a] stack
      method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
                  = fun f x -&gt; List.fold_left f x l
    end;;
</FONT><FONT COLOR=maroon>class ['a] stack3 :
  object
    val mutable l : 'a list
    method clear : unit
    method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b
    method length : int
    method pop : 'a
    method push : 'a -&gt; unit
  end
</FONT></PRE><!--TOC subsection Hashtbl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.2.2</A>&#XA0;&#XA0;Hashtbl</H3><!--SEC END --><P>
<A NAME="module:hashtbl"></A></P><P>A simplified version of object-oriented hash tables should have the
following class type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class type ['a, 'b] hash_table =
    object
      method find : 'a -&gt; 'b
      method add : 'a -&gt; 'b -&gt; unit
    end;;
</FONT><FONT COLOR=maroon>class type ['a, 'b] hash_table =
  object method add : 'a -&gt; 'b -&gt; unit method find : 'a -&gt; 'b end
</FONT></PRE><P>
A simple implementation, which is quite reasonable for small hastables is
to use an association list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a, 'b] small_hashtbl : ['a, 'b] hash_table =
    object
      val mutable table = []
      method find key = List.assoc key table
      method add key valeur = table &lt;- (key, valeur) :: table
    end;;
</FONT><FONT COLOR=maroon>class ['a, 'b] small_hashtbl : ['a, 'b] hash_table
</FONT></PRE><P>
A better implementation, and one that scales up better, is to use a
true hash tables&#X2026; whose elements are small hash tables!
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['a, 'b] hashtbl size : ['a, 'b] hash_table =
    object (self)
      val table = Array.init size (fun i -&gt; new small_hashtbl)
      method private hash key =
        (Hashtbl.hash key) mod (Array.length table)
      method find key = table.(self#hash key) # find key
      method add key = table.(self#hash key) # add key
    end;;
</FONT><FONT COLOR=maroon>class ['a, 'b] hashtbl : int -&gt; ['a, 'b] hash_table
</FONT></PRE><!--TOC subsection Sets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.2.3</A>&#XA0;&#XA0;Sets</H3><!--SEC END --><P>
<A NAME="module:set"></A></P><P>Implementing sets leads to another difficulty. Indeed, the method
<TT>union</TT> needs to be able to access the internal representation of
another object of the same class.</P><P>This is another instance of friend functions as seen in section
<A HREF="#ss:friends">3.17</A>. Indeed, this is the same mechanism used in the module
<TT>Set</TT> in the absence of objects.</P><P>In the object-oriented version of sets, we only need to add an additional
method <TT>tag</TT> to return the representation of a set. Since sets are
parametric in the type of elements, the method <TT>tag</TT> has a parametric type
<TT>'a tag</TT>, concrete within
the module definition but abstract in its signature.
From outside, it will then be guaranteed that two objects with a method <TT>tag</TT>
of the same type will share the same representation.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type SET =
    sig
      type 'a tag
      class ['a] c :
        object ('b)
          method is_empty : bool
          method mem : 'a -&gt; bool
          method add : 'a -&gt; 'b
          method union : 'b -&gt; 'b
          method iter : ('a -&gt; unit) -&gt; unit
          method tag : 'a tag
        end
    end;;

  module Set : SET =
    struct
      let rec merge l1 l2 =
        match l1 with
          [] -&gt; l2
        | h1 :: t1 -&gt;
            match l2 with
              [] -&gt; l1
            | h2 :: t2 -&gt;
                if h1 &lt; h2 then h1 :: merge t1 l2
                else if h1 &gt; h2 then h2 :: merge l1 t2
                else merge t1 l2
      type 'a tag = 'a list
      class ['a] c =
        object (_ : 'b)
          val repr = ([] : 'a list)
          method is_empty = (repr = [])
          method mem x = List.exists ((=) x) repr
          method add x = {&lt; repr = merge [x] repr &gt;}
          method union (s : 'b) = {&lt; repr = merge repr s#tag &gt;}
          method iter (f : 'a -&gt; unit) = List.iter f repr
          method tag = repr
        end
    end;;
</FONT></PRE><!--TOC section The subject/observer pattern-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">5.3</A>&#XA0;&#XA0;The subject/observer pattern</H2><!--SEC END --><P>

<A NAME="ss:subject-observer"></A></P><P>The following example, known as the subject/observer pattern, is often
presented in the literature as a difficult inheritance problem with
inter-connected classes.
The general pattern amounts to the definition a pair of two
classes that recursively interact with one another.</P><P>The class <TT>observer</TT> has a distinguished method <TT>notify</TT> that requires
two arguments, a subject and an event to execute an action.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class virtual ['subject, 'event] observer =
    object
      method virtual notify : 'subject -&gt;  'event -&gt; unit
    end;;
</FONT><FONT COLOR=maroon>class virtual ['subject, 'event] observer :
  object method virtual notify : 'subject -&gt; 'event -&gt; unit end
</FONT></PRE><P>
The class <TT>subject</TT> remembers a list of observers in an instance variable,
and has a distinguished method <TT>notify_observers</TT> to broadcast the message
<TT>notify</TT> to all observers with a particular event <TT>e</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['observer, 'event] subject =
    object (self)
      val mutable observers = ([]:'observer list)
      method add_observer obs = observers &lt;- (obs :: observers)
      method notify_observers (e : 'event) =
          List.iter (fun x -&gt; x#notify self e) observers
    end;;
</FONT><FONT COLOR=maroon>class ['a, 'event] subject :
  object ('b)
    constraint 'a = &lt; notify : 'b -&gt; 'event -&gt; unit; .. &gt;
    val mutable observers : 'a list
    method add_observer : 'a -&gt; unit
    method notify_observers : 'event -&gt; unit
  end
</FONT></PRE><P>
The difficulty usually lies in defining instances of the pattern above
by inheritance. This can be done in a natural and obvious manner in
OCaml, as shown on the following example manipulating windows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> type event = Raise | Resize | Move;;
<FONT COLOR=maroon>type event = Raise | Resize | Move

</FONT><FONT COLOR=black>#</FONT> let string_of_event = function
      Raise -&gt; "Raise" | Resize -&gt; "Resize" | Move -&gt; "Move";;
<FONT COLOR=maroon>val string_of_event : event -&gt; string = &lt;fun&gt;

</FONT><FONT COLOR=black>#</FONT> let count = ref 0;;
<FONT COLOR=maroon>val count : int ref = {contents = 0}

</FONT><FONT COLOR=black>#</FONT> class ['observer] window_subject =
    let id = count := succ !count; !count in
    object (self)
      inherit ['observer, event] subject
      val mutable position = 0
      method identity = id
      method move x = position &lt;- position + x; self#notify_observers Move
      method draw = Printf.printf "{Position = %d}\n"  position;
    end;;
<FONT COLOR=maroon>class ['a] window_subject :
  object ('b)
    constraint 'a = &lt; notify : 'b -&gt; event -&gt; unit; .. &gt;
    val mutable observers : 'a list
    val mutable position : int
    method add_observer : 'a -&gt; unit
    method draw : unit
    method identity : int
    method move : int -&gt; unit
    method notify_observers : event -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> class ['subject] window_observer =
    object
      inherit ['subject, event] observer
      method notify s e = s#draw
    end;;
</FONT><FONT COLOR=maroon>class ['a] window_observer :
  object
    constraint 'a = &lt; draw : unit; .. &gt;
    method notify : 'a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
As can be expected, the type of <TT>window</TT> is recursive.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let window = new window_subject;;
</FONT><FONT COLOR=maroon>val window : &lt; notify : 'a -&gt; event -&gt; unit; _.. &gt; window_subject as 'a =
  &lt;obj&gt;
</FONT></PRE><P>
However, the two classes of <TT>window_subject</TT> and <TT>window_observer</TT> are not
mutually recursive.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let window_observer = new window_observer;;
<FONT COLOR=maroon>val window_observer : &lt; draw : unit; _.. &gt; window_observer = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> window#add_observer window_observer;;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> window#move 1;;
</FONT><FONT COLOR=maroon>{Position = 1}
- : unit = ()
</FONT></PRE><P>Classes <TT>window_observer</TT> and <TT>window_subject</TT> can still be extended by
inheritance. For instance, one may enrich the <TT>subject</TT> with new
behaviors and refine the behavior of the observer.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['observer] richer_window_subject =
    object (self)
      inherit ['observer] window_subject
      val mutable size = 1
      method resize x = size &lt;- size + x; self#notify_observers Resize
      val mutable top = false
      method raise = top &lt;- true; self#notify_observers Raise
      method draw = Printf.printf "{Position = %d; Size = %d}\n"  position size;
    end;;
<FONT COLOR=maroon>class ['a] richer_window_subject :
  object ('b)
    constraint 'a = &lt; notify : 'b -&gt; event -&gt; unit; .. &gt;
    val mutable observers : 'a list
    val mutable position : int
    val mutable size : int
    val mutable top : bool
    method add_observer : 'a -&gt; unit
    method draw : unit
    method identity : int
    method move : int -&gt; unit
    method notify_observers : event -&gt; unit
    method raise : unit
    method resize : int -&gt; unit
  end

</FONT><FONT COLOR=black>#</FONT> class ['subject] richer_window_observer =
    object
      inherit ['subject] window_observer as super
      method notify s e = if e &lt;&gt; Raise then s#raise; super#notify s e
    end;;
</FONT><FONT COLOR=maroon>class ['a] richer_window_observer :
  object
    constraint 'a = &lt; draw : unit; raise : unit; .. &gt;
    method notify : 'a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
We can also create a different kind of observer:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> class ['subject] trace_observer =
    object
      inherit ['subject, event] observer
      method notify s e =
        Printf.printf
          "&lt;Window %d &lt;== %s&gt;\n" s#identity (string_of_event e)
    end;;
</FONT><FONT COLOR=maroon>class ['a] trace_observer :
  object
    constraint 'a = &lt; identity : int; .. &gt;
    method notify : 'a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
and attach several observers to the same object:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let window = new richer_window_subject;;
<FONT COLOR=maroon>val window :
  &lt; notify : 'a -&gt; event -&gt; unit; _.. &gt; richer_window_subject as 'a = &lt;obj&gt;

</FONT><FONT COLOR=black>#</FONT> window#add_observer (new richer_window_observer);;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> window#add_observer (new trace_observer);;
<FONT COLOR=maroon>- : unit = ()

</FONT><FONT COLOR=black>#</FONT> window#move 1; window#resize 2;;
</FONT><FONT COLOR=maroon>&lt;Window 1 &lt;== Move&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 1}
{Position = 1; Size = 1}
&lt;Window 1 &lt;== Resize&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 3}
{Position = 1; Size = 3}
- : unit = ()
</FONT></PRE><!--TOC part The OCaml language-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc50">Part&#XA0;II</A><BR>
The OCaml language</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:refman"></A>
</P><!--TOC chapter The OCaml language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc51">Chapter&#XA0;6</A>&#XA0;&#XA0;The OCaml language</H1><!--SEC END --><P> <A NAME="c:refman"></A>

</P><!--NAME language.html-->
<!--TOC subsection Foreword-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Foreword</H3><!--SEC END --><P>This document is intended as a reference manual for the OCaml
language. It lists the language constructs, and gives their precise
syntax and informal semantics. It is by no means a tutorial
introduction to the language: there is not a single example. A good
working knowledge of OCaml is assumed.</P><P>No attempt has been made at mathematical rigor: words are employed
with their intuitive meaning, without further definition. As a
consequence, the typing rules have been left out, by lack of the
mathematical framework required to express them, while they are
definitely part of a full formal definition of the language.</P><!--TOC subsection Notations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Notations</H3><!--SEC END --><P>The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (<FONT COLOR=blue><TT>like</TT> <TT>this</TT></FONT>).
Non-terminal symbols are set in italic font (<FONT COLOR=maroon><I>like</I></FONT> &#XA0;<FONT COLOR=maroon><I>that</I></FONT>).
Square brackets [&#X2026;] denote optional components. Curly brackets
{&#X2026;} denotes zero, one or several repetitions of the enclosed
components. Curly bracket with a trailing plus sign {&#X2026;}<SUP>+</SUP>
denote one or several repetitions of the enclosed components.
Parentheses (&#X2026;) denote grouping.</P><!--CUT DEF section  --><!--TOC section Lexical conventions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">6.1</A>&#XA0;&#XA0;Lexical conventions</H2><!--SEC END --><!--NAME lex.html-->
<!--TOC subsubsection Blanks-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Blanks</H4><!--SEC END --><P>The following characters are considered as blanks: space, newline,
horizontal tabulation, carriage return, line feed and form feed. Blanks are
ignored, but they separate adjacent identifiers, literals and
keywords that would otherwise be confused as one single identifier,
literal or keyword.</P><!--TOC subsubsection Comments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments</H4><!--SEC END --><P>Comments are introduced by the two characters <TT>(*</TT>, with no
intervening blanks, and terminated by the characters <TT>*)</TT>, with
no intervening blanks. Comments are treated as blank characters.
Comments do not occur inside string or character literals. Nested
comments are handled correctly.</P><!--TOC subsubsection Identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Identifiers</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;(<I><A href="#letter" class="syntax"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>)&#XA0;{&#XA0;<I><A href="#letter" class="syntax"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223;&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;}&#XA0;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="letter" class="syntax"><FONT COLOR=maroon>letter</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>A</TT></FONT>&#XA0;&#X2026;&#XA0;<FONT COLOR=blue><TT>Z</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>a</TT></FONT>&#XA0;&#X2026;&#XA0;<FONT COLOR=blue><TT>z</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Identifiers are sequences of letters, digits, <TT>_</TT> (the underscore
character), and <TT>'</TT> (the single quote), starting with a
letter or an underscore.
Letters contain at least the 52 lowercase and uppercase
letters from the ASCII set. The current implementation
also recognizes as letters all accented characters from the ISO
8859-1 (&#X201C;ISO Latin 1&#X201D;) set. All characters in an identifier are
meaningful. The current implementation accepts identifiers up to
16000000 characters in length.</P><!--TOC subsubsection Integer literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Integer literals</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;[<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0x</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>0X</TT></FONT>)&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)
{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;[<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0o</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>0O</TT></FONT>)&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>7</TT></FONT>)&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>7</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;[<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0b</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>0B</TT></FONT>)&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>1</TT></FONT>)&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>1</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}</TD></TR>
</TABLE></TD></TR>
</TABLE><P>An integer literal is a sequence of one or more digits, optionally
preceded by a minus sign. By default, integer literals are in decimal
(radix 10). The following prefixes select a different radix:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Prefix</B></TD><TD ALIGN=center NOWRAP><B>Radix</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>0x</TT>, <TT>0X</TT></TD><TD ALIGN=left NOWRAP>hexadecimal (radix 16)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0o</TT>, <TT>0O</TT></TD><TD ALIGN=left NOWRAP>octal (radix 8)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0b</TT>, <TT>0B</TT></TD><TD ALIGN=left NOWRAP>binary (radix 2)</TD></TR>
</TABLE></DIV><P>
(The initial <TT>0</TT> is the digit zero; the <TT>O</TT> for octal is the letter O.)
The interpretation of integer literals that fall outside the range of
representable integer values is undefined.</P><P>For convenience and readability, underscore characters (<TT>_</TT>) are accepted
(and ignored) within integer literals.</P><!--TOC subsubsection Floating-point literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Floating-point literals</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="float-literal" class="syntax"><FONT COLOR=maroon>float-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}&#XA0;[<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}]
[(<FONT COLOR=blue><TT>e</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>E</TT></FONT>)&#XA0;[<FONT COLOR=blue><TT>+</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>-</TT></FONT>]&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)&#XA0;{&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;}]</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Floating-point decimals consist in an integer part, a decimal part and
an exponent part. The integer part is a sequence of one or more
digits, optionally preceded by a minus sign. The decimal part is a
decimal point followed by zero, one or more digits.
The exponent part is the character <TT>e</TT> or <TT>E</TT> followed by an
optional <TT>+</TT> or <TT>-</TT> sign, followed by one or more digits.
The decimal part or the exponent part can be omitted, but not both to
avoid ambiguity with integer literals.
The interpretation of floating-point literals that fall outside the
range of representable floating-point values is undefined.</P><P>For convenience and readability, underscore characters (<TT>_</TT>) are accepted
(and ignored) within floating-point literals.</P><!--TOC subsubsection Character literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Character literals</H4><!--SEC END --><P>
<A NAME="s:characterliteral"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="char-literal" class="syntax"><FONT COLOR=maroon>char-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<FONT COLOR=maroon><I>regular-char</I></FONT>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#escape-sequence" class="syntax"><FONT COLOR=maroon>escape-sequence</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="escape-sequence" class="syntax"><FONT COLOR=maroon>escape-sequence</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>\</TT></FONT>&#XA0;(<FONT COLOR=blue><TT>\</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>"</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>n</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>t</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>b</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>r</TT></FONT>)
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>\</TT></FONT>&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>\x</TT></FONT>&#XA0;(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)
(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Character literals are delimited by <TT>'</TT> (single quote) characters.
The two single quotes enclose either one character different from
<TT>'</TT> and <TT>\</TT>, or one of the escape sequences below:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Sequence</B></TD><TD ALIGN=center NOWRAP><B>Character denoted</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>\\</TT></TD><TD ALIGN=left NOWRAP>backslash (<TT>\</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\"</TT></TD><TD ALIGN=left NOWRAP>double quote (<TT>"</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\'</TT></TD><TD ALIGN=left NOWRAP>single quote (<TT>'</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\n</TT></TD><TD ALIGN=left NOWRAP>linefeed (LF)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\r</TT></TD><TD ALIGN=left NOWRAP>carriage return (CR)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\t</TT></TD><TD ALIGN=left NOWRAP>horizontal tabulation (TAB)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\b</TT></TD><TD ALIGN=left NOWRAP>backspace (BS)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\</TT><I>space</I></TD><TD ALIGN=left NOWRAP>space (SPC)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\</TT><I>ddd</I></TD><TD ALIGN=left NOWRAP>the character with ASCII code <I>ddd</I> in decimal</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\x</TT><I>hh</I></TD><TD ALIGN=left NOWRAP>the character with ASCII code <I>hh</I> in hexadecimal</TD></TR>
</TABLE></DIV><!--TOC subsubsection String literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->String literals</H4><!--SEC END --><P>
<A NAME="s:stringliteral"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="string-literal" class="syntax"><FONT COLOR=maroon>string-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>"</TT></FONT>&#XA0;{&#XA0;<I><A href="#string-character" class="syntax"><FONT COLOR=maroon>string-character</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>"</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="string-character" class="syntax"><FONT COLOR=maroon>string-character</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>regular-char-str</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#escape-sequence" class="syntax"><FONT COLOR=maroon>escape-sequence</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>String literals are delimited by <TT>"</TT> (double quote) characters.
The two double quotes enclose a sequence of either characters
different from <TT>"</TT> and <TT>\</TT>, or escape sequences from the
table given above for character literals.</P><P>To allow splitting long string literals across lines, the sequence
<TT>\</TT><I>newline</I>&#XA0;<I>blanks</I> (a <TT>\</TT> at end-of-line followed by any
number of blanks at the beginning of the next line) is ignored inside
string literals.</P><P>The current implementation places practically no restrictions on the
length of string literals.</P><!--TOC subsubsection Naming labels-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Naming labels</H4><!--SEC END --><P>To avoid ambiguities, naming labels in expressions cannot just be defined
syntactically as the sequence of the three tokens <TT>~</TT>, <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> and
<TT>:</TT>, and have to be defined at the lexical level.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;(<FONT COLOR=blue><TT>a</TT></FONT>&#XA0;&#X2026;&#XA0;<FONT COLOR=blue><TT>z</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>)&#XA0;{&#XA0;<I><A href="#letter" class="syntax"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223;&#XA0;<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#X2223;&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;}&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="label" class="syntax"><FONT COLOR=maroon>label</FONT></A></I>&#XA0;</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="optlabel" class="syntax"><FONT COLOR=maroon>optlabel</FONT></A></I>&#XA0;</TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Naming labels come in two flavours: <I><A href="#label" class="syntax"><FONT COLOR=maroon>label</FONT></A></I> for normal arguments and
<I><A href="#optlabel" class="syntax"><FONT COLOR=maroon>optlabel</FONT></A></I> for optional ones. They are simply distinguished by their
first character, either <TT>~</TT> or <TT>?</TT>.</P><P>Despite <I><A href="#label" class="syntax"><FONT COLOR=maroon>label</FONT></A></I> and <I><A href="#optlabel" class="syntax"><FONT COLOR=maroon>optlabel</FONT></A></I> being lexical entities in expressions,
their expansions <FONT COLOR=blue><TT>~</TT></FONT> <I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> and <FONT COLOR=blue><TT>?</TT></FONT> <I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> will be
used in grammars, for the sake of readability. Note also that inside
type expressions, this expansion can be taken literally, <EM>i.e.</EM>
there are really 3 tokens, with optional spaces beween them.</P><!--TOC subsubsection Prefix and infix symbols-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Prefix and infix symbols</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="infix-symbol" class="syntax"><FONT COLOR=maroon>infix-symbol</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
(<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&lt;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&gt;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>@</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>^</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&amp;</TT></FONT>&#XA0;&#X2223;&#XA0;
<FONT COLOR=blue><TT>+</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>-</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>/</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>$</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>%</TT></FONT>)&#XA0;{&#XA0;<I><A href="#operator-char" class="syntax"><FONT COLOR=maroon>operator-char</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>!</TT></FONT>&#XA0;{&#XA0;<I><A href="#operator-char" class="syntax"><FONT COLOR=maroon>operator-char</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;(<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>)&#XA0;{&#XA0;<I><A href="#operator-char" class="syntax"><FONT COLOR=maroon>operator-char</FONT></A></I>&#XA0;}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="operator-char" class="syntax"><FONT COLOR=maroon>operator-char</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>!</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>$</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>%</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&amp;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>+</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>-</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#X2223;&#XA0;
<FONT COLOR=blue><TT>/</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&lt;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&gt;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>@</TT></FONT>&#XA0;&#X2223;&#XA0;
<FONT COLOR=blue><TT>^</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Sequences of &#X201C;operator characters&#X201D;, such as <TT>&lt;=&gt;</TT> or <TT>!!</TT>,
are read as a single token from the <I><A href="#infix-symbol" class="syntax"><FONT COLOR=maroon>infix-symbol</FONT></A></I> or <I><A href="#prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>
class. These symbols are parsed as prefix and infix operators inside
expressions, but otherwise behave like normal identifiers.
</P><!--TOC subsubsection Keywords-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Keywords</H4><!--SEC END --><P>The identifiers below are reserved as keywords, and cannot be employed
otherwise:
</P><PRE>      and         as          assert      asr         begin       class
      constraint  do          done        downto      else        end
      exception   external    false       for         fun         function
      functor     if          in          include     inherit     initializer
      land        lazy        let         lor         lsl         lsr
      lxor        match       method      mod         module      mutable
      new         object      of          open        or          private
      rec         sig         struct      then        to          true
      try         type        val         virtual     when        while
      with
</PRE><P>The following character sequences are also keywords:
</P><PRE>
<TT>    !=    #     &amp;     &amp;&amp;    '     (     )     *     +     ,     -</TT>
<TT>    -.    -&gt;    .     ..    :     ::    :=    :&gt;    ;     ;;    &lt;</TT>
<TT>    &lt;-    =     &gt;     &gt;]    &gt;}    ?     ??    [     [&lt;    [&gt;    [|</TT>
<TT>    ]     _     `     {     {&lt;    |     |]    }     ~</TT>
</PRE><P>
Note that the following identifiers are keywords of the Camlp4
extensions and should be avoided for compatibility reasons.
</P><PRE>    parser    value   &lt;&lt;    &lt;:    &gt;&gt;    $     $$    $:
</PRE><!--TOC subsubsection Ambiguities-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Ambiguities</H4><!--SEC END --><P>Lexical ambiguities are resolved according to the &#X201C;longest match&#X201D;
rule: when a character sequence can be decomposed into two tokens in
several different ways, the decomposition retained is the one with the
longest first token.</P><!--TOC subsubsection Line number directives-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Line number directives</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="linenum-directive" class="syntax"><FONT COLOR=maroon>linenum-directive</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;{<FONT COLOR=blue><TT>0</TT></FONT>&#XA0;&#X2026;&#XA0;<FONT COLOR=blue><TT>9</TT></FONT>}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;{<FONT COLOR=blue><TT>0</TT></FONT>&#XA0;&#X2026;&#XA0;<FONT COLOR=blue><TT>9</TT></FONT>}<SUP>+</SUP>&#XA0;<FONT COLOR=blue><TT>"</TT></FONT>&#XA0;{&#XA0;<I><A href="#string-character" class="syntax"><FONT COLOR=maroon>string-character</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>"</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Preprocessors that generate OCaml source code can insert line number
directives in their output so that error messages produced by the
compiler contain line numbers and file names referring to the source
file before preprocessing, instead of after preprocessing.
A line number directive is composed of a <TT>#</TT> (sharp sign), followed by
a positive integer (the source line number), optionally followed by a
character string (the source file name).
Line number directives are treated as blank characters during lexical
analysis.</P><!--TOC section Values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">6.2</A>&#XA0;&#XA0;Values</H2><!--SEC END --><P>This section describes the kinds of values that are manipulated by
OCaml programs.</P><!--TOC subsection Base values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">6.2.1</A>&#XA0;&#XA0;Base values</H3><!--SEC END --><!--TOC subsubsection Integer numbers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Integer numbers</H4><!--SEC END --><P>Integer values are integer numbers from &#X2212;2<SUP>30</SUP> to 2<SUP>30</SUP>&#X2212;1, that
is &#X2212;1073741824 to 1073741823. The implementation may support a
wider range of integer values: on 64-bit platforms, the current
implementation supports integers ranging from &#X2212;2<SUP>62</SUP> to 2<SUP>62</SUP>&#X2212;1.</P><!--TOC subsubsection Floating-point numbers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Floating-point numbers</H4><!--SEC END --><P>Floating-point values are numbers in floating-point representation.
The current implementation uses double-precision floating-point
numbers conforming to the IEEE 754 standard, with 53 bits of mantissa
and an exponent ranging from &#X2212;1022 to 1023.</P><!--TOC subsubsection Characters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Characters</H4><!--SEC END --><P>Character values are represented as 8-bit integers between 0 and 255.
Character codes between 0 and 127 are interpreted following the ASCII
standard. The current implementation interprets character codes
between 128 and 255 following the ISO 8859-1 standard.</P><!--TOC subsubsection Character strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Character strings</H4><!--SEC END --><P> <A NAME="s:string-val"></A></P><P>String values are finite sequences of characters. The current
implementation supports strings containing up to 2<SUP>24</SUP> &#X2212; 5
characters (16777211 characters); on 64-bit platforms, the limit is
2<SUP>57</SUP> &#X2212; 9.</P><!--TOC subsection Tuples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">6.2.2</A>&#XA0;&#XA0;Tuples</H3><!--SEC END --><P>Tuples of values are written (<I>v</I><SUB>1</SUB>, &#X2026;, <I>v<SUB>n</SUB></I>), standing for the
<I>n</I>-tuple of values <I>v</I><SUB>1</SUB> to <I>v<SUB>n</SUB></I>. The current implementation
supports tuple of up to 2<SUP>22</SUP> &#X2212; 1 elements (4194303 elements).</P><!--TOC subsection Records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">6.2.3</A>&#XA0;&#XA0;Records</H3><!--SEC END --><P>Record values are labeled tuples of values. The record value written
<FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=maroon><I>v</I></FONT><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026;<FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> <I><FONT COLOR=maroon>v</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> associates the value
<I>v<SUB>i</SUB></I> to the record field <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>i</SUB></I>, for <I>i</I> = 1 &#X2026; <I>n</I>. The current
implementation supports records with up to 2<SUP>22</SUP> &#X2212; 1 fields
(4194303 fields).</P><!--TOC subsection Arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">6.2.4</A>&#XA0;&#XA0;Arrays</H3><!--SEC END --><P>Arrays are finite, variable-sized sequences of values of the same
type. The current implementation supports arrays containing up to
2<SUP>22</SUP> &#X2212; 1 elements (4194303 elements) unless the elements are
floating-point numbers (2097151 elements in this case); on 64-bit
platforms, the limit is 2<SUP>54</SUP> &#X2212; 1 for all arrays.</P><!--TOC subsection Variant values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">6.2.5</A>&#XA0;&#XA0;Variant values</H3><!--SEC END --><P>Variant values are either a constant constructor, or a non-constant
constructor applied to a number of values. The former case is written
<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>; the latter case is written <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT><FONT COLOR=maroon><I>v</I></FONT><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> ... <FONT COLOR=blue><TT>,</TT></FONT> <I><FONT COLOR=maroon>v</FONT><SUB>n</SUB></I>
<FONT COLOR=blue><TT>)</TT></FONT>, where the <I><FONT COLOR=maroon>v</FONT><SUB>i</SUB></I> are said to be the arguments of the non-constant
constructor <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>. The parentheses may be omitted if there is only
one argument.</P><P>The following constants are treated like built-in constant
constructors:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constant</B></TD><TD ALIGN=center NOWRAP><B>Constructor</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>false</TT></TD><TD ALIGN=left NOWRAP>the boolean false</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>true</TT></TD><TD ALIGN=left NOWRAP>the boolean true</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>()</TT></TD><TD ALIGN=left NOWRAP>the &#X201C;unit&#X201D; value</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>[]</TT></TD><TD ALIGN=left NOWRAP>the empty list</TD></TR>
</TABLE></DIV><P>The current implementation limits each variant type to have at most
246 non-constant constructors and 2<SUP>30</SUP>&#X2212;1 constant constructors.</P><!--TOC subsection Polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">6.2.6</A>&#XA0;&#XA0;Polymorphic variants</H3><!--SEC END --><P>Polymorphic variants are an alternate form of variant values, not
belonging explicitly to a predefined variant type, and following
specific typing rules. They can be either constant, written
<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>, or non-constant, written <FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>(<I>v</I>).</P><!--TOC subsection Functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">6.2.7</A>&#XA0;&#XA0;Functions</H3><!--SEC END --><P>Functional values are mappings from values to values.</P><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">6.2.8</A>&#XA0;&#XA0;Objects</H3><!--SEC END --><P>Objects are composed of a hidden internal state which is a
record of instance variables, and a set of methods for accessing and
modifying these variables. The structure of an object is described by
the toplevel class that created it.</P><!--TOC section Names-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">6.3</A>&#XA0;&#XA0;Names</H2><!--SEC END --><P> <A NAME="s:names"></A>
</P><P>Identifiers are used to give names to several classes of language
objects and refer to these objects by name later:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
value names (syntactic class <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">value constructors and exception constructors (class <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">labels (<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">polymorphic variant tags (<I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">type constructors (<I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">record fields (<I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">class names (<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">method names (<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">instance variable names (<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">module names (<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">module type names (<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I>).
</LI></UL><P>
These eleven name spaces are distinguished both by the context and by the
capitalization of the identifier: whether the first letter of the
identifier is in lowercase (written <FONT COLOR=maroon><I>lowercase-ident</I></FONT> below) or in
uppercase (written <FONT COLOR=maroon><I>capitalized-ident</I></FONT>). Underscore is considered a
lowercase letter for this purpose.</P><P><A NAME="@manual.kwd0"></A>
<A NAME="@manual.kwd1"></A></P><!--TOC subsubsection Naming objects-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Naming objects</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#operator-name" class="syntax"><FONT COLOR=maroon>operator-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="operator-name" class="syntax"><FONT COLOR=maroon>operator-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>&#XA0;&#X2223;&#XA0;&#XA0;<I><A href="#infix-op" class="syntax"><FONT COLOR=maroon>infix-op</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="infix-op" class="syntax"><FONT COLOR=maroon>infix-op</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#infix-symbol" class="syntax"><FONT COLOR=maroon>infix-symbol</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>or</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>&amp;</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>:=</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>mod</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>land</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>lor</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>lxor</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>lsl</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>lsr</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>asr</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>capitalized-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>capitalized-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
As shown above, prefix and infix symbols as well as some keywords can
be used as value names, provided they are written between parentheses.
The capitalization rules are summarized in the table below.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Name space</B></TD><TD ALIGN=center NOWRAP><B>Case of first letter</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Values</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Constructors</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Labels</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Polymorphic variant tags</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Exceptions</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Type constructors</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Record fields</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Classes</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Instance variables</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Methods</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Modules</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Module types</TD><TD ALIGN=left NOWRAP>any</TD></TR>
</TABLE></DIV><P><I>Note on polymorphic variant tags:</I> the current implementation accepts
lowercase variant tags in addition to uppercase variant tags, but we
suggest you avoid lowercase variant tags for portability and
compatibility with future OCaml versions.</P><!--TOC subsubsection Referring to named objects-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Referring to named objects</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="value-path" class="syntax"><FONT COLOR=maroon>value-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;}&#XA0;&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;]&#XA0;&#XA0;<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A named object can be referred to either by its name (following the
usual static scoping rules for names) or by an access path <FONT COLOR=maroon><I>prefix</I></FONT> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT>,
where <FONT COLOR=maroon><I>prefix</I></FONT> designates a module and <FONT COLOR=maroon><I>name</I></FONT> is the name of an object
defined in that module. The first component of the path, <FONT COLOR=maroon><I>prefix</I></FONT>, is
either a simple module name or an access path <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> &#X2026;,
in case the defining module is itself nested inside other modules.
For referring to type constructors or module types, the <FONT COLOR=maroon><I>prefix</I></FONT> can
also contain simple functor applications (as in the syntactic class
<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I> above), in case the defining module is the
result of a functor application.</P><P>Label names, tag names, method names and instance variable names need
not be qualified: the former three are global labels, while the latter
are local to a class.

</P><!--TOC section Type expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">6.4</A>&#XA0;&#XA0;Type expressions</H2><!--SEC END --><!--NAME types.html-->
<P>
<A NAME="@manual.kwd2"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;[[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>]&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>as</TT></FONT>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#polymorphic-variant-type" class="syntax"><FONT COLOR=maroon>polymorphic-variant-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>&lt;</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>..</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>&gt;</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>&lt;</TT></FONT>&#XA0;<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<FONT COLOR=blue><TT>..</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>&gt;</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}&#XA0;)&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;}<SUP>+</SUP>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed type constructions. The constructions with
higher precedences come first.
<A NAME="@manual.kwd3"></A>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Type constructor application</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>*</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>-&gt;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>as</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><P>Type expressions denote types in definitions of data types as well as
in type constraints over patterns and expressions.</P><!--TOC subsubsection Type variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type variables</H4><!--SEC END --><P>The type expression <FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> stands for the type variable named
<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>. The type expression <FONT COLOR=blue><TT>_</TT></FONT> stands for an anonymous type variable.
In data type definitions, type variables are names for the
data type parameters. In type constraints, they represent unspecified
types that can be instantiated by any type to satisfy the type
constraint. In general the scope of a named type variable is the
whole top-level phrase where it appears, and it can only be
generalized when leaving
this scope. Anonymous variables have no such restriction.
In the following cases, the scope of named type variables is
restricted to the type expression where they appear: 1) for universal
(explicitly polymorphic) type variables; 2) for type variables that
only appear in public method specifications (as those variables will
be made universal, as described in section&#XA0;<A HREF="#sec-methspec">6.9.1</A>);
3) for variables used as aliases, when the type they are aliased to
would be invalid in the scope of the enclosing definition (<I>i.e.</I>
when it contains free universal type variables, or locally
defined types.)</P><!--TOC subsubsection Parenthesized types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized types</H4><!--SEC END --><P>The type expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> denotes the same type as
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><!--TOC subsubsection Function types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function types</H4><!--SEC END --><P>The type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the type of
functions mapping arguments of type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to results of type
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><P><I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the same function type, but
the argument is labeled <I><A href="#label" class="syntax"><FONT COLOR=maroon>label</FONT></A></I>.</P><P><FONT COLOR=blue><TT>?</TT></FONT> <I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the type of functions
mapping an optional labeled argument of type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to results of
type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. That is, the physical type of the function will be
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>option</TT> <TT>-&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><!--TOC subsubsection Tuple types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Tuple types</H4><!--SEC END --><P>The type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>*</TT></FONT> &#X2026; <FONT COLOR=blue><TT>*</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>
denotes the type of tuples whose elements belong to types <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,
&#X2026; &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> respectively.</P><!--TOC subsubsection Constructed types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constructed types</H4><!--SEC END --><P>Type constructors with no parameter, as in <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>, are type
expressions.</P><P>The type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> &#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>, where <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> is a type
constructor with one parameter, denotes the application of the unary type
constructor <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> to the type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><P>The type expression (<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,&#X2026;,&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>) &#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>, where
<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> is a type constructor with <I>n</I> parameters, denotes the
application of the <I>n</I>-ary type constructor <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> to the types
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> through <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Aliased and recursive types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Aliased and recursive types</H4><!--SEC END --><P><A NAME="@manual.kwd4"></A></P><P>The type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>as</TT> <TT>'</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> denotes the same type as
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>, and also binds the type variable <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> to type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> both
in <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> and in other types. In general the scope of an alias is
the same as for a named type variable, and covers the whole enclosing
definition. If the type variable
<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> actually occurs in <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>, a recursive type is created. Recursive
types for which there exists a recursive path that does not contain
an object or polymorphic variant type constructor are rejected, except
when the <TT>-rectypes</TT> mode is selected.</P><P>If <FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> denotes an explicit polymorphic variable, and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
denotes either an object or polymorphic variant type, the row variable
of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> is captured by <FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>, and quantified upon.</P><!--TOC subsubsection Polymorphic variant types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant types</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="polymorphic-variant-type" class="syntax"><FONT COLOR=maroon>polymorphic-variant-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;[&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;]&#XA0;<I><A href="#tag-spec" class="syntax"><FONT COLOR=maroon>tag-spec</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#tag-spec" class="syntax"><FONT COLOR=maroon>tag-spec</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[&gt;</TT></FONT>&#XA0;[&#XA0;<I><A href="#tag-spec" class="syntax"><FONT COLOR=maroon>tag-spec</FONT></A></I>&#XA0;]&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#tag-spec" class="syntax"><FONT COLOR=maroon>tag-spec</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[&lt;</TT></FONT>&#XA0;[&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;]&#XA0;<I><A href="#tag-spec-full" class="syntax"><FONT COLOR=maroon>tag-spec-full</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#tag-spec-full" class="syntax"><FONT COLOR=maroon>tag-spec-full</FONT></A></I>&#XA0;}&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>&gt;</TT></FONT>&#XA0;{&#XA0;<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>&#XA0;}<SUP>+</SUP>&#XA0;]&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-spec" class="syntax"><FONT COLOR=maroon>tag-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>of</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-spec-full" class="syntax"><FONT COLOR=maroon>tag-spec-full</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>of</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;]&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>&amp;</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Polymorphic variant types describe the values a polymorphic variant
may take.</P><P>The first case is an exact variant type: all possible tags are
known, with their associated types, and they can all be present.
Its structure is fully known.</P><P>The second case is an open variant type, describing a polymorphic
variant value: it gives the list of all tags the value could take,
with their associated types. This type is still compatible with a
variant type containing more tags. A special case is the unknown
type, which does not define any tag, and is compatible with any
variant type.</P><P>The third case is a closed variant type. It gives information about
all the possible tags and their associated types, and which tags are
known to potentially appear in values. The exact variant type (first
case) is
just an abbreviation for a closed variant type where all possible tags
are also potentially present.</P><P>In all three cases, tags may be either specified directly in the
<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I> &#XA0;[<FONT COLOR=blue><TT>of</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>] form, or indirectly through a type
expression. In this last case, the type expression must expand to an
exact variant type, whose tag specifications are inserted in its
place.</P><P>Full specifications of variant tags are only used for non-exact closed
types. They can be understood as a conjunctive type for the argument:
it is intended to have all the types enumerated in the
specification.</P><P>Such conjunctive constraints may be unsatisfiable. In such a case the
corresponding tag may not be used in a value of this type. This
does not mean that the whole type is not valid: one can still use
other available tags.</P><!--TOC subsubsection Object types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object types</H4><!--SEC END --><P>An object type
<FONT COLOR=blue><TT>&lt;</TT></FONT> [<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>;</TT></FONT> <I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I> }] <FONT COLOR=blue><TT>&gt;</TT></FONT>
is a record of method types.</P><P>Each method may have an explicit polymorphic type: { <FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> }<SUP>+</SUP>
<FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>. Explicit polymorphic variables have a local scope, and
an explicit polymorphic type can only be unified to an
equivalent one, where only the order and names of polymorphic
variables may change.</P><P>The type <FONT COLOR=blue><TT>&lt;</TT></FONT> {<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I> <FONT COLOR=blue><TT>;</TT></FONT>} <FONT COLOR=blue><TT>..</TT> <TT>&gt;</TT></FONT> is the
type of an object whose method names and types are described by
<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A></I><SUB>1</SUB>, &#X2026;, &#XA0;<I><A href="#method-type" class="syntax"><FONT COLOR=maroon>method-type</FONT></A><SUB>n</SUB></I>, and possibly some other
methods represented by the ellipsis. This ellipsis actually is
a special kind of type variable (called <EM>row variable</EM> in the
literature) that stands for any number of extra method types.</P><!--TOC subsubsection #-types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->#-types</H4><!--SEC END --><P>
<A NAME="s:sharp-types"></A></P><P>The type <FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> is a special kind of abbreviation. This
abbreviation unifies with the type of any object belonging to a subclass
of class <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>.
It is handled in a special way as it usually hides a type variable (an
ellipsis, representing the methods that may be added in a subclass).
In particular, it vanishes when the ellipsis gets instantiated.
Each type expression <FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> defines a new type variable, so
type <FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT> <TT>#</TT></FONT> &#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> is usually not the same as
type (<FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> <FONT COLOR=blue><TT>as</TT> <TT>'</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>) <FONT COLOR=blue><TT>-&gt;</TT> <TT>'</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>.
</P><P>Use of #-types to abbreviate polymorphic variant types is deprecated.
If <TT>t</TT> is an exact variant type then <TT>#t</TT> translates to <TT>[&lt; t]</TT>,
and <FONT COLOR=blue><TT>#t[&gt;</TT> <TT>`tag</TT></FONT><SUB>1</SUB> &#X2026;<FONT COLOR=blue><TT>`tag</TT></FONT><I><SUB>k</SUB></I><FONT COLOR=blue><TT>]</TT></FONT> translates to
<FONT COLOR=blue><TT>[&lt;</TT> <TT>t</TT> <TT>&gt;</TT> <TT>`tag</TT></FONT><SUB>1</SUB> &#X2026;<FONT COLOR=blue><TT>`tag</TT></FONT><I><SUB>k</SUB></I><FONT COLOR=blue><TT>]</TT></FONT></P><!--TOC subsubsection Variant and record types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variant and record types</H4><!--SEC END --><P>There are no type expressions describing (defined) variant types nor
record types, since those are always named, i.e. defined before use
and referred to by name. Type definitions are described in
section&#XA0;<A HREF="#s:type-defs">6.8.1</A>.

</P><!--TOC section Constants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">6.5</A>&#XA0;&#XA0;Constants</H2><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="constant" class="syntax"><FONT COLOR=maroon>constant</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#float-literal" class="syntax"><FONT COLOR=maroon>float-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#char-literal" class="syntax"><FONT COLOR=maroon>char-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#string-literal" class="syntax"><FONT COLOR=maroon>string-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>false</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>true</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>()</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[||]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The syntactic class of constants comprises literals from the four
base types (integers, floating-point numbers, characters, character
strings), and constant constructors from both normal and polymorphic
variants, as well as the special constants <TT>false</TT>, <TT>true</TT>, <TT>()</TT>,
<TT>[]</TT>, and <TT>[||]</TT>, which behave like constant constructors.

</P><!--TOC section Patterns-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc65">6.6</A>&#XA0;&#XA0;Patterns</H2><!--SEC END --><P>

<A NAME="@manual.kwd5"></A>
</P><!--NAME patterns.html-->
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constant" class="syntax"><FONT COLOR=maroon>constant</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>as</TT></FONT>&#XA0;&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT><I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;}&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;]&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;}&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;]&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>::</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[|</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;}&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;]&#XA0;<FONT COLOR=blue><TT>|]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>lazy</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed pattern constructions. The constructions with
higher precedences come first.
<A NAME="@manual.kwd6"></A>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Constructor application</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>::</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>,</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>|</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>as</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><P>Patterns are templates that allow selecting data structures of a
given shape, and binding identifiers to components of the data
structure. This selection operation is called pattern matching; its
outcome is either &#X201C;this value does not match this pattern&#X201D;, or
&#X201C;this value matches this pattern, resulting in the following bindings
of names to values&#X201D;.</P><!--TOC subsubsection Variable patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variable patterns</H4><!--SEC END --><P>A pattern that consists in a value name matches any value,
binding the name to the value. The pattern <FONT COLOR=blue><TT>_</TT></FONT> also matches
any value, but does not bind any name.</P><P>Patterns are <EM>linear</EM>: a variable cannot be bound several times by
a given pattern. In particular, there is no way to test for equality
between two parts of a data structure using only a pattern (but
<FONT COLOR=blue><TT>when</TT></FONT> guards can be used for this purpose).</P><!--TOC subsubsection Constant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constant patterns</H4><!--SEC END --><P>A pattern consisting in a constant matches the values that
are equal to this constant.</P><!--TOC subsubsection Alias patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Alias patterns</H4><!--SEC END --><P>
<A NAME="@manual.kwd7"></A></P><P>The pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>as</TT></FONT> &#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> matches the same values as
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>. If the matching against <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> is successful,
the name <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> is bound to the matched value, in addition to the
bindings performed by the matching against <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.</P><!--TOC subsubsection Parenthesized patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT> matches the same values as
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>. A type constraint can appear in a
parenthesized pattern, as in <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>. This
constraint forces the type of <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to be compatible with
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><!--TOC subsubsection &#X201C;Or&#X201D; patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->&#X201C;Or&#X201D; patterns</H4><!--SEC END --><P>The pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> represents the logical &#X201C;or&#X201D; of
the two patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> and <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>. A value matches
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> if it matches <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> or
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>. The two sub-patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> and <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>
must bind exactly the same identifiers to values having the same types.
Matching is performed from left to right.
More precisely,
in case some value&#XA0;<I>v</I> matches <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>, the bindings
performed are those of <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> when <I>v</I> matches <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.
Otherwise, value&#XA0;<I>v</I> matches <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> whose bindings are performed.</P><!--TOC subsubsection Variant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variant patterns</H4><!--SEC END --><P>The pattern <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>)</TT></FONT> matches
all variants whose
constructor is equal to <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>, and whose arguments match
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. It is a type error if <I>n</I> is not the
number of arguments expected by the constructor.</P><P>The pattern <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> <FONT COLOR=blue><TT>_</TT></FONT> matches all variants whose constructor is
<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>.</P><P>The pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> matches non-empty lists whose
heads match <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>, and whose tails match <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>.</P><P>The pattern <FONT COLOR=blue><TT>[</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> matches lists
of length <I>n</I> whose elements match <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>,
respectively. This pattern behaves like
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#X2026; <FONT COLOR=blue><TT>::</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>::</TT> <TT>[]</TT></FONT>.</P><!--TOC subsubsection Polymorphic variant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> matches all polymorphic variants
whose tag is equal to <I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>, and whose argument matches
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.</P><!--TOC subsubsection Polymorphic variant abbreviation patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant abbreviation patterns</H4><!--SEC END --><P>If the type [<FONT COLOR=blue><TT>('a,'b,</TT></FONT>&#X2026;<FONT COLOR=blue><TT>)</TT></FONT>] <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> = <FONT COLOR=blue><TT>[</TT> <TT>`</TT></FONT>&#XA0;<I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I><SUB>1</SUB> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>
&#X2026; <FONT COLOR=blue><TT>|</TT> <TT>`</TT></FONT>&#XA0;<I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A><SUB>n</SUB></I> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I><FONT COLOR=blue><TT>]</TT></FONT> is defined, then the pattern <FONT COLOR=blue><TT>#</TT></FONT><I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
is a shorthand for the following or-pattern:
<FONT COLOR=blue><TT>(</TT> <TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>(_</TT> <TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>)</TT> <TT>|</TT></FONT> &#X2026; <FONT COLOR=blue><TT>|</TT> <TT>`</TT></FONT>&#XA0;<I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A><SUB>n</SUB></I><FONT COLOR=blue><TT>(_</TT>
<TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I><FONT COLOR=blue><TT>))</TT></FONT>. It matches all values of type <FONT COLOR=blue><TT>[&lt;</TT></FONT> <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT>.</P><!--TOC subsubsection Tuple patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Tuple patterns</H4><!--SEC END --><P>The pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> matches <I>n</I>-tuples
whose components match the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> through <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. That
is, the pattern matches the tuple values (<I>v</I><SUB>1</SUB>, &#X2026;, <I>v<SUB>n</SUB></I>) such that
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> matches <I>v<SUB>i</SUB></I> for <I>i</I> = 1,&#X2026; , <I>n</I>.</P><!--TOC subsubsection Record patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Record patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>
&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> matches records that define at least the fields
<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> through <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>, and such that the value associated to
<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>i</SUB></I> matches the pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>, for <I>i</I> = 1,&#X2026; , <I>n</I>.
The record value can define more fields than <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>; the values associated to these extra fields are not taken
into account for matching.</P><!--TOC subsubsection Array patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Array patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>[|</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT>
matches arrays of length <I>n</I> such that the <I>i</I>-th array element
matches the pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>, for <I>i</I> = 1,&#X2026; , <I>n</I>.</P><!--TOC section Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">6.7</A>&#XA0;&#XA0;Expressions<A NAME="s:value-expr"></A></H2><!--SEC END --><!--NAME expr.html-->
<P>
<A NAME="@manual.kwd8"></A>
<A NAME="@manual.kwd9"></A>
<A NAME="@manual.kwd10"></A>
<A NAME="@manual.kwd11"></A>
<A NAME="@manual.kwd12"></A>
<A NAME="@manual.kwd13"></A>
<A NAME="@manual.kwd14"></A>
<A NAME="@manual.kwd15"></A>
<A NAME="@manual.kwd16"></A>
<A NAME="@manual.kwd17"></A>
<A NAME="@manual.kwd18"></A>
<A NAME="@manual.kwd19"></A>
<A NAME="@manual.kwd20"></A>
<A NAME="@manual.kwd21"></A>
<A NAME="@manual.kwd22"></A>
<A NAME="@manual.kwd23"></A>
<A NAME="@manual.kwd24"></A>
<A NAME="@manual.kwd25"></A>
<A NAME="@manual.kwd26"></A>
<A NAME="@manual.kwd27"></A>
<A NAME="@manual.kwd28"></A>
<A NAME="@manual.kwd29"></A>
<A NAME="@manual.kwd30"></A>
<A NAME="@manual.kwd31"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#value-path" class="syntax"><FONT COLOR=maroon>value-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constant" class="syntax"><FONT COLOR=maroon>constant</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>begin</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>::</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>[|</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>|]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I>&#XA0;}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;<I><A href="#infix-op" class="syntax"><FONT COLOR=maroon>infix-op</FONT></A></I>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>&lt;-</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.(</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.(</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;<FONT COLOR=blue><TT>&lt;-</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.[</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.[</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>&#XA0;<FONT COLOR=blue><TT>&lt;-</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>if</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>then</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;[&#XA0;<FONT COLOR=blue><TT>else</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>while</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>do</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>done</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>for</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;(&#XA0;<FONT COLOR=blue><TT>to</TT></FONT>&#XA0;&#X2223;&#XA0;&#XA0;<FONT COLOR=blue><TT>downto</TT></FONT>&#XA0;)&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>do</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>done</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>match</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern-matching" class="syntax"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>function</TT></FONT>&#XA0;<I><A href="#pattern-matching" class="syntax"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>fun</TT></FONT>&#XA0;<I><A href="#multiple-matching" class="syntax"><FONT COLOR=maroon>multiple-matching</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>try</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern-matching" class="syntax"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>let</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>rec</TT></FONT>]&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>&#XA0;&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>in</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>new</TT></FONT>&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>object</TT></FONT>&#XA0;<I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>&lt;-</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{&lt;</TT></FONT>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>&gt;}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>assert</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>lazy</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="pattern-matching" class="syntax"><FONT COLOR=maroon>pattern-matching</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;]&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>when</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>when</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="multiple-matching" class="syntax"><FONT COLOR=maroon>multiple-matching</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{&#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>&#XA0;}<SUP>+</SUP>&#XA0;&#XA0;[<FONT COLOR=blue><TT>when</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;&#XA0;{&#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>~</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>?</TT></FONT>&#XA0;<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>)</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed constructions. The constructions with higher
precedence come first. For infix and prefix symbols, we write
&#X201C;<TT>*</TT>&#X2026;&#X201D; to mean &#X201C;any symbol starting with <TT>*</TT>&#X201D;.
<A NAME="@manual.kwd32"></A><A NAME="@manual.kwd33"></A><A NAME="@manual.kwd34"></A><A NAME="@manual.kwd35"></A><A NAME="@manual.kwd36"></A><A NAME="@manual.kwd37"></A><A NAME="@manual.kwd38"></A></P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Construction or operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
prefix-symbol</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>.   .(    .[</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP>function application, constructor application, <TT>assert</TT>, <TT>lazy</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>-   -.</TT> (prefix)</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>**</TT>&#X2026;<TT>   lsl   lsr   asr</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>*</TT>&#X2026;<TT>   /</TT>&#X2026;<TT>   %</TT>&#X2026;<TT>   mod   land   lor   lxor</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>+</TT>&#X2026;<TT>   -</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>::</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@</TT>&#X2026;<TT>   ^</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>=</TT>&#X2026;<TT>   &lt;</TT>&#X2026;<TT>   &gt;</TT>&#X2026;<TT>   |</TT>&#X2026;<TT>   &amp;</TT>&#X2026;<TT>   $</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&amp;   &amp;&amp;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>or  ||</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>,</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;-   :=</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>if</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>let  match  fun  function  try</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><!--TOC subsection Basic expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">6.7.1</A>&#XA0;&#XA0;Basic expressions</H3><!--SEC END --><!--TOC subsubsection Constants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constants</H4><!--SEC END --><P>Expressions consisting in a constant evaluate to this constant.</P><!--TOC subsubsection Value paths-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value paths</H4><!--SEC END --><P> <A NAME="expr:var"></A></P><P>Expressions consisting in an access path evaluate to the value bound to
this path in the current evaluation environment. The path can
be either a value name or an access path to a value component of a module.</P><!--TOC subsubsection Parenthesized expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized expressions</H4><!--SEC END --><P>
<A NAME="@manual.kwd39"></A>
<A NAME="@manual.kwd40"></A></P><P>The expressions <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> and <FONT COLOR=blue><TT>begin</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> have the same
value as <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. The two constructs are semantically equivalent, but it
is good style to use <FONT COLOR=blue><TT>begin</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> inside control structures:
</P><PRE>
        if &#X2026; then begin &#X2026; ; &#X2026; end else begin &#X2026; ; &#X2026; end
</PRE><P>
and <FONT COLOR=blue><TT>(</TT></FONT> &#X2026; <FONT COLOR=blue><TT>)</TT></FONT> for the other grouping situations.</P><P>Parenthesized expressions can contain a type constraint, as in <FONT COLOR=blue><TT>(</TT></FONT>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>. This constraint forces the type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> to be
compatible with <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><P>Parenthesized expressions can also contain coercions
<FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> &#XA0;[<FONT COLOR=blue><TT>:</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>:&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT> (see
subsection&#XA0;<A HREF="#s:coercions">6.7.6</A> below).</P><!--TOC subsubsection Function application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function application</H4><!--SEC END --><P>Function application is denoted by juxtaposition of (possibly labeled)
expressions. The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> &#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>
evaluates the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> and those appearing in <I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>
to <I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>. The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> must evaluate to a
functional value <I>f</I>, which is then applied to the values of 
<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>, &#X2026;, &#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>.</P><P>The order in which the expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, &#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>, &#X2026;,
&#XA0;<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I> are evaluated is not specified.</P><P>Arguments and parameters are matched according to their respective
labels. Argument order is irrelevant, except among arguments with the
same label, or no label.</P><P>If a parameter is specified as optional (label prefixed by <TT>?</TT>) in the
type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the corresponding argument will be automatically
wrapped with the constructor <TT>Some</TT>, except if the argument itself is
also prefixed by <TT>?</TT>, in which case it is passed as is.
If a non-labeled argument is passed, and its corresponding parameter
is preceded by one or several optional parameters, then these
parameters are <EM>defaulted</EM>, <EM>i.e.</EM> the value <TT>None</TT> will be
passed for them.
All other missing parameters (without corresponding argument), both
optional and non-optional, will be kept, and the result of the
function will still be a function of these missing parameters to the
body of <I>f</I>.</P><P>As a special case, if the function has a known arity, all the
arguments are unlabeled, and their number matches the number of
non-optional parameters, then labels are ignored and non-optional
parameters are matched in their definition order. Optional arguments
are defaulted.</P><P>In all cases but exact match of order and labels, without optional
parameters, the function type should be known at the application
point. This can be ensured by adding a type constraint. Principality
of the derivation can be checked in the <TT>-principal</TT> mode.</P><!--TOC subsubsection Function definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function definition</H4><!--SEC END --><P>Two syntactic forms are provided to define functions. The first form
is introduced by the keyword <TT>function</TT>:
<A NAME="@manual.kwd41"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>function</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
This expression evaluates to a functional value with one argument.
When this function is applied to a value <I>v</I>, this value is
matched against each pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>.
If one of these matchings succeeds, that is, if the value <I>v</I>
matches the pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> for some <I>i</I>,
then the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> associated to the selected pattern
is evaluated, and its value becomes the value of the function
application. The evaluation of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an
environment enriched by the bindings performed during the matching.</P><P>If several patterns match the argument <I>v</I>, the one that occurs
first in the function definition is selected. If none of the patterns
matches the argument, the exception <TT>Match_failure</TT> is raised.
<A NAME="@manual0"></A></P><P><BR>
</P><P>The other form of function definition is introduced by the keyword <TT>fun</TT>:
<A NAME="@manual.kwd42"></A>
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
This expression is equivalent to:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT> &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>The parameter patterns <TT>~var</TT> and <FONT COLOR=blue><TT>~(var</TT></FONT> [<FONT COLOR=blue><TT>:</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>])</TT></FONT>
are shorthands for respectively <TT>~var:var</TT> and
<FONT COLOR=blue><TT>~var:(var</TT></FONT> [<FONT COLOR=blue><TT>:</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]<FONT COLOR=blue><TT>)</TT></FONT>, and similarly for their optional
counterparts.</P><P>Functions of the form <FONT COLOR=blue><TT>fun</TT> <TT>?lab:(</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>
&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> are equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT> <TT>?lab:</TT></FONT><I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT>
<TT>let</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>=</TT>
<TT>match</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>with</TT> <TT>Some</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>|</TT> <TT>None</TT> <TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB>
<FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
where <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
is a fresh variable. When <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> will be evaluated is left
unspecified.</P><P>After these two transformations, expressions are of the form
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> [<I><A href="#label" class="syntax"><FONT COLOR=maroon>label</FONT></A></I><SUB>1</SUB>] &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT> &#XA0;[<I><A href="#label" class="syntax"><FONT COLOR=maroon>label</FONT></A><SUB>n</SUB></I>] &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
If we ignore labels, which will only be meaningful at function
application, this is equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>function</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>function</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
That is, the <TT>fun</TT> expression above evaluates to a curried function
with <I>n</I> arguments: after applying this function <I>n</I> times to the
values <I>v</I><SUB>1</SUB>&#XA0;&#X2026;&#XA0;<I>v<SUB>m</SUB></I>, the values will be matched
in parallel against the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>.
If the matching succeeds, the function returns the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> in
an environment enriched by the bindings performed during the matchings.
If the matching fails, the exception <TT>Match_failure</TT> is raised.</P><!--TOC subsubsection Guards in pattern-matchings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Guards in pattern-matchings</H4><!--SEC END --><P><A NAME="@manual.kwd43"></A>
Cases of a pattern matching (in the <TT>function</TT>, <TT>fun</TT>, <TT>match</TT> and
<TT>try</TT> constructs) can include guard expressions, which are
arbitrary boolean expressions that must evaluate to <TT>true</TT> for the
match case to be selected. Guards occur just before the <TT>-&gt;</TT> token and
are introduced by the <TT>when</TT> keyword:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>function</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB>&#XA0;&#XA0;&#XA0;[<FONT COLOR=blue><TT>when</TT></FONT>&#XA0;&#XA0;&#XA0;<FONT COLOR=maroon><I>cond</I></FONT><SUB>1</SUB>]</TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I>&#XA0;&#XA0;&#XA0;&#XA0;[<FONT COLOR=blue><TT>when</TT></FONT>&#XA0;&#XA0;&#XA0;<I><FONT COLOR=maroon>cond</FONT><SUB>n</SUB></I>]</TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Matching proceeds as described before, except that if the value
matches some pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> which has a guard <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I>, then the
expression <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> is evaluated (in an environment enriched by the
bindings performed during matching). If <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> evaluates to <TT>true</TT>,
then <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated and its value returned as the result of the
matching, as usual. But if <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> evaluates to <TT>false</TT>, the matching
is resumed against the patterns following <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>.</P><!--TOC subsubsection Local definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Local definitions</H4><!--SEC END --><P> <A NAME="s:localdef"></A></P><P><A NAME="@manual.kwd44"></A></P><P>The <TT>let</TT> and <TT>let rec</TT> constructs bind value names locally.
The construct
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
evaluates <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> in some unspecified order, then matches
their values against the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the
matchings succeed, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is evaluated in the environment enriched by
the bindings performed during matching, and the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is
returned as the value of the whole <TT>let</TT> expression. If one of the
matchings fails, the exception <TT>Match_failure</TT> is raised.
<A NAME="@manual1"></A></P><P>An alternate syntax is provided to bind variables to functional
values: instead of writing
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT> &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
in a <TT>let</TT> expression, one may instead write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P><BR>
Recursive definitions of names are introduced by <TT>let rec</TT>:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>
<FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
The only difference with the <TT>let</TT> construct described above is
that the bindings of names to values performed by the
pattern-matching are considered already performed when the expressions
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are evaluated. That is, the expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>
to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> can reference identifiers that are bound by one of the
patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>, &#X2026;, &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>, and expect them to have the
same value as in <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the body of the <TT>let rec</TT> construct.</P><P>The recursive definition is guaranteed to behave as described above if
the expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are function definitions
(<FONT COLOR=blue><TT>fun</TT></FONT> &#X2026; or <FONT COLOR=blue><TT>function</TT></FONT> &#X2026;), and the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>
&#X2026; &#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> are just value names, as in:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
This defines <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> as mutually recursive functions
local to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. </P><P>The behavior of other forms of <TT>let rec</TT> definitions is
implementation-dependent. The current implementation also supports
a certain class of recursive definitions of non-functional values,
as explained in section&#XA0;<A HREF="#s:letrecvalues">7.3</A>.</P><!--TOC subsection Control structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">6.7.2</A>&#XA0;&#XA0;Control structures</H3><!--SEC END --><!--TOC subsubsection Sequence-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Sequence</H4><!--SEC END --><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> first, then
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, and returns the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.</P><!--TOC subsubsection Conditional-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Conditional</H4><!--SEC END --><P>
<A NAME="@manual.kwd45"></A></P><P>The expression <FONT COLOR=blue><TT>if</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>else</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> evaluates to
the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> if <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to the boolean <FONT COLOR=blue><TT>true</TT></FONT>,
and to the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> if <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to the boolean
<FONT COLOR=blue><TT>false</TT></FONT>.</P><P>The <FONT COLOR=blue><TT>else</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> part can be omitted, in which case it defaults to
<FONT COLOR=blue><TT>else</TT> <TT>()</TT></FONT>.</P><!--TOC subsubsection Case expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Case expression</H4><!--SEC END --><P><A NAME="@manual.kwd46"></A></P><P>The expression
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>match</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>with</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
matches the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> against the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the matching against <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> succeeds, the
associated expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated, and its value becomes the
value of the whole <FONT COLOR=blue><TT>match</TT></FONT> expression. The evaluation of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an environment enriched by the bindings
performed during matching. If several patterns match the value of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the one that occurs first in the <FONT COLOR=blue><TT>match</TT></FONT> expression is
selected. If none of the patterns match the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the
exception <FONT COLOR=blue><TT>Match_failure</TT></FONT> is raised.
<A NAME="@manual2"></A></P><!--TOC subsubsection Boolean operators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Boolean operators</H4><!--SEC END --><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT> if both
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluate to <FONT COLOR=blue><TT>true</TT></FONT>; otherwise, it evaluates to
<FONT COLOR=blue><TT>false</TT></FONT>. The first component, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, is evaluated first. The
second component, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, is not evaluated if the first component
evaluates to <FONT COLOR=blue><TT>false</TT></FONT>. Hence, the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> behaves
exactly as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>if</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>else</TT> <TT>false</TT></FONT>.
</DIV><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>||</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT> if one of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT>; otherwise, it evaluates to
<FONT COLOR=blue><TT>false</TT></FONT>. The first component, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, is evaluated first. The
second component, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, is not evaluated if the first component
evaluates to <FONT COLOR=blue><TT>true</TT></FONT>. Hence, the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>||</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> behaves
exactly as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>if</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT> <TT>true</TT> <TT>else</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.
</DIV><P><A NAME="@manual.kwd47"></A>
The boolean operator <FONT COLOR=blue><TT>&amp;</TT></FONT> is synonymous for <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT>. The boolean operator
<FONT COLOR=blue><TT>or</TT></FONT> is synonymous for <FONT COLOR=blue><TT>||</TT></FONT>.</P><!--TOC subsubsection Loops-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Loops</H4><!--SEC END --><P><A NAME="@manual.kwd48"></A>
The expression <FONT COLOR=blue><TT>while</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>do</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>done</TT></FONT> repeatedly
evaluates <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> while <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT>. The loop
condition <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> is evaluated and tested at the beginning of each
iteration. The whole <FONT COLOR=blue><TT>while</TT></FONT> &#X2026; <FONT COLOR=blue><TT>done</TT></FONT> expression evaluates to
the unit value <FONT COLOR=blue><TT>()</TT></FONT>.</P><P><A NAME="@manual.kwd49"></A>
The expression <FONT COLOR=blue><TT>for</TT> <FONT COLOR=maroon><I>name</I></FONT> <TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>to</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>do</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> <FONT COLOR=blue><TT>done</TT></FONT>
first evaluates the expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> (the boundaries)
into integer values <I>n</I> and <I>p</I>. Then, the loop body <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> is
repeatedly evaluated in an environment where <FONT COLOR=maroon><I>name</I></FONT> is successively
bound to the values
<I>n</I>, <I>n</I>+1, &#X2026;, <I>p</I>&#X2212;1, <I>p</I>.
The loop body is never evaluated if <I>n</I> &gt; <I>p</I>.</P><P>The expression <FONT COLOR=blue><TT>for</TT> <FONT COLOR=maroon><I>name</I></FONT> <TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>downto</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>do</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> <FONT COLOR=blue><TT>done</TT></FONT>
evaluates similarly, except that <FONT COLOR=maroon><I>name</I></FONT> is successively bound to the values
<I>n</I>, <I>n</I>&#X2212;1, &#X2026;, <I>p</I>+1, <I>p</I>.
The loop body is never evaluated if <I>n</I> &lt; <I>p</I>.</P><P>In both cases, the whole <FONT COLOR=blue><TT>for</TT></FONT> expression evaluates to the unit
value <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Exception handling-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception handling</H4><!--SEC END --><P>
<A NAME="@manual.kwd50"></A></P><P>The expression
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>try&#XA0;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>with</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
evaluates the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> and returns its value if the
evaluation of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> does not raise any exception. If the evaluation
of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> raises an exception, the exception value is matched against
the patterns <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the matching against
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> succeeds, the associated expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated,
and its value becomes the value of the whole <FONT COLOR=blue><TT>try</TT></FONT> expression. The
evaluation of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an environment enriched by the
bindings performed during matching. If several patterns match the value of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the one that occurs first in the <FONT COLOR=blue><TT>try</TT></FONT> expression is
selected. If none of the patterns matches the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, the
exception value is raised again, thereby transparently &#X201C;passing
through&#X201D; the <FONT COLOR=blue><TT>try</TT></FONT> construct.</P><!--TOC subsection Operations on data structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">6.7.3</A>&#XA0;&#XA0;Operations on data structures</H3><!--SEC END --><!--TOC subsubsection Products-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Products</H4><!--SEC END --><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> evaluates to the
<I>n</I>-tuple of the values of expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>. The
evaluation order for the subexpressions is not specified.</P><!--TOC subsubsection Variants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variants</H4><!--SEC END --><P>The expression <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to the variant value whose
constructor is <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>, and whose argument is the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>For lists, some syntactic sugar is provided. The expression
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> stands for the constructor <FONT COLOR=blue><TT>(</TT> <TT>::</TT> <TT>)</TT></FONT> 
applied to the argument <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT>, and therefore
evaluates to the list whose head is the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and whose tail
is the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>. The expression <FONT COLOR=blue><TT>[</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>
&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> is equivalent to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#X2026; <FONT COLOR=blue><TT>::</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>::</TT>
<TT>[]</TT></FONT>, and therefore evaluates to the list whose elements are the
values of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Polymorphic variants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variants</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to the polymorphic variant
value whose tag is <I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I>, and whose argument is the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.</P><!--TOC subsubsection Records-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Records</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>
&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> evaluates to the record value
{ <I>field</I><SUB>1</SUB> = <I>v</I><SUB>1</SUB>; &#X2026;; <I>field<SUB>n</SUB></I> = <I>v<SUB>n</SUB></I> }
where <I>v<SUB>i</SUB></I> is the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> for <I>i</I> = 1,&#X2026; , <I>n</I>.
The fields <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> to <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> must all belong to the same record
types; all fields belonging to this record type must appear exactly
once in the record expression, though they can appear in any
order. The order in which <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are evaluated is not
specified.</P><P>The expression
<FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT>
builds a fresh record with fields <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> equal to
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>, and all other fields having the same value as
in the record <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. In other terms, it returns a shallow copy of
the record <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, except for the fields <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>,
which are initialized to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> evaluates <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to a record
value, and returns the value associated to <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> in this record
value.</P><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to a record
value, which is then modified in-place by replacing the value
associated to <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> in this record by the value of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>. This operation is permitted only if <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> has been
declared <FONT COLOR=blue><TT>mutable</TT></FONT> in the definition of the record type. The whole
expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to the unit value
<FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>[|</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT> evaluates to
a <I>n</I>-element array, whose elements are initialized with the values of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> respectively. The order in which these
expressions are evaluated is unspecified.</P><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.(</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT> returns the value of element
number <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> in the array denoted by <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>. The first element
has number 0; the last element has number <I>n</I>&#X2212;1, where <I>n</I> is the
size of the array. The exception <TT>Invalid_argument</TT> is raised if the
access is out of bounds.</P><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.(</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT> <TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> modifies in-place
the array denoted by <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, replacing element number <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> by
the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB>. The exception <TT>Invalid_argument</TT> is raised if
the access is out of bounds. The value of the whole expression is <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Strings</H4><!--SEC END --><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.[</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>]</TT></FONT> returns the value of character
number <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> in the string denoted by <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>. The first character
has number 0; the last character has number <I>n</I>&#X2212;1, where <I>n</I> is the
length of the string. The exception <TT>Invalid_argument</TT> is raised if the
access is out of bounds.</P><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.[</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>]</TT> <TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> modifies in-place
the string denoted by <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, replacing character number <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> by
the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB>. The exception <TT>Invalid_argument</TT> is raised if
the access is out of bounds. The value of the whole expression is <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsection Operators-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">6.7.4</A>&#XA0;&#XA0;Operators</H3><!--SEC END --><P>Symbols from the class <FONT COLOR=blue><TT>infix-symbols</TT></FONT>, as well as the keywords
<TT>*</TT>, <TT>=</TT>, <TT>or</TT> and <TT>&amp;</TT>, can appear in infix position (between two
expressions). Symbols from the class <FONT COLOR=blue><TT>prefix-symbols</TT></FONT>
can appear in prefix position (in front of an expression).</P><P>Infix and prefix symbols do not have a fixed meaning: they are simply
interpreted as applications of functions bound to the names
corresponding to the symbols. The expression <I><A href="#prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is
interpreted as the application <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#prefix-symbol" class="syntax"><FONT COLOR=maroon>prefix-symbol</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. Similarly, the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#XA0;<I><A href="#infix-symbol" class="syntax"><FONT COLOR=maroon>infix-symbol</FONT></A></I> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> is
interpreted as the application <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#infix-symbol" class="syntax"><FONT COLOR=maroon>infix-symbol</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.</P><P>The table below lists the symbols defined in the initial environment
and their initial meaning. (See the description of the core
library module <TT>Pervasives</TT> in chapter&#XA0;<A HREF="#c:corelib">20</A> for more
details). Their meaning may be changed at any time using
<FONT COLOR=blue><TT>let</TT> <TT>(</TT></FONT> <I><A href="#infix-op" class="syntax"><FONT COLOR=maroon>infix-op</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#X2026;</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Initial meaning</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>+</TT></TD><TD VALIGN=top ALIGN=left>Integer addition.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-</TT> (infix)</TD><TD VALIGN=top ALIGN=left>Integer subtraction.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-</TT> (prefix)</TD><TD VALIGN=top ALIGN=left>Integer negation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>*</TT></TD><TD VALIGN=top ALIGN=left>Integer multiplication.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>/</TT></TD><TD VALIGN=top ALIGN=left>Integer division.
Raise <TT>Division_by_zero</TT> if second argument is zero.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>mod</TT></TD><TD VALIGN=top ALIGN=left>Integer modulus. Raise
<TT>Division_by_zero</TT> if second argument is zero.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>land</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;and&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lor</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;or&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lxor</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;exclusive or&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lsl</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical shift left on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lsr</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical shift right on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>asr</TT></TD><TD VALIGN=top ALIGN=left>Bitwise arithmetic shift right on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>+.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point addition.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-.</TT> (infix)</TD><TD VALIGN=top ALIGN=left>Floating-point subtraction.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-.</TT> (prefix)</TD><TD VALIGN=top ALIGN=left>Floating-point negation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>*.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point multiplication.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>/.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point division.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>**</TT></TD><TD VALIGN=top ALIGN=left>Floating-point exponentiation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>@</TT> </TD><TD VALIGN=top ALIGN=left>List concatenation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>^</TT> </TD><TD VALIGN=top ALIGN=left>String concatenation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>!</TT> </TD><TD VALIGN=top ALIGN=left>Dereferencing (return the current
contents of a reference).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>:=</TT></TD><TD VALIGN=top ALIGN=left>Reference assignment (update the
reference given as first argument with the value of the second
argument).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>=</TT> </TD><TD VALIGN=top ALIGN=left>Structural equality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;&gt;</TT> </TD><TD VALIGN=top ALIGN=left>Structural inequality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>==</TT> </TD><TD VALIGN=top ALIGN=left>Physical equality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>!=</TT> </TD><TD VALIGN=top ALIGN=left>Physical inequality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;less than&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;=</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;less than or equal&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&gt;</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;greater than&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&gt;=</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;greater than or equal&#X201D;.</TD></TR>
</TABLE></DIV><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">6.7.5</A>&#XA0;&#XA0;Objects</H3><!--SEC END --><P> <A NAME="s:objects"></A></P><!--TOC subsubsection Object creation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object creation</H4><!--SEC END --><P><A NAME="@manual.kwd51"></A></P><P>When <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to a class body, <FONT COLOR=blue><TT>new</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to an object containing the instance variables and
methods of this class.</P><P>When <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to a class function, <FONT COLOR=blue><TT>new</TT></FONT> <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to a function expecting the same number of arguments and
returning a new object of this class.</P><!--TOC subsubsection Immediate object creation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Immediate object creation</H4><!--SEC END --><P><A NAME="@manual.kwd52"></A></P><P>Creating directly an object through the <FONT COLOR=blue><TT>object</TT></FONT> <I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
construct is operationally equivalent to defining locally a <FONT COLOR=blue><TT>class</TT></FONT>
<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>object</TT></FONT> &#XA0;<I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> &#X2014;see sections
<A HREF="#ss:class-body">6.9.2</A> and following for the syntax of <I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I>&#X2014;
and immediately creating a single object from it by <FONT COLOR=blue><TT>new</TT></FONT> <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>.</P><P>The typing of immediate objects is slightly different from explicitely
defining a class in two respects. First, the inferred object type may
contain free type variables. Second, since the class body of an
immediate object will never be extended, its self type can be unified
with a closed object type.</P><!--TOC subsubsection Message sending-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Message sending</H4><!--SEC END --><P>The expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT> &#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> invokes the method
<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> of the object denoted by <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>If <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> is a polymorphic method, its type should be known at
the invocation site. This is true for instance if <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is the name
of a fresh object (<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> = <FONT COLOR=blue><TT>new</TT></FONT> &#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> &#X2026; ) or if
there is a type constraint. Principality of the derivation can be
checked in the <TT>-principal</TT> mode.</P><!--TOC subsubsection Accessing and modifying instance variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Accessing and modifying instance variables</H4><!--SEC END --><P>The instance variables of a class are visible only in the body of the
methods defined in the same class or a class that inherits from the
class defining the instance variables. The expression <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
evaluates to the value of the given instance variable. The expression
<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> assigns the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> to the instance
variable <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>, which must be mutable. The whole expression
<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Object duplication-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object duplication</H4><!--SEC END --><P>An object can be duplicated using the library function <TT>Oo.copy</TT>
(see 
<A HREF="libref/Oo.html">Module <TT>Oo</TT></A>). Inside a method, the expression
 <FONT COLOR=blue><TT>{&lt;</TT></FONT> <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>;</TT></FONT> <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>&gt;}</TT></FONT>
returns a copy of self with the given instance variables replaced by
the values of the associated expressions; other instance variables
have the same value in the returned object as in self.</P><!--TOC subsection Coercions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">6.7.6</A>&#XA0;&#XA0;Coercions</H3><!--SEC END --><P> <A NAME="s:coercions"></A></P><P>Expressions whose type contains object or polymorphic variant types
can be explicitly coerced (weakened) to a supertype.
The expression <FONT COLOR=blue><TT>(</TT></FONT><I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT> coerces the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
to type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.
The expression <FONT COLOR=blue><TT>(</TT></FONT><I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB><FONT COLOR=blue><TT>)</TT></FONT> coerces the
expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> from type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><P>The former operator will sometimes fail to coerce an expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
from a type <I>t</I><SUB>1</SUB> to a type <I>t</I><SUB>2</SUB> even if type <I>t</I><SUB>1</SUB> is a subtype of type
<I>t</I><SUB>2</SUB>: in the current implementation it only expands two levels of
type abbreviations containing objects and/or polymorphic variants,
keeping only recursion when it is explicit in the class type (for objects).
As an exception to the above algorithm, if both the inferred type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> are ground (<EM>i.e.</EM> do not contain type variables), the
former operator behaves as the latter one, taking the inferred type of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> as <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>. In case of failure with the former operator,
the latter one should be used.</P><P>It is only possible to coerce an expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> from type
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>, if the type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is an instance of
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> (like for a type annotation), and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a subtype
of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. The type of the coerced expression is an
instance of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. If the types contain variables,
they may be instantiated by the subtyping algorithm, but this is only
done after determining whether <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a potential subtype of
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. This means that typing may fail during this latter
unification step, even if some instance of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a subtype of
some instance of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.
In the following paragraphs we describe the subtyping relation used.</P><!--TOC subsubsection Object types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object types</H4><!--SEC END --><P>A fixed object type admits as subtype any object type including all
its methods. The types of the methods shall be subtypes of those in
the supertype. Namely,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT>&lt;&#XA0;</TT>&#XA0;<I>met</I><SUB>1</SUB>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ</I><SUB>1</SUB>&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;<I>met<SUB>n</SUB></I>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ<SUB>n</SUB></I>&#XA0;<TT>&gt;&#XA0;</TT>&#XA0;</TD></TR>
</TABLE><P>
is a supertype of
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT>&lt;&#XA0;</TT>&#XA0;<I>met</I><SUB>1</SUB>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<SUB>1</SUB>&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;<I>met<SUB>n</SUB></I>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<I><SUB>n</SUB></I>&#XA0;<TT>&#XA0;;&#XA0;</TT>
<I>met</I><SUB><I>n</I>+1</SUB>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<SUB><I>n</I>+1</SUB>&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;;&#XA0;</TT>&#XA0;<I>met</I><SUB><I>n</I>+<I>m</I></SUB>&#XA0;<TT>&#XA0;:&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<SUB><I>n</I>+<I>m</I></SUB>
&#XA0;[<TT>;&#XA0;..</TT>]&#XA0;<TT>&#XA0;&gt;</TT>&#XA0;</TD></TR>
</TABLE><P>
which may contain an ellipsis <TT>..</TT>, if every <I>typ<SUB>i</SUB></I> is a supertype of
<I>typ</I>&#X2032;<I><SUB>i</SUB></I>.</P><P>A monomorphic method type can be a supertype of a polymorphic method
type. Namely, if <FONT COLOR=maroon><I>typ</I></FONT> is an instance of <I>typ</I>&#X2032;, then <TT>'</TT><I>a</I><SUB>1</SUB>
...<TT>'</TT><I>a<SUB>n</SUB></I><TT>.</TT><I>typ</I>&#X2032; is a subtype of <FONT COLOR=maroon><I>typ</I></FONT>.</P><P>Inside a class definition, newly defined types are not available for
subtyping, as the type abbreviations are not yet completely
defined. There is an exception for coercing <FONT COLOR=maroon><I>self</I></FONT> to the (exact)
type of its class: this is allowed if the type of <FONT COLOR=maroon><I>self</I></FONT> does not
appear in a contravariant position in the class type, <EM>i.e.</EM> if
there are no binary methods.</P><!--TOC subsubsection Polymorphic variant types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant types</H4><!--SEC END --><P>A polymorphic variant type <FONT COLOR=maroon><I>typ</I></FONT> is subtype of another polymorphic
variant type <I>typ</I>&#X2032; if the upper bound of <FONT COLOR=maroon><I>typ</I></FONT> (<EM>i.e.</EM> the
maximum set of constructors that may appear in an instance of <FONT COLOR=maroon><I>typ</I></FONT>)
is included in the lower bound of <I>typ</I>&#X2032;, and the types of arguments
for the constructors of <FONT COLOR=maroon><I>typ</I></FONT> are subtypes of those in
<I>typ</I>&#X2032;. Namely,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT>[</TT>[<TT>&lt;</TT>]&#XA0;<TT>&#XA0;'</TT><I>C</I><SUB>1</SUB>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>&#XA0;<I>typ</I><SUB>1</SUB>&#XA0;<TT>&#XA0;|&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;|&#XA0;'</TT><I>C<SUB>n</SUB></I>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>&#XA0;<I>typ<SUB>n</SUB></I>&#XA0;<TT>&#XA0;]</TT>&#XA0;</TD></TR>
</TABLE><P>
which may be a shrinkable type, is a subtype of
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT>[</TT>[<TT>&gt;</TT>]&#XA0;<TT>&#XA0;'</TT><I>C</I><SUB>1</SUB>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<SUB>1</SUB>&#XA0;<TT>&#XA0;|&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;|&#XA0;'</TT><I>C<SUB>n</SUB></I>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<I><SUB>n</SUB></I>
<TT>|&#XA0;'</TT><I>C</I><SUB><I>n</I>+1</SUB>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>&#XA0;<I>typ</I>&#X2032;<SUB><I>n</I>+1</SUB>&#XA0;<TT>&#XA0;|&#XA0;</TT>&#XA0;...&#XA0;<TT>&#XA0;|&#XA0;'</TT><I>C</I><SUB><I>n</I>+<I>m</I></SUB>&#XA0;<TT>&#XA0;<I>of</I>&#XA0;</TT>
<I>typ</I>&#X2032;<SUB><I>n</I>+<I>m</I></SUB>&#XA0;<TT>&#XA0;]</TT>&#XA0;</TD></TR>
</TABLE><P>
which may be an extensible type, if every <I>typ<SUB>i</SUB></I> is a subtype of <I>typ</I>&#X2032;<I><SUB>i</SUB></I>.</P><!--TOC subsubsection Variance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variance</H4><!--SEC END --><P>Other types do not introduce new subtyping, but they may propagate the
subtyping of their arguments. For instance, <I>typ</I><SUB>1</SUB> <TT> * </TT> <I>typ</I><SUB>2</SUB> is a
subtype of <I>typ</I>&#X2032;<SUB>1</SUB> <TT> * </TT> <I>typ</I>&#X2032;<SUB>2</SUB> when <I>typ</I><SUB>1</SUB> and <I>typ</I><SUB>2</SUB> are
respectively subtypes of <I>typ</I>&#X2032;<SUB>1</SUB> and <I>typ</I>&#X2032;<SUB>2</SUB>.
For function types, the relation is more subtle:
<I>typ</I><SUB>1</SUB> <TT>-&gt;</TT> <I>typ</I><SUB>2</SUB> is a subtype of <I>typ</I>&#X2032;<SUB>1</SUB> <TT>-&gt;</TT> <I>typ</I>&#X2032;<SUB>2</SUB>
if <I>typ</I><SUB>1</SUB> is a supertype of <I>typ</I>&#X2032;<SUB>1</SUB> and <I>typ</I><SUB>2</SUB> is a
subtype of <I>typ</I>&#X2032;<SUB>2</SUB>. For this reason, function types are covariant in
their second argument (like tuples), but contravariant in their first
argument. Mutable types, like <TT>array</TT> or <TT>ref</TT> are neither covariant
nor contravariant, they are nonvariant, that is they do not propagate
subtyping.</P><P>For user defined types, the variance is automatically inferred: a
parameter is covariant if it has only covariant occurences,
contravariant if it has only contravariant occurences,
variance-free if it has no occurences, and nonvariant otherwise.
A variance-free parameter may change freely through subtyping, it does
not have to be a subtype or a supertype.
For abstract and private types, the variance must be given explicitly,
otherwise the default is nonvariant. This is also the case for
constrained arguments in type definitions.</P><!--TOC section Type and exception definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc73">6.8</A>&#XA0;&#XA0;Type and exception definitions</H2><!--SEC END --><!--TOC subsection Type definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.8.1</A>&#XA0;&#XA0;Type definitions</H3><!--SEC END --><P>
<A NAME="s:type-defs"></A></P><P>Type definitions bind type constructors to data types: either
variant types, record types, type abbreviations, or abstract data
types. They also bind the value constructors and record fields
associated with the definition.</P><P><A NAME="@manual.kwd53"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-definition" class="syntax"><FONT COLOR=maroon>type-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<I><A href="#type-params" class="syntax"><FONT COLOR=maroon>type-params</FONT></A></I>]&#XA0;&#XA0;<I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>&#XA0;&#XA0;[<I><A href="#type-information" class="syntax"><FONT COLOR=maroon>type-information</FONT></A></I>]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-information" class="syntax"><FONT COLOR=maroon>type-information</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<I><A href="#type-equation" class="syntax"><FONT COLOR=maroon>type-equation</FONT></A></I>]&#XA0;&#XA0;[<I><A href="#type-representation" class="syntax"><FONT COLOR=maroon>type-representation</FONT></A></I>]&#XA0;&#XA0;{&#XA0;<I><A href="#type-constraint" class="syntax"><FONT COLOR=maroon>type-constraint</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-equation" class="syntax"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-representation" class="syntax"><FONT COLOR=maroon>type-representation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-params" class="syntax"><FONT COLOR=maroon>type-params</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#type-param" class="syntax"><FONT COLOR=maroon>type-param</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#type-param" class="syntax"><FONT COLOR=maroon>type-param</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#type-param" class="syntax"><FONT COLOR=maroon>type-param</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-param" class="syntax"><FONT COLOR=maroon>type-param</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<I><A href="#variance" class="syntax"><FONT COLOR=maroon>variance</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="variance" class="syntax"><FONT COLOR=maroon>variance</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>+</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>-</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>of</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>mutable</TT></FONT>&#XA0;<I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-constraint" class="syntax"><FONT COLOR=maroon>type-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>constraint</TT></FONT>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<A NAME="@manual.kwd54"></A>
<A NAME="@manual.kwd55"></A></P><P>Type definitions are introduced by the <TT>type</TT> keyword, and
consist in one or several simple definitions, possibly mutually
recursive, separated by the <TT>and</TT> keyword. Each simple definition
defines one type constructor.</P><P>A simple definition consists in a lowercase identifier, possibly
preceded by one or several type parameters, and followed by an
optional type equation, then an optional type representation, and then
a constraint clause. The identifier is the name of the type
constructor being defined.</P><P>The optional type parameters are either one type variable <FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>,
for type constructors with one parameter, or a list of type variables
(<FONT COLOR=blue><TT>'</TT></FONT><I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I><SUB>1</SUB>,&#X2026;,<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A><SUB>n</SUB></I>), for type constructors with several
parameters. Each type parameter may be prefixed by a variance
constraint <FONT COLOR=blue><TT>+</TT></FONT> (resp. <FONT COLOR=blue><TT>-</TT></FONT>) indicating that the parameter is
covariant (resp. contravariant). These type parameters can appear in
the type expressions of the right-hand side of the definition,
restricted eventually by a variance constraint ; <EM>i.e.</EM> a
covariant parameter may only appear on the right side of a functional
arrow (more precisely, follow the left branch of an even number of
arrows), and a contravariant parameter only the left side (left branch of
an odd number of arrows). If the type has either a representation or
an equation, and the parameter is free (<EM>i.e.</EM> not bound via a
type constraint to a constructed type), its variance constraint is
checked but subtyping <EM>etc.</EM> will use the inferred variance of the
parameter, which may be better; otherwise (<EM>i.e.</EM> for abstract
types or non-free parameters), the variance must be given explicitly,
and the parameter is invariant if no variance was given.</P><P>The optional type equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> makes the defined type
equivalent to the type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> on the right of the <FONT COLOR=blue><TT>=</TT></FONT>
sign: one can be substituted for the other during typing.
If no type equation is given, a new type is generated: the defined type
is incompatible with any other type.</P><P>The optional type representation describes the data structure
representing the defined type, by giving the list of associated
constructors (if it is a variant type) or associated fields (if it is
a record type). If no type representation is given, nothing is
assumed on the structure of the type besides what is stated in the
optional type equation.</P><P>The type representation <FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>|</TT></FONT> <I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I> }
describes a variant type. The constructor declarations
<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I><SUB>1</SUB>, &#X2026;, &#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A><SUB>n</SUB></I> describe the constructors
associated to this variant type. The constructor
declaration <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>of</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>*</TT></FONT> &#X2026; <FONT COLOR=blue><TT>*</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>
declares the name <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> as a non-constant constructor, whose
arguments have types <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> &#X2026;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.
The constructor declaration <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>
declares the name <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> as a constant
constructor. Constructor names must be capitalized.</P><P>The type representation <FONT COLOR=blue><TT>=</TT> <TT>{</TT></FONT> <I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>;</TT></FONT> <I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
describes a record type. The field declarations <I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I><SUB>1</SUB>, &#X2026;,
&#XA0;<I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A><SUB>n</SUB></I> describe the fields associated to this record type.
The field declaration <I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> declares
<I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I> as a field whose argument has type <I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>.
The field declaration <FONT COLOR=blue><TT>mutable</TT></FONT> <I><A href="#field-name" class="syntax"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
<A NAME="@manual.kwd56"></A>
behaves similarly; in addition, it allows physical modification over
the argument to this field.
Immutable fields are covariant, but mutable fields are neither
covariant nor contravariant.
Both mutable and immutable field may have an explicitly polymorphic
type. The polymorphism of the contents is statically checked whenever
a record value is created or modified. Extracted values may have their
types instanciated.</P><P>The two components of a type definition, the optional equation and the
optional representation, can be combined independently, giving
rise to four typical situations:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Abstract type: no equation, no representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
When appearing in a module signature, this definition specifies
nothing on the type constructor, besides its number of parameters: 
its representation is hidden and it is assumed incompatible with any
other type.</DD><DT CLASS="dt-description"><B>Type abbreviation: an equation, no representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
This defines the type constructor as an abbreviation for the type
expression on the right of the <FONT COLOR=blue><TT>=</TT></FONT> sign. </DD><DT CLASS="dt-description"><B>New variant type or record type: no equation, a representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
This generates a new type constructor and defines associated
constructors or fields, through which values of that type can be
directly built or inspected.</DD><DT CLASS="dt-description"><B>Re-exported variant type or record type: an equation,
a representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
In this case, the type constructor is defined as an abbreviation for
the type expression given in the equation, but in addition the
constructors or fields given in the representation remain attached to
the defined type constructor. The type expression in the equation part
must agree with the representation: it must be of the same kind
(record or variant) and have exactly the same constructors or fields,
in the same order, with the same arguments. 
</DD></DL><P>The type variables appearing as type parameters can optionally be
prefixed by <TT>+</TT> or <TT>-</TT> to indicate that the type constructor is
covariant or contravariant with respect to this parameter. This
variance information is used to decide subtyping relations when
checking the validity of <FONT COLOR=blue><TT>:&gt;</TT></FONT> coercions (see section <A HREF="#s:coercions">6.7.6</A>).</P><P>For instance, <TT>type +'a t</TT> declares <TT>t</TT> as an abstract type that is
covariant in its parameter; this means that if the type &#X3C4; is a
subtype of the type &#X3C3;, then &#X3C4; <I><TT> t</TT></I> is a subtype of &#X3C3;
<I><TT> t</TT></I>. Similarly, <TT>type -'a t</TT> declares that the abstract type <TT>t</TT> is
contravariant in its parameter: if &#X3C4; is subtype of &#X3C3;, then
&#X3C3; <I><TT> t</TT></I> is subtype of &#X3C4; <I><TT> t</TT></I>. If no <TT>+</TT> or <TT>-</TT> variance
annotation is given, the type constructor is assumed invariant in the
corresponding parameter. For instance, the abstract type declaration
<TT>type 'a t</TT> means that &#X3C4; <I><TT> t</TT></I> is neither a subtype nor a
supertype of &#X3C3; <I><TT> t</TT></I> if &#X3C4; is subtype of &#X3C3;.</P><P>The variance indicated by the <TT>+</TT> and <TT>-</TT> annotations on parameters
are required only for abstract types. For abbreviations, variant
types or record types, the variance properties of the type constructor
are inferred from its definition, and the variance annotations are
only checked for conformance with the definition.</P><P><A NAME="@manual.kwd57"></A>
The construct  <FONT COLOR=blue><TT>constraint</TT> <TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>  allows the
specification of
type parameters. Any actual type argument corresponding to the type
parameter <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> has to be an instance of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> (more precisely,
<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> are unified). Type variables of <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> can
appear in the type equation and the type declaration.</P><!--TOC subsection Exception definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">6.8.2</A>&#XA0;&#XA0;Exception definitions</H3><!--SEC END --><P> <A NAME="s:excdef"></A>
<A NAME="@manual.kwd58"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="exception-definition" class="syntax"><FONT COLOR=maroon>exception-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>exception</TT></FONT>&#XA0;<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>of</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>exception</TT></FONT>&#XA0;<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Exception definitions add new constructors to the built-in variant
type <CODE>exn</CODE> of exception values. The constructors are declared as
for a definition of a variant type.</P><P>The form <FONT COLOR=blue><TT>exception</TT></FONT> <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> &#XA0;[<FONT COLOR=blue><TT>of</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>*</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> }]
generates a new exception, distinct from all other exceptions in the system.
The form <FONT COLOR=blue><TT>exception</TT></FONT> <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>
gives an alternate name to an existing exception.

</P><!--TOC section Classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">6.9</A>&#XA0;&#XA0;Classes</H2><!--SEC END --><P>Classes are defined using a small language, similar to the module
language.</P><!--TOC subsection Class types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">6.9.1</A>&#XA0;&#XA0;Class types</H3><!--SEC END --><P>Class types are the class-level equivalent of type expressions: they
specify the general shape and type properties of classes.</P><P><A NAME="@manual.kwd59"></A>
<A NAME="@manual.kwd60"></A>
<A NAME="@manual.kwd61"></A>
<A NAME="@manual.kwd62"></A>
<A NAME="@manual.kwd63"></A>
<A NAME="@manual.kwd64"></A>
<A NAME="@manual.kwd65"></A>
<A NAME="@manual.kwd66"></A>
<A NAME="@manual.kwd67"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#class-body-type" class="syntax"><FONT COLOR=maroon>class-body-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;[[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>]&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-body-type" class="syntax"><FONT COLOR=maroon>class-body-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>object</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>]&#XA0;&#XA0;{<I><A href="#class-field-spec" class="syntax"><FONT COLOR=maroon>class-field-spec</FONT></A></I>}&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>}&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>&#XA0;&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-field-spec" class="syntax"><FONT COLOR=maroon>class-field-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>inherit</TT></FONT>&#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>val</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>mutable</TT></FONT>]&#XA0;[<FONT COLOR=blue><TT>virtual</TT></FONT>]&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>virtual</TT></FONT>&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>constraint</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Simple class expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple class expressions</H4><!--SEC END --><P>The expression <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> is equivalent to the class type bound to
the name <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>. Similarly, the expression
<FONT COLOR=blue><TT>[</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> &#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> is equivalent to
the parametric class type bound to the name <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>, in which
type parameters have been instantiated to respectively <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,
&#X2026;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Class function type-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class function type</H4><!--SEC END --><P>The class type expression <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> is the type of
class functions (functions from values to classes) that take as
argument a value of type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> and return as result a class of
type <I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>.</P><!--TOC subsubsection Class body type-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class body type</H4><!--SEC END --><P>The class type expression
<FONT COLOR=blue><TT>object</TT></FONT> [<FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>] &#XA0;{<I><A href="#class-field-spec" class="syntax"><FONT COLOR=maroon>class-field-spec</FONT></A></I>} <FONT COLOR=blue><TT>end</TT></FONT>
is the type of a class body. It specifies its instance variables and
methods. In this type, <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> is matched against the self type, therefore
providing a binding for the self type.</P><P>A class body will match a class body type if it provides definitions
for all the components specified in the class type, and these
definitions meet the type requirements given in the class type.
Furthermore, all methods either virtual or public present in the class
body must also be present in the class type (on the other hand, some
instance variables and concrete private methods may be omitted). A
virtual method will match a concrete method, which makes it possible
to forget its implementation. An immutable instance variable will match a
mutable instance variable.</P><!--TOC subsubsection Inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Inheritance</H4><!--SEC END --><P><A NAME="@manual.kwd68"></A></P><P>The inheritance construct <FONT COLOR=blue><TT>inherit</TT></FONT> <I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> provides for inclusion of
methods and instance variables from other class types.
The instance variable and method types from <I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> are added
into the current class type.</P><!--TOC subsubsection Instance variable specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Instance variable specification</H4><!--SEC END --><P><A NAME="@manual.kwd69"></A>
<A NAME="@manual.kwd70"></A>
<A NAME="@manual.kwd71"></A></P><P>A specification of an instance variable is written
<FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] [<FONT COLOR=blue><TT>virtual</TT></FONT>] <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>, where
<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
is the name of the instance variable and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> its expected type.
The flag <FONT COLOR=blue><TT>mutable</TT></FONT> indicates whether this instance variable can be
physically modified.
The flag <FONT COLOR=blue><TT>virtual</TT></FONT> indicates that this instance variable is not
initialized. It can be initialized later through inheritance.</P><P>An instance variable specification will hide any previous
specification of an instance variable of the same name.</P><!--TOC subsubsection Method specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Method specification</H4><!--SEC END --><P>
<A NAME="sec-methspec"></A></P><P><A NAME="@manual.kwd72"></A>
<A NAME="@manual.kwd73"></A></P><P>The specification of a method is written
<FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>, where
<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> is the name of the method and <I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> its
expected type, possibly polymorphic. The flag <FONT COLOR=blue><TT>private</TT></FONT> indicates
that the method cannot be accessed from outside the object.</P><P>The polymorphism may be left implicit in public method specifications:
any type variable which is not bound to a class parameter and does not
appear elsewhere inside the class specification will be assumed to be
universal, and made polymorphic in the resulting method type.
Writing an explicit polymorphic type will disable this behaviour.</P><P>Several specifications for the same method must have compatible types.
Any non-private specification of a method forces it to be public.</P><!--TOC subsubsection Virtual method specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual method specification</H4><!--SEC END --><P><A NAME="@manual.kwd74"></A>
<A NAME="@manual.kwd75"></A>
<A NAME="@manual.kwd76"></A></P><P>Virtual method specification is written <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>]
<FONT COLOR=blue><TT>virtual</TT></FONT> <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>, where <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> is the
name of the method and <I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> its expected type.</P><!--TOC subsubsection Constraints on type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constraints on type parameters</H4><!--SEC END --><P><A NAME="@manual.kwd77"></A></P><P>The construct <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.</P><!--TOC subsection Class expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">6.9.2</A>&#XA0;&#XA0;Class expressions</H3><!--SEC END --><P>Class expressions are the class-level equivalent of value expressions:
they evaluate to classes, thus providing implementations for the
specifications expressed in class types.</P><P><A NAME="@manual.kwd78"></A>
<A NAME="@manual.kwd79"></A>
<A NAME="@manual.kwd80"></A>
<A NAME="@manual.kwd81"></A>
<A NAME="@manual.kwd82"></A>
<A NAME="@manual.kwd83"></A>
<A NAME="@manual.kwd84"></A>
<A NAME="@manual.kwd85"></A>
<A NAME="@manual.kwd86"></A>
<A NAME="@manual.kwd87"></A>
<A NAME="@manual.kwd88"></A>
<A NAME="@manual.kwd89"></A>
<A NAME="@manual.kwd90"></A>
<A NAME="@manual.kwd91"></A>
<A NAME="@manual.kwd92"></A>
<A NAME="@manual.kwd93"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>}&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>&#XA0;&#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>&#XA0;&#XA0;{<I><A href="#argument" class="syntax"><FONT COLOR=maroon>argument</FONT></A></I>}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>fun</TT></FONT>&#XA0;{<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>}<SUP>+</SUP>&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>let</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>rec</TT></FONT>]&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>&#XA0;&#XA0;{<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>}&#XA0;<FONT COLOR=blue><TT>in</TT></FONT>&#XA0;&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>object</TT></FONT>&#XA0;<I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-field" class="syntax"><FONT COLOR=maroon>class-field</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>inherit</TT></FONT>&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>as</TT></FONT>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>val</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>mutable</TT></FONT>]&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>val</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>mutable</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>virtual</TT></FONT>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;&#XA0;{<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>}&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<FONT COLOR=blue><TT>virtual</TT></FONT>&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>constraint</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>initializer</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Simple class expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple class expressions</H4><!--SEC END --><P>The expression <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to the class bound to the name
<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>. Similarly, the expression
<FONT COLOR=blue><TT>[</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> &#XA0;<I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to the parametric class bound to the name <I><A href="#class-path" class="syntax"><FONT COLOR=maroon>class-path</FONT></A></I>,
in which type parameters have been instantiated to respectively
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>, &#X2026;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> evaluates to the same module as
<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> checks that
<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> match the type of <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> (that is, that the
implementation <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> meets the type specification
<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>). The whole expression evaluates to the same class as
<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>, except that all components not specified in
<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I> are hidden and can no longer be accessed.</P><!--TOC subsubsection Class application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class application</H4><!--SEC END --><P>Class application is denoted by juxtaposition of (possibly labeled)
expressions. It denotes the class whose constructor is the original
constructor applied to the given arguments. The arguments are
evaluated like for expression application, but the constructor itself will
only be evaluated when objects are created. In particular, side-effects
caused by the application of the constructor will only occur at object
creation time.</P><!--TOC subsubsection Class function-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class function</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>fun</TT></FONT> [[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A href="#label-name" class="syntax"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>]&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> evaluates
to a function from values to classes.
When this function is applied to a value <I>v</I>, this value is
matched against the pattern <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> and the result is the result of
the evaluation of <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> in the extended environment.</P><P>Conversion from functions with default values to functions with
patterns only works identically for class functions as for normal
functions.</P><P>The expression
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>
</DIV><P>
is a short form for
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT> &#XA0;<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><!--TOC subsubsection Local definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Local definitions</H4><!--SEC END --><P>The <TT>let</TT> and <TT>let rec</TT> constructs bind value names locally,
as for the core language expressions.</P><P>If a local definition occurs at the very beginning of a class
definition, it will be evaluated when the class is created (just as if
the definition was outside of the class).
Otherwise, it will be evaluated when the object constructor is called.</P><!--TOC subsubsection Class body-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class<A NAME="ss:class-body"></A> body</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;[<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>]&#XA0;&#XA0;{&#XA0;<I><A href="#class-field" class="syntax"><FONT COLOR=maroon>class-field</FONT></A></I>&#XA0;}</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
The expression
<FONT COLOR=blue><TT>object</TT></FONT> <I><A href="#class-body" class="syntax"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> denotes
a class body. This is the prototype for an object : it lists the
instance variables and methods of an objet of this class.</P><P>A class body is a class value: it is not evaluated at once. Rather,
its components are evaluated each time an object is created.</P><P>In a class body, the pattern <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> &#XA0;[<FONT COLOR=blue><TT>:</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT> is
matched against self, therefore provinding a binding for self and self
type. Self can only be used in method and initializers.</P><P>Self type cannot be a closed object type, so that the class remains
extensible.</P><!--TOC subsubsection Inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Inheritance</H4><!--SEC END --><P><A NAME="@manual.kwd94"></A></P><P>The inheritance construct <FONT COLOR=blue><TT>inherit</TT></FONT> <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> allows reusing
methods and instance variables from other classes. The class
expression <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> must evaluate to a class body. The instance
variables, methods and initializers from this class body are added
into the current class. The addition of a method will override any
previously defined methods of the same name.</P><P><A NAME="@manual.kwd95"></A>
An ancestor can be bound by prepending the construct <FONT COLOR=blue><TT>as</TT></FONT> <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>
to the inheritance construct above. <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> is not a true
variable and can only be used to select a method, i.e. in an expression
<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT> &#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>. This gives access to the
method <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> as it was defined in the parent class even if it is
redefined in the current class.
The scope of an ancestor binding is limited to the current class.
The ancestor method may be called from a subclass but only indirectly. </P><!--TOC subsubsection Instance variable definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Instance variable definition</H4><!--SEC END --><P><A NAME="@manual.kwd96"></A>
<A NAME="@manual.kwd97"></A></P><P>The definition <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> adds an
instance variable <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> whose initial value is the value of
expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.
The flag <FONT COLOR=blue><TT>mutable</TT></FONT> allows physical modification of this variable by
methods.</P><P>An instance variables can only be used in the following methods and
initializers of the class.</P><P>Since version 3.10, redefinitions of a visible instance variable with
the same name do not create a new variable, but are merged, using the
last value for initialization. They must have identical types and
mutability.
However, if an instance variable is hidden by
omitting it from an interface, it will be kept distinct from
other instance variables with the same name.</P><!--TOC subsubsection Virtual instance variable definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual instance variable definition</H4><!--SEC END --><P><A NAME="@manual.kwd98"></A>
<A NAME="@manual.kwd99"></A>
<A NAME="@manual.kwd100"></A></P><P>Variable specification is written <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT>
<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>. It specifies whether the variable is
modifiable, and gives its type.</P><P>Virtual instance variables were added in version 3.10.</P><!--TOC subsubsection Method definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Method definition</H4><!--SEC END --><P><A NAME="@manual.kwd101"></A>
<A NAME="@manual.kwd102"></A></P><P>Method definition is written <FONT COLOR=blue><TT>method</TT></FONT> <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. The
definition of a method overrides any previous definition of this
method. The method will be public (that is, not private) if any of
the definition states so.</P><P>A private method, <FONT COLOR=blue><TT>method</TT> <TT>private</TT></FONT> <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, is a
method that can only be invoked on self (from other methods of the
same object, defined in this class or one of its subclasses). This
invocation is performed using the expression
<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT> &#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>, where <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> is directly bound to
self at the beginning of the class definition. Private methods do
not appear in object types. A method may have both public and private
definitions, but as soon as there is a public one, all subsequent
definitions will be made public.</P><P>Methods may have an explicitly polymorphic type, allowing them to be
used polymorphically in programs (even for the same object). The
explicit declaration may be done in one of three ways: (1) by giving an
explicit polymorphic type in the method definition, immediately after
the method name, <EM>i.e.</EM>
<FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;{<FONT COLOR=blue><TT>'</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>}<SUP>+</SUP> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>
&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>; (2) by a forward declaration of the explicit polymorphic type
through a virtual method definition; (3) by importing such a
declaration through inheritance and/or constraining the type of <EM>self</EM>.</P><P>Some special expressions are available in method bodies for
manipulating instance variables and duplicating self:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X2026;
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>&lt;-</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{&lt;</TT></FONT>&#XA0;[&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;}&#XA0;]&#XA0;<FONT COLOR=blue><TT>&gt;}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expression <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> modifies in-place the current
object by replacing the value associated to <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> by the
value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. Of course, this instance variable must have been
declared mutable.</P><P>The expression
<FONT COLOR=blue><TT>{&lt;</TT></FONT> [ <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>;</TT></FONT> <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> } ] <FONT COLOR=blue><TT>&gt;}</TT></FONT>
evaluates to a copy of the current object in which the values of
instance variables <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I><SUB>1</SUB>, &#X2026;, &#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A><SUB>n</SUB></I> have
been replaced by the values of the corresponding expressions <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>,
&#X2026;, &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Virtual method definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual method definition</H4><!--SEC END --><P><A NAME="@manual.kwd103"></A>
<A NAME="@manual.kwd104"></A>
<A NAME="@manual.kwd105"></A></P><P>Method specification is written <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT>
<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>. It specifies whether the method is
public or private, and gives its type. If the method is intended to be
polymorphic, the type should be explicit.</P><!--TOC subsubsection Constraints on type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constraints on type parameters</H4><!--SEC END --><P><A NAME="@manual.kwd106"></A></P><P>The construct <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.</P><!--TOC subsubsection Initializers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Initializers</H4><!--SEC END --><P><A NAME="@manual.kwd107"></A></P><P>A class initializer <FONT COLOR=blue><TT>initializer</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> specifies an expression that
will be evaluated when an object will be created from the class, once
all the instance variables have been initialized.</P><!--TOC subsection Class definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">6.9.3</A>&#XA0;&#XA0;Class definitions</H3><!--SEC END --><P>
<A NAME="s:classdef"></A></P><P><A NAME="@manual.kwd108"></A>
<A NAME="@manual.kwd109"></A>
<A NAME="@manual.kwd110"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-definition" class="syntax"><FONT COLOR=maroon>class-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT>&#XA0;<I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>]&#XA0;[<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>]&#XA0;&#XA0;<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>
&#XA0;{<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>}&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>]&#XA0;&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>,</TT></FONT>&#XA0;<FONT COLOR=blue><TT>'</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A class definition <FONT COLOR=blue><TT>class</TT></FONT> <I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I> } is
recursive. Each <I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I> defines a <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> that can be
used in the whole expression except for inheritance. It can also be
used for inheritance, but only in the definitions that follow its own.</P><P>A class binding binds the class name <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> to the value of
expression <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>. It also binds the class type <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> to
the type of the class, and defines two type abbreviations :
<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> and <FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>. The first one is the type of
objects of this class, while the second is more general as it unifies
with the type of any object belonging to a subclass (see
section&#XA0;<A HREF="#s:sharp-types">6.4</A>).</P><!--TOC subsubsection Virtual class-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual class</H4><!--SEC END --><P><A NAME="@manual.kwd111"></A>
A class must be flagged virtual if one of its methods is virtual (that
is, appears in the class type, but is not actually defined).
Objects cannot be created from a virtual class.</P><!--TOC subsubsection Type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type parameters</H4><!--SEC END --><P>The class type parameters correspond to the ones of the class type and
of the two type abbreviations defined by the class binding. They must
be bound to actual types in the class definition using type
constraints. So that the abbreviations are well-formed, type
variables of the inferred type of the class must either be type
parameters or be bound in the constraint clause.</P><!--TOC subsection Class specification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">6.9.4</A>&#XA0;&#XA0;Class specification</H3><!--SEC END --><P>
<A NAME="s:class-spec"></A></P><P><A NAME="@manual.kwd112"></A>
<A NAME="@manual.kwd113"></A>
<A NAME="@manual.kwd114"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-specification" class="syntax"><FONT COLOR=maroon>class-specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT>&#XA0;<I><A href="#class-spec" class="syntax"><FONT COLOR=maroon>class-spec</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#class-spec" class="syntax"><FONT COLOR=maroon>class-spec</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-spec" class="syntax"><FONT COLOR=maroon>class-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>]&#XA0;[<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>]&#XA0;&#XA0;<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>
&#XA0;<I><A href="#class-type" class="syntax"><FONT COLOR=maroon>class-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>This is the counterpart in signatures of class definitions.
A class specification matches a class definition if they have the same
type parameters and their types match.</P><!--TOC subsection Class type definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">6.9.5</A>&#XA0;&#XA0;Class type definitions</H3><!--SEC END --><P>
<A NAME="s:classtype"></A></P><P><A NAME="@manual.kwd115"></A>
<A NAME="@manual.kwd116"></A>
<A NAME="@manual.kwd117"></A>
<A NAME="@manual.kwd118"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="classtype-definition" class="syntax"><FONT COLOR=maroon>classtype-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I>
&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>]&#XA0;[<FONT COLOR=blue><TT>[</TT></FONT>&#XA0;<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>]&#XA0;&#XA0;<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#class-body-type" class="syntax"><FONT COLOR=maroon>class-body-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A class type definition <FONT COLOR=blue><TT>class</TT></FONT> <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#class-body-type" class="syntax"><FONT COLOR=maroon>class-body-type</FONT></A></I>
defines an abbreviation <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> for the class body type
<I><A href="#class-body-type" class="syntax"><FONT COLOR=maroon>class-body-type</FONT></A></I>. As for class definitions, two type abbreviations
<I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> and <FONT COLOR=blue><TT>#</TT></FONT> <I><A href="#class-name" class="syntax"><FONT COLOR=maroon>class-name</FONT></A></I> are also defined. The definition can
be parameterized by some type parameters. If any method in the class
type body is virtual, the definition must be flagged <FONT COLOR=blue><TT>virtual</TT></FONT>.</P><P>Two class type definitions match if they have the same type parameters
and the types they expand to match.

</P><!--TOC section Module types (module specifications)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc82">6.10</A>&#XA0;&#XA0;Module types (module specifications)</H2><!--SEC END --><P>Module types are the module-level equivalent of type expressions: they
specify the general shape and type properties of modules.</P><P><A NAME="@manual.kwd119"></A>
<A NAME="@manual.kwd120"></A>
<A NAME="@manual.kwd121"></A>
<A NAME="@manual.kwd122"></A>
<A NAME="@manual.kwd123"></A>
<A NAME="@manual.kwd124"></A>
<A NAME="@manual.kwd125"></A>
<A NAME="@manual.kwd126"></A>
<A NAME="@manual.kwd127"></A>
<A NAME="@manual.kwd128"></A>
<A NAME="@manual.kwd129"></A>
<A NAME="@manual.kwd130"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>sig</TT></FONT>&#XA0;{&#XA0;<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>;;</TT></FONT>]&#XA0;}&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>functor</TT></FONT>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;[<I><A href="#type-params" class="syntax"><FONT COLOR=maroon>type-params</FONT></A></I>]&#XA0;&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>val</TT></FONT>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>external</TT></FONT>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<FONT COLOR=maroon><I>external-declaration</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#type-definition" class="syntax"><FONT COLOR=maroon>type-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>exception</TT></FONT>&#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#class-specification" class="syntax"><FONT COLOR=maroon>class-specification</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#classtype-definition" class="syntax"><FONT COLOR=maroon>classtype-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;}
<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>open</TT></FONT>&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>include</TT></FONT>&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Simple module types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">6.10.1</A>&#XA0;&#XA0;Simple module types</H3><!--SEC END --><P>The expression <I><A href="#modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I> is equivalent to the module type bound
to the name <I><A href="#modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I>.
The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> denotes the same type as
<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>.</P><!--TOC subsection Signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">6.10.2</A>&#XA0;&#XA0;Signatures</H3><!--SEC END --><P><A NAME="@manual.kwd131"></A>
<A NAME="@manual.kwd132"></A></P><P>Signatures are type specifications for structures. Signatures
<FONT COLOR=blue><TT>sig</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> are collections of type specifications for value
names, type names, exceptions, module names and module type names. A
structure will match a signature if the structure provides definitions
(implementations) for all the names specified in the signature (and
possibly more), and these definitions meet the type requirements given
in the signature.</P><P>For compatibility with Caml Light, an optional <TT>;;</TT> is allowed after each
specification in a signature. The <TT>;;</TT> has no semantic meaning.</P><!--TOC subsubsection Value specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value specifications</H4><!--SEC END --><P><A NAME="@manual.kwd133"></A></P><P>A specification of a value component in a signature is written
<FONT COLOR=blue><TT>val</TT></FONT> <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>, where <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> is the name of the
value and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> its expected type.</P><P><A NAME="@manual.kwd134"></A></P><P>The form <FONT COLOR=blue><TT>external</TT></FONT> <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<FONT COLOR=maroon><I>external-declaration</I></FONT>
is similar, except that it requires in addition the name to be
implemented as the external function specified in <FONT COLOR=maroon><I>external-declaration</I></FONT>
(see chapter&#XA0;<A HREF="#c:intf-c">19</A>).</P><!--TOC subsubsection Type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd135"></A></P><P>A specification of one or several type components in a signature is
written <FONT COLOR=blue><TT>type</TT></FONT> <I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of type names.</P><P>Each type definition in the signature specifies an optional type
equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> and an optional type representation 
<FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I> &#X2026; or <FONT COLOR=blue><TT>=</TT> <TT>{</TT></FONT> <I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I> &#X2026; <FONT COLOR=blue><TT>}</TT></FONT>.
The implementation of the type name in a matching structure must
be compatible with the type expression specified in the equation (if
given), and have the specified representation (if given). Conversely,
users of that signature will be able to rely on the type equation
or type representation, if given. More precisely, we have the
following four situations:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Abstract type: no equation, no representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
Names that are defined as abstract types in a signature can be
implemented in a matching structure by any kind of type definition
(provided it has the same number of type parameters). The exact
implementation of the type will be hidden to the users of the
structure. In particular, if the type is implemented as a variant type
or record type, the associated constructors and fields will not be
accessible to the users; if the type is implemented as an
abbreviation, the type equality between the type name and the
right-hand side of the abbreviation will be hidden from the users of the
structure. Users of the structure consider that type as incompatible
with any other type: a fresh type has been generated.</DD><DT CLASS="dt-description"><B>Type abbreviation: an equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>, no representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
The type name must be implemented by a type compatible with <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.
All users of the structure know that the type name is
compatible with <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.</DD><DT CLASS="dt-description"><B>New variant type or record type: no equation, a representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
The type name must be implemented by a variant type or record type
with exactly the constructors or fields specified. All users of the
structure have access to the constructors or fields, and can use them
to create or inspect values of that type. However, users of the
structure consider that type as incompatible with any other type: a
fresh type has been generated.</DD><DT CLASS="dt-description"><B>Re-exported variant type or record type: an equation,
a representation.</B></DT><DD CLASS="dd-description"> &#XA0;<BR>
This case combines the previous two: the representation of the type is
made visible to all users, and no fresh type is generated.
</DD></DL><!--TOC subsubsection Exception specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception specification</H4><!--SEC END --><P><A NAME="@manual.kwd136"></A></P><P>The specification <FONT COLOR=blue><TT>exception</TT></FONT> <I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I> in a signature requires the
matching structure to provide an exception with the name and arguments
specified in the definition, and makes the exception available to all
users of the structure.</P><!--TOC subsubsection Class specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class specifications</H4><!--SEC END --><P><A NAME="@manual.kwd137"></A></P><P>A specification of one or several classes in a signature is written
<FONT COLOR=blue><TT>class</TT></FONT> <I><A href="#class-spec" class="syntax"><FONT COLOR=maroon>class-spec</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#class-spec" class="syntax"><FONT COLOR=maroon>class-spec</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of class names.</P><P>Class specifications are described more precisely in
section&#XA0;<A HREF="#s:class-spec">6.9.4</A>.</P><!--TOC subsubsection Class type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd138"></A>
<A NAME="@manual.kwd139"></A></P><P>A specification of one or several classe types in a signature is
written <FONT COLOR=blue><TT>class</TT> <TT>type</TT></FONT> <I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I> { <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I> } and
consists of a sequence of mutually recursive definitions of class type
names. Class type specifications are described more precisely in
section&#XA0;<A HREF="#s:classtype">6.9.5</A>.</P><!--TOC subsubsection Module specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module specifications</H4><!--SEC END --><P><A NAME="@manual.kwd140"></A></P><P>A specification of a module component in a signature is written
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>, where <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> is the
name of the module component and <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> its expected type.
Modules can be nested arbitrarily; in particular, functors can appear
as components of structures and functor types as components of
signatures.</P><P>For specifying a module component that is a functor, one may write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT>
&#X2026; <FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>)</TT>
<TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
</DIV><P>
instead of
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT>
<TT>functor</TT> <TT>(</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
</DIV><!--TOC subsubsection Module type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd141"></A>
<A NAME="@manual.kwd142"></A></P><P>A module type component of a signature can be specified either as a
manifest module type or as an abstract module type.</P><P>An abstract module type specification
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> allows the name <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> to be
implemented by any module type in a matching signature, but hides the
implementation of the module type to all users of the signature.</P><P>A manifest module type specification
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
requires the name <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> to be implemented by the module type
<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> in a matching signature, but makes the equality between
<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> and <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> apparent to all users of the signature.</P><!--TOC subsubsection Opening a module path-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Opening a module path</H4><!--SEC END --><P><A NAME="@manual.kwd143"></A></P><P>The expression <FONT COLOR=blue><TT>open</TT></FONT> <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> in a signature does not specify
any components. It simply affects the parsing of the following items
of the signature, allowing components of the module denoted by
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> to be referred to by their simple names <FONT COLOR=maroon><I>name</I></FONT> instead of
path accesses <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT>. The scope of the <TT>open</TT>
stops at the end of the signature expression.</P><!--TOC subsubsection Including a signature-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Including a signature</H4><!--SEC END --><P><A NAME="@manual.kwd144"></A></P><P>The expression <FONT COLOR=blue><TT>include</TT></FONT> <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> in a signature performs textual
inclusion of the components of the signature denoted by <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>.
It behaves as if the components of the included signature were copied
at the location of the <FONT COLOR=blue><TT>include</TT></FONT>. The <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> argument must
refer to a module type that is a signature, not a functor type.</P><!--TOC subsection Functor types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">6.10.3</A>&#XA0;&#XA0;Functor types</H3><!--SEC END --><P><A NAME="@manual.kwd145"></A></P><P>The module type expression 
<FONT COLOR=blue><TT>functor</TT> <TT>(</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB> 
is the type of functors (functions from modules to modules) that take
as argument a module of type <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> and return as result a
module of type <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB>. The module type <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB> can
use the name <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> to refer to type components of the actual
argument of the functor. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (&#X201C;higher-order&#X201D; functor).</P><!--TOC subsection The <TT>with</TT> operator-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">6.10.4</A>&#XA0;&#XA0;The <TT>with</TT> operator</H3><!--SEC END --><P><A NAME="@manual.kwd146"></A></P><P>Assuming <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> denotes a signature, the expression
<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT> &#XA0;<I><A href="#mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I> { <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I> } denotes
the same signature where type equations have been added to some of the
type specifications, as described by the constraints following the
<TT>with</TT> keyword. The constraint <FONT COLOR=blue><TT>type</TT></FONT> [<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>] &#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
<FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> adds the type equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> to the specification
of the type component named <I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I> of the constrained signature.
The constraint <FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I> adds
type equations to all type components of the sub-structure denoted by
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>, making them equivalent to the corresponding type
components of the structure denoted by <I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>.</P><P>For instance, if the module type name <TT>S</TT> is bound to the signature
</P><PRE>        sig type t module M: (sig type u end) end
</PRE><P>then <TT>S with type t=int</TT> denotes the signature
</P><PRE>        sig type t=int module M: (sig type u end) end
</PRE><P>and <TT>S with module M = N</TT> denotes the signature
</P><PRE>        sig type t module M: (sig type u=N.u end) end
</PRE><P>A functor taking two arguments of type <TT>S</TT> that share their <TT>t</TT> component
is written
</P><PRE>        functor (A: S) (B: S with type t = A.t) ...
</PRE><P>
Constraints are added left to right. After each constraint has been
applied, the resulting signature must be a subtype of the signature
before the constraint was applied. Thus, the <FONT COLOR=blue><TT>with</TT></FONT> operator can
only add information on the type components of a signature, but never
remove information.

</P><!--TOC section Module expressions (module implementations)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc87">6.11</A>&#XA0;&#XA0;Module<A NAME="s:module-expr"></A> expressions (module implementations)</H2><!--SEC END --><P>Module expressions are the module-level equivalent of value
expressions: they evaluate to modules, thus providing implementations
for the specifications expressed in module types.</P><P><A NAME="@manual.kwd147"></A>
<A NAME="@manual.kwd148"></A>
<A NAME="@manual.kwd149"></A>
<A NAME="@manual.kwd150"></A>
<A NAME="@manual.kwd151"></A>
<A NAME="@manual.kwd152"></A>
<A NAME="@manual.kwd153"></A>
<A NAME="@manual.kwd154"></A>
<A NAME="@manual.kwd155"></A>
<A NAME="@manual.kwd156"></A>
<A NAME="@manual.kwd157"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>struct</TT></FONT>&#XA0;{&#XA0;<I><A href="#definition" class="syntax"><FONT COLOR=maroon>definition</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>;;</TT></FONT>]&#XA0;&#X2223;&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>;;</TT></FONT>&#XA0;}&#XA0;<FONT COLOR=blue><TT>end</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>functor</TT></FONT>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="definition" class="syntax"><FONT COLOR=maroon>definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>let</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>rec</TT></FONT>]&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>&#XA0;&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>external</TT></FONT>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<FONT COLOR=maroon><I>external-declaration</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#type-definition" class="syntax"><FONT COLOR=maroon>type-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#exception-definition" class="syntax"><FONT COLOR=maroon>exception-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#class-definition" class="syntax"><FONT COLOR=maroon>class-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#classtype-definition" class="syntax"><FONT COLOR=maroon>classtype-definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>&#XA0;}
&#XA0;[&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;]&#XA0;&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>open</TT></FONT>&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>include</TT></FONT>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Simple module expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">6.11.1</A>&#XA0;&#XA0;Simple module expressions</H3><!--SEC END --><P>The expression <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> evaluates to the module bound to the name
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> evaluates to the same module as
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> checks that the
type of <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> is a subtype of <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>, that is, that all
components specified in <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> are implemented in
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>, and their implementation meets the requirements given
in <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>. In other terms, it checks that the implementation
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> meets the type specification <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>. The whole
expression evaluates to the same module as <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>, except that
all components not specified in <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> are hidden and can no
longer be accessed.</P><!--TOC subsection Structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">6.11.2</A>&#XA0;&#XA0;Structures</H3><!--SEC END --><P><A NAME="@manual.kwd158"></A>
<A NAME="@manual.kwd159"></A></P><P>Structures <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> are collections of definitions for
value names, type names, exceptions, module names and module type
names. The definitions are evaluated in the order in which they appear
in the structure. The scope of the bindings performed by the
definitions extend to the end of the structure. As a consequence, a
definition may refer to names bound by earlier definitions in the same
structure.</P><P>For compatibility with toplevel phrases (chapter&#XA0;<A HREF="#c:camllight">9</A>)
and with Caml Light, an optional <TT>;;</TT> is allowed after each
definition in a structure. The <TT>;;</TT> has no semantic meaning. Also for
compatibility, <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>;;</TT></FONT> is allowed as a component of a structure,
meaning <FONT COLOR=blue><TT>let</TT> <TT>_</TT> <TT>=</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>, i.e. evaluate <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> for its side-effects.
In this case, the <TT>;;</TT> of the previous component is not optional.</P><!--TOC subsubsection Value definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value definitions</H4><!--SEC END --><P><A NAME="@manual.kwd160"></A></P><P>A value definition <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I> }
bind value names in the same way as a <FONT COLOR=blue><TT>let</TT></FONT> &#X2026; <FONT COLOR=blue><TT>in</TT></FONT> &#X2026; expression
(see section&#XA0;<A HREF="#s:localdef">6.7.1</A>). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values
in the right-hand sides.</P><P><A NAME="@manual.kwd161"></A></P><P>A value definition <FONT COLOR=blue><TT>external</TT></FONT> <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<FONT COLOR=maroon><I>external-declaration</I></FONT>
implements <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> as the external function specified in
<FONT COLOR=maroon><I>external-declaration</I></FONT> (see chapter&#XA0;<A HREF="#c:intf-c">19</A>).</P><!--TOC subsubsection Type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd162"></A></P><P>A definition of one or several type components is written
<FONT COLOR=blue><TT>type</TT></FONT> <I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#typedef" class="syntax"><FONT COLOR=maroon>typedef</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of type names.</P><!--TOC subsubsection Exception definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception definitions</H4><!--SEC END --><P><A NAME="@manual.kwd163"></A></P><P>Exceptions are defined with the syntax <FONT COLOR=blue><TT>exception</TT></FONT> <I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>
or <FONT COLOR=blue><TT>exception</TT></FONT> <I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>.</P><!--TOC subsubsection Class definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class definitions</H4><!--SEC END --><P><A NAME="@manual.kwd164"></A></P><P>A definition of one or several classes is written <FONT COLOR=blue><TT>class</TT></FONT>
<I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#class-binding" class="syntax"><FONT COLOR=maroon>class-binding</FONT></A></I> } and consists of a sequence of
mutually recursive definitions of class names. Class definitions are
described more precisely in section&#XA0;<A HREF="#s:classdef">6.9.3</A>.</P><!--TOC subsubsection Class type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd165"></A>
<A NAME="@manual.kwd166"></A></P><P>A definition of one or several classes is written
<FONT COLOR=blue><TT>class</TT> <TT>type</TT></FONT> <I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I> &#XA0;{ <FONT COLOR=blue><TT>and</TT></FONT> <I><A href="#classtype-def" class="syntax"><FONT COLOR=maroon>classtype-def</FONT></A></I> } and consists of
a sequence of mutually recursive definitions of class type names.
Class type definitions are described more precisely in
section&#XA0;<A HREF="#s:classtype">6.9.5</A>.</P><!--TOC subsubsection Module definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module definitions</H4><!--SEC END --><P><A NAME="@manual.kwd167"></A></P><P>The basic form for defining a module component is
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>, which evaluates <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> and binds
the result to the name <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>.</P><P>One can write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><P>
instead of
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>(</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>.
</DIV><P>
Another derived form is
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>)</TT> <TT>=</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><P>
which is equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT>
<TT>functor</TT> <TT>(</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><!--TOC subsubsection Module type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd168"></A>
<A NAME="@manual.kwd169"></A></P><P>A definition for a module type is written
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>.
It binds the name <I><A href="#modtype-name" class="syntax"><FONT COLOR=maroon>modtype-name</FONT></A></I> to the module type denoted by the
expression <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>.</P><!--TOC subsubsection Opening a module path-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Opening a module path</H4><!--SEC END --><P><A NAME="@manual.kwd170"></A></P><P>The expression <FONT COLOR=blue><TT>open</TT></FONT> <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> in a structure does not define any
components nor perform any bindings. It simply affects the parsing of
the following items of the structure, allowing components of the
module denoted by <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> to be referred to by their simple names
<FONT COLOR=maroon><I>name</I></FONT> instead of path accesses <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT>. The scope of
the <TT>open</TT> stops at the end of the structure expression.</P><!--TOC subsubsection Including the components of another structure-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Including the components of another structure</H4><!--SEC END --><P><A NAME="@manual.kwd171"></A></P><P>The expression <FONT COLOR=blue><TT>include </TT></FONT> <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> in a structure re-exports in
the current structure all definitions of the structure denoted by
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>. For instance, if the identifier <TT>S</TT> is bound to the
module
</P><PRE>        struct type t = int  let x = 2 end
</PRE><P>the module expression
</P><PRE>        struct include S  let y = (x + 1 : t) end
</PRE><P>is equivalent to the module expression
</P><PRE>        struct type t = S.t  let x = S.x  let y = (x + 1 : t) end
</PRE><P>The difference between <FONT COLOR=blue><TT>open</TT></FONT> and <FONT COLOR=blue><TT>include</TT></FONT> is that <FONT COLOR=blue><TT>open</TT></FONT>
simply provides short names for the components of the opened
structure, without defining any components of the current structure,
while <FONT COLOR=blue><TT>include</TT></FONT> also adds definitions for the components of the
included structure.</P><!--TOC subsection Functors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">6.11.3</A>&#XA0;&#XA0;Functors</H3><!--SEC END --><!--TOC subsubsection Functor definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Functor definition</H4><!--SEC END --><P><A NAME="@manual.kwd172"></A></P><P>The expression <FONT COLOR=blue><TT>functor</TT> <TT>(</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>
&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> evaluates to a functor that takes as argument modules of
the type <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB>, binds <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> to these modules,
evaluates <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> in the extended environment, and returns the
resulting modules as results. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (&#X201C;higher-order&#X201D; functor).</P><!--TOC subsubsection Functor application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Functor application</H4><!--SEC END --><P>The expression <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>(</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT> evaluates
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB> to a functor and <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> to a module, and
applies the former to the latter. The type of <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> must
match the type expected for the arguments of the functor <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB>.</P><!--TOC section Compilation units-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">6.12</A>&#XA0;&#XA0;Compilation units</H2><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="unit-interface" class="syntax"><FONT COLOR=maroon>unit-interface</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>;;</TT></FONT>]&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="unit-implementation" class="syntax"><FONT COLOR=maroon>unit-implementation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<I><A href="#definition" class="syntax"><FONT COLOR=maroon>definition</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>;;</TT></FONT>]&#XA0;}</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Compilation units bridge the module system and the separate
compilation system. A compilation unit is composed of two parts: an
interface and an implementation. The interface contains a sequence of
specifications, just as the inside of a <FONT COLOR=blue><TT>sig</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT>
signature expression. The implementation contains a sequence of
definitions, just as the inside of a <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> module
expression. A compilation unit also has a name <FONT COLOR=maroon><I>unit-name</I></FONT>, derived
from the names of the files containing the interface and the
implementation (see chapter&#XA0;<A HREF="#c:camlc">8</A> for more details). A
compilation unit behaves roughly as the module definition
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT> <FONT COLOR=maroon><I>unit-name</I></FONT> <TT>:</TT> <TT>sig</TT></FONT> &#XA0;<I><A href="#unit-interface" class="syntax"><FONT COLOR=maroon>unit-interface</FONT></A></I> <FONT COLOR=blue><TT>end</TT> <TT>=</TT>
<TT>struct</TT></FONT> &#XA0;<I><A href="#unit-implementation" class="syntax"><FONT COLOR=maroon>unit-implementation</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
</DIV><P>A compilation unit can refer to other compilation units by their
names, as if they were regular modules. For instance, if <TT>U</TT> is a
compilation unit that defines a type <TT>t</TT>, other compilation units can
refer to that type under the name <TT>U.t</TT>; they can also refer to <TT>U</TT> as
a whole structure. Except for names of other compilation units, a unit
interface or unit implementation must not have any other free variables.
In other terms, the type-checking and compilation of an interface or
implementation proceeds in the initial environment
</P><DIV CLASS="center">
<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT> <TT>sig</TT></FONT> &#XA0;<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>end</TT></FONT> &#X2026;
&#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT> <TT>sig</TT></FONT> &#XA0;<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>end</TT></FONT>
</DIV><P>
where <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> are the names of the other
compilation units available in the search path (see
chapter&#XA0;<A HREF="#c:camlc">8</A> for more details) and <I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I><SUB>1</SUB> &#X2026;
&#XA0;<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A><SUB>n</SUB></I> are their respective interfaces.

</P><!--CUT END -->
<!--TOC chapter Language extensions-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc92">Chapter&#XA0;7</A>&#XA0;&#XA0;Language extensions</H1><!--SEC END --><P> <A NAME="c:extensions"></A>
</P><P>This chapter describes language extensions and convenience features
that are implemented in OCaml, but not described in the
OCaml reference manual.</P><!--TOC section Integer literals for types <TT>int32</TT>, <TT>int64</TT>
and <TT>nativeint</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc93">7.1</A>&#XA0;&#XA0;Integer literals for types <TT>int32</TT>, <TT>int64</TT>
and <TT>nativeint</TT></H2><!--SEC END --><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="int32-literal" class="syntax"><FONT COLOR=maroon>int32-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>l</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="int64-literal" class="syntax"><FONT COLOR=maroon>int64-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>L</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="nativeint-literal" class="syntax"><FONT COLOR=maroon>nativeint-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>n</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
An integer literal can be followed by one of the letters <TT>l</TT>, <TT>L</TT> or <TT>n</TT>
to indicate that this integer has type <TT>int32</TT>, <TT>int64</TT> or <TT>nativeint</TT>
respectively, instead of the default type <TT>int</TT> for integer literals.
<A NAME="@manual3"></A>
<A NAME="@manual4"></A>
<A NAME="@manual5"></A>
The library modules <TT>Int32</TT>[<TT><A HREF="libref/Int32.html">Int32</A></TT>],
<TT>Int64</TT>[<TT><A HREF="libref/Int64.html">Int64</A></TT>] and <TT>Nativeint</TT>[<TT><A HREF="libref/Nativeint.html">Nativeint</A></TT>]
provide operations on these integer types.</P><!--TOC section Streams and stream parsers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc94">7.2</A>&#XA0;&#XA0;Streams and stream parsers</H2><!--SEC END --><P>
<A NAME="s:streams"></A></P><P>(Removed in Objective Caml 3.03)</P><P>The syntax for streams and stream parsers is no longer part of the
OCaml language, but available through a Camlp4 syntax
extension. See the Camlp4 reference manual for more information.
Support for basic operations on streams is still available through the
<TT>Stream</TT>[<TT><A HREF="libref/Stream.html">Stream</A></TT>] module of the standard library.
OCaml programs
that use the stream parser syntax should be compiled with the
<TT>-pp camlp4o</TT> option to <TT>ocamlc</TT> and <TT>ocamlopt</TT>. For interactive use,
run <TT>ocaml</TT> and issue the <CODE>#load "dynlink.cma";;</CODE> command,
followed by the <CODE>#load "camlp4o.cma";;</CODE> command.</P><!--TOC section Recursive definitions of values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">7.3</A>&#XA0;&#XA0;Recursive definitions of values</H2><!--SEC END --><P> <A NAME="s:letrecvalues"></A></P><P>(Introduced in Objective Caml 1.00)</P><P>As mentioned in section&#XA0;<A HREF="#s:localdef">6.7.1</A>, the <FONT COLOR=blue><TT>let rec</TT></FONT> binding
construct, in addition to the definition of recursive functions,
also supports a certain class of recursive definitions of
non-functional values, such as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT> <TT>1</TT> <TT>::</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB>
<FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT> <TT>2</TT> <TT>::</TT></FONT> &#XA0;<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB>
<FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
which binds <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> to the cyclic list <TT>1::2::1::2::</TT>&#X2026;, and
<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> to the cyclic list <TT>2::1::2::1::</TT>&#X2026;Informally, the class of accepted definitions consists of those
definitions where the defined names occur only inside function
bodies or as argument to a data constructor.</P><P>More precisely, consider the expression:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
It will be accepted if each one of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> is
statically constructive with respect to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>,
is not immediately linked to any of <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>,
and is not an array constructor whose arguments have abstract type.</P><P>An expression <FONT COLOR=maroon><I>e</I></FONT> is said to be <EM>statically constructive
with respect to</EM> the variables <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> if at least
one of the following conditions is true:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I>e</I></FONT> has no free occurrence of any of <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> is a variable
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>fun</TT></FONT> &#X2026; <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026;
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>function</TT></FONT> &#X2026; <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026;
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>lazy</TT> <TT>(</TT></FONT> &#X2026; <FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has one of the following forms, where each one of
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026; &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> is statically constructive with respect to
<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>, and <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> is statically constructive with
respect to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>, &#XA0;<FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I>:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>let</TT> <TT>module</TT></FONT> &#X2026; <FONT COLOR=blue><TT>in</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>
</LI><LI CLASS="li-itemize"><I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I><FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>`</TT></FONT><I><A href="#tag-name" class="syntax"><FONT COLOR=maroon>tag-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I><FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>[|</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>m</SUB></I> = &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>{</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>with</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>
&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A><SUB>m</SUB></I> = &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> where <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> is not immediately
linked to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026; &#XA0;<I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I>
</LI></UL>
</LI></UL><P>An expression <FONT COLOR=maroon><I>e</I></FONT> is said to be <EM>immediately linked to</EM> the variable
<FONT COLOR=maroon><I>name</I></FONT> in the following cases:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I>e</I></FONT> is <FONT COLOR=maroon><I>name</I></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> where <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I>
is immediately linked to <FONT COLOR=maroon><I>name</I></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT> &#XA0;<I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> where <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> is immediately
linked to <FONT COLOR=maroon><I>name</I></FONT> or to one of the <I><FONT COLOR=maroon>xname</FONT><SUB>i</SUB></I> such that <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I>
is immediately linked to <FONT COLOR=maroon><I>name</I></FONT>.
</LI></UL><!--TOC section Range patterns-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc96">7.4</A>&#XA0;&#XA0;Range patterns</H2><!--SEC END --><P>(Introduced in Objective Caml 1.00)</P><P>In patterns, OCaml recognizes the form
<FONT COLOR=blue><TT>'</TT> <FONT COLOR=maroon><I>c</I></FONT> <TT>'</TT> <TT>..</TT> <TT>'</TT> <FONT COLOR=maroon><I>d</I></FONT> <TT>'</TT></FONT>
(two character literals separated by&#XA0;<TT>..</TT>) as shorthand for the pattern
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT></FONT> <I>c</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>'</TT> <TT>|</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>|</TT> <TT>'</TT></FONT> <I><FONT COLOR=maroon>c</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT> <FONT COLOR=maroon><I>d</I></FONT> <TT>'</TT></FONT>
</DIV><P>
where <I>c</I><SUB>1</SUB>, <I>c</I><SUB>2</SUB>, &#X2026;, <I>c<SUB>n</SUB></I> are the characters
that occur between <I>c</I> and <I>d</I> in the ASCII character set. For
instance, the pattern <TT>'0'..'9'</TT> matches all characters that are digits.</P><!--TOC section Assertion checking-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc97">7.5</A>&#XA0;&#XA0;Assertion checking</H2><!--SEC END --><P>
<A NAME="@manual.kwd173"></A></P><P>(Introduced in Objective Caml 1.06)</P><P>OCaml supports the <TT>assert</TT> construct to check debugging assertions.
The expression <FONT COLOR=blue><TT>assert</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> evaluates the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> and
returns <TT>()</TT> if <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to <TT>true</TT>. Otherwise, the exception
<TT>Assert_failure</TT> is raised with the source file name and the
location of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> as arguments. Assertion
checking can be turned off with the <TT>-noassert</TT> compiler option.</P><P>As a special case, <TT>assert false</TT> is reduced to
<TT>raise (Assert_failure ...)</TT>, which is polymorphic (and
is not turned off by the <TT>-noassert</TT> option).
<A NAME="@manual6"></A></P><!--TOC section Lazy evaluation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc98">7.6</A>&#XA0;&#XA0;Lazy evaluation</H2><!--SEC END --><P>
<A NAME="@manual.kwd174"></A></P><P>(Introduced in Objective Caml 1.06 for expressions;
in Objective Caml 3.11 for patterns)</P><P>The expression <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> returns a value <I>v</I> of type <TT>Lazy.t</TT> that
encapsulates the computation of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. The argument <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is not
evaluated at this point in the program. Instead, its evaluation will
be performed the first time <TT>Lazy.force</TT> is applied to the value
<I>v</I>, returning the actual value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. Subsequent applications
of <TT>Lazy.force</TT> to <I>v</I> do not evaluate <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> again. Applications
of <TT>Lazy.force</TT> may be implicit through pattern matching.</P><P>The pattern <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> matches values <I>v</I> of type <TT>Lazy.t</TT>,
provided <I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I> matches the result of forcing <I>v</I> with
<TT>Lazy.force</TT>. A successful match of a pattern containing <TT>lazy</TT>
sub-patterns forces the corresponding parts of the value being matched, even
those that imply no test such as <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I> or <FONT COLOR=blue><TT>lazy</TT> <TT>_</TT></FONT>.
Matching a value with a <I><A href="#pattern-matching" class="syntax"><FONT COLOR=maroon>pattern-matching</FONT></A></I> where some patterns
contain <TT>lazy</TT> sub-patterns may imply forcing parts of the value,
even when the pattern selected in the end has no <TT>lazy</TT> sub-pattern.</P><P>For more information, see the description of module <TT>Lazy</TT> in the
standard library (see
<A HREF="libref/Lazy.html">Module <TT>Lazy</TT></A>).
<A NAME="@manual7"></A><A NAME="@manual8"></A></P><!--TOC section Local modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">7.7</A>&#XA0;&#XA0;Local modules</H2><!--SEC END --><P>
<A NAME="@manual.kwd175"></A>
<A NAME="@manual.kwd176"></A></P><P>(Introduced in Objective Caml 2.00)</P><P>The expression
<FONT COLOR=blue><TT>let</TT> <TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
locally binds the module expression <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> to the identifier
<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> during the evaluation of the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.
It then returns the value of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. For example:
</P><PRE>        let remove_duplicates comparison_fun string_list =
          let module StringSet =
            Set.Make(struct type t = string
                            let compare = comparison_fun end) in
          StringSet.elements
            (List.fold_right StringSet.add string_list StringSet.empty)
</PRE><!--TOC section Recursive modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc100">7.8</A>&#XA0;&#XA0;Recursive modules</H2><!--SEC END --><P> <A NAME="s-recursive-modules"></A>
<A NAME="@manual.kwd177"></A>
<A NAME="@manual.kwd178"></A></P><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#definition" class="syntax"><FONT COLOR=maroon>definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>rec</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;
&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#specification" class="syntax"><FONT COLOR=maroon>specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>rec</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>
&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I>&#XA0;}</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Recursive module definitions, introduced by the <TT>module rec</TT> &#X2026;<TT>and</TT> &#X2026; construction, generalize regular module definitions
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> and module specifications
<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> by allowing the defining
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> and the <I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I> to refer recursively to the module
identifiers being defined. A typical example of a recursive module
definition is:
</P><PRE>    module rec A : sig
                     type t = Leaf of string | Node of ASet.t
                     val compare: t -&gt; t -&gt; int
                   end
                 = struct
                     type t = Leaf of string | Node of ASet.t
                     let compare t1 t2 =
                       match (t1, t2) with
                         (Leaf s1, Leaf s2) -&gt; Pervasives.compare s1 s2
                       | (Leaf _, Node _) -&gt; 1
                       | (Node _, Leaf _) -&gt; -1
                       | (Node n1, Node n2) -&gt; ASet.compare n1 n2
                   end
        and ASet : Set.S with type elt = A.t
                 = Set.Make(A)
</PRE><P>It can be given the following specification:
</P><PRE>    module rec A : sig
                     type t = Leaf of string | Node of ASet.t
                     val compare: t -&gt; t -&gt; int
                   end
        and ASet : Set.S with type elt = A.t
</PRE><P>
This is an experimental extension of OCaml: the class of
recursive definitions accepted, as well as its dynamic semantics are
not final and subject to change in future releases.</P><P>Currently, the compiler requires that all dependency cycles between
the recursively-defined module identifiers go through at least one
&#X201C;safe&#X201D; module. A module is &#X201C;safe&#X201D; if all value definitions that
it contains have function types <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. Evaluation of a
recursive module definition proceeds by building initial values for
the safe modules involved, binding all (functional) values to
<FONT COLOR=blue><TT>fun</TT> <TT>_</TT> <TT>-&gt;</TT> <TT>raise</TT> <TT>Undefined_recursive_module</TT></FONT>. The defining
module expressions are then evaluated, and the initial values
for the safe modules are replaced by the values thus computed. If a
function component of a safe module is applied during this computation
(which corresponds to an ill-founded recursive definition), the
<TT>Undefined_recursive_module</TT> exception is raised.</P><!--TOC section Private types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">7.9</A>&#XA0;&#XA0;Private types</H2><!--SEC END --><P>
<A NAME="@manual.kwd179"></A></P><P>Private type declarations in module signatures, of the form
<TT>type t = private ...</TT>, enable libraries to
reveal some, but not all aspects of the implementation of a type to
clients of the library. In this respect, they strike a middle ground
between abstract type declarations, where no information is revealed
on the type implementation, and data type definitions and type
abbreviations, where all aspects of the type implementation are
publicized. Private type declarations come in three flavors: for
variant and record types (section&#XA0;<A HREF="#s-private-types-variant">7.9.1</A>),
for type abbreviations (section&#XA0;<A HREF="#s-private-types-abbrev">7.9.2</A>),
and for row types (section&#XA0;<A HREF="#s-private-rows">7.9.3</A>).</P><!--TOC subsection Private variant and record types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">7.9.1</A>&#XA0;&#XA0;Private variant and record types</H3><!--SEC END --><P>
<A NAME="s-private-types-variant"></A></P><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#type-representation" class="syntax"><FONT COLOR=maroon>type-representation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<FONT COLOR=blue><TT>private</TT></FONT>&#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>|</TT></FONT>&#XA0;<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<FONT COLOR=blue><TT>private</TT></FONT>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field-decl" class="syntax"><FONT COLOR=maroon>field-decl</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>}</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Values of a variant or record type declared <TT>private</TT>
can be de-structured normally in pattern-matching or via
the <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I> notation for record accesses. However, values of
these types cannot be constructed directly by constructor application
or record construction. Moreover, assignment on a mutable field of a
private record type is not allowed.</P><P>The typical use of private types is in the export signature of a
module, to ensure that construction of values of the private type always
go through the functions provided by the module, while still allowing
pattern-matching outside the defining module. For example:
</P><PRE>        module M : sig
                     type t = private A | B of int
                     val a : t
                     val b : int -&gt; t
                   end
                 = struct
                     type t = A | B of int
                     let a = A
                     let b n = assert (n &gt; 0); B n
                   end
</PRE><P>Here, the <TT>private</TT> declaration ensures that in any value of type
<TT>M.t</TT>, the argument to the <TT>B</TT> constructor is always a positive integer.</P><P>With respect to the variance of their parameters, private types are
handled like abstract types. That is, if a private type has
parameters, their variance is the one explicitly given by prefixing
the parameter by a &#X2018;<TT>+</TT>&#X2019; or a &#X2018;<TT>-</TT>&#X2019;, it is invariant otherwise.</P><!--TOC subsection Private type abbreviations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc103">7.9.2</A>&#XA0;&#XA0;Private type abbreviations</H3><!--SEC END --><P> <A NAME="s-private-types-abbrev"></A></P><P>(Introduced in Objective Caml 3.11)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#type-equation" class="syntax"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<FONT COLOR=blue><TT>private</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Unlike a regular type abbreviation, a private type abbreviation
declares a type that is distinct from its implementation type <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>.
However, coercions from the type to <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> are permitted.
Moreover, the compiler &#X201C;knows&#X201D; the implementation type and can take
advantage of this knowledge to perform type-directed optimizations.
For ambiguity reasons, <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> cannot be an object or polymorphic
variant type, but a similar behaviour can be obtained through private
row types.</P><P>The following example uses a private type abbreviation to define a
module of nonnegative integers:
</P><PRE>        module N : sig
                     type t = private int
                     val of_int: int -&gt; t
                     val to_int: t -&gt; int
                   end
                 = struct
                     type t = int
                     let of_int n = assert (n &gt;= 0); n
                     let to_int n = n
                   end
</PRE><P>The type <TT>N.t</TT> is incompatible with <TT>int</TT>, ensuring that nonnegative
integers and regular integers are not confused. However, if <TT>x</TT> has
type <TT>N.t</TT>, the coercion <TT>(x :&gt; int)</TT> is legal and returns the
underlying integer, just like <TT>N.to_int x</TT>. Deep coercions are also
supported: if <TT>l</TT> has type <TT>N.t list</TT>, the coercion <TT>(l :&gt; int list)</TT>
returns the list of underlying integers, like <TT>List.map N.to_int l</TT>
but without copying the list <TT>l</TT>.</P><P>Note that the coercion <TT>(</TT><I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><TT> :&gt; </TT><I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><TT>)</TT> is actually an abbreviated form,
and will only work in presence of private abbreviations if both the
type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> and <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> contain no type variables. If this is not the
case, you must use the full form <TT>(</TT><I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><TT> : </TT>typ_e<TT> :&gt; </TT><I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I><TT>)</TT> where
typ_e is the expected type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>. Concretely, this would be <TT>(x : N.t :&gt; int)</TT> and <TT>(l : N.t list :&gt; int list)</TT> for the above examples.</P><!--TOC subsection Private row types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">7.9.3</A>&#XA0;&#XA0;Private row types</H3><!--SEC END --><P> <A NAME="s-private-rows"></A>
<A NAME="@manual.kwd180"></A></P><P>(Introduced in Objective Caml 3.09)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#type-equation" class="syntax"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<FONT COLOR=blue><TT>private</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Private row types are type abbreviations where part of the
structure of the type is left abstract. Concretely <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> in the
above should denote either an object type or a polymorphic variant
type, with some possibility of refinement left. If the private
declaration is used in an interface, the corresponding implementation
may either provide a ground instance, or a refined private type.
</P><PRE>   module M : sig type c = private &lt; x : int; .. &gt; val o : c end =
     struct
       class c = object method x = 3 method y = 2 end
       let o = new c
     end
</PRE><P>This declaration does more than hiding the <TT>y</TT> method, it also makes
the type <TT>c</TT> incompatible with any other closed object type, meaning
that only <TT>o</TT> will be of type <TT>c</TT>. In that respect it behaves
similarly to private record types. But private row types are
more flexible with respect to incremental refinement. This feature can
be used in combination with functors.
</P><PRE>   module F(X : sig type c = private &lt; x : int; .. &gt; end) =
     struct
       let get_x (o : X.c) = o#x
     end
   module G(X : sig type c = private &lt; x : int; y : int; .. &gt; end) =
     struct
       include F(X)
       let get_y (o : X.c) = o#y
     end
</PRE><P>
Polymorphic variant types can be refined in two ways, either to allow
the addition of new constructors, or to allow the disparition of
declared constructors. The second case corresponds to private variant
types (one cannot create a value of the private type), while the first
case requires default cases in pattern-matching to handle addition.
</P><PRE>   type t = [ `A of int | `B of bool ]
   type u = private [&lt; t &gt; `A ]
   type v = private [&gt; t ]
</PRE><P>With type <TT>u</TT>, it is possible to create values of the form <TT>(`A n)</TT>,
but not <TT>(`B b)</TT>. With type <TT>v</TT>, construction is not restricted but
pattern-matching must have a default case.</P><P>Like for abstract and private types, the variance of type parameters
is not inferred, and must be given explicitly.</P><!--TOC section Local opens-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc105">7.10</A>&#XA0;&#XA0;Local opens</H2><!--SEC END --><P>
<A NAME="@manual.kwd181"></A>
<A NAME="@manual.kwd182"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>let</TT></FONT>&#XA0;<FONT COLOR=blue><TT>open</TT></FONT>&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>in</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.(</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expressions
<FONT COLOR=blue><TT>let</TT> <TT>open</TT></FONT> <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
and
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I>.&#XA0;(<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>) are strictly equivalent. They
locally open the module referred to by the module path <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> in
the scope of the expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>Restricting opening to the scope of a single expression instead of a
whole structure allows one to benefit from shorter syntax to refer to
components of the opened module, without polluting the global
scope. Also, this can make the code easier to read (the open statement is
closer to where it is used) and to refactor (because the code
fragment is more self-contained).</P><!--TOC section Record notations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc106">7.11</A>&#XA0;&#XA0;Record notations</H2><!--SEC END --><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>]&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I>]&#XA0;}&#XA0;&#XA0;[<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>&#XA0;]&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;}&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>{</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>;</TT></FONT>&#XA0;<I><A href="#field" class="syntax"><FONT COLOR=maroon>field</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>]&#XA0;}&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>In a record pattern or a record construction expression, a single
identifier <FONT COLOR=maroon><I>id</I></FONT> stands for <FONT COLOR=maroon><I>id</I></FONT> = &#XA0;<FONT COLOR=maroon><I>id</I></FONT>, and a qualified identifier
<I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>id</I></FONT> stands for <I><A href="#module-path" class="syntax"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT> &#XA0;<FONT COLOR=maroon><I>id</I></FONT> = &#XA0;<FONT COLOR=maroon><I>id</I></FONT>.
For example, assuming
the record type
</P><PRE>          type point = { x: float; y: float }
</PRE><P>has been declared, the following expressions are equivalent:
</P><PRE>          let x = 1 and y = 2 in { x = x; y = y }
          let x = 1 and y = 2 in { x; y }
          let x = 1 and y = 2 in { x = x; y }
</PRE><P>Likewise, the following functions are equivalent:
</P><PRE>          fun {x = x; y = y} -&gt; x + y
          fun {x; y} -&gt; x + y
</PRE><P>
Optionally, a record pattern can be terminated by <TT>; _</TT> to convey the
fact that not all fields of the record type are listed in the record
pattern and that it is intentional. By default, the compiler ignores
the <TT>; _</TT> annotation. If the <TT>R</TT> warning is turned on, however,
the compiler will warn if a record pattern fails to list all fields of
the corresponding record type and is not terminated by <TT>; _</TT>.
Continuing the <TT>point</TT> example above,
</P><PRE>          fun {x} -&gt; x + 1
</PRE><P>will warn if the <TT>R</TT> warning is on, while
</P><PRE>          fun {x; _} -&gt; x + 1
</PRE><P>will not warn. This warning can help spot program points where record
patterns may need to be modified after new fields were added to a
record type.</P><!--TOC section Explicit polymorphic type annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc107">7.12</A>&#XA0;&#XA0;Explicit polymorphic type annotations</H2><!--SEC END --><P>
<A NAME="@manual.kwd183"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Polymorphic type annotations in <TT>let</TT>-definitions behave in a way
similar to polymorphic methods: they explicitly require the defined
value to be polymorphic, and allow one to use this polymorphism in
recursive occurences (when using <TT>let rec</TT>). Note however that this
is just an usual polymorphic type, unifiable with any instance of
itself.</P><P>There two possible applications of this feature. One is polymorphic
recursion:
</P><PRE>        type 'a t = Leaf of 'a | Node of ('a * 'a) t
        let rec depth : 'a. 'a t -&gt; 'b = function
            Leaf _ -&gt; 1
          | Node x -&gt; 1 + depth x
</PRE><P>Note that <TT>'b</TT> is not explicitly polymorphic here, and it will
actually be unified with <TT>int</TT>.</P><P>The other application is to ensure that some definition is sufficiently
polymorphic.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> let id : 'a. 'a -&gt; 'a = <U>fun x -&gt; x+1</U> ;;
</FONT><FONT COLOR=maroon>Error: This definition has type int -&gt; int which is less general than
         'a. 'a -&gt; 'a
</FONT></PRE><!--TOC section Locally abstract types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc108">7.13</A>&#XA0;&#XA0;Locally abstract types</H2><!--SEC END --><P>
<A NAME="@manual.kwd184"></A>
<A NAME="@manual.kwd185"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expression <FONT COLOR=blue><TT>fun</TT> <TT>(</TT> <TT>type</TT></FONT> <I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> introduces a
type constructor named <I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> which is considered abstract
in the scope of the sub-expression, but then replaced by a fresh type
variable. Note that contrary to what the syntax could suggest, the
expression <FONT COLOR=blue><TT>fun</TT> <TT>(</TT> <TT>type</TT></FONT> <I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> itself does not
suspend the evaluation of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> as a regular abstraction would. The
syntax has been chosen to fit nicely in the context of function
declarations, where it is generally used. It is possible to freely mix
regular function parameters with pseudo type parameters, as in:
</P><PRE>        let f = fun (type t) (foo : t list) -&gt; ...
</PRE><P>and even use the alternative syntax for declaring functions:
</P><PRE>        let f (type t) (foo : t list) = ...
</PRE><P>
This construction is useful because the type constructor it introduces
can be used in places where a type variable is not allowed. For
instance, one can use it to define an exception in a local module
within a polymorphic function.
</P><PRE>        let f (type t) () =
          let module M = struct exception E of t end in
          (fun x -&gt; M.E x), (function M.E x -&gt; Some x | _ -&gt; None)
</PRE><P>
Here is another example:
</P><PRE>        let sort_uniq (type s) (cmp : s -&gt; s -&gt; int) =
          let module S = Set.Make(struct type t = s let compare = cmp end) in
          fun l -&gt;
            S.elements (List.fold_right S.add l S.empty)
</PRE><P>
It is also extremely useful for first-class modules and GADTs.</P><!--TOC paragraph Polymorphic syntax-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Polymorphic syntax</H5><!--SEC END --><P> (Introduced in OCaml 4.00)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#let-binding" class="syntax"><FONT COLOR=maroon>let-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;&#XA0;{&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
The (<FONT COLOR=blue><TT>type</TT></FONT> <FONT COLOR=maroon><I>t</I></FONT>) syntax construction by itself does not make
polymorphic the type variable it introduces, but it can be combined
with explicit polymorphic annotations where needed. 
Some syntactic sugar is provided to make this easier.
Namely,
</P><PRE>        let rec f : type t1 t2. t1 * t2 list -&gt; t1 = ...
</PRE><P>is automatically expanded into
</P><PRE>        let rec f : 't1 't2. 't1 * 't2 list -&gt; 't1 =
          fun (type t1) (type t2) -&gt; (... : t1 * t2 list -&gt; t1)
</PRE><!--TOC section First-class modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc109">7.14</A>&#XA0;&#XA0;First-class modules</H2><!--SEC END --><P><A NAME="s-first-class-modules"></A>
<A NAME="@manual.kwd186"></A>
<A NAME="@manual.kwd187"></A>
<A NAME="@manual.kwd188"></A></P><P>(Introduced in OCaml 3.12, pattern syntax and package type inference
since 4.00)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(module</TT></FONT>&#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(val</TT></FONT>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>]<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(module</TT></FONT>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>]<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#pattern" class="syntax"><FONT COLOR=maroon>pattern</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(module</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>]<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#modtype-path" class="syntax"><FONT COLOR=maroon>modtype-path</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>with</TT></FONT>&#XA0;&#XA0;<I><A href="#package-constraint" class="syntax"><FONT COLOR=maroon>package-constraint</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>and</TT></FONT>&#XA0;<I><A href="#package-constraint" class="syntax"><FONT COLOR=maroon>package-constraint</FONT></A></I>&#XA0;}
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="package-constraint" class="syntax"><FONT COLOR=maroon>package-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Modules are typically thought of as static components. This extension
makes it possible to pack a module as a first-class value, which can
later be dynamically unpacked into a module.</P><P>The expression (<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>) converts the
module (structure or functor) denoted by module expression <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>
to a value of the core language that encapsulates this module. The
type of this core language value is (<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>).
The <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I> annotation can be omitted if it can be inferred
from the context.</P><P>Conversely, the module expression (<FONT COLOR=blue><TT>val</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>)
evaluates the core language expression <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> to a value, which must
have type <FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>, and extracts the module that was
encapsulated in this value. Again <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I> can be omitted if the
type of <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> is known.</P><P>The pattern (<FONT COLOR=blue><TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>) matches a
package with type <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I> and binds it to <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>.
It is not allowed in toplevel let bindings.
Again <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I> can be omitted if it can be inferred from the
enclosing pattern.</P><P>The <I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I> syntactic class appearing in the (<FONT COLOR=blue><TT>module</TT></FONT>
<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>) type expression and in the annotated forms represents a
subset of module types.
This subset consists of named module types with optional constraints
of a limited form: only non-parametrized types can be specified. For
type-checking purposes, package types are compared by path equality on
the module type name component, and normal type equality for
constraints.</P><P>The module expression (<FONT COLOR=blue><TT>val</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>) cannot be used in the
body of a functor, because this can cause unsoundness in conjunction
with applicative functors. It can be used anywhere in the context of a local
module binding
<FONT COLOR=blue><TT>let</TT> <TT>module</TT></FONT> <I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I> = &#XA0;(<FONT COLOR=blue><TT>val</TT></FONT> <I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT> &#XA0;<I><A href="#package-type" class="syntax"><FONT COLOR=maroon>package-type</FONT></A></I>) <FONT COLOR=blue><TT>in</TT></FONT> &#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>,
however.</P><!--TOC paragraph Basic example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Basic example</H5><!--SEC END --><P> A typical use of first-class modules is to
select at run-time among several implementations of a signatures.
Each implementation is a structure that we can encapsulate as a
first-class module, then store in a data structure such as a hash
table:
</P><PRE>        module type DEVICE = sig ... end
        let devices : (string, module DEVICE) Hashtbl.t = Hashtbl.create 17

        module SVG = struct ... end
        let _ = Hashtbl.add devices "SVG" (module SVG : DEVICE)

        module PDF = struct ... end
        let _ = Hashtbl.add devices "PDF" (module PDF: DEVICE)
</PRE><P>We can then select one implementation based on command-line
arguments, for instance:
</P><PRE>        module Device =
          (val (try Hashtbl.find devices (parse_cmdline())
                with Not_found -&gt; eprintf "Unknown device %s\n"; exit 2)
           : DEVICE)
</PRE><P>Alternatively, the selection can be performed within a function:
</P><PRE>        let draw_using_device device_name picture =
          let module Device =
            (val (Hashtbl.find_devices device_name) : DEVICE)
          in
            Device.draw picture
</PRE><!--TOC paragraph Advanced examples-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Advanced examples</H5><!--SEC END --><P>
With first-class modules, it is possible to parametrize some code over the
implementation of a module without using a functor.</P><PRE>        let sort (type s) (module Set : Set.S with type elt = s) l =
          Set.elements (List.fold_right Set.add l Set.empty)
        val sort : (module Set.S with type elt = 'a) -&gt; 'a list -&gt; 'a list
</PRE><P>
To use this function, one can wrap the <TT>Set.Make</TT> functor:</P><PRE>        let make_set (type s) cmp =
          let module S = Set.Make(struct
            type t = s
            let compare = cmp
          end) in
          (module S : Set.S with type elt = s)
        val make_set : ('a -&gt; 'a -&gt; int) -&gt; (module Set.S with type elt = 'a)
</PRE><!--TOC section Recovering the type of a module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">7.15</A>&#XA0;&#XA0;Recovering the type of a module</H2><!--SEC END --><P><A NAME="@manual.kwd189"></A>
<A NAME="@manual.kwd190"></A>
<A NAME="@manual.kwd191"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#module-type" class="syntax"><FONT COLOR=maroon>module-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;<FONT COLOR=blue><TT>of</TT></FONT>&#XA0;<I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The construction <FONT COLOR=blue><TT>module</TT> <TT>type</TT> <TT>of</TT></FONT> <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I> expands to the module type
(signature or functor type) inferred for the module expression <I><A href="#module-expr" class="syntax"><FONT COLOR=maroon>module-expr</FONT></A></I>.</P><P>A typical use, in conjunction with the signature-level <FONT COLOR=blue><TT>include</TT></FONT>
construct, is to extend the signature of an existing structure, as in
the following example.
</P><PRE>        module type MYHASH = sig
          include module type of Hashtbl
          val replace: ('a, 'b) t -&gt; 'a -&gt; 'b -&gt; unit
        end
</PRE><P>The signature <TT>MYHASH</TT>, then, contains all the fields of the signature
of module <TT>Hashtbl</TT>, plus the new field <TT>replace</TT>. An implementation
of this signature can be obtained easily, using the <FONT COLOR=blue><TT>include</TT></FONT>
construct at the structure level this time:
</P><PRE>        module MyHash : MYHASH = struct
          include Hashtbl
          let replace t k v = remove t k; add t k v
        end
</PRE><!--TOC section Substituting inside a signature-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc111">7.16</A>&#XA0;&#XA0;Substituting inside a signature</H2><!--SEC END --><P>
<A NAME="@manual.kwd192"></A>
<A NAME="@manual.kwd193"></A>
<A NAME="@manual.kwd194"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#mod-constraint" class="syntax"><FONT COLOR=maroon>mod-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>type</TT></FONT>&#XA0;[<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>]&#XA0;&#XA0;<I><A href="#typeconstr-name" class="syntax"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:=</TT></FONT>&#XA0;&#XA0;[<I><A href="#type-parameters" class="syntax"><FONT COLOR=maroon>type-parameters</FONT></A></I>]&#XA0;&#XA0;<I><A href="#typeconstr" class="syntax"><FONT COLOR=maroon>typeconstr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>module</TT></FONT>&#XA0;<I><A href="#module-name" class="syntax"><FONT COLOR=maroon>module-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:=</TT></FONT>&#XA0;&#XA0;<I><A href="#extended-module-path" class="syntax"><FONT COLOR=maroon>extended-module-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>&#X201C;Destructive&#X201D; substitution (<TT>with ... :=</TT>) behaves essentially like
normal signature constraints (<TT>with ... =</TT>), but it additionally removes
the redefined type or module from the signature. There are a number of
restrictions: one can only remove types and modules at the outermost
level (not inside submodules), and the definition must be either
another type constructor (with identical type parameters), or a module
path.</P><P>A natural application of destructive substitution is merging two
signatures sharing a type name.
</P><PRE>        module type Printable = sig
          type t
          val print : Format.formatter -&gt; t -&gt; unit
        end
        module type Comparable = sig
          type t
          val compare : t -&gt; t -&gt; int
        end
        module type PrintableComparable = sig
          include Printable
          include Comparable with type t := t
        end
</PRE><P>
One can also use this to completely remove a field:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type S = Comparable with type t := int;;
</FONT><FONT COLOR=maroon>module type S = sig val compare : int -&gt; int -&gt; int end
</FONT></PRE><P>
or to rename one:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type S = sig
    type u
    include Comparable with type t := u
  end;;
</FONT><FONT COLOR=maroon>module type S = sig type u val compare : u -&gt; u -&gt; int end
</FONT></PRE><P>Note that you can also remove manifest types, by substituting with the
same type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR="#006000"> module type ComparableInt = Comparable with type t = int ;;
<FONT COLOR=maroon>module type ComparableInt = sig type t = int val compare : t -&gt; t -&gt; int end
</FONT><FONT COLOR=black>#</FONT> module type CompareInt = ComparableInt with type t := int ;;
</FONT><FONT COLOR=maroon>module type CompareInt = sig val compare : int -&gt; int -&gt; int end
</FONT></PRE><!--TOC section Explicit overriding in class definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc112">7.17</A>&#XA0;&#XA0;Explicit overriding in class definitions</H2><!--SEC END --><P>
<A NAME="@manual.kwd195"></A>
<A NAME="@manual.kwd196"></A>
<A NAME="@manual.kwd197"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#class-field" class="syntax"><FONT COLOR=maroon>class-field</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>inherit!</TT></FONT>&#XA0;<I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>as</TT></FONT>&#XA0;<I><A href="#value-name" class="syntax"><FONT COLOR=maroon>value-name</FONT></A></I>]
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>val!</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>mutable</TT></FONT>]&#XA0;<I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I>&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method!</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;&#XA0;{<I><A href="#parameter" class="syntax"><FONT COLOR=maroon>parameter</FONT></A></I>}&#XA0;&#XA0;[<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;&#XA0;<FONT COLOR=blue><TT>method!</TT></FONT>&#XA0;[<FONT COLOR=blue><TT>private</TT></FONT>]&#XA0;<I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#poly-typexpr" class="syntax"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>=</TT></FONT>&#XA0;&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The keywords <TT>inherit!</TT>, <TT>val!</TT> and <TT>method!</TT> have the same semantics
as <TT>inherit</TT>, <TT>val</TT> and <TT>method</TT>, but they additionally require the
definition they introduce to be an overriding. Namely, <TT>method!</TT>
requires <I><A href="#method-name" class="syntax"><FONT COLOR=maroon>method-name</FONT></A></I> to be already defined in this class, <TT>val!</TT>
requires <I><A href="#inst-var-name" class="syntax"><FONT COLOR=maroon>inst-var-name</FONT></A></I> to be already defined in this class, and
<TT>inherit!</TT> requires <I><A href="#class-expr" class="syntax"><FONT COLOR=maroon>class-expr</FONT></A></I> to override some definitions.
If no such overriding occurs, an error is signaled.</P><P>As a side-effect, these 3 keywords avoid the warnings
&#X201C;method override&#X201D; and &#X201C; instance variable override&#X201D;.
As of OCaml 3.12, the warning &#X201C;method override&#X201D; has to be
enabled manually for backwards compatibility reasons.</P><!--TOC section Generalized algebraic datatypes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc113">7.18</A>&#XA0;&#XA0;Generalized algebraic datatypes</H2><!--SEC END --><P>
<A NAME="@manual.kwd198"></A>
<A NAME="@manual.kwd199"></A></P><P>(Introduced in OCaml 4.00)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A href="#constr-decl" class="syntax"><FONT COLOR=maroon>constr-decl</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#constr-name" class="syntax"><FONT COLOR=maroon>constr-name</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>:</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;&#XA0;{&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>-&gt;</TT></FONT>&#XA0;&#XA0;<I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A href="#type-param" class="syntax"><FONT COLOR=maroon>type-param</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;[<I><A href="#variance" class="syntax"><FONT COLOR=maroon>variance</FONT></A></I>]&#XA0;<FONT COLOR=blue><TT>_</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Generalized algebraic datatypes, or GADTs, extend usual sum types in
two ways: constraints on type parameters may change depending on the
value constructor, and some type variables may be existentially
quantified.
Adding constraints is done by giving an explicit return type
(the rightmost <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> in the above syntax), where type parameters
are instantiated.
This return type must use the same type constructor as the type being
defined, and have the same number of parameters.
Variables are made existential when they appear inside a constructor&#X2019;s
argument, but not in its return type.</P><P>Since the use of a return type often eludes the need to name type
parameters in the left-hand side of a type definition, one can replace
them with anonymous types &#X201C;<TT>_</TT>&#X201D; there.</P><P>The constraints associated to each constructor can be recovered
through pattern-matching.
Namely, if the type of the scrutinee of a pattern-matching contains
a locally abstract type, this type can be refined according to the
constructor used.
These extra constraints are only valid inside the corresponding branch
of the pattern-matching.
If a constructor has some existential variables, fresh locally
abstract types are generated, and they must not escape the
scope of this branch.</P><P>Here is a concrete example:
</P><PRE>        type _ term =
          | Int : int -&gt; int term
          | Add : (int -&gt; int -&gt; int) term
          | App : ('b -&gt; 'a) term * 'b term -&gt; 'a term

        let rec eval : type a. a term -&gt; a = function
          | Int n    -&gt; n                 (* a = int *)
          | Add      -&gt; (fun x y -&gt; x+y)  (* a = int -&gt; int -&gt; int *)
          | App(f,x) -&gt; (eval f) (eval x)
                  (* eval called at types (b-&gt;a) and b for fresh b *)

        let two = eval (App (App (Add, Int 1), Int 1))
        val two : int = 2
</PRE><P>
Type inference for GADTs is notoriously hard.
This is due to the fact some types may become ambiguous when escaping
from a branch.
For instance, in the <TT>Int</TT> case above, <TT>n</TT> could have either type <TT>int</TT>
or <TT>a</TT>, and they are not equivalent outside of that branch.
As a first approximation, type inference will always work if a
pattern-matching is annotated with types containing no free type
variables (both on the scrutinee and the return type).
This is the case in the above example, thanks to the type annotation
containing only locally abstract types.</P><P>In practice, type inference is a bit more clever than that: type
annotations do not need to be immediately on the pattern-matching, and
the types do not have to be always closed.
As a result, it is usually enough to only annotate functions, as in
the example above. Type annotations are
propagated in two ways: for the scrutinee, they follow the flow of
type inference, in a way similar to polymorphic methods; for the
return type, they follow the structure of the program, they are split
on functions, propagated to all branches of a pattern matching,
and go through tuples, records, and sum types.
Moreover, the notion of ambiguity used is stronger: a type is only
seen as ambiguous if it was mixed with incompatible types (equated by
constraints), without type annotations between them.
For instance, the following program types correctly.
</P><PRE>        let rec sum : type a. a term -&gt; _ = fun x -&gt;
          let y =
            match x with
            | Int n -&gt; n
            | Add   -&gt; 0
            | App(f,x) -&gt; sum f + sum x
          in y + 1
        val sum : 'a term -&gt; int = &lt;fun&gt;
</PRE><P>Here the return type <TT>int</TT> is never mixed with <TT>a</TT>, so it is seen as
non-ambiguous, and can be inferred.
When using such partial type annotations we strongly suggest
specifying the <TT>-principal</TT> mode, to check that inference is
principal.</P><P>The exhaustiveness check is aware of GADT constraints, and can
automatically infer that some cases cannot happen.
For instance, the following pattern matching is correctly seen as
exhaustive (the <TT>Add</TT> case cannot happen).
</P><PRE>        let get_int : int term -&gt; int = function
          | Int n    -&gt; n
          | App(_,_) -&gt; 0
</PRE><!--TOC paragraph Advanced examples-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Advanced examples</H5><!--SEC END --><P>
The <TT>term</TT> type we have defined above is an <EM>indexed</EM> type, where
a type parameter reflects a property of the value contents.
Another use of GADTs is <EM>singleton</EM> types, where a GADT value
represents exactly one type. This value can be used as runtime
representation for this type, and a function receiving it can have a
polytypic behavior.</P><P>Here is an example of a polymorphic function that takes the
runtime representation of some type <TT>t</TT> and a value of the same type,
then pretty-prints the value as a string:
</P><PRE>        type _ typ =
          | Int : int typ
          | String : string typ
          | Pair : 'a typ * 'b typ -&gt; ('a * 'b) typ

        let rec to_string: type t. t typ -&gt; t -&gt; string =
          fun t x -&gt;
          match t with
          | Int -&gt; string_of_int x
          | String -&gt; Printf.sprintf "%S" x
          | Pair(t1,t2) -&gt;
              let (x1, x2) = x in
              Printf.sprintf "(%s,%s)" (to_string t1 x1) (to_string t2 x2)
</PRE><P>
Another frequent application of GADTs is equality witnesses.
</P><PRE>        type (_,_) eq = Eq : ('a,'a) eq

        let cast : type a b. (a,b) eq -&gt; a -&gt; b = fun Eq x -&gt; x
</PRE><P>Here type <TT>eq</TT> has only one constructor, and by matching on it one
adds a local constraint allowing the conversion between <TT>a</TT> and <TT>b</TT>.
By building such equality witnesses, one can make equal types which
are syntactically different.</P><P>Here is an example using both singleton types and equality witnesses
to implement dynamic types.
</P><PRE>        let rec eq_type : type a b. a typ -&gt; b typ -&gt; (a,b) eq option =
          fun a b -&gt;
          match a, b with
          | Int, Int -&gt; Some Eq
          | String, String -&gt; Some Eq
          | Pair(a1,a2), Pair(b1,b2) -&gt;
              begin match eq_type a1 b1, eq_type a2 b2 with
              | Some Eq, Some Eq -&gt; Some Eq
              | _ -&gt; None
              end
          | _ -&gt; None

        type dyn = Dyn : 'a typ * 'a -&gt; dyn

        let get_dyn : type a. a typ -&gt; dyn -&gt; a option =
          fun a (Dyn(b,x)) -&gt;
          match eq_type a b with
          | None -&gt; None
          | Some Eq -&gt; Some x
</PRE><!--TOC part The OCaml tools-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc114">Part&#XA0;III</A><BR>
The OCaml tools</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:commands"></A></P><!--TOC chapter Batch compilation (ocamlc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc115">Chapter&#XA0;8</A>&#XA0;&#XA0;Batch compilation (ocamlc)</H1><!--SEC END --><P> <A NAME="c:camlc"></A>
</P><P>This chapter describes the OCaml batch compiler <TT>ocamlc</TT>,
which compiles OCaml source files to bytecode object files and links
these object files to produce standalone bytecode executable files.
These executable files are then run by the bytecode interpreter
<TT>ocamlrun</TT>.</P><!--TOC section Overview of the compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc116">8.1</A>&#XA0;&#XA0;Overview of the compiler</H2><!--SEC END --><P>The <TT>ocamlc</TT> command has a command-line interface similar to the one of
most C compilers. It accepts several types of arguments and processes them
sequentially:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arguments ending in <TT>.mli</TT> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <I>x</I><TT>.mli</TT>, the <TT>ocamlc</TT> compiler produces a compiled interface
in the file <I>x</I><TT>.cmi</TT>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.ml</TT> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <I>x</I><TT>.ml</TT>, the <TT>ocamlc</TT>
compiler produces compiled object bytecode in the file <I>x</I><TT>.cmo</TT>.<P>If the interface file <I>x</I><TT>.mli</TT> exists, the implementation
<I>x</I><TT>.ml</TT> is checked against the corresponding compiled interface
<I>x</I><TT>.cmi</TT>, which is assumed to exist. If no interface
<I>x</I><TT>.mli</TT> is provided, the compilation of <I>x</I><TT>.ml</TT> produces a
compiled interface file <I>x</I><TT>.cmi</TT> in addition to the compiled
object code file <I>x</I><TT>.cmo</TT>. The file <I>x</I><TT>.cmi</TT> produced
corresponds to an interface that exports everything that is defined in
the implementation <I>x</I><TT>.ml</TT>.</P></LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmo</TT> are taken to be compiled object bytecode. These
files are linked together, along with the object files obtained
by compiling <TT>.ml</TT> arguments (if any), and the OCaml standard
library, to produce a standalone executable program. The order in
which <TT>.cmo</TT> and <TT>.ml</TT> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <I>x</I><TT>.cmo</TT> file must come
before all <TT>.cmo</TT> files that refer to the unit <I>x</I>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.cma</TT> are taken to be libraries of object bytecode.
A library of object bytecode packs in a single file a set of object
bytecode files (<TT>.cmo</TT> files). Libraries are built with <TT>ocamlc -a</TT>
(see the description of the <TT>-a</TT> option below). The object files
contained in the library are linked as regular <TT>.cmo</TT> files (see
above), in the order specified when the <TT>.cma</TT> file was built. The
only difference is that if an object file contained in a library is
not referenced anywhere in the program, then it is not linked in.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.c</TT> are passed to the C compiler, which generates
a <TT>.o</TT> object file (<TT>.obj</TT> under Windows). This object file is linked
with the program if the <TT>-custom</TT> flag is set (see the description of
<TT>-custom</TT> below).</LI><LI CLASS="li-itemize">Arguments ending in <TT>.o</TT> or <TT>.a</TT> (<TT>.obj</TT> or <TT>.lib</TT> under Windows)
are assumed to be C object files and libraries. They are passed to the
C linker when linking in <TT>-custom</TT> mode (see the description of
<TT>-custom</TT> below).</LI><LI CLASS="li-itemize">Arguments ending in <TT>.so</TT> (<TT>.dll</TT> under Windows)
are assumed to be C shared libraries (DLLs). During linking, they are
searched for external C functions referenced from the OCaml code,
and their names are written in the generated bytecode executable.
The run-time system <TT>ocamlrun</TT> then loads them dynamically at program
start-up time.</LI></UL><P>The output of the linking phase is a file containing compiled bytecode
that can be executed by the OCaml bytecode interpreter:
the command named <TT>ocamlrun</TT>. If <TT>a.out</TT> is the name of the file
produced by the linking phase, the command
</P><PRE>
        ocamlrun a.out <I>arg</I><SUB>1</SUB> <I>arg</I><SUB>2</SUB> &#X2026; <I>arg<SUB>n</SUB></I>
</PRE><P>
executes the compiled code contained in <TT>a.out</TT>, passing it as
arguments the character strings <I>arg</I><SUB>1</SUB> to <I>arg<SUB>n</SUB></I>.
(See chapter&#XA0;<A HREF="#c:runtime">10</A> for more details.)</P><P>On most systems, the file produced by the linking
phase can be run directly, as in:
</P><PRE>
        ./a.out <I>arg</I><SUB>1</SUB> <I>arg</I><SUB>2</SUB> &#X2026; <I>arg<SUB>n</SUB></I>
</PRE><P>
The produced file has the executable bit set, and it manages to launch
the bytecode interpreter by itself.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc117">8.2</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P><A NAME="s:comp-options"></A></P><P>The following command-line options are recognized by <TT>ocamlc</TT>.
The options <TT>-pack</TT>, <TT>-a</TT>, <TT>-c</TT> and <TT>-output-obj</TT> are mutually exclusive.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-a</B></TT></DT><DD CLASS="dd-description">
Build a library (<TT>.cma</TT> file) with the object files (<TT>.cmo</TT> files)
given on the command line, instead of linking them into an executable
file. The name of the library must be set with the <TT>-o</TT> option.<P>If <TT>-custom</TT>, <TT>-cclib</TT> or <TT>-ccopt</TT> options are passed on the command
line, these options are stored in the resulting <TT>.cma</TT> library. Then,
linking with this library automatically adds back the <TT>-custom</TT>,
<TT>-cclib</TT> and <TT>-ccopt</TT> options as if they had been provided on the
command line, unless the <TT>-noautolink</TT> option is given.</P></DD><DT CLASS="dt-description"><TT><B>-absname</B></TT></DT><DD CLASS="dd-description">
Force error messages to show absolute paths for file names.</DD><DT CLASS="dt-description"><TT><B>-annot</B></TT></DT><DD CLASS="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc). The information for file <I>src</I><TT>.ml</TT>
is put into file <I>src</I><TT>.annot</TT>. In case of a type error, dump
all the information inferred by the type-checker before the error.
The <I>src</I><TT>.annot</TT> file can be used with the emacs commands given in
<TT>emacs/caml-types.el</TT> to display types and other annotations
interactively.</DD><DT CLASS="dt-description"><TT><B>-c</B></TT></DT><DD CLASS="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.</DD><DT CLASS="dt-description"><B><TT>-cc</TT> <I>ccomp</I></B></DT><DD CLASS="dd-description">
Use <I>ccomp</I> as the C linker when linking in &#X201C;custom runtime&#X201D;
mode (see the <TT>-custom</TT> option)
and as the C compiler for compiling <TT>.c</TT> source files.</DD><DT CLASS="dt-description"><B><TT>-cclib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the C linker when linking in
&#X201C;custom runtime&#X201D; mode (see the <TT>-custom</TT> option). This causes the
given C library to be linked with the program.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker. When linking in
&#X201C;custom runtime&#X201D; mode, for instance,
<TT>-ccopt -L</TT><I>dir</I> causes the C linker to search for C libraries in
directory <I>dir</I>. (See the <TT>-custom</TT> option.)</DD><DT CLASS="dt-description"><TT><B>-config</B></TT></DT><DD CLASS="dd-description">
Print the version number of <TT>ocamlc</TT> and a detailed summary of its
configuration, then exit.</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description">
Link in &#X201C;custom runtime&#X201D; mode. In the default linking mode, the
linker produces bytecode that is intended to be executed with the
shared runtime system, <TT>ocamlrun</TT>. In the custom runtime mode, the
linker produces an output file that contains both the runtime system
and the bytecode for the program. The resulting file is larger, but it
can be executed directly, even if the <TT>ocamlrun</TT> command is not
installed. Moreover, the &#X201C;custom runtime&#X201D; mode enables static
linking of OCaml code with user-defined C functions, as described in
chapter&#XA0;<A HREF="#c:intf-c">19</A>.
<BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0;
Never use the <TT>strip</TT> command on executables produced by <TT>ocamlc -custom</TT>,
this would remove the bytecode part of the executable.
</BLOCKQUOTE></DD><DT CLASS="dt-description"><B><TT>-dllib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Arrange for the C shared library <TT>dll</TT><I>libname</I><TT>.so</TT>
(<TT>dll</TT><I>libname</I><TT>.dll</TT> under Windows) to be loaded dynamically
by the run-time system <TT>ocamlrun</TT> at program start-up time.</DD><DT CLASS="dt-description"><B><TT>-dllpath</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Adds the directory <I>dir</I> to the run-time search path for shared
C libraries. At link-time, shared libraries are searched in the
standard search path (the one corresponding to the <TT>-I</TT> option).
The <TT>-dllpath</TT> option simply stores <I>dir</I> in the produced
executable file, where <TT>ocamlrun</TT> can find it and use it as
described in section&#XA0;<A HREF="#s-ocamlrun-dllpath">10.3</A>.</DD><DT CLASS="dt-description"><TT><B>-g</B></TT></DT><DD CLASS="dd-description">
Add debugging information while compiling and linking. This option is
required in order to be able to debug the program with <TT>ocamldebug</TT>
(see chapter&#XA0;<A HREF="#c:debugger">16</A>), and to produce stack backtraces when
the program terminates on an uncaught exception (see
section&#XA0;<A HREF="#ocamlrun-options">10.2</A>).</DD><DT CLASS="dt-description"><TT><B>-i</B></TT></DT><DD CLASS="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<TT>.ml</TT>
file). No compiled files (<TT>.cmo</TT> and <TT>.cmi</TT> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<TT>.mli</TT> file) for a file:
just redirect the standard output of the compiler to a <TT>.mli</TT> file,
and edit that file to remove all declarations of unexported names.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled interface files (<TT>.cmi</TT>), compiled object code files
(<TT>.cmo</TT>), libraries (<TT>.cma</TT>), and C libraries specified with
<TT>-cclib -lxxx</TT>. By default, the current directory is
searched first, then the standard library directory. Directories added
with <TT>-I</TT> are searched after the current directory, in the order in
which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P></DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf-suffix</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Recognize file names ending with <I>string</I> as interface files
(instead of the default <TT>.mli</TT>).</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-linkall</B></TT></DT><DD CLASS="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (option <TT>-a</TT>), setting the <TT>-linkall</TT> option forces all
subsequent links of programs involving that library to link all the
modules contained in the library.</DD><DT CLASS="dt-description"><TT><B>-make-runtime</B></TT></DT><DD CLASS="dd-description">
Build a custom runtime system (in the file specified by option <TT>-o</TT>)
incorporating the C object files and libraries given on the command
line. This custom runtime system can be used later to execute
bytecode executables produced with the
<TT>ocamlc -use-runtime</TT> <I>runtime-name</I> option.
See section&#XA0;<A HREF="#s:custom-runtime">19.1.6</A> for more information.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</DD><DT CLASS="dt-description"><TT><B>-noautolink</B></TT></DT><DD CLASS="dd-description">
When linking <TT>.cma</TT> libraries, ignore <TT>-custom</TT>, <TT>-cclib</TT> and <TT>-ccopt</TT>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <TT>-noautolink</TT> and pass the correct C
libraries and options on the command line.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by the compiler. The
default output name is <TT>a.out</TT> under Unix and <TT>camlprog.exe</TT> under
Windows. If the <TT>-a</TT> option is given, specify the name of the library
produced. If the <TT>-pack</TT> option is given, specify the name of the
packed object file produced. If the <TT>-output-obj</TT> option is given,
specify the name of the output file produced. If the <TT>-c</TT> option is
given, specify the name of the object file produced for the <EM>next</EM>
source file that appears on the command line.</DD><DT CLASS="dt-description"><TT><B>-output-obj</B></TT></DT><DD CLASS="dd-description">
Cause the linker to produce a C object file instead of a bytecode
executable file. This is useful to wrap OCaml code as a C library,
callable from any C program. See chapter&#XA0;<A HREF="#c:intf-c">19</A>,
section&#XA0;<A HREF="#s:embedded-code">19.7.5</A>. The name of the output object file
must be set with the <TT>-o</TT> option. This
option can also be used to produce a C source file (<TT>.c</TT> extension) or
a compiled shared/dynamic library (<TT>.so</TT> extension, <TT>.dll</TT> under Windows).</DD><DT CLASS="dt-description"><TT><B>-pack</B></TT></DT><DD CLASS="dd-description">
Build a bytecode object file (<TT>.cmo</TT> file) and its associated compiled
interface (<TT>.cmi</TT>) that combines the object
files given on the command line, making them appear as sub-modules of
the output <TT>.cmo</TT> file. The name of the output <TT>.cmo</TT> file must be
given with the <TT>-o</TT> option. For instance,
<PRE>        ocamlc -pack -o p.cmo a.cmo b.cmo c.cmo
</PRE>generates compiled files <TT>p.cmo</TT> and <TT>p.cmi</TT> describing a compilation
unit having three sub-modules <TT>A</TT>, <TT>B</TT> and <TT>C</TT>, corresponding to the
contents of the object files <TT>a.cmo</TT>, <TT>b.cmo</TT> and <TT>c.cmo</TT>. These
contents can be referenced as <TT>P.A</TT>, <TT>P.B</TT> and <TT>P.C</TT> in the remainder
of the program.</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause the compiler to call the given <I>command</I> as a preprocessor
for each source file. The output of <I>command</I> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <TT>-principal</TT> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</DD><DT CLASS="dt-description"><B><TT>-runtime-variant</TT> <I>suffix</I></B></DT><DD CLASS="dd-description">
Add the <I>suffix</I> string to the name of the runtime library used by
the program. Currently, only one such suffix is supported: <TT>d</TT>, and
only if the OCaml compiler was configured with option
<TT>-with-debug-runtime</TT>. This suffix gives the debug version of the
runtime, which is useful for debugging pointer problems in low-level
code such as C stubs.</DD><DT CLASS="dt-description"><TT><B>-thread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
system <TT>threads</TT> library described in chapter&#XA0;<A HREF="#c:threads">25</A>.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
Turn bound checking off for array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
slightly faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.</DD><DT CLASS="dt-description"><B><TT>-use-runtime</TT> <I>runtime-name</I></B></DT><DD CLASS="dd-description">
Generate a bytecode executable file that can be executed on the custom
runtime system <I>runtime-name</I>, built earlier with
<TT>ocamlc -make-runtime</TT> <I>runtime-name</I>.
See section&#XA0;<A HREF="#s:custom-runtime">19.1.6</A> for more information.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</DD><DT CLASS="dt-description"><TT><B>-verbose</B></TT></DT><DD CLASS="dd-description">
Print all external commands before they are executed, in particular
invocations of the C compiler and linker in <TT>-custom</TT> mode. Useful to
debug C library problems.</DD><DT CLASS="dt-description"><B><TT>-vnum</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description">
Print the version number of the compiler in short form (e.g. <TT>3.11.0</TT>),
then exit.</DD><DT CLASS="dt-description"><TT><B>-vmthread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
VM-level <TT>threads</TT> library described in chapter&#XA0;<A HREF="#c:threads">25</A>.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable, disable, or mark as errors the warnings specified by the argument
<I>warning-list</I>.
Each warning can be <EM>enabled</EM> or <EM>disabled</EM>, and each warning
can be <EM>marked</EM> or <EM>unmarked</EM>.
If a warning is disabled, it isn&#X2019;t displayed and doesn&#X2019;t affect
compilation in any way (even if it is marked). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and marked, the compiler will stop
with an error after displaying that warning if the source code
triggers it.<P>The <I>warning-list</I> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>+</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num</I></B></DT><DD CLASS="dd-description"> Disable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable and mark warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Disable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable and mark warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable and mark the set of warnings
corresponding to <I>letter</I>. The letter may be uppercase or
lowercase.
</DD><DT CLASS="dt-description"><I><B>uppercase-letter</B></I></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding
to <I>uppercase-letter</I>.
</DD><DT CLASS="dt-description"><I><B>lowercase-letter</B></I></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding
to <I>lowercase-letter</I>.
</DD></DL><P>Warning numbers and letters which are out of the range of warnings
that are currently defined are ignored. The warning are as follows.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>1</B></DT><DD CLASS="dd-description"> Suspicious-looking start-of-comment mark.
</DD><DT CLASS="dt-description"><B>2</B></DT><DD CLASS="dd-description"> Suspicious-looking end-of-comment mark.
</DD><DT CLASS="dt-description"><B>3</B></DT><DD CLASS="dd-description"> Deprecated syntax.
</DD><DT CLASS="dt-description"><B>4</B></DT><DD CLASS="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</DD><DT CLASS="dt-description"><B>5</B></DT><DD CLASS="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</DD><DT CLASS="dt-description"><B>6</B></DT><DD CLASS="dd-description"> Label omitted in function application.
</DD><DT CLASS="dt-description"><B>7</B></DT><DD CLASS="dd-description"> Method overridden.
</DD><DT CLASS="dt-description"><B>8</B></DT><DD CLASS="dd-description"> Partial match: missing cases in pattern-matching.
</DD><DT CLASS="dt-description"><B>9</B></DT><DD CLASS="dd-description"> Missing fields in a record pattern.
</DD><DT CLASS="dt-description"><B>10</B></DT><DD CLASS="dd-description"> Expression on the left-hand side of a sequence that doesn&#X2019;t have type
<TT>unit</TT> (and that is not a function, see warning number 5).
</DD><DT CLASS="dt-description"><B>11</B></DT><DD CLASS="dd-description"> Redundant case in a pattern matching (unused match case).
</DD><DT CLASS="dt-description"><B>12</B></DT><DD CLASS="dd-description"> Redundant sub-pattern in a pattern-matching.
</DD><DT CLASS="dt-description"><B>13</B></DT><DD CLASS="dd-description"> Instance variable overridden.
</DD><DT CLASS="dt-description"><B>14</B></DT><DD CLASS="dd-description"> Illegal backslash escape in a string constant.
</DD><DT CLASS="dt-description"><B>15</B></DT><DD CLASS="dd-description"> Private method made public implicitly.
</DD><DT CLASS="dt-description"><B>16</B></DT><DD CLASS="dd-description"> Unerasable optional argument.
</DD><DT CLASS="dt-description"><B>17</B></DT><DD CLASS="dd-description"> Undeclared virtual method.
</DD><DT CLASS="dt-description"><B>18</B></DT><DD CLASS="dd-description"> Non-principal type.
</DD><DT CLASS="dt-description"><B>19</B></DT><DD CLASS="dd-description"> Type without principality.
</DD><DT CLASS="dt-description"><B>20</B></DT><DD CLASS="dd-description"> Unused function argument.
</DD><DT CLASS="dt-description"><B>21</B></DT><DD CLASS="dd-description"> Non-returning statement.
</DD><DT CLASS="dt-description"><B>22</B></DT><DD CLASS="dd-description"> Camlp4 warning.
</DD><DT CLASS="dt-description"><B>23</B></DT><DD CLASS="dd-description"> Useless record <TT>with</TT> clause.
</DD><DT CLASS="dt-description"><B>24</B></DT><DD CLASS="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</DD><DT CLASS="dt-description"><B>25</B></DT><DD CLASS="dd-description"> Pattern-matching with all clauses guarded. Exhaustiveness cannot be
checked.
</DD><DT CLASS="dt-description"><B>26</B></DT><DD CLASS="dd-description"> Suspicious unused variable: unused variable that is bound
with <TT>let</TT> or <TT>as</TT>, and doesn&#X2019;t start with an underscore (<TT>_</TT>)
character.
</DD><DT CLASS="dt-description"><B>27</B></DT><DD CLASS="dd-description"> Innocuous unused variable: unused variable that is not bound with
<TT>let</TT> nor <TT>as</TT>, and doesn&#X2019;t start with an underscore (<TT>_</TT>)
character.
</DD><DT CLASS="dt-description"><B>28</B></DT><DD CLASS="dd-description"> Wildcard pattern given as argument to a constant constructor.
</DD><DT CLASS="dt-description"><B>29</B></DT><DD CLASS="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</DD><DT CLASS="dt-description"><B>30</B></DT><DD CLASS="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.
</DD><DT CLASS="dt-description"><B>31</B></DT><DD CLASS="dd-description"> A module is linked twice in the same executable.
</DD><DT CLASS="dt-description"><B>32</B></DT><DD CLASS="dd-description"> Unused value declaration.
</DD><DT CLASS="dt-description"><B>33</B></DT><DD CLASS="dd-description"> Unused open statement.
</DD><DT CLASS="dt-description"><B>34</B></DT><DD CLASS="dd-description"> Unused type declaration.
</DD><DT CLASS="dt-description"><B>35</B></DT><DD CLASS="dd-description"> Unused for-loop index.
</DD><DT CLASS="dt-description"><B>36</B></DT><DD CLASS="dd-description"> Unused ancestor variable.
</DD><DT CLASS="dt-description"><B>37</B></DT><DD CLASS="dd-description"> Unused constructor.
</DD><DT CLASS="dt-description"><B>38</B></DT><DD CLASS="dd-description"> Unused exception constructor.
</DD><DT CLASS="dt-description"><B>39</B></DT><DD CLASS="dd-description"> Unused rec flag.
</DD><DT CLASS="dt-description"><B>A</B></DT><DD CLASS="dd-description"> All warnings.
</DD><DT CLASS="dt-description"><B>C</B></DT><DD CLASS="dd-description"> Set of warnings 1, 2.
</DD><DT CLASS="dt-description"><B>D</B></DT><DD CLASS="dd-description"> Synonym for warning 3.
</DD><DT CLASS="dt-description"><B>E</B></DT><DD CLASS="dd-description"> Synonym for warning 4.
</DD><DT CLASS="dt-description"><B>F</B></DT><DD CLASS="dd-description"> Synonym for warning 5.
</DD><DT CLASS="dt-description"><B>K</B></DT><DD CLASS="dd-description"> Set of warnings 32, 33, 34, 35, 36, 37, 38, 39.
</DD><DT CLASS="dt-description"><B>L</B></DT><DD CLASS="dd-description"> Synonym for warning 6.
</DD><DT CLASS="dt-description"><B>M</B></DT><DD CLASS="dd-description"> Synonym for warning 7.
</DD><DT CLASS="dt-description"><B>P</B></DT><DD CLASS="dd-description"> Synonym for warning 8.
</DD><DT CLASS="dt-description"><B>R</B></DT><DD CLASS="dd-description"> Synonym for warning 9.
</DD><DT CLASS="dt-description"><B>S</B></DT><DD CLASS="dd-description"> Synonym for warning 10.
</DD><DT CLASS="dt-description"><B>U</B></DT><DD CLASS="dd-description"> Set of warnings 11, 12.
</DD><DT CLASS="dt-description"><B>V</B></DT><DD CLASS="dd-description"> Synonym for warning 13.
</DD><DT CLASS="dt-description"><B>X</B></DT><DD CLASS="dd-description"> Set of warnings 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 30.
</DD><DT CLASS="dt-description"><B>Y</B></DT><DD CLASS="dd-description"> Synonym for warning 26.
</DD><DT CLASS="dt-description"><B>Z</B></DT><DD CLASS="dd-description"> Synonym for warning 27.

</DD></DL><P>The default setting is <TT>-w +a-4-6-7-9-27-29-32..37</TT>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</P></DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Mark as errors the warnings specified in the argument <I>warning-list</I>.
The compiler will stop with an error when one of these warnings is
emitted. The <I>warning-list</I> has the same meaning as for
the <TT>-w</TT> option: a <TT>+</TT> sign (or an uppercase letter) turns the
corresponding warnings into errors, a <TT>-</TT>
sign (or a lowercase letter) turns them back into warnings, and a
<TT>@</TT> sign both enables and marks the corresponding warnings.<P>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <TT>-warn-error</TT>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</P><P>The default setting is <TT>-warn-error -a</TT>
(none of the warnings is treated as an error).</P></DD><DT CLASS="dt-description"><TT><B>-warn-help</B></TT></DT><DD CLASS="dd-description">
Show description for all available warning numbers.</DD><DT CLASS="dt-description"><TT><B>-where</B></TT></DT><DD CLASS="dd-description">
Print the location of the standard library, then exit.</DD><DT CLASS="dt-description"><B><TT>-</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as a file name, even if it starts with a dash (<TT>-</TT>)
character.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Modules and the file system-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc118">8.3</A>&#XA0;&#XA0;Modules and the file system</H2><!--SEC END --><P>This short section is intended to clarify the relationship between the
names of the modules corresponding to compilation units and the names
of the files that contain their compiled interface and compiled
implementation.</P><P>The compiler always derives the module name by taking the capitalized
base name of the source file (<TT>.ml</TT> or <TT>.mli</TT> file). That is, it
strips the leading directory name, if any, as well as the <TT>.ml</TT> or
<TT>.mli</TT> suffix; then, it set the first letter to uppercase, in order to
comply with the requirement that module names must be capitalized.
For instance, compiling the file <TT>mylib/misc.ml</TT> provides an
implementation for the module named <TT>Misc</TT>. Other compilation units
may refer to components defined in <TT>mylib/misc.ml</TT> under the names
<TT>Misc.</TT><I>name</I>; they can also do <TT>open Misc</TT>, then use unqualified
names <I>name</I>.</P><P>The <TT>.cmi</TT> and <TT>.cmo</TT> files produced by the compiler have the same
base name as the source file. Hence, the compiled files always have
their base name equal (modulo capitalization of the first letter) to
the name of the module they describe (for <TT>.cmi</TT> files) or implement
(for <TT>.cmo</TT> files).</P><P>When the compiler encounters a reference to a free module identifier
<TT>Mod</TT>, it looks in the search path for a file named <TT>Mod.cmi</TT> or <TT>mod.cmi</TT>
and loads the compiled interface
contained in that file. As a consequence, renaming <TT>.cmi</TT> files is not
advised: the name of a <TT>.cmi</TT> file must always correspond to the name
of the compilation unit it implements. It is admissible to move them
to another directory, if their base name is preserved, and the correct
<TT>-I</TT> options are given to the compiler. The compiler will flag an
error if it loads a <TT>.cmi</TT> file that has been renamed.</P><P>Compiled bytecode files (<TT>.cmo</TT> files), on the other hand, can be
freely renamed once created. That&#X2019;s because the linker never attempts
to find by itself the <TT>.cmo</TT> file that implements a module with a
given name: it relies instead on the user providing the list of <TT>.cmo</TT>
files by hand.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc119">8.4</A>&#XA0;&#XA0;Common errors</H2><!--SEC END --><P> <A NAME="s:comp-errors"></A></P><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B>Cannot find file <I>filename</I></B></DT><DD CLASS="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path. The <I>filename</I> is either a
compiled interface file (<TT>.cmi</TT> file), or a compiled bytecode file
(<TT>.cmo</TT> file). If <I>filename</I> has the format <I>mod</I><TT>.cmi</TT>, this
means you are trying to compile a file that references identifiers
from module <I>mod</I>, but you have not yet compiled an interface for
module <I>mod</I>. Fix: compile <I>mod</I><TT>.mli</TT> or <I>mod</I><TT>.ml</TT>
first, to create the compiled interface <I>mod</I><TT>.cmi</TT>.<P>If <I>filename</I> has the format <I>mod</I><TT>.cmo</TT>, this
means you are trying to link a bytecode object file that does not
exist yet. Fix: compile <I>mod</I><TT>.ml</TT> first.</P><P>If your program spans several directories, this error can also appear
because you haven&#X2019;t specified the directories to look into. Fix: add
the correct <TT>-I</TT> options to the command line.</P></DD><DT CLASS="dt-description"><B>Corrupted compiled interface <I>filename</I></B></DT><DD CLASS="dd-description">
The compiler produces this error when it tries to read a compiled
interface file (<TT>.cmi</TT> file) that has the wrong structure. This means
something went wrong when this <TT>.cmi</TT> file was written: the disk was
full, the compiler was interrupted in the middle of the file creation,
and so on. This error can also appear if a <TT>.cmi</TT> file is modified after
its creation by the compiler. Fix: remove the corrupted <TT>.cmi</TT> file,
and rebuild it.</DD><DT CLASS="dt-description"><B>This expression has type <I>t</I><SUB>1</SUB>, but is used with type <I>t</I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
This is by far the most common type error in programs. Type <I>t</I><SUB>1</SUB> is
the type inferred for the expression (the part of the program that is
displayed in the error message), by looking at the expression itself.
Type <I>t</I><SUB>2</SUB> is the type expected by the context of the expression; it
is deduced by looking at how the value of this expression is used in
the rest of the program. If the two types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not
compatible, then the error above is produced.<P>In some cases, it is hard to understand why the two types <I>t</I><SUB>1</SUB> and
<I>t</I><SUB>2</SUB> are incompatible. For instance, the compiler can report that
&#X201C;expression of type <TT>foo</TT> cannot be used with type <TT>foo</TT>&#X201D;, and it
really seems that the two types <TT>foo</TT> are compatible. This is not
always true. Two type constructors can have the same name, but
actually represent different types. This can happen if a type
constructor is redefined. Example:
</P><PRE>        type foo = A | B
        let f = function A -&gt; 0 | B -&gt; 1
        type foo = C | D
        f C
</PRE><P>This result in the error message &#X201C;expression <TT>C</TT> of type <TT>foo</TT> cannot
be used with type <TT>foo</TT>&#X201D;.</P></DD><DT CLASS="dt-description"><B>The type of this expression, <I>t</I>, contains type variables
that cannot be generalized</B></DT><DD CLASS="dd-description">
Type variables (<TT>'a</TT>, <TT>'b</TT>, &#X2026;) in a type <I>t</I> can be in either
of two states: generalized (which means that the type <I>t</I> is valid
for all possible instantiations of the variables) and not generalized
(which means that the type <I>t</I> is valid only for one instantiation
of the variables). In a <TT>let</TT> binding <TT>let </TT><I>name</I><TT> = </TT><I>expr</I>,
the type-checker normally generalizes as many type variables as
possible in the type of <I>expr</I>. However, this leads to unsoundness
(a well-typed program can crash) in conjunction with polymorphic
mutable data structures. To avoid this, generalization is performed at
<TT>let</TT> bindings only if the bound expression <I>expr</I> belongs to the
class of &#X201C;syntactic values&#X201D;, which includes constants, identifiers,
functions, tuples of syntactic values, etc. In all other cases (for
instance, <I>expr</I> is a function application), a polymorphic mutable
could have been created and generalization is therefore turned off for
all variables occuring in contravariant or non-variant branches of the
type. For instance, if the type of a non-value is <TT>'a list</TT> the
variable is generalizable (<TT>list</TT> is a covariant type constructor),
but not in <TT>'a list -&gt; 'a list</TT> (the left branch of <TT>-&gt;</TT> is
contravariant) or <TT>'a ref</TT> (<TT>ref</TT> is non-variant).<P>Non-generalized type variables in a type cause no difficulties inside
a given structure or compilation unit (the contents of a <TT>.ml</TT> file,
or an interactive session), but they cannot be allowed inside
signatures nor in compiled interfaces (<TT>.cmi</TT> file), because they
could be used inconsistently later. Therefore, the compiler
flags an error when a structure or compilation unit defines a value
<I>name</I> whose type contains non-generalized type variables. There
are two ways to fix this error:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Add a type constraint or a <TT>.mli</TT> file to give a monomorphic
type (without type variables) to <I>name</I>. For instance, instead of
writing
<PRE>    let sort_int_list = Sort.list (&lt;)
    (* inferred type 'a list -&gt; 'a list, with 'a not generalized *)
</PRE>write
<PRE>    let sort_int_list = (Sort.list (&lt;) : int list -&gt; int list);;
</PRE></LI><LI CLASS="li-itemize">If you really need <I>name</I> to have a polymorphic type, turn
its defining expression into a function by adding an extra parameter.
For instance, instead of writing
<PRE>    let map_length = List.map Array.length
    (* inferred type 'a array list -&gt; int list, with 'a not generalized *)
</PRE>write
<PRE>    let map_length lv = List.map Array.length lv
</PRE></LI></UL></DD><DT CLASS="dt-description"><B>Reference to undefined global <I>mod</I></B></DT><DD CLASS="dd-description">
This error appears when trying to link an incomplete or incorrectly
ordered set of files. Either you have forgotten to provide an
implementation for the compilation unit named <I>mod</I> on the command line
(typically, the file named <I>mod</I><TT>.cmo</TT>, or a library containing
that file). Fix: add the missing <TT>.ml</TT> or <TT>.cmo</TT> file to the command
line. Or, you have provided an implementation for the module named
<I>mod</I>, but it comes too late on the command line: the
implementation of <I>mod</I> must come before all bytecode object files
that reference <I>mod</I>. Fix: change the order of <TT>.ml</TT> and <TT>.cmo</TT>
files on the command line.<P>Of course, you will always encounter this error if you have mutually
recursive functions across modules. That is, function <TT>Mod1.f</TT> calls
function <TT>Mod2.g</TT>, and function <TT>Mod2.g</TT> calls function <TT>Mod1.f</TT>.
In this case, no matter what permutations you perform on the command
line, the program will be rejected at link-time. Fixes:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Put <TT>f</TT> and <TT>g</TT> in the same module.
</LI><LI CLASS="li-itemize">Parameterize one function by the other.
That is, instead of having
<PRE>mod1.ml:    let f x = ... Mod2.g ...
mod2.ml:    let g y = ... Mod1.f ...
</PRE>define
<PRE>mod1.ml:    let f g x = ... g ...
mod2.ml:    let rec g y = ... Mod1.f g ...
</PRE>and link <TT>mod1.cmo</TT> before <TT>mod2.cmo</TT>.
</LI><LI CLASS="li-itemize">Use a reference to hold one of the two functions, as in :
<PRE>mod1.ml:    let forward_g =
                ref((fun x -&gt; failwith "forward_g") : &lt;type&gt;)
            let f x = ... !forward_g ...
mod2.ml:    let g y = ... Mod1.f ...
            let _ = Mod1.forward_g := g
</PRE></LI></UL></DD><DT CLASS="dt-description"><B>The external function <I>f</I> is not available</B></DT><DD CLASS="dd-description">
This error appears when trying to link code that calls external
functions written in C. As explained in
chapter&#XA0;<A HREF="#c:intf-c">19</A>, such code must be linked with C libraries that
implement the required <I>f</I> C function. If the C libraries in
question are not shared libraries (DLLs), the code must be linked in
&#X201C;custom runtime&#X201D; mode. Fix: add the required C libraries to the
command line, and possibly the <TT>-custom</TT> option.</DD></DL><!--TOC chapter The toplevel system (ocaml)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc120">Chapter&#XA0;9</A>&#XA0;&#XA0;The toplevel system (ocaml)</H1><!--SEC END --><P> <A NAME="c:camllight"></A>
</P><P>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system
through a read-eval-print loop. In this mode, the system repeatedly
reads OCaml phrases from the input, then typechecks, compile and
evaluate them, then prints the inferred type and result value, if
any. The system prints a <TT>#</TT> (sharp) prompt before reading each
phrase.</P><P>Input to the toplevel can span several lines. It is terminated by <TT>;;</TT> (a
double-semicolon). The toplevel input consists in one or several
toplevel phrases, with the following syntax:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="toplevel-input" class="syntax"><FONT COLOR=maroon>toplevel-input</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{&#XA0;<I><A href="#toplevel-phrase" class="syntax"><FONT COLOR=maroon>toplevel-phrase</FONT></A></I>&#XA0;}&#XA0;<FONT COLOR=blue><TT>;;</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="toplevel-phrase" class="syntax"><FONT COLOR=maroon>toplevel-phrase</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A href="#definition" class="syntax"><FONT COLOR=maroon>definition</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#expr" class="syntax"><FONT COLOR=maroon>expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>#</TT></FONT>&#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>&#XA0;&#XA0;<I><A href="#directive-argument" class="syntax"><FONT COLOR=maroon>directive-argument</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="directive-argument" class="syntax"><FONT COLOR=maroon>directive-argument</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X454;
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#string-literal" class="syntax"><FONT COLOR=maroon>string-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#integer-literal" class="syntax"><FONT COLOR=maroon>integer-literal</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#value-path" class="syntax"><FONT COLOR=maroon>value-path</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A phrase can consist of a definition, similar to those found in
implementations of compilation units or in <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT>
module expressions. The definition can bind value names, type names,
an exception, a module name, or a module type name. The toplevel
system performs the bindings, then prints the types and values (if
any) for the names thus defined.</P><P>A phrase may also consist in a <TT>open</TT> directive (see
section&#XA0;<A HREF="#s:module-expr">6.11</A>), or a value expression
(section&#XA0;<A HREF="#s:value-expr">6.7</A>). Expressions are simply evaluated,
without performing any bindings, and the value of the expression is
printed.</P><P>Finally, a phrase can also consist in a toplevel directive,
starting with <TT>#</TT> (the sharp sign). These directives control the
behavior of the toplevel; they are listed below in
section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0;
The toplevel system is started by the command <TT>ocaml</TT>, as follows:
<PRE>
        ocaml <I>options objects</I>                # interactive mode
        ocaml <I>options objects scriptfile</I>        # script mode
</PRE>
<I>options</I> are described below.
<I>objects</I> are filenames ending in <TT>.cmo</TT> or <TT>.cma</TT>; they are
loaded into the interpreter immediately after <I>options</I> are set.
<I>scriptfile</I> is any file name not ending in <TT>.cmo</TT> or <TT>.cma</TT>.<P>If no <I>scriptfile</I> is given on the command line, the toplevel system
enters interactive mode: phrases are read on standard input, results
are printed on standard output, errors on standard error. End-of-file
on standard input terminates <TT>ocaml</TT> (see also the <TT>#quit</TT> directive
in section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>).</P><P>On start-up (before the first phrase is read), if the file
<TT>.ocamlinit</TT> exists in the current directory,
its contents are read as a sequence of OCaml phrases
and executed as per the <TT>#use</TT> directive
described in section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>.
The evaluation outcode for each phrase are not displayed.
If the current directory does not contain an <TT>.ocamlinit</TT> file, but
the user&#X2019;s home directory (environment variable <TT>HOME</TT>) does, the
latter is read and executed as described below.</P><P>The toplevel system does not perform line editing, but it can
easily be used in conjunction with an external line editor such as
<TT>ledit</TT>, <TT>ocaml2</TT> or <TT>rlwrap</TT>


(see the
<A HREF="http://caml.inria.fr/humps/index_framed_caml.html">Caml Hump</A>).

Another option is to use <TT>ocaml</TT> under Gnu Emacs, which gives the
full editing power of Emacs (command <TT>run-caml</TT> from library <TT>inf-caml</TT>).</P><P>At any point, the parsing, compilation or evaluation of the current
phrase can be interrupted by pressing <TT>ctrl-C</TT> (or, more precisely,
by sending the <TT>INTR</TT> signal to the <TT>ocaml</TT> process). The toplevel
then immediately returns to the <TT>#</TT> prompt.</P><P>If <I>scriptfile</I> is given on the command-line to <TT>ocaml</TT>, the toplevel
system enters script mode: the contents of the file are read as a
sequence of OCaml phrases and executed, as per the <TT>#use</TT>
directive (section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>). The outcome of the
evaluation is not printed. On reaching the end of file, the <TT>ocaml</TT>
command exits immediately. No commands are read from standard input.
<TT>Sys.argv</TT> is transformed, ignoring all OCaml parameters, and
starting with the script file name in <TT>Sys.argv.(0)</TT>.</P><P>In script mode, the first line of the script is ignored if it starts
with <TT>#!</TT>. Thus, it should be possible to make the script
itself executable and put as first line <TT>#!/usr/local/bin/ocaml</TT>,
thus calling the toplevel system automatically when the script is
run. However, <TT>ocaml</TT> itself is a <TT>#!</TT> script on most installations
of OCaml, and Unix kernels usually do not handle nested <TT>#!</TT>
scripts. A better solution is to put the following as the first line
of the script:
</P><PRE>        #!/usr/local/bin/ocamlrun /usr/local/bin/ocaml
</PRE></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
In addition to the text-only command <TT>ocaml.exe</TT>, which works exactly
as under Unix (see above), a graphical user interface for the
toplevel is available under the name <TT>ocamlwin.exe</TT>. It should be
launched from the Windows file manager or program manager.
This interface provides a text window in which commands can be entered
and edited, and the toplevel responses are printed.
</BLOCKQUOTE><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc121">9.1</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P> <A NAME="s:toplevel-options"></A></P><P>The following command-line options are recognized by the <TT>ocaml</TT> command.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-absname</B></TT></DT><DD CLASS="dd-description">
Force error messages to show absolute paths for file names.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files. By default, the current directory is
searched first, then the standard library directory. Directories added
with <TT>-I</TT> are searched after the current directory, in the order in
which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P><P>Directories can also be added to the list once
the toplevel is running with the <TT>#directory</TT> directive
(section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>).</P></DD><DT CLASS="dt-description"><B><TT>-init</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Load the given file instead of the default initialization file.
The default file is <TT>.ocamlinit</TT> in the current directory if it
exists, otherwise <TT>.ocamlinit</TT> in the user&#X2019;s home directory.</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><TT><B>-noprompt</B></TT></DT><DD CLASS="dd-description">
Do not display any prompt when waiting for input.</DD><DT CLASS="dt-description"><TT><B>-nostdlib</B></TT></DT><DD CLASS="dd-description">
Do not include the standard library directory in the list of
directories searched for source and compiled files.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <TT>-principal</TT> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
See the corresponding option for <TT>ocamlc</TT>, chapter&#XA0;<A HREF="#c:camlc">8</A>.
Turn bound checking off on array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
slightly faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument <I>warning-list</I>.
See section&#XA0;<A HREF="#s:comp-options">8.2</A> for the syntax of the argument.</DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Treat as errors the warnings enabled by the argument <I>warning-list</I>.
See section&#XA0;<A HREF="#s:comp-options">8.2</A> for the syntax of the argument.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0;
The following environment variables are also consulted:
<DL CLASS="description"><DT CLASS="dt-description">
<B><TT>LC_CTYPE</TT></B></DT><DD CLASS="dd-description"> If set to <TT>iso_8859_1</TT>, accented characters (from the
ISO Latin-1 character set) in string and character literals are
printed as is; otherwise, they are printed as decimal escape sequences
(<TT>\</TT><I>ddd</I>).</DD><DT CLASS="dt-description"><TT><B>TERM</B></TT></DT><DD CLASS="dd-description"> When printing error messages, the toplevel system
attempts to underline visually the location of the error. It
consults the <TT>TERM</TT> variable to determines the type of output terminal
and look up its capabilities in the terminal database.</DD><DT CLASS="dt-description"><TT><B>HOME</B></TT></DT><DD CLASS="dd-description"> Directory where the <TT>.ocamlinit</TT> file is searched.
</DD></DL>
</BLOCKQUOTE><!--TOC section Toplevel directives-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc122">9.2</A>&#XA0;&#XA0;Toplevel directives</H2><!--SEC END --><P>
<A NAME="s:toplevel-directives"></A></P><P>The following directives control the toplevel behavior, load files in
memory, and trace program execution.</P><P><B>Note:</B> all directives start with a <TT>#</TT> (sharp) symbol. This <TT>#</TT>
must be typed before the directive, and must not be confused with the
<TT>#</TT> prompt displayed by the interactive loop. For instance,
typing <TT>#quit;;</TT> will exit the toplevel loop, but typing <TT>quit;;</TT>
will result in an &#X201C;unbound value <TT>quit</TT>&#X201D; error.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>#quit;;</B></TT></DT><DD CLASS="dd-description">
Exit the toplevel loop and terminate the <TT>ocaml</TT> command.</DD><DT CLASS="dt-description"><B><TT>#labels </TT><I>bool</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Ignore labels in function types if argument is <TT>false</TT>, or switch back
to default behaviour (commuting style) if argument is <TT>true</TT>.</DD><DT CLASS="dt-description"><B><TT>#warnings "</TT><I>warning-list</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument.</DD><DT CLASS="dt-description"><B><TT>#directory "</TT><I>dir-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files.</DD><DT CLASS="dt-description"><B><TT>#cd "</TT><I>dir-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Change the current working directory.</DD><DT CLASS="dt-description"><B><TT>#load "</TT><I>file-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Load in memory a bytecode object file (<TT>.cmo</TT> file) or library file
(<TT>.cma</TT> file) produced by the batch compiler <TT>ocamlc</TT>.</DD><DT CLASS="dt-description"><B><TT>#load_rec "</TT><I>file-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Load in memory a bytecode object file (<TT>.cmo</TT> file) or library file
(<TT>.cma</TT> file) produced by the batch compiler <TT>ocamlc</TT>.
When loading an object file that depends on other modules
which have not been loaded yet, the .cmo files for these modules
are searched and loaded as well, recursively. The loading order
is not specified.</DD><DT CLASS="dt-description"><B><TT>#use "</TT><I>file-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Read, compile and execute source phrases from the given file.
This is textual inclusion: phrases are processed just as if
they were typed on standard input. The reading of the file stops at
the first error encountered.</DD><DT CLASS="dt-description"><B><TT>#install_printer </TT><I>printer-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
This directive registers the function named <I>printer-name</I> (a
value path) as a printer for values whose types match the argument
type of the function. That is, the toplevel loop will call
<I>printer-name</I> when it has such a value to print.<P>The printing function <I>printer-name</I> should have type
<FONT COLOR=blue><TT>Format.formatter</TT> <TT>-&gt;</TT> <FONT COLOR=maroon><I>t</I></FONT> <TT>-&gt;</TT> <TT>unit</TT></FONT>, where <FONT COLOR=maroon><I>t</I></FONT> is the
type for the values to be printed, and should output its textual
representation for the value of type <FONT COLOR=maroon><I>t</I></FONT> on the given formatter,
using the functions provided by the <TT>Format</TT> library. For backward
compatibility, <I>printer-name</I> can also have type
<FONT COLOR=maroon><I>t</I></FONT> <FONT COLOR=blue><TT>-&gt;</TT> <TT>unit</TT></FONT> and should then output on the standard
formatter, but this usage is deprecated.</P></DD><DT CLASS="dt-description"><B><TT>#remove_printer </TT><I>printer-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Remove the named function from the table of toplevel printers.</DD><DT CLASS="dt-description"><B><TT>#trace </TT><I>function-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
After executing this directive, all calls to the function named
<I>function-name</I> will be &#X201C;traced&#X201D;. That is, the argument and the
result are displayed for each call, as well as the exceptions escaping
out of the function, raised either by the function itself or by
another function it calls. If the function is curried, each argument
is printed as it is passed to the function.</DD><DT CLASS="dt-description"><B><TT>#untrace </TT><I>function-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Stop tracing the given function.</DD><DT CLASS="dt-description"><B><TT>#untrace_all;;</TT></B></DT><DD CLASS="dd-description">
Stop tracing all functions traced so far.</DD><DT CLASS="dt-description"><B><TT>#print_depth </TT><I>n</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Limit the printing of values to a maximal depth of <I>n</I>.
The parts of values whose depth exceeds <I>n</I> are printed as <TT>...</TT>
(ellipsis).</DD><DT CLASS="dt-description"><B><TT>#print_length </TT><I>n</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Limit the number of value nodes printed to at most <I>n</I>.
Remaining parts of values are printed as <TT>...</TT> (ellipsis).</DD></DL><!--TOC section The toplevel and the module system-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc123">9.3</A>&#XA0;&#XA0;The toplevel and the module system</H2><!--SEC END --><P> <A NAME="s:toplevel-modules"></A></P><P>Toplevel phrases can refer to identifiers defined in compilation units
with the same mechanisms as for separately compiled units: either by
using qualified names (<TT>Modulename.localname</TT>), or by using
the <TT>open</TT> construct and unqualified names (see section&#XA0;<A HREF="#s:names">6.3</A>).</P><P>However, before referencing another compilation unit, an
implementation of that unit must be present in memory.
At start-up, the toplevel system contains implementations for all the
modules in the the standard library. Implementations for user modules
can be entered with the <TT>#load</TT> directive described above. Referencing
a unit for which no implementation has been provided
results in the error <TT>Reference to undefined global `...'</TT>.</P><P>Note that entering <TT>open </TT><I>Mod</I> merely accesses the compiled
interface (<TT>.cmi</TT> file) for <I>Mod</I>, but does not load the
implementation of <I>Mod</I>, and does not cause any error if no
implementation of <I>Mod</I> has been loaded. The error
&#X201C;reference to undefined global <I>Mod</I>&#X201D; will occur only when
executing a value or module definition that refers to <I>Mod</I>.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc124">9.4</A>&#XA0;&#XA0;Common errors</H2><!--SEC END --><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B>Cannot find file <I>filename</I></B></DT><DD CLASS="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path.<P>If <I>filename</I> has the format <I>mod</I><TT>.cmi</TT>, this
means you have referenced the compilation unit <I>mod</I>, but its
compiled interface could not be found. Fix: compile <I>mod</I><TT>.mli</TT> or
<I>mod</I><TT>.ml</TT> first, to create the compiled interface <I>mod</I><TT>.cmi</TT>.</P><P>If <I>filename</I> has the format <I>mod</I><TT>.cmo</TT>, this
means you are trying to load with <TT>#load</TT> a bytecode object file that
does not exist yet. Fix: compile <I>mod</I><TT>.ml</TT> first.</P><P>If your program spans several directories, this error can also appear
because you haven&#X2019;t specified the directories to look into. Fix: use
the <TT>#directory</TT> directive to add the correct directories to the
search path.</P></DD><DT CLASS="dt-description"><B>This expression has type <I>t</I><SUB>1</SUB>, but is used with type <I>t</I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
See section&#XA0;<A HREF="#s:comp-errors">8.4</A>.</DD><DT CLASS="dt-description"><B>Reference to undefined global <I>mod</I></B></DT><DD CLASS="dd-description">
You have neglected to load in memory an implementation for a module
with <TT>#load</TT>. See section&#XA0;<A HREF="#s:toplevel-modules">9.3</A> above.</DD></DL><!--TOC section Building custom toplevel systems: <TT>ocamlmktop</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc125">9.5</A>&#XA0;&#XA0;Building custom toplevel systems: <TT>ocamlmktop</TT></H2><!--SEC END --><P>The <TT>ocamlmktop</TT> command builds OCaml toplevels that
contain user code preloaded at start-up.</P><P>The <TT>ocamlmktop</TT> command takes as argument a set of <TT>.cmo</TT> and <TT>.cma</TT>
files, and links them with the object files that implement the OCaml toplevel.
The typical use is:
</P><PRE>        ocamlmktop -o mytoplevel foo.cmo bar.cmo gee.cmo
</PRE><P>This creates the bytecode file <TT>mytoplevel</TT>, containing the OCaml toplevel
system, plus the code from the three <TT>.cmo</TT>
files. This toplevel is directly executable and is started by:
</P><PRE>        ./mytoplevel
</PRE><P>This enters a regular toplevel loop, except that the code from
<TT>foo.cmo</TT>, <TT>bar.cmo</TT> and <TT>gee.cmo</TT> is already loaded in memory, just as
if you had typed:
</P><PRE>        #load "foo.cmo";;
        #load "bar.cmo";;
        #load "gee.cmo";;
</PRE><P>on entrance to the toplevel. The modules <TT>Foo</TT>, <TT>Bar</TT> and <TT>Gee</TT> are
not opened, though; you still have to do
</P><PRE>        open Foo;;
</PRE><P>yourself, if this is what you wish.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc126">9.6</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamlmktop</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-cclib</TT> <I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the C linker when linking in
&#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter&#XA0;<A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker, when linking in
&#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter&#XA0;<A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description">
Link in &#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter&#XA0;<A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled object code files (<TT>.cmo</TT> and <TT>.cma</TT>).</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the toplevel file produced by the linker.
The default is <TT>a.out</TT>.</DD></DL><!--TOC chapter The runtime system (ocamlrun)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc127">Chapter&#XA0;10</A>&#XA0;&#XA0;The runtime system (ocamlrun)</H1><!--SEC END --><P> <A NAME="c:runtime"></A>
</P><P>The <TT>ocamlrun</TT> command executes bytecode files produced by the
linking phase of the <TT>ocamlc</TT> command.</P><!--TOC section Overview-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">10.1</A>&#XA0;&#XA0;Overview</H2><!--SEC END --><P>The <TT>ocamlrun</TT> command comprises three main parts: the bytecode
interpreter, that actually executes bytecode files; the memory
allocator and garbage collector; and a set of C functions that
implement primitive operations such as input/output.</P><P>The usage for <TT>ocamlrun</TT> is:
</P><PRE>
        ocamlrun <I>options bytecode-executable arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
The first non-option argument is taken to be the name of the file
containing the executable bytecode. (That file is searched in the
executable path as well as in the current directory.) The remaining
arguments are passed to the OCaml program, in the string array
<TT>Sys.argv</TT>. Element 0 of this array is the name of the
bytecode executable file; elements 1 to <I>n</I> are the remaining
arguments <I>arg</I><SUB>1</SUB> to <I>arg<SUB>n</SUB></I>.</P><P>As mentioned in chapter&#XA0;<A HREF="#c:camlc">8</A>, the bytecode executable files
produced by the <TT>ocamlc</TT> command are self-executable, and manage to
launch the <TT>ocamlrun</TT> command on themselves automatically. That is,
assuming <TT>a.out</TT> is a bytecode executable file,
</P><PRE>
        a.out <I>arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
works exactly as
</P><PRE>
        ocamlrun a.out <I>arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
Notice that it is not possible to pass options to <TT>ocamlrun</TT> when
invoking <TT>a.out</TT> directly.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
Under several versions of Windows, bytecode executable files are
self-executable only if their name ends in <TT>.exe</TT>. It is recommended
to always give <TT>.exe</TT> names to bytecode executables, e.g. compile
with <TT>ocamlc -o myprog.exe ...</TT> rather than <TT>ocamlc -o myprog ...</TT>.
</BLOCKQUOTE><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">10.2</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P> <A NAME="ocamlrun-options"></A></P><P>The following command-line options are recognized by <TT>ocamlrun</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-b</B></TT></DT><DD CLASS="dd-description">
When the program aborts due to an uncaught exception, print a detailed
&#X201C;back trace&#X201D; of the execution, showing where the exception was
raised and which function calls were outstanding at this point. The
back trace is printed only if the bytecode executable contains
debugging information, i.e. was compiled and linked with the <TT>-g</TT>
option to <TT>ocamlc</TT> set. This is equivalent to setting the <TT>b</TT> flag
in the <TT>OCAMLRUNPARAM</TT> environment variable (see below).
</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Search the directory <I>dir</I> for dynamically-loaded libraries,
in addition to the standard search path (see
section&#XA0;<A HREF="#s-ocamlrun-dllpath">10.3</A>).
</DD><DT CLASS="dt-description"><TT><B>-p</B></TT></DT><DD CLASS="dd-description">
Print the names of the primitives known to this version of
<TT>ocamlrun</TT> and exit.
</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Direct the memory manager to print some progress messages on
standard error. This is equivalent to setting <TT>v=63</TT> in the
<TT>OCAMLRUNPARAM</TT> environment variable (see below).
</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.
</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD></DL><P>The following environment variables are also consulted:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>CAML_LD_LIBRARY_PATH</TT></B></DT><DD CLASS="dd-description"> Additional directories to search for
dynamically-loaded libraries (see section&#XA0;<A HREF="#s-ocamlrun-dllpath">10.3</A>).</DD><DT CLASS="dt-description"><TT><B>OCAMLLIB</B></TT></DT><DD CLASS="dd-description"> The directory containing the OCaml standard
library. (If <TT>OCAMLLIB</TT> is not set, <TT>CAMLLIB</TT> will be used instead.)
Used to locate the <TT>ld.conf</TT> configuration file for
dynamic loading (see section&#XA0;<A HREF="#s-ocamlrun-dllpath">10.3</A>). If not set,
default to the library directory specified when compiling OCaml.</DD><DT CLASS="dt-description"><TT><B>OCAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> Set the runtime system options
and garbage collection parameters.
(If <TT>OCAMLRUNPARAM</TT> is not set, <TT>CAMLRUNPARAM</TT> will be used instead.)
This variable must be a sequence of parameter specifications.
A parameter specification is an option letter followed by an <TT>=</TT>
sign, a decimal number (or an hexadecimal number prefixed by <TT>0x</TT>),
and an optional multiplier. There are
nine options, six of which correspond to the fields of the
<TT>control</TT> record documented in
<A HREF="libref/Gc.html">Module <TT>Gc</TT></A>.
<DL CLASS="description"><DT CLASS="dt-description">
<B>b</B></DT><DD CLASS="dd-description"> (backtrace) Trigger the printing of a stack backtrace
when an uncaught exception aborts the program.
This option takes no argument.
</DD><DT CLASS="dt-description"><B>p</B></DT><DD CLASS="dd-description"> (parser trace) Turn on debugging support for
<TT>ocamlyacc</TT>-generated parsers. When this option is on,
the pushdown automaton that executes the parsers prints a
trace of its actions. This option takes no argument.
</DD><DT CLASS="dt-description"><B>s</B></DT><DD CLASS="dd-description"> (<TT>minor_heap_size</TT>) Size of the minor heap. (in words)
</DD><DT CLASS="dt-description"><B>i</B></DT><DD CLASS="dd-description"> (<TT>major_heap_increment</TT>) Default size increment for the
major heap. (in words)
</DD><DT CLASS="dt-description"><B>o</B></DT><DD CLASS="dd-description"> (<TT>space_overhead</TT>) The major GC speed setting.
</DD><DT CLASS="dt-description"><B>O</B></DT><DD CLASS="dd-description"> (<TT>max_overhead</TT>) The heap compaction trigger setting.
</DD><DT CLASS="dt-description"><B>v</B></DT><DD CLASS="dd-description"> (<TT>verbose</TT>) What GC messages to print to stderr. This
is a sum of values selected from the following:
<DL CLASS="description"><DT CLASS="dt-description">
<B>1 (= 0x001)</B></DT><DD CLASS="dd-description"> Start of major GC cycle.
</DD><DT CLASS="dt-description"><B>2 (= 0x002)</B></DT><DD CLASS="dd-description"> Minor collection and major GC slice.
</DD><DT CLASS="dt-description"><B>4 (= 0x004)</B></DT><DD CLASS="dd-description"> Growing and shrinking of the heap.
</DD><DT CLASS="dt-description"><B>8 (= 0x008)</B></DT><DD CLASS="dd-description"> Resizing of stacks and memory manager tables.
</DD><DT CLASS="dt-description"><B>16 (= 0x010)</B></DT><DD CLASS="dd-description"> Heap compaction.
</DD><DT CLASS="dt-description"><B>32 (= 0x020)</B></DT><DD CLASS="dd-description"> Change of GC parameters.
</DD><DT CLASS="dt-description"><B>64 (= 0x040)</B></DT><DD CLASS="dd-description"> Computation of major GC slice size.
</DD><DT CLASS="dt-description"><B>128 (= 0x080)</B></DT><DD CLASS="dd-description"> Calling of finalisation functions
</DD><DT CLASS="dt-description"><B>256 (= 0x100)</B></DT><DD CLASS="dd-description"> Startup messages (loading the bytecode
executable file, resolving shared libraries).
</DD></DL>
</DD><DT CLASS="dt-description"><B>l</B></DT><DD CLASS="dd-description"> (<TT>stack_limit</TT>) The limit (in words) of the stack size.
</DD><DT CLASS="dt-description"><B>h</B></DT><DD CLASS="dd-description"> The initial size of the major heap (in words).
</DD></DL>
The multiplier is <TT>k</TT>, <TT>M</TT>, or <TT>G</TT>, for multiplication by 2<SUP>10</SUP>,
2<SUP>20</SUP>, and 2<SUP>30</SUP> respectively.
For example, on a 32-bit machine, under <TT>bash</TT> the command
<PRE>        export OCAMLRUNPARAM='b,s=256k,v=0x015'
</PRE> tells a subsequent <TT>ocamlrun</TT> to print backtraces for uncaught exceptions,
set its initial minor heap size to 1&#XA0;megabyte and
print a message at the start of each major GC cycle, when the heap
size changes, and when compaction is triggered.</DD><DT CLASS="dt-description"><TT><B>CAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> If <TT>OCAMLRUNPARAM</TT> is not found in the
environment, then <TT>CAMLRUNPARAM</TT> will be used instead. If
<TT>CAMLRUNPARAM</TT> is not found, then the default values will be used.</DD><DT CLASS="dt-description"><TT><B>PATH</B></TT></DT><DD CLASS="dd-description"> List of directories searched to find the bytecode
executable file.
</DD></DL><!--TOC section Dynamic loading of shared libraries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">10.3</A>&#XA0;&#XA0;Dynamic loading of shared libraries</H2><!--SEC END --><P> <A NAME="s-ocamlrun-dllpath"></A></P><P>On platforms that support dynamic loading, <TT>ocamlrun</TT> can link
dynamically with C shared libraries (DLLs) providing additional C primitives
beyond those provided by the standard runtime system. The names for
these libraries are provided at link time as described in
section&#XA0;<A HREF="#dynlink-c-code">19.1.4</A>), and recorded in the bytecode executable
file; <TT>ocamlrun</TT>, then, locates these libraries and resolves references
to their primitives when the bytecode executable program starts.</P><P>The <TT>ocamlrun</TT> command searches shared libraries in the following
directories, in the order indicated:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Directories specified on the <TT>ocamlrun</TT> command line with the
<TT>-I</TT> option.
</LI><LI CLASS="li-enumerate">Directories specified in the <TT>CAML_LD_LIBRARY_PATH</TT> environment
variable.
</LI><LI CLASS="li-enumerate">Directories specified at link-time via the <TT>-dllpath</TT> option to
<TT>ocamlc</TT>. (These directories are recorded in the bytecode executable
file.)
</LI><LI CLASS="li-enumerate">Directories specified in the file <TT>ld.conf</TT>. This file resides
in the OCaml standard library directory, and lists directory
names (one per line) to be searched. Typically, it contains only one
line naming the <TT>stublibs</TT> subdirectory of the OCaml standard
library directory. Users can add there the names of other directories
containing frequently-used shared libraries; however, for consistency
of installation, we recommend that shared libraries are installed
directly in the system <TT>stublibs</TT> directory, rather than adding lines
to the <TT>ld.conf</TT> file.
</LI><LI CLASS="li-enumerate">Default directories searched by the system dynamic loader.
Under Unix, these generally include <TT>/lib</TT> and <TT>/usr/lib</TT>, plus the
directories listed in the file <TT>/etc/ld.so.conf</TT> and the environment
variable <TT>LD_LIBRARY_PATH</TT>. Under Windows, these include the Windows
system directories, plus the directories listed in the <TT>PATH</TT>
environment variable.
</LI></OL><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc131">10.4</A>&#XA0;&#XA0;Common errors</H2><!--SEC END --><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B><I>filename</I><TT>: no such file or directory</TT></B></DT><DD CLASS="dd-description">
If <I>filename</I> is the name of a self-executable bytecode file, this
means that either that file does not exist, or that it failed to run
the <TT>ocamlrun</TT> bytecode interpreter on itself. The second possibility
indicates that OCaml has not been properly installed on your
system.</DD><DT CLASS="dt-description"><TT><B>Cannot exec ocamlrun</B></TT></DT><DD CLASS="dd-description">
(When launching a self-executable bytecode file.) The <TT>ocamlrun</TT>
could not be found in the executable path. Check that OCaml
has been properly installed on your system.</DD><DT CLASS="dt-description"><TT><B>Cannot find the bytecode file</B></TT></DT><DD CLASS="dd-description">
The file that <TT>ocamlrun</TT> is trying to execute (e.g. the file given as
first non-option argument to <TT>ocamlrun</TT>) either does not exist, or is
not a valid executable bytecode file.</DD><DT CLASS="dt-description"><TT><B>Truncated bytecode file</B></TT></DT><DD CLASS="dd-description">
The file that <TT>ocamlrun</TT> is trying to execute is not a valid executable
bytecode file. Probably it has been truncated or mangled since
created. Erase and rebuild it.</DD><DT CLASS="dt-description"><TT><B>Uncaught exception</B></TT></DT><DD CLASS="dd-description">
The program being executed contains a &#X201C;stray&#X201D; exception. That is,
it raises an exception at some point, and this exception is never
caught. This causes immediate termination of the program. The name of
the exception is printed, along with its string and integer arguments
(arguments of more complex types are not correctly printed).
To locate the context of the uncaught exception, compile the program
with the <TT>-g</TT> option and either run it again under the <TT>ocamldebug</TT>
debugger (see chapter&#XA0;<A HREF="#c:debugger">16</A>), or run it with <TT>ocamlrun -b</TT>
or with the <TT>OCAMLRUNPARAM</TT> environment variable set to <TT>b=1</TT>.</DD><DT CLASS="dt-description"><TT><B>Out of memory</B></TT></DT><DD CLASS="dd-description">
The program being executed requires more memory than available. Either
the program builds excessively large data structures; or the program
contains too many nested function calls, and the stack overflows. In
some cases, your program is perfectly correct, it just requires more
memory than your machine provides. In other cases, the &#X201C;out of
memory&#X201D; message reveals an error in your program: non-terminating
recursive function, allocation of an excessively large array or
string, attempts to build an infinite list or other data structure,
&#X2026;<P>To help you diagnose this error, run your program with the <TT>-v</TT> option
to <TT>ocamlrun</TT>, or with the <TT>OCAMLRUNPARAM</TT> environment variable set to
<TT>v=63</TT>. If it displays lots of &#X201C;<TT>Growing stack</TT>&#X2026;&#X201D;
messages, this is probably a looping recursive function. If it
displays lots of &#X201C;<TT>Growing heap</TT>&#X2026;&#X201D; messages, with the heap size
growing slowly, this is probably an attempt to construct a data
structure with too many (infinitely many?) cells. If it displays few
&#X201C;<TT>Growing heap</TT>&#X2026;&#X201D; messages, but with a huge increment in the
heap size, this is probably an attempt to build an excessively large
array or string.</P></DD></DL><!--TOC chapter Native-code compilation (ocamlopt)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc132">Chapter&#XA0;11</A>&#XA0;&#XA0;Native-code compilation (ocamlopt)</H1><!--SEC END --><P> <A NAME="c:nativecomp"></A>
</P><P>This chapter describes the OCaml high-performance
native-code compiler <TT>ocamlopt</TT>, which compiles OCaml source files to
native code object files and link these object files to produce
standalone executables.</P><P>The native-code compiler is only available on certain platforms.
It produces code that runs faster than the bytecode produced by
<TT>ocamlc</TT>, at the cost of increased compilation time and executable code
size. Compatibility with the bytecode compiler is extremely high: the
same source code should run identically when compiled with <TT>ocamlc</TT> and
<TT>ocamlopt</TT>.</P><P>It is not possible to mix native-code object files produced by <TT>ocamlopt</TT>
with bytecode object files produced by <TT>ocamlc</TT>: a program must be
compiled entirely with <TT>ocamlopt</TT> or entirely with <TT>ocamlc</TT>. Native-code
object files produced by <TT>ocamlopt</TT> cannot be loaded in the toplevel
system <TT>ocaml</TT>.</P><!--TOC section Overview of the compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc133">11.1</A>&#XA0;&#XA0;Overview of the compiler</H2><!--SEC END --><P>The <TT>ocamlopt</TT> command has a command-line interface very close to that
of <TT>ocamlc</TT>. It accepts the same types of arguments, and processes them
sequentially:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arguments ending in <TT>.mli</TT> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <I>x</I><TT>.mli</TT>, the <TT>ocamlopt</TT> compiler produces a compiled interface
in the file <I>x</I><TT>.cmi</TT>. The interface produced is identical to that
produced by the bytecode compiler <TT>ocamlc</TT>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.ml</TT> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <I>x</I><TT>.ml</TT>, the <TT>ocamlopt</TT>
compiler produces two files: <I>x</I><TT>.o</TT>, containing native object code,
and <I>x</I><TT>.cmx</TT>, containing extra information for linking and
optimization of the clients of the unit. The compiled implementation
should always be referred to under the name <I>x</I><TT>.cmx</TT> (when given
a <TT>.o</TT> or <TT>.obj</TT> file, <TT>ocamlopt</TT> assumes that it contains code compiled from C,
not from OCaml).<P>The implementation is checked against the interface file <I>x</I><TT>.mli</TT>
(if it exists) as described in the manual for <TT>ocamlc</TT>
(chapter&#XA0;<A HREF="#c:camlc">8</A>).</P></LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmx</TT> are taken to be compiled object code. These
files are linked together, along with the object files obtained
by compiling <TT>.ml</TT> arguments (if any), and the OCaml standard
library, to produce a native-code executable program. The order in
which <TT>.cmx</TT> and <TT>.ml</TT> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <I>x</I><TT>.cmx</TT> file must come
before all <TT>.cmx</TT> files that refer to the unit <I>x</I>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmxa</TT> are taken to be libraries of object code.
Such a library packs in two files (<I>lib</I><TT>.cmxa</TT> and <I>lib</I><TT>.a</TT>/<TT>.lib</TT>)
a set of object files (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files). Libraries are build with
<TT>ocamlopt -a</TT> (see the description of the <TT>-a</TT> option below). The object
files contained in the library are linked as regular <TT>.cmx</TT> files (see
above), in the order specified when the library was built. The only
difference is that if an object file contained in a library is not
referenced anywhere in the program, then it is not linked in.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.c</TT> are passed to the C compiler, which generates
a <TT>.o</TT>/<TT>.obj</TT> object file. This object file is linked with the program.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.o</TT>, <TT>.a</TT> or <TT>.so</TT> (<TT>.obj</TT>, <TT>.lib</TT> and <TT>.dll</TT>
under Windows) are assumed to be C object files and
libraries. They are linked with the program.</LI></UL><P>The output of the linking phase is a regular Unix or Windows
executable file. It does not need <TT>ocamlrun</TT> to run.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc134">11.2</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamlopt</TT>.
The options <TT>-pack</TT>, <TT>-a</TT>, <TT>-shared</TT>, <TT>-c</TT> and <TT>-output-obj</TT> are mutually
exclusive.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-a</B></TT></DT><DD CLASS="dd-description">
Build a library (<TT>.cmxa</TT> and <TT>.a</TT>/<TT>.lib</TT> files) with the object files
(<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) given on the command line, instead of
linking them into an executable file. The name of the library must be
set with the <TT>-o</TT> option.<P>If <TT>-cclib</TT> or <TT>-ccopt</TT> options are passed on the command
line, these options are stored in the resulting <TT>.cmxa</TT> library. Then,
linking with this library automatically adds back the
<TT>-cclib</TT> and <TT>-ccopt</TT> options as if they had been provided on the
command line, unless the <TT>-noautolink</TT> option is given.</P></DD><DT CLASS="dt-description"><TT><B>-absname</B></TT></DT><DD CLASS="dd-description">
Force error messages to show absolute paths for file names.</DD><DT CLASS="dt-description"><TT><B>-annot</B></TT></DT><DD CLASS="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc). The information for file <I>src</I><TT>.ml</TT>
is put into file <I>src</I><TT>.annot</TT>. In case of a type error, dump
all the information inferred by the type-checker before the error.
The <I>src</I><TT>.annot</TT> file can be used with the emacs commands given in
<TT>emacs/caml-types.el</TT> to display types and other annotations
interactively.</DD><DT CLASS="dt-description"><TT><B>-c</B></TT></DT><DD CLASS="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.</DD><DT CLASS="dt-description"><B><TT>-cc</TT> <I>ccomp</I></B></DT><DD CLASS="dd-description">
Use <I>ccomp</I> as the C linker called to build the final executable
and as the C compiler for compiling <TT>.c</TT> source files.</DD><DT CLASS="dt-description"><B><TT>-cclib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the linker. This causes the given
C library to be linked with the program.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker. For instance,
<TT>-ccopt -L</TT><I>dir</I> causes the C linker to search for C libraries in
directory <I>dir</I>.</DD><DT CLASS="dt-description"><TT><B>-compact</B></TT></DT><DD CLASS="dd-description">
Optimize the produced code for space rather than for time. This
results in slightly smaller but slightly slower programs. The default is to
optimize for speed.</DD><DT CLASS="dt-description"><TT><B>-config</B></TT></DT><DD CLASS="dd-description">
Print the version number of <TT>ocamlopt</TT> and a detailed summary of its
configuration, then exit.</DD><DT CLASS="dt-description"><B><TT>-for-pack</TT> <I>module-path</I></B></DT><DD CLASS="dd-description">
Generate an object file (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) that can later be included
as a sub-module (with the given access path) of a compilation unit
constructed with <TT>-pack</TT>. For instance, <TT>ocamlopt -for-pack P -c A.ml</TT>
will generate <TT>a.cmx</TT> and <TT>a.o</TT> files that can later be used with
<TT>ocamlopt -pack -o P.cmx a.cmx</TT>.</DD><DT CLASS="dt-description"><TT><B>-g</B></TT></DT><DD CLASS="dd-description">
Add debugging information while compiling and linking. This option is
required in order to produce stack backtraces when
the program terminates on an uncaught exception (see
section&#XA0;<A HREF="#ocamlrun-options">10.2</A>).</DD><DT CLASS="dt-description"><TT><B>-i</B></TT></DT><DD CLASS="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<TT>.ml</TT>
file). No compiled files (<TT>.cmo</TT> and <TT>.cmi</TT> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<TT>.mli</TT> file) for a file:
just redirect the standard output of the compiler to a <TT>.mli</TT> file,
and edit that file to remove all declarations of unexported names.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled interface files (<TT>.cmi</TT>), compiled object code files
(<TT>.cmx</TT>), and libraries (<TT>.cmxa</TT>). By default, the current directory
is searched first, then the standard library directory. Directories
added with <TT>-I</TT> are searched after the current directory, in the order
in which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P></DD><DT CLASS="dt-description"><B><TT>-inline</TT> <I>n</I></B></DT><DD CLASS="dd-description">
Set aggressiveness of inlining to <I>n</I>, where <I>n</I> is a positive
integer. Specifying <TT>-inline 0</TT> prevents all functions from being
inlined, except those whose body is smaller than the call site. Thus,
inlining causes no expansion in code size. The default aggressiveness,
<TT>-inline 1</TT>, allows slightly larger functions to be inlined, resulting
in a slight expansion in code size. Higher values for the <TT>-inline</TT>
option cause larger and larger functions to become candidate for
inlining, but can result in a serious increase in code size.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf-suffix</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Recognize file names ending with <I>string</I> as interface files
(instead of the default <TT>.mli</TT>).</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-linkall</B></TT></DT><DD CLASS="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (<TT>-a</TT> flag), setting the <TT>-linkall</TT> flag forces all
subsequent links of programs involving that library to link all the
modules contained in the library.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</DD><DT CLASS="dt-description"><TT><B>-noautolink</B></TT></DT><DD CLASS="dd-description">
When linking <TT>.cmxa</TT> libraries, ignore <TT>-cclib</TT> and <TT>-ccopt</TT>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <TT>-noautolink</TT> and pass the correct C
libraries and options on the command line.</DD><DT CLASS="dt-description"><TT><B>-nodynlink</B></TT></DT><DD CLASS="dd-description">
Allow the compiler to use some optimizations that are valid only for code
that is never dynlinked.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by the linker. The
default output name is <TT>a.out</TT> under Unix and <TT>camlprog.exe</TT> under
Windows. If the <TT>-a</TT> option is given, specify the name of the library
produced. If the <TT>-pack</TT> option is given, specify the name of the
packed object file produced. If the <TT>-output-obj</TT> option is given,
specify the name of the output file produced. If the <TT>-shared</TT> option
is given, specify the name of plugin file produced.</DD><DT CLASS="dt-description"><TT><B>-output-obj</B></TT></DT><DD CLASS="dd-description">
Cause the linker to produce a C object file instead of an executable
file. This is useful to wrap OCaml code as a C library,
callable from any C program. See chapter&#XA0;<A HREF="#c:intf-c">19</A>,
section&#XA0;<A HREF="#s:embedded-code">19.7.5</A>. The name of the output object file
must be set with the <TT>-o</TT> option.
This option can also be used to produce a compiled shared/dynamic
library (<TT>.so</TT> extension, <TT>.dll</TT> under Windows).</DD><DT CLASS="dt-description"><TT><B>-p</B></TT></DT><DD CLASS="dd-description">
Generate extra code to write profile information when the program is
executed. The profile information can then be examined with the
analysis program <TT>gprof</TT>. (See chapter&#XA0;<A HREF="#c:profiler">17</A> for more
information on profiling.) The <TT>-p</TT> option must be given both at
compile-time and at link-time. Linking object files not compiled with
<TT>-p</TT> is possible, but results in less precise profiling.<BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0; See the Unix manual page for <TT>gprof(1)</TT> for more
information about the profiles.<P>Full support for <TT>gprof</TT> is only available for certain platforms
(currently: Intel x86 32 and 64 bits under Linux, BSD and MacOS X).
On other platforms, the <TT>-p</TT> option will result in a less precise
profile (no call graph information, only a time profile).
</P></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
The <TT>-p</TT> option does not work under Windows.
</BLOCKQUOTE></DD><DT CLASS="dt-description"><TT><B>-pack</B></TT></DT><DD CLASS="dd-description">
Build an object file (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) and its associated compiled
interface (<TT>.cmi</TT>) that combines the <TT>.cmx</TT> object
files given on the command line, making them appear as sub-modules of
the output <TT>.cmx</TT> file. The name of the output <TT>.cmx</TT> file must be
given with the <TT>-o</TT> option. For instance,
<PRE>        ocamlopt -pack -o P.cmx A.cmx B.cmx C.cmx
</PRE>generates compiled files <TT>P.cmx</TT>, <TT>P.o</TT> and <TT>P.cmi</TT> describing a
compilation unit having three sub-modules <TT>A</TT>, <TT>B</TT> and <TT>C</TT>,
corresponding to the contents of the object files <TT>A.cmx</TT>, <TT>B.cmx</TT> and
<TT>C.cmx</TT>. These contents can be referenced as <TT>P.A</TT>, <TT>P.B</TT> and <TT>P.C</TT>
in the remainder of the program.<P>The <TT>.cmx</TT> object files being combined must have been compiled with
the appropriate <TT>-for-pack</TT> option. In the example above,
<TT>A.cmx</TT>, <TT>B.cmx</TT> and <TT>C.cmx</TT> must have been compiled with
<TT>ocamlopt -for-pack P</TT>.</P><P>Multiple levels of packing can be achieved by combining <TT>-pack</TT> with
<TT>-for-pack</TT>. Consider the following example:
</P><PRE>        ocamlopt -for-pack P.Q -c A.ml
        ocamlopt -pack -o Q.cmx -for-pack P A.cmx
        ocamlopt -for-pack P -c B.ml
        ocamlopt -pack -o P.cmx Q.cmx B.cmx
</PRE><P>The resulting <TT>P.cmx</TT> object file has sub-modules <TT>P.Q</TT>, <TT>P.Q.A</TT>
and <TT>P.B</TT>.</P></DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause the compiler to call the given <I>command</I> as a preprocessor
for each source file. The output of <I>command</I> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. All programs accepted in
<TT>-principal</TT> mode are also accepted in default mode with equivalent
types, but different binary signatures.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</DD><DT CLASS="dt-description"><TT><B>-S</B></TT></DT><DD CLASS="dd-description">
Keep the assembly code produced during the compilation. The assembly
code for the source file <I>x</I><TT>.ml</TT> is saved in the file <I>x</I><TT>.s</TT>.</DD><DT CLASS="dt-description"><TT><B>-shared</B></TT></DT><DD CLASS="dd-description">
Build a plugin (usually <TT>.cmxs</TT>) that can be dynamically loaded with
the <TT>Dynlink</TT> module. The name of the plugin must be
set with the <TT>-o</TT> option. A plugin can include a number of OCaml
modules and libraries, and extra native objects (<TT>.o</TT>, <TT>.obj</TT>, <TT>.a</TT>,
<TT>.lib</TT> files). Building native plugins is only supported for some
operating system. Under some systems (currently,
only Linux AMD 64), all the OCaml code linked in a plugin must have
been compiled without the <TT>-nodynlink</TT> flag. Some constraints might also
apply to the way the extra native objects have been compiled (under
Linux AMD 64, they must contain only position-independent code).</DD><DT CLASS="dt-description"><TT><B>-thread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
system <TT>threads</TT> library described in chapter&#XA0;<A HREF="#c:threads">25</A>.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
Turn bound checking off for array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
faster, but unsafe: anything can happen if the program accesses an
array or string outside of its bounds. Additionally, turn off the
check for zero divisor in integer division and modulus operations.
With <TT>-unsafe</TT>, an integer division (or modulus) by zero can halt the
program or continue with an unspecified result instead of raising a
<TT>Division_by_zero</TT> exception.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</DD><DT CLASS="dt-description"><TT><B>-verbose</B></TT></DT><DD CLASS="dd-description">
Print all external commands before they are executed, in particular
invocations of the assembler, C compiler, and linker.</DD><DT CLASS="dt-description"><B><TT>-vnum</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description">
Print the version number of the compiler in short form (e.g. <TT>3.11.0</TT>),
then exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable, disable, or mark as errors the warnings specified by the argument
<I>warning-list</I>.
Each warning can be <EM>enabled</EM> or <EM>disabled</EM>, and each warning
can be <EM>marked</EM> or <EM>unmarked</EM>.
If a warning is disabled, it isn&#X2019;t displayed and doesn&#X2019;t affect
compilation in any way (even if it is marked). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and marked, the compiler will stop
with an error after displaying that warning if the source code
triggers it.<P>The <I>warning-list</I> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>+</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num</I></B></DT><DD CLASS="dd-description"> Disable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable and mark warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Disable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable and mark warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable and mark the set of warnings
corresponding to <I>letter</I>. The letter may be uppercase or
lowercase.
</DD><DT CLASS="dt-description"><I><B>uppercase-letter</B></I></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding
to <I>uppercase-letter</I>.
</DD><DT CLASS="dt-description"><I><B>lowercase-letter</B></I></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding
to <I>lowercase-letter</I>.
</DD></DL><P>Warning numbers and letters which are out of the range of warnings
that are currently defined are ignored. The warning are as follows.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>1</B></DT><DD CLASS="dd-description"> Suspicious-looking start-of-comment mark.
</DD><DT CLASS="dt-description"><B>2</B></DT><DD CLASS="dd-description"> Suspicious-looking end-of-comment mark.
</DD><DT CLASS="dt-description"><B>3</B></DT><DD CLASS="dd-description"> Deprecated syntax.
</DD><DT CLASS="dt-description"><B>4</B></DT><DD CLASS="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</DD><DT CLASS="dt-description"><B>5</B></DT><DD CLASS="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</DD><DT CLASS="dt-description"><B>6</B></DT><DD CLASS="dd-description"> Label omitted in function application.
</DD><DT CLASS="dt-description"><B>7</B></DT><DD CLASS="dd-description"> Method overridden.
</DD><DT CLASS="dt-description"><B>8</B></DT><DD CLASS="dd-description"> Partial match: missing cases in pattern-matching.
</DD><DT CLASS="dt-description"><B>9</B></DT><DD CLASS="dd-description"> Missing fields in a record pattern.
</DD><DT CLASS="dt-description"><B>10</B></DT><DD CLASS="dd-description"> Expression on the left-hand side of a sequence that doesn&#X2019;t have type
<TT>unit</TT> (and that is not a function, see warning number 5).
</DD><DT CLASS="dt-description"><B>11</B></DT><DD CLASS="dd-description"> Redundant case in a pattern matching (unused match case).
</DD><DT CLASS="dt-description"><B>12</B></DT><DD CLASS="dd-description"> Redundant sub-pattern in a pattern-matching.
</DD><DT CLASS="dt-description"><B>13</B></DT><DD CLASS="dd-description"> Instance variable overridden.
</DD><DT CLASS="dt-description"><B>14</B></DT><DD CLASS="dd-description"> Illegal backslash escape in a string constant.
</DD><DT CLASS="dt-description"><B>15</B></DT><DD CLASS="dd-description"> Private method made public implicitly.
</DD><DT CLASS="dt-description"><B>16</B></DT><DD CLASS="dd-description"> Unerasable optional argument.
</DD><DT CLASS="dt-description"><B>17</B></DT><DD CLASS="dd-description"> Undeclared virtual method.
</DD><DT CLASS="dt-description"><B>18</B></DT><DD CLASS="dd-description"> Non-principal type.
</DD><DT CLASS="dt-description"><B>19</B></DT><DD CLASS="dd-description"> Type without principality.
</DD><DT CLASS="dt-description"><B>20</B></DT><DD CLASS="dd-description"> Unused function argument.
</DD><DT CLASS="dt-description"><B>21</B></DT><DD CLASS="dd-description"> Non-returning statement.
</DD><DT CLASS="dt-description"><B>22</B></DT><DD CLASS="dd-description"> Camlp4 warning.
</DD><DT CLASS="dt-description"><B>23</B></DT><DD CLASS="dd-description"> Useless record <TT>with</TT> clause.
</DD><DT CLASS="dt-description"><B>24</B></DT><DD CLASS="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</DD><DT CLASS="dt-description"><B>25</B></DT><DD CLASS="dd-description"> Pattern-matching with all clauses guarded. Exhaustiveness cannot be
checked.
</DD><DT CLASS="dt-description"><B>26</B></DT><DD CLASS="dd-description"> Suspicious unused variable: unused variable that is bound
with <TT>let</TT> or <TT>as</TT>, and doesn&#X2019;t start with an underscore (<TT>_</TT>)
character.
</DD><DT CLASS="dt-description"><B>27</B></DT><DD CLASS="dd-description"> Innocuous unused variable: unused variable that is not bound with
<TT>let</TT> nor <TT>as</TT>, and doesn&#X2019;t start with an underscore (<TT>_</TT>)
character.
</DD><DT CLASS="dt-description"><B>28</B></DT><DD CLASS="dd-description"> Wildcard pattern given as argument to a constant constructor.
</DD><DT CLASS="dt-description"><B>29</B></DT><DD CLASS="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</DD><DT CLASS="dt-description"><B>30</B></DT><DD CLASS="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.
</DD><DT CLASS="dt-description"><B>31</B></DT><DD CLASS="dd-description"> A module is linked twice in the same executable.
</DD><DT CLASS="dt-description"><B>32</B></DT><DD CLASS="dd-description"> Unused value declaration.
</DD><DT CLASS="dt-description"><B>33</B></DT><DD CLASS="dd-description"> Unused open statement.
</DD><DT CLASS="dt-description"><B>34</B></DT><DD CLASS="dd-description"> Unused type declaration.
</DD><DT CLASS="dt-description"><B>35</B></DT><DD CLASS="dd-description"> Unused for-loop index.
</DD><DT CLASS="dt-description"><B>36</B></DT><DD CLASS="dd-description"> Unused ancestor variable.
</DD><DT CLASS="dt-description"><B>37</B></DT><DD CLASS="dd-description"> Unused constructor.
</DD><DT CLASS="dt-description"><B>38</B></DT><DD CLASS="dd-description"> Unused exception constructor.
</DD><DT CLASS="dt-description"><B>39</B></DT><DD CLASS="dd-description"> Unused rec flag.
</DD><DT CLASS="dt-description"><B>A</B></DT><DD CLASS="dd-description"> All warnings.
</DD><DT CLASS="dt-description"><B>C</B></DT><DD CLASS="dd-description"> Set of warnings 1, 2.
</DD><DT CLASS="dt-description"><B>D</B></DT><DD CLASS="dd-description"> Synonym for warning 3.
</DD><DT CLASS="dt-description"><B>E</B></DT><DD CLASS="dd-description"> Synonym for warning 4.
</DD><DT CLASS="dt-description"><B>F</B></DT><DD CLASS="dd-description"> Synonym for warning 5.
</DD><DT CLASS="dt-description"><B>K</B></DT><DD CLASS="dd-description"> Set of warnings 32, 33, 34, 35, 36, 37, 38, 39.
</DD><DT CLASS="dt-description"><B>L</B></DT><DD CLASS="dd-description"> Synonym for warning 6.
</DD><DT CLASS="dt-description"><B>M</B></DT><DD CLASS="dd-description"> Synonym for warning 7.
</DD><DT CLASS="dt-description"><B>P</B></DT><DD CLASS="dd-description"> Synonym for warning 8.
</DD><DT CLASS="dt-description"><B>R</B></DT><DD CLASS="dd-description"> Synonym for warning 9.
</DD><DT CLASS="dt-description"><B>S</B></DT><DD CLASS="dd-description"> Synonym for warning 10.
</DD><DT CLASS="dt-description"><B>U</B></DT><DD CLASS="dd-description"> Set of warnings 11, 12.
</DD><DT CLASS="dt-description"><B>V</B></DT><DD CLASS="dd-description"> Synonym for warning 13.
</DD><DT CLASS="dt-description"><B>X</B></DT><DD CLASS="dd-description"> Set of warnings 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 30.
</DD><DT CLASS="dt-description"><B>Y</B></DT><DD CLASS="dd-description"> Synonym for warning 26.
</DD><DT CLASS="dt-description"><B>Z</B></DT><DD CLASS="dd-description"> Synonym for warning 27.

</DD></DL><P>The default setting is <TT>-w +a-4-6-7-9-27..29</TT>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</P></DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Mark as errors the warnings specified in the argument <I>warning-list</I>.
The compiler will stop with an error when one of these warnings is
emitted. The <I>warning-list</I> has the same meaning as for
the <TT>-w</TT> option: a <TT>+</TT> sign (or an uppercase letter) turns the
corresponding warnings into errors, a <TT>-</TT>
sign (or a lowercase letter) turns them back into warnings, and a
<TT>@</TT> sign both enables and marks the corresponding warnings.<P>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <TT>-warn-error</TT>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</P><P>The default setting is <TT>-warn-error -a</TT>
(none of the warnings is treated as an error).</P></DD><DT CLASS="dt-description"><TT><B>-where</B></TT></DT><DD CLASS="dd-description">
Print the location of the standard library, then exit.</DD><DT CLASS="dt-description"><B><TT>-</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as a file name, even if it starts with a dash (-)
character.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC paragraph Options for the IA32 architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the IA32 architecture</H5><!--SEC END --><P>
The IA32 code generator (Intel Pentium, AMD Athlon) supports the
following additional option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-ffast-math</B></TT></DT><DD CLASS="dd-description"> Use the IA32 instructions to compute
trigonometric and exponential functions, instead of calling the
corresponding library routines. The functions affected are:
<TT>atan</TT>, <TT>atan2</TT>, <TT>cos</TT>, <TT>log</TT>, <TT>log10</TT>, <TT>sin</TT>, <TT>sqrt</TT> and <TT>tan</TT>.
The resulting code runs faster, but the range of supported arguments
and the precision of the result can be reduced. In particular,
trigonometric operations <TT>cos</TT>, <TT>sin</TT>, <TT>tan</TT> have their range reduced to
[&#X2212;2<SUP>64</SUP>, 2<SUP>64</SUP>].
</DD></DL><!--TOC paragraph Options for the AMD64 architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the AMD64 architecture</H5><!--SEC END --><P>
The AMD64 code generator (64-bit versions of Intel Pentium and AMD
Athlon) supports the following additional options:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-fPIC</B></TT></DT><DD CLASS="dd-description"> Generate position-independent machine code. This is
the default.
</DD><DT CLASS="dt-description"><TT><B>-fno-PIC</B></TT></DT><DD CLASS="dd-description"> Generate position-dependent machine code.
</DD></DL><!--TOC paragraph Options for the Sparc architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the Sparc architecture</H5><!--SEC END --><P>
The Sparc code generator supports the following additional options:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-march=v8</B></TT></DT><DD CLASS="dd-description"> Generate SPARC version 8 code.
</DD><DT CLASS="dt-description"><TT><B>-march=v9</B></TT></DT><DD CLASS="dd-description"> Generate SPARC version 9 code.
</DD></DL><P>
The default is to generate code for SPARC version 7, which runs on all
SPARC processors.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc135">11.3</A>&#XA0;&#XA0;Common errors</H2><!--SEC END --><P>The error messages are almost identical to those of <TT>ocamlc</TT>.
See section&#XA0;<A HREF="#s:comp-errors">8.4</A>.</P><!--TOC section Running executables produced by ocamlopt-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc136">11.4</A>&#XA0;&#XA0;Running executables produced by ocamlopt</H2><!--SEC END --><P>Executables generated by <TT>ocamlopt</TT> are native, stand-alone executable
files that can be invoked directly. They do
not depend on the <TT>ocamlrun</TT> bytecode runtime system nor on
dynamically-loaded C/OCaml stub libraries.</P><P>During execution of an <TT>ocamlopt</TT>-generated executable,
the following environment variables are also consulted:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>OCAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> Same usage as in <TT>ocamlrun</TT>
(see section&#XA0;<A HREF="#ocamlrun-options">10.2</A>), except that option <TT>l</TT>
is ignored (the operating system&#X2019;s stack size limit
is used instead).
</DD><DT CLASS="dt-description"><TT><B>CAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> If <TT>OCAMLRUNPARAM</TT> is not found in the
environment, then <TT>CAMLRUNPARAM</TT> will be used instead. If
<TT>CAMLRUNPARAM</TT> is not found, then the default values will be used.
</DD></DL><!--TOC section Compatibility with the bytecode compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc137">11.5</A>&#XA0;&#XA0;Compatibility with the bytecode compiler</H2><!--SEC END --><P>
<A NAME="s:compat-native-bytecode"></A></P><P>This section lists the known incompatibilities between the bytecode
compiler and the native-code compiler. Except on those points, the two
compilers should generate code that behave identically.</P><UL CLASS="itemize"><LI CLASS="li-itemize">Signals are detected only when the program performs an
allocation in the heap. That is, if a signal is delivered while in a
piece of code that does not allocate, its handler will not be called
until the next heap allocation.</LI><LI CLASS="li-itemize">Stack overflow, typically caused by excessively deep recursion,
is handled in one of the following ways, depending on the
platform used:
<UL CLASS="itemize"><LI CLASS="li-itemize">
By raising a <TT>Stack_overflow</TT> exception, like the bytecode
compiler does. (IA32/Linux, AMD64/Linux, PowerPC/MacOSX, MS Windows
32-bit ports).
</LI><LI CLASS="li-itemize">By aborting the program on a &#X201C;segmentation fault&#X201D; signal.
(All other Unix systems.)
</LI><LI CLASS="li-itemize">By terminating the program silently.
(MS Windows 64 bits).
</LI></UL></LI><LI CLASS="li-itemize">On IA32 processors only (Intel and AMD x86 processors in 32-bit
mode), some intermediate results in floating-point computations are
kept in extended precision rather than being rounded to double
precision like the bytecode compiler always does. Floating-point
results can therefore differ slightly between bytecode and native code.</LI></UL><!--TOC chapter Lexer and parser generators (ocamllex, ocamlyacc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc138">Chapter&#XA0;12</A>&#XA0;&#XA0;Lexer and parser generators (ocamllex, ocamlyacc)</H1><!--SEC END --><P>
<A NAME="c:ocamlyacc"></A>
</P><P>This chapter describes two program generators: <TT>ocamllex</TT>, that
produces a lexical analyzer from a set of regular expressions with
associated semantic actions, and <TT>ocamlyacc</TT>, that produces a parser
from a grammar with associated semantic actions.</P><P>These program generators are very close to the well-known <TT>lex</TT> and
<TT>yacc</TT> commands that can be found in most C programming environments.
This chapter assumes a working knowledge of <TT>lex</TT> and <TT>yacc</TT>: while
it describes the input syntax for <TT>ocamllex</TT> and <TT>ocamlyacc</TT> and the
main differences with <TT>lex</TT> and <TT>yacc</TT>, it does not explain the basics
of writing a lexer or parser description in <TT>lex</TT> and <TT>yacc</TT>. Readers
unfamiliar with <TT>lex</TT> and <TT>yacc</TT> are referred to &#X201C;Compilers:
principles, techniques, and tools&#X201D; by Aho, Sethi and Ullman
(Addison-Wesley, 1986), or &#X201C;Lex &amp; Yacc&#X201D;, by Levine, Mason and
Brown (O&#X2019;Reilly, 1992).</P><!--TOC section Overview of <TT>ocamllex</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc139">12.1</A>&#XA0;&#XA0;Overview of <TT>ocamllex</TT></H2><!--SEC END --><P>The <TT>ocamllex</TT> command produces a lexical analyzer from a set of regular
expressions with attached semantic actions, in the style of
<TT>lex</TT>. Assuming the input file is <I>lexer</I><TT>.mll</TT>, executing
</P><PRE>
        ocamllex <I>lexer</I>.mll
</PRE><P>
produces OCaml code for a lexical analyzer in file <I>lexer</I><TT>.ml</TT>.
This file defines one lexing function per entry point in the lexer
definition. These functions have the same names as the entry
points. Lexing functions take as argument a lexer buffer, and return
the semantic attribute of the corresponding entry point.</P><P>Lexer buffers are an abstract data type implemented in the standard
library module <TT>Lexing</TT>. The functions <TT>Lexing.from_channel</TT>,
<TT>Lexing.from_string</TT> and <TT>Lexing.from_function</TT> create
lexer buffers that read from an input channel, a character string, or
any reading function, respectively. (See the description of module
<TT>Lexing</TT> in chapter&#XA0;<A HREF="#c:stdlib">21</A>.)</P><P>When used in conjunction with a parser generated by <TT>ocamlyacc</TT>, the
semantic actions compute a value belonging to the type <TT>token</TT> defined
by the generated parsing module. (See the description of <TT>ocamlyacc</TT>
below.)</P><!--TOC subsection Options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc140">12.1.1</A>&#XA0;&#XA0;Options</H3><!--SEC END --><P>
The following command-line options are recognized by <TT>ocamllex</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-ml</B></TT></DT><DD CLASS="dd-description">
Output code that does not use OCaml&#X2019;s built-in automata
interpreter. Instead, the automaton is encoded by OCaml functions.
This option mainly is useful for debugging <TT>ocamllex</TT>, using it for
production lexers is not recommended.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>output-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by <TT>ocamllex</TT>.
The default is the input file name with its extension replaced by <TT>.ml</TT>.</DD><DT CLASS="dt-description"><TT><B>-q</B></TT></DT><DD CLASS="dd-description">
Quiet mode. <TT>ocamllex</TT> normally outputs informational messages
to standard output. They are suppressed if option <TT>-q</TT> is used.</DD><DT CLASS="dt-description"><B><TT>-v</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Syntax of lexer definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc141">12.2</A>&#XA0;&#XA0;Syntax of lexer definitions</H2><!--SEC END --><P>The format of lexer definitions is as follows:
</P><PRE>
{ <I>header</I> }
let <I>ident</I> = <I>regexp</I> &#X2026;
rule <I>entrypoint</I> [<I>arg</I><SUB>1</SUB>&#X2026; <I>arg<SUB>n</SUB></I>] =
  parse <I>regexp</I> { <I>action</I> }
      | &#X2026;
      | <I>regexp</I> { <I>action</I> }
and <I>entrypoint</I> [<I>arg</I><SUB>1</SUB>&#X2026; <I>arg<SUB>n</SUB></I>] =
  parse &#X2026;
and &#X2026;
{ <I>trailer</I> }
</PRE><P>
Comments are delimited by <TT>(*</TT> and <TT>*)</TT>, as in OCaml.
The <TT>parse</TT> keyword, can be replaced by the <TT>shortest</TT> keyword, with
the semantic consequences explained below.</P><!--TOC subsection Header and trailer-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">12.2.1</A>&#XA0;&#XA0;Header and trailer</H3><!--SEC END --><P>
The <I>header</I> and <I>trailer</I> sections are arbitrary OCaml
text enclosed in curly braces. Either or both can be omitted. If
present, the header text is copied as is at the beginning of the
output file and the trailer text at the end. Typically, the
header section contains the <TT>open</TT> directives required
by the actions, and possibly some auxiliary functions used in the
actions.</P><!--TOC subsection Naming regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc143">12.2.2</A>&#XA0;&#XA0;Naming regular expressions</H3><!--SEC END --><P>Between the header and the entry points, one can give names to
frequently-occurring regular expressions. This is written
<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I>.
In regular expressions that follow this declaration, the identifier
<I>ident</I> can be used as shorthand for <I>regexp</I>.</P><!--TOC subsection Entry points-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">12.2.3</A>&#XA0;&#XA0;Entry points</H3><!--SEC END --><P>The names of the entry points must be valid identifiers for OCaml
values (starting with a lowercase letter).
Similarily, the arguments <TT><I>arg<SUB>1</SUB></I>&#X2026;
<I>arg<SUB>n</SUB></I></TT> must be valid identifiers for OCaml.
Each entry point becomes an
OCaml function that takes <I>n</I>+1 arguments,
the extra implicit last argument being of type <TT>Lexing.lexbuf</TT>.
Characters are read from the <TT>Lexing.lexbuf</TT> argument and matched
against the regular expressions provided in the rule, until a prefix
of the input matches one of the rule. The corresponding action is
then evaluated and returned as the result of the function.</P><P>If several regular expressions match a prefix of the input, the
&#X201C;longest match&#X201D; rule applies: the regular expression that matches
the longest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is selected.</P><P>However, if lexer rules are introduced with the <TT>shortest</TT> keyword in
place of the <TT>parse</TT> keyword, then the &#X201C;shortest match&#X201D; rule applies:
the shortest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is still selected.
This feature is not intended for use in ordinary lexical analyzers, it
may facilitate the use of <TT>ocamllex</TT> as a simple text processing tool.</P><!--TOC subsection Regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">12.2.4</A>&#XA0;&#XA0;Regular expressions</H3><!--SEC END --><P>The regular expressions are in the style of <TT>lex</TT>, with a more
OCaml-like syntax.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X2026;</TD></TR>
</TABLE></TD></TR>
</TABLE><DL CLASS="description"><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>regular-char</I></FONT> &#X2223;  <I><A href="#escape-sequence" class="syntax"><FONT COLOR=maroon>escape-sequence</FONT></A></I> <FONT COLOR=blue><TT>'</TT></FONT></B></DT><DD CLASS="dd-description">
A character constant, with the same syntax as OCaml character
constants. Match the denoted character.</DD><DT CLASS="dt-description"><TT><B>_</B></TT></DT><DD CLASS="dd-description">
(underscore) Match any character.</DD><DT CLASS="dt-description"><FONT COLOR=blue><TT><B>eof</B></TT></FONT></DT><DD CLASS="dd-description">
Match the end of the lexer input.<BR>
<B>Note:</B> On some systems, with interactive input, an end-of-file
may be followed by more characters. However, <TT>ocamllex</TT> will not
correctly handle regular expressions that contain <TT>eof</TT> followed by
something else.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>"</TT></FONT> { <I><A href="#string-character" class="syntax"><FONT COLOR=maroon>string-character</FONT></A></I> } <FONT COLOR=blue><TT>"</TT></FONT></B></DT><DD CLASS="dd-description">
A string constant, with the same syntax as OCaml string
constants. Match the corresponding sequence of characters.</DD><DT CLASS="dt-description"><FONT COLOR=blue><B><TT>[</TT> <FONT COLOR=maroon><I>character-set</I></FONT> <TT>]</TT></B></FONT></DT><DD CLASS="dd-description">
Match any single character belonging to the given
character set. Valid character sets are: single
character constants <FONT COLOR=blue><TT>'</TT> <FONT COLOR=maroon><I>c</I></FONT> <TT>'</TT></FONT>; ranges of characters
<FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>'</TT> <TT>-</TT> <TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>'</TT></FONT> (all characters between <I>c</I><SUB>1</SUB> and <I>c</I><SUB>2</SUB>,
inclusive); and the union of two or more character sets, denoted by
concatenation.</DD><DT CLASS="dt-description"><FONT COLOR=blue><B><TT>[</TT> <TT>^</TT> <FONT COLOR=maroon><I>character-set</I></FONT> <TT>]</TT></B></FONT></DT><DD CLASS="dd-description">
Match any single character not belonging to the given character set.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>#</TT></FONT> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(difference of character sets)
Regular expressions <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> and <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB> must be character sets
defined with <FONT COLOR=blue><TT>[</TT></FONT>&#X2026; <FONT COLOR=blue><TT>]</TT></FONT> (or a a single character expression or
underscore <TT>_</TT>).
Match the difference of the two specified character sets.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>*</TT></FONT></B></DT><DD CLASS="dd-description">
(repetition) Match the concatenation of zero or more
strings that match <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>+</TT></FONT></B></DT><DD CLASS="dd-description">
(strict repetition) Match the concatenation of one or more
strings that match <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>?</TT></FONT></B></DT><DD CLASS="dd-description">
(option) Match the empty string, or a string matching <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(alternative) Match any string that matches <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> or <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(concatenation) Match the concatenation of two strings, the first
matching <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB>, the second matching <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB>.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT></B></DT><DD CLASS="dd-description">
Match the same strings as <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><I><B><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></B></I></DT><DD CLASS="dd-description">
Reference the regular expression bound to <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> by an earlier
<FONT COLOR=blue><TT>let</TT></FONT> <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> definition.</DD><DT CLASS="dt-description"><B><I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I></B></DT><DD CLASS="dd-description">
Bind the substring matched by <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> to identifier <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>.
</DD></DL><P>Concerning the precedences of operators, <TT>#</TT> has the highest precedence,
followed by <TT>*</TT>, <TT>+</TT> and <TT>?</TT>,
then concatenation, then <TT>|</TT> (alternation), then <TT>as</TT>.</P><!--TOC subsection Actions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">12.2.5</A>&#XA0;&#XA0;Actions</H3><!--SEC END --><P>The actions are arbitrary OCaml expressions. They are evaluated in
a context where the identifiers defined by using the <TT>as</TT> construct
are bound to subparts of the matched string.
Additionally, <TT>lexbuf</TT> is bound to the current lexer
buffer. Some typical uses for <TT>lexbuf</TT>, in conjunction with the
operations on lexer buffers provided by the <TT>Lexing</TT> standard library
module, are listed below.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>Lexing.lexeme lexbuf</B></TT></DT><DD CLASS="dd-description">
Return the matched string.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_char lexbuf </TT><I>n</I></B></DT><DD CLASS="dd-description">
Return the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT>
character in the matched string. The first character corresponds to <I>n</I> = 0.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_start lexbuf</TT></B></DT><DD CLASS="dd-description">
Return the absolute position in the input text of the beginning of the
matched string (i.e. the offset of the first character of the matched
string). The first character read from the input text has offset 0.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_end lexbuf</TT></B></DT><DD CLASS="dd-description">
Return the absolute position in the input text of the end of the
matched string (i.e. the offset of the first character after the
matched string). The first character read from the input text has
offset 0.</DD><DT CLASS="dt-description"><B><I>entrypoint</I> [<I>exp<SUB>1</SUB></I>&#X2026; <I>exp<SUB>n</SUB></I>] <TT>lexbuf</TT></B></DT><DD CLASS="dd-description">
(Where <I>entrypoint</I> is the name of another entry point in the same
lexer definition.) Recursively call the lexer on the given entry point.
Notice that <TT>lexbuf</TT> is the last argument.
Useful for lexing nested comments, for example.</DD></DL><!--TOC subsection Variables in regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">12.2.6</A>&#XA0;&#XA0;Variables in regular expressions</H3><!--SEC END --><P>
The <TT>as</TT> construct is similar to &#X201C;<EM>groups</EM>&#X201D; as provided by
numerous regular expression packages.
The type of these variables can be <TT>string</TT>, <TT>char</TT>, <TT>string option</TT>
or <TT>char option</TT>.</P><P>We first consider the case of linear patterns, that is the case when
all <TT>as</TT> bound variables are distinct.
In <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I>, the type of <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> normally is <TT>string</TT> (or
<TT>string option</TT>) except
when <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> is a character constant, an underscore, a string
constant of length one, a character set specification, or an
alternation of those. Then, the type of <I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> is <TT>char</TT> (or <TT>char option</TT>).
Option types are introduced when overall rule matching does not
imply matching of the bound sub-pattern. This is in particular the
case of <FONT COLOR=blue><TT>(</TT></FONT> <I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>?</TT></FONT> and of
<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT> <TT>(</TT></FONT> &#XA0;<I><A href="#regexp" class="syntax"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>as</TT></FONT> &#XA0;<I><A href="#ident" class="syntax"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>.</P><P>There is no linearity restriction over <TT>as</TT> bound variables.
When a variable is bound more than once, the previous rules are to be
extended as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A variable is a <TT>char</TT> variable when all its occurrences bind
<TT>char</TT> occurrences in the previous sense.
</LI><LI CLASS="li-itemize">A variable is an <TT>option</TT> variable when the overall expression
can be matched without binding this variable.
</LI></UL><P>
For instance, in
<TT>('a' as x) | ( 'a' (_ as x) )</TT> the variable <TT>x</TT> is of type
<TT>char</TT>, whereas in
<TT>("ab" as x) | ( 'a' (_ as x) ? )</TT> the variable <TT>x</TT> is of type
<TT>string option</TT>.</P><P>In some cases, a sucessful match may not yield a unique set of bindings.
For instance the matching of <CODE>aba</CODE> by the regular expression
<TT>(('a'|"ab") as x) (("ba"|'a') as y)</TT> may result in binding
either
<CODE>x</CODE> to <CODE>"ab"</CODE> and <CODE>y</CODE> to <CODE>"a"</CODE>, or
<CODE>x</CODE> to <CODE>"a"</CODE> and <CODE>y</CODE> to <CODE>"ba"</CODE>.
The automata produced <TT>ocamllex</TT> on such ambiguous regular
expressions will select one of the possible resulting sets of
bindings.
The selected set of bindings is purposely left unspecified.</P><!--TOC subsection Reserved identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">12.2.7</A>&#XA0;&#XA0;Reserved identifiers</H3><!--SEC END --><P>All identifiers starting with <TT>__ocaml_lex</TT> are reserved for use by
<TT>ocamllex</TT>; do not use any such identifier in your programs.</P><!--TOC section Overview of <TT>ocamlyacc</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc149">12.3</A>&#XA0;&#XA0;Overview of <TT>ocamlyacc</TT></H2><!--SEC END --><P>The <TT>ocamlyacc</TT> command produces a parser from a context-free grammar
specification with attached semantic actions, in the style of <TT>yacc</TT>.
Assuming the input file is <I>grammar</I><TT>.mly</TT>, executing
</P><PRE>
        ocamlyacc <I>options grammar</I>.mly
</PRE><P>
produces OCaml code for a parser in the file <I>grammar</I><TT>.ml</TT>,
and its interface in file <I>grammar</I><TT>.mli</TT>.</P><P>The generated module defines one parsing function per entry point in
the grammar. These functions have the same names as the entry points.
Parsing functions take as arguments a lexical analyzer (a function
from lexer buffers to tokens) and a lexer buffer, and return the
semantic attribute of the corresponding entry point. Lexical analyzer
functions are usually generated from a lexer specification by the
<TT>ocamllex</TT> program. Lexer buffers are an abstract data type
implemented in the standard library module <TT>Lexing</TT>. Tokens are values from
the concrete type <TT>token</TT>, defined in the interface file
<I>grammar</I><TT>.mli</TT> produced by <TT>ocamlyacc</TT>.</P><!--TOC section Syntax of grammar definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc150">12.4</A>&#XA0;&#XA0;Syntax of grammar definitions</H2><!--SEC END --><P>Grammar definitions have the following format:
</P><PRE>
%{
  <I>header</I>
%}
  <I>declarations</I>
%%
  <I>rules</I>
%%
  <I>trailer</I>
</PRE><P>Comments are enclosed between <CODE>/*</CODE> and <CODE>*/</CODE> (as in C) in the
&#X201C;declarations&#X201D; and &#X201C;rules&#X201D; sections, and between <CODE>(*</CODE> and
<CODE>*)</CODE> (as in OCaml) in the &#X201C;header&#X201D; and &#X201C;trailer&#X201D; sections.</P><!--TOC subsection Header and trailer-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc151">12.4.1</A>&#XA0;&#XA0;Header and trailer</H3><!--SEC END --><P>The header and the trailer sections are OCaml code that is copied
as is into file <I>grammar</I><TT>.ml</TT>. Both sections are optional. The header
goes at the beginning of the output file; it usually contains
<TT>open</TT> directives and auxiliary functions required by the semantic
actions of the rules. The trailer goes at the end of the output file.</P><!--TOC subsection Declarations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc152">12.4.2</A>&#XA0;&#XA0;Declarations</H3><!--SEC END --><P>Declarations are given one per line. They all start with a <CODE>%</CODE> sign.</P><DL CLASS="description"><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%token</TT></FONT> <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026; &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I></B></DT><DD CLASS="dd-description">
Declare the given symbols <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026; &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I>
as tokens (terminal symbols). These symbols
are added as constant constructors for the <TT>token</TT> concrete type.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%token</TT> <TT>&lt;</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>&gt;</TT></FONT> &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026; &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I></B></DT><DD CLASS="dd-description">
Declare the given symbols <I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026; &#XA0;<I><A href="#constr" class="syntax"><FONT COLOR=maroon>constr</FONT></A></I> as tokens with an
attached attribute of the
given type. These symbols are added as constructors with arguments of
the given type for the <TT>token</TT> concrete type. The <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> part is
an arbitrary OCaml type expression, except that all type
constructor names must be fully qualified (e.g. <TT>Modname.typename</TT>)
for all types except standard built-in types, even if the proper
<CODE>open</CODE> directives (e.g. <CODE>open Modname</CODE>) were given in the
header section. That&#X2019;s because the header is copied only to the <TT>.ml</TT>
output file, but not to the <TT>.mli</TT> output file, while the <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> part
of a <CODE>%token</CODE> declaration is copied to both.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%start</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026; &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
Declare the given symbols as entry points for the grammar. For each
entry point, a parsing function with the same name is defined in the
output module. Non-terminals that are not declared as entry points
have no such parsing function. Start symbols must be given a type with
the <CODE>%type</CODE> directive below.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%type</TT> <TT>&lt;</TT></FONT> <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>&gt;</TT></FONT> &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT> &#X2026; &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
Specify the type of the semantic attributes for the given symbols.
This is mandatory for start symbols only. Other nonterminal symbols
need not be given types by hand: these types will be inferred when
running the output files through the OCaml compiler (unless the
<CODE>-s</CODE> option is in effect). The <I><A href="#typexpr" class="syntax"><FONT COLOR=maroon>typexpr</FONT></A></I> part is an arbitrary OCaml
type expression, except that all type constructor names must be
fully qualified, as explained above for <TT>%token</TT>.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%left</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026; &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%right</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026; &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%nonassoc</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026; &#XA0;<FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description"><P>Associate precedences and associativities to the given symbols. All
symbols on the same line are given the same precedence. They have
higher precedence than symbols declared before in a <CODE>%left</CODE>,
<CODE>%right</CODE> or <CODE>%nonassoc</CODE> line. They have lower precedence
than symbols declared after in a <CODE>%left</CODE>, <CODE>%right</CODE> or
<CODE>%nonassoc</CODE> line. The symbols are declared to associate to the
left (<CODE>%left</CODE>), to the right (<CODE>%right</CODE>), or to be
non-associative (<CODE>%nonassoc</CODE>). The symbols are usually tokens.
They can also be dummy nonterminals, for use with the <CODE>%prec</CODE>
directive inside the rules.</P><P>The precedence declarations are used in the following way to
resolve reduce/reduce and shift/reduce conflicts:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Tokens and rules have precedences. By default, the precedence
of a rule is the precedence of its rightmost terminal. You
can override this default by using the <FONT COLOR=blue><TT>%prec</TT></FONT> directive in the rule.
</LI><LI CLASS="li-itemize">A reduce/reduce conflict
is resolved in favor of the first rule (in the order given by the
source file), and <TT>ocamlyacc</TT> outputs a warning.
</LI><LI CLASS="li-itemize">A shift/reduce conflict
is resolved by comparing the precedence of the rule to be
reduced with the precedence of the token to be shifted. If the
precedence of the rule is higher, then the rule will be reduced;
if the precedence of the token is higher, then the token will
be shifted.
</LI><LI CLASS="li-itemize">A shift/reduce conflict between a rule and a token with the
same precedence will be resolved using the associativity: if the
token is left-associative, then the parser will reduce; if the
token is right-associative, then the parser will shift. If the
token is non-associative, then the parser will declare a syntax
error.
</LI><LI CLASS="li-itemize">When a shift/reduce conflict cannot be resolved using the above
method, then <TT>ocamlyacc</TT> will output a warning and the parser will
always shift.
</LI></UL></DD></DL><!--TOC subsection Rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">12.4.3</A>&#XA0;&#XA0;Rules</H3><!--SEC END --><P>The syntax for rules is as usual:
</P><PRE>
<I>nonterminal</I> :
    <I>symbol</I> &#X2026; <I>symbol</I> { <I>semantic-action</I> }
  | &#X2026;
  | <I>symbol</I> &#X2026; <I>symbol</I> { <I>semantic-action</I> }
;
</PRE><P>
Rules can also contain the <CODE>%prec </CODE><I>symbol</I> directive in the
right-hand side part, to override the default precedence and
associativity of the rule with the precedence and associativity of the
given symbol.</P><P>Semantic actions are arbitrary OCaml expressions, that
are evaluated to produce the semantic attribute attached to
the defined nonterminal. The semantic actions can access the
semantic attributes of the symbols in the right-hand side of
the rule with the <CODE>$</CODE> notation: <CODE>$1</CODE> is the attribute for the
first (leftmost) symbol, <CODE>$2</CODE> is the attribute for the second
symbol, etc.</P><P>The rules may contain the special symbol <TT>error</TT> to indicate
resynchronization points, as in <TT>yacc</TT>.</P><P>Actions occurring in the middle of rules are not supported.</P><P>Nonterminal symbols are like regular OCaml symbols, except that they
cannot end with <TT>'</TT> (single quote).</P><!--TOC subsection Error handling-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc154">12.4.4</A>&#XA0;&#XA0;Error handling</H3><!--SEC END --><P>Error recovery is supported as follows: when the parser reaches an
error state (no grammar rules can apply), it calls a function named
<TT>parse_error</TT> with the string <TT>"syntax error"</TT> as argument. The default
<TT>parse_error</TT> function does nothing and returns, thus initiating error
recovery (see below). The user can define a customized <TT>parse_error</TT>
function in the header section of the grammar file.</P><P>The parser also enters error recovery mode if one of the grammar
actions raises the <TT>Parsing.Parse_error</TT> exception.</P><P>In error recovery mode, the parser discards states from the
stack until it reaches a place where the error token can be shifted.
It then discards tokens from the input until it finds three successive
tokens that can be accepted, and starts processing with the first of
these. If no state can be uncovered where the error token can be
shifted, then the parser aborts by raising the <TT>Parsing.Parse_error</TT>
exception.</P><P>Refer to documentation on <TT>yacc</TT> for more details and guidance in how
to use error recovery.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc155">12.5</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P>The <TT>ocamlyacc</TT> command recognizes the following options:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-b</TT><I>prefix</I></B></DT><DD CLASS="dd-description">
Name the output files <I>prefix</I><TT>.ml</TT>, <I>prefix</I><TT>.mli</TT>,
<I>prefix</I><TT>.output</TT>, instead of the default naming convention.</DD><DT CLASS="dt-description"><TT><B>-q</B></TT></DT><DD CLASS="dd-description">
This option has no effect.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Generate a description of the parsing tables and a report on conflicts
resulting from ambiguities in the grammar. The description is put in
file <I>grammar</I><TT>.output</TT>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><TT><B>-</B></TT></DT><DD CLASS="dd-description">
Read the grammar specification from standard input. The default
output file names are <TT>stdin.ml</TT> and <TT>stdin.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>--</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as the grammar specification, even if its name
starts with a dash (-) character. This option must be the last on the
command line.</DD></DL><P>At run-time, the <TT>ocamlyacc</TT>-generated parser can be debugged by
setting the <TT>p</TT> option in the <TT>OCAMLRUNPARAM</TT> environment variable
(see section&#XA0;<A HREF="#ocamlrun-options">10.2</A>). This causes the pushdown
automaton executing the parser to print a trace of its action (tokens
shifted, rules reduced, etc). The trace mentions rule numbers and
state numbers that can be interpreted by looking at the file
<I>grammar</I><TT>.output</TT> generated by <TT>ocamlyacc -v</TT>.</P><!--TOC section A complete example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc156">12.6</A>&#XA0;&#XA0;A complete example</H2><!--SEC END --><P>The all-time favorite: a desk calculator. This program reads
arithmetic expressions on standard input, one per line, and prints
their values. Here is the grammar definition:
</P><PRE>        /* File parser.mly */
        %token &lt;int&gt; INT
        %token PLUS MINUS TIMES DIV
        %token LPAREN RPAREN
        %token EOL
        %left PLUS MINUS        /* lowest precedence */
        %left TIMES DIV         /* medium precedence */
        %nonassoc UMINUS        /* highest precedence */
        %start main             /* the entry point */
        %type &lt;int&gt; main
        %%
        main:
            expr EOL                { $1 }
        ;
        expr:
            INT                     { $1 }
          | LPAREN expr RPAREN      { $2 }
          | expr PLUS expr          { $1 + $3 }
          | expr MINUS expr         { $1 - $3 }
          | expr TIMES expr         { $1 * $3 }
          | expr DIV expr           { $1 / $3 }
          | MINUS expr %prec UMINUS { - $2 }
        ;
</PRE><P>Here is the definition for the corresponding lexer:
</P><PRE>        (* File lexer.mll *)
        {
        open Parser        (* The type token is defined in parser.mli *)
        exception Eof
        }
        rule token = parse
            [' ' '\t']     { token lexbuf }     (* skip blanks *)
          | ['\n' ]        { EOL }
          | ['0'-'9']+ as lxm { INT(int_of_string lxm) }
          | '+'            { PLUS }
          | '-'            { MINUS }
          | '*'            { TIMES }
          | '/'            { DIV }
          | '('            { LPAREN }
          | ')'            { RPAREN }
          | eof            { raise Eof }
</PRE><P>Here is the main program, that combines the parser with the lexer:
</P><PRE>        (* File calc.ml *)
        let _ =
          try
            let lexbuf = Lexing.from_channel stdin in
            while true do
              let result = Parser.main Lexer.token lexbuf in
                print_int result; print_newline(); flush stdout
            done
          with Lexer.Eof -&gt;
            exit 0
</PRE><P>To compile everything, execute:
</P><PRE>        ocamllex lexer.mll       # generates lexer.ml
        ocamlyacc parser.mly     # generates parser.ml and parser.mli
        ocamlc -c parser.mli
        ocamlc -c lexer.ml
        ocamlc -c parser.ml
        ocamlc -c calc.ml
        ocamlc -o calc lexer.cmo parser.cmo calc.cmo
</PRE><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc157">12.7</A>&#XA0;&#XA0;Common errors</H2><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>ocamllex: transition table overflow, automaton is too big</B></DT><DD CLASS="dd-description"><P>The deterministic automata generated by <TT>ocamllex</TT> are limited to at
most 32767 transitions. The message above indicates that your lexer
definition is too complex and overflows this limit. This is commonly
caused by lexer definitions that have separate rules for each of the
alphabetic keywords of the language, as in the following example.
</P><PRE>rule token = parse
  "keyword1"   { KWD1 }
| "keyword2"   { KWD2 }
| ...
| "keyword100" { KWD100 }
| ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { IDENT id}
</PRE><P>To keep the generated automata small, rewrite those definitions with
only one general &#X201C;identifier&#X201D; rule, followed by a hashtable lookup
to separate keywords from identifiers:
</P><PRE>{ let keyword_table = Hashtbl.create 53
  let _ =
    List.iter (fun (kwd, tok) -&gt; Hashtbl.add keyword_table kwd tok)
              [ "keyword1", KWD1;
                "keyword2", KWD2; ...
                "keyword100", KWD100 ]
}
rule token = parse
  ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { try
                   Hashtbl.find keyword_table id
                 with Not_found -&gt;
                   IDENT id }
</PRE></DD><DT CLASS="dt-description"><B>ocamllex: Position memory overflow, too many bindings</B></DT><DD CLASS="dd-description">
The deterministic automata generated by <TT>ocamllex</TT> maintain a table of
positions inside the scanned lexer buffer. The size of this table is
limited to at most 255 cells. This error should not show up in normal
situations.</DD></DL><!--TOC chapter Dependency generator (ocamldep)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc158">Chapter&#XA0;13</A>&#XA0;&#XA0;Dependency generator (ocamldep)</H1><!--SEC END --><P> <A NAME="c:camldep"></A>
</P><P>The <TT>ocamldep</TT> command scans a set of OCaml source files
(<TT>.ml</TT> and <TT>.mli</TT> files) for references to external compilation units,
and outputs dependency lines in a format suitable for the <TT>make</TT>
utility. This ensures that <TT>make</TT> will compile the source files in the
correct order, and recompile those files that need to when a source
file is modified.</P><P>The typical usage is:
</P><PRE>
        ocamldep <I>options</I> *.mli *.ml &gt; .depend
</PRE><P>
where <TT>*.mli *.ml</TT> expands to all source files in the current
directory and <TT>.depend</TT> is the file that should contain the
dependencies. (See below for a typical <TT>Makefile</TT>.)</P><P>Dependencies are generated both for compiling with the bytecode
compiler <TT>ocamlc</TT> and with the native-code compiler <TT>ocamlopt</TT>.</P><P>The <TT>ocamlbuild</TT> compilation manager (see chapter&#XA0;<A HREF="#c:ocamlbuild">18</A>)
provide a higher-level, more automated alternative to the combination
of <TT>make</TT> and <TT>ocamldep</TT>. </P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc159">13.1</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamldep</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source files. If a source file <TT>foo.ml</TT> mentions an external
compilation unit <TT>Bar</TT>, a dependency on that unit&#X2019;s interface
<TT>bar.cmi</TT> is generated only if the source for <TT>bar</TT> is found in the
current directory or in one of the directories specified with <TT>-I</TT>.
Otherwise, <TT>Bar</TT> is assumed to be a module from the standard library,
and no dependencies are generated. For programs that span multiple
directories, it is recommended to pass <TT>ocamldep</TT> the same <TT>-I</TT> options
that are passed to the compiler.</DD><DT CLASS="dt-description"><B><TT>-ml-synonym</TT> <I>.ext</I></B></DT><DD CLASS="dd-description">
Consider the given extension (with leading dot) to be a synonym for .ml.</DD><DT CLASS="dt-description"><B><TT>-mli-synonym</TT> <I>.ext</I></B></DT><DD CLASS="dd-description">
Consider the given extension (with leading dot) to be a synonym for .mli.</DD><DT CLASS="dt-description"><TT><B>-modules</B></TT></DT><DD CLASS="dd-description">
Output raw dependencies of the form
<PRE>      filename: Module1 Module2 ... ModuleN
</PRE>where <TT>Module1</TT>, &#X2026;, <TT>ModuleN</TT> are the names of the compilation
units referenced within the file <TT>filename</TT>, but these names are not
resolved to source file names. Such raw dependencies cannot be used
by <TT>make</TT>, but can be post-processed by other tools such as <TT>Omake</TT>.</DD><DT CLASS="dt-description"><TT><B>-native</B></TT></DT><DD CLASS="dd-description">
Generate dependencies for a pure native-code program (no bytecode
version). When an implementation file (<TT>.ml</TT> file) has no explicit
interface file (<TT>.mli</TT> file), <TT>ocamldep</TT> generates dependencies on the
bytecode compiled file (<TT>.cmo</TT> file) to reflect interface changes.
This can cause unnecessary bytecode recompilations for programs that
are compiled to native-code only. The flag <TT>-native</TT> causes
dependencies on native compiled files (<TT>.cmx</TT>) to be generated instead
of on <TT>.cmo</TT> files. (This flag makes no difference if all source files
have explicit <TT>.mli</TT> interface files.)</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause <TT>ocamldep</TT> to call the given <I>command</I> as a preprocessor
for each source file.</DD><DT CLASS="dt-description"><TT><B>-slash</B></TT></DT><DD CLASS="dd-description">
Under Windows, use a forward slash (/) as the path separator instead
of the usual backward slash (\). Under Unix, this option does
nothing.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section A typical Makefile-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc160">13.2</A>&#XA0;&#XA0;A typical Makefile</H2><!--SEC END --><P>Here is a template <TT>Makefile</TT> for a OCaml program.</P><PRE>OCAMLC=ocamlc
OCAMLOPT=ocamlopt
OCAMLDEP=ocamldep
INCLUDES=                 # all relevant -I options here
OCAMLFLAGS=$(INCLUDES)    # add other options for ocamlc here
OCAMLOPTFLAGS=$(INCLUDES) # add other options for ocamlopt here

# prog1 should be compiled to bytecode, and is composed of three
# units: mod1, mod2 and mod3.

# The list of object files for prog1
PROG1_OBJS=mod1.cmo mod2.cmo mod3.cmo

prog1: $(PROG1_OBJS)
        $(OCAMLC) -o prog1 $(OCAMLFLAGS) $(PROG1_OBJS)

# prog2 should be compiled to native-code, and is composed of two
# units: mod4 and mod5.

# The list of object files for prog2
PROG2_OBJS=mod4.cmx mod5.cmx

prog2: $(PROG2_OBJS)
        $(OCAMLOPT) -o prog2 $(OCAMLFLAGS) $(PROG2_OBJS)

# Common rules
.SUFFIXES: .ml .mli .cmo .cmi .cmx

.ml.cmo:
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

.mli.cmi:
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

.ml.cmx:
        $(OCAMLOPT) $(OCAMLOPTFLAGS) -c $&lt;

# Clean up
clean:
        rm -f prog1 prog2
        rm -f *.cm[iox]

# Dependencies
depend:
        $(OCAMLDEP) $(INCLUDES) *.mli *.ml &gt; .depend

include .depend
</PRE><!--TOC chapter The browser/editor (ocamlbrowser)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc161">Chapter&#XA0;14</A>&#XA0;&#XA0;The browser/editor (ocamlbrowser)</H1><!--SEC END --><P> <A NAME="c:browser"></A>
</P><P>This chapter describes OCamlBrowser, a source and compiled interface
browser, written using LablTk. This is a useful companion to the
programmer.</P><P>Its functions are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
navigation through OCaml&#X2019;s modules (using compiled interfaces).
</LI><LI CLASS="li-itemize">source editing, type-checking, and browsing.
</LI><LI CLASS="li-itemize">integrated OCaml shell, running as a subprocess.
</LI></UL><!--TOC section Invocation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc162">14.1</A>&#XA0;&#XA0;Invocation</H2><!--SEC END --><P> <A NAME="s:browser-options"></A></P><P>The browser is started by the command <TT>ocamlbrowser</TT>, as follows:
</P><PRE>
        ocamlbrowser <I>options</I>
</PRE><P>The following command-line options are recognized by <TT>ocamlbrowser</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files. By default, only the standard library
directory is searched. The standard library can also be changed by
setting the <TT>OCAMLLIB</TT> environment variable.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><TT><B>-oldui</B></TT></DT><DD CLASS="dd-description">
Old multi-window interface. The default is now more like Smalltalk&#X2019;s
class browser.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument <I>warning-list</I>.</DD></DL><P>Most options can also be modified inside the application by the <B>Modules - Path editor</B> and <B>Compiler - Preferences</B> commands.
They are inherited when you start a toplevel shell.</P><!--TOC section Viewer-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc163">14.2</A>&#XA0;&#XA0;Viewer</H2><!--SEC END --><P>
This is the first window you get when you start OCamlBrowser.
It displays a search window, and the list of modules in the load path.
At the top a row of menus.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>File - Open</B> and <B>File - Editor</B> give access to the
editor.</LI><LI CLASS="li-itemize"><B>File - Shell</B> creates an OCaml subprocess in a shell.</LI><LI CLASS="li-itemize"><B>View - Show all defs</B> displays the signature of the currently
selected module.</LI><LI CLASS="li-itemize"><B>View - Search entry</B> shows/hides the search entry just
below the menu bar.</LI><LI CLASS="li-itemize"><B>Modules - Path editor</B> changes the load path. <B>Modules
- Reset cache</B> rescans the load path and resets the module cache.
Do it if you recompile some interface, or get confused about what is
in the cache.</LI><LI CLASS="li-itemize"><B>Modules - Search symbol</B> allows searching a symbol either
by its name, like the bottom line of the viewer, or more
interestingly, by its type. <B>Exact type</B> searches for a type
with exactly the same information as the pattern (variables match
only variables). <B>Included type</B> allows giving only partial
information: the actual type may take more arguments and return more
results, and variables in the pattern match anything. In both cases,
argument and tuple order is irrelevant<SUP><A NAME="text2" HREF="#note2">1</A></SUP>,
and unlabeled arguments in the pattern match any label.</LI><LI CLASS="li-itemize">The <B>Search entry</B> just below the menu bar allows one to
search for an identifier in all modules (wildcards &#X201C;?&#X201D; and &#X201C;*&#X201D;
allowed). If you choose the <TT>type</TT> option, the search is done by type
inclusion (<EM>cf.</EM> Search Symbol - Included type).</LI><LI CLASS="li-itemize">The <B>Close all</B> button is there to dismiss the windows
created by the Detach button.
By double-clicking on it you will quit the browser.</LI></UL><!--TOC section Module browsing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc164">14.3</A>&#XA0;&#XA0;Module browsing</H2><!--SEC END --><P>You select a module in the leftmost box by either cliking on it or
pressing return when it is selected. Fast access is available in all
boxes pressing the first few letter of the desired name.
Double-clicking / double-return displays the whole signature for the
module.</P><P>Defined identifiers inside the module are displayed in a box to the
right of the previous one. If you click on one, this will either
display its contents in another box (if this is a sub-module) or
display the signature for this identifier below.</P><P>Signatures are clickable. Double clicking with the left mouse
button on an identifier in a signature brings you to its signature.
A single click on the right button pops up a menu displaying the
type declaration for the selected identifier. Its title, when
selectable, also brings you to its signature.</P><P>At the bottom, a series of buttons, depending on the context.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Detach</B> copies the currently displayed signature in a new window,
to keep it.
</LI><LI CLASS="li-itemize"><B>Impl</B> and <B>Intf</B> bring you to the implementation or
interface of the currently displayed signature, if it is available.
</LI></UL><P>Control-S lets you search a string in the signature.</P><!--TOC section File editor-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc165">14.4</A>&#XA0;&#XA0;File editor</H2><!--SEC END --><P>
You can edit files with it, if you&#X2019;re not yet used to emacs. Otherwise
you can use it as a browser, making occasional corrections.</P><P>The <B>Edit</B> menu contains commands for jump (C-g), search (C-s),
and sending the current phrase (or selection if some text is selected)
to a sub-shell (M-x). For this last option, you may choose the shell
via a dialog.</P><P>Essential functions are in the <B>Compiler</B> menu.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Preferences</B> opens a dialog to set internals of the editor
and type-checker.</LI><LI CLASS="li-itemize"><B>Lex</B> adds colors according to lexical categories.</LI><LI CLASS="li-itemize"><B>Typecheck</B> verifies typing, and memorizes to let one see an
expression&#X2019;s type by double-clicking on it. This is also valid for
interfaces. If an error occurs, the part of the interface preceding
the error is computed.<P>After typechecking, pressing the right button pops up a menu that gives
the type of the pointed expression and, where applicable, provides
some links that can be followed.</P></LI><LI CLASS="li-itemize"><B>Clear errors</B> dismisses type-checker error messages and warnings.</LI><LI CLASS="li-itemize"><B>Signature</B> shows the signature of the current file
(after type checking).
</LI></UL><!--TOC section Shell-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc166">14.5</A>&#XA0;&#XA0;Shell</H2><!--SEC END --><P>
When you create a shell, a dialog is presented to you, letting you
choose which command you want to run, and the title of the shell (to
choose it in the Editor).</P><P>The executed subshell is given the current load path.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>File</B> use a source file or load a bytecode file. You may
also import the browser&#X2019;s path into the subprocess.
</LI><LI CLASS="li-itemize"><B>History</B> M-p and M-n browse up and down.
</LI><LI CLASS="li-itemize"><B>Signal</B> C-c interrupts, and you can also kill the subprocess.
</LI></UL><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note2" HREF="#text2">1</A></DT><DD CLASS="dd-thefootnotes">To avoid
combinatorial explosion of the search space, optional arguments in
the actual type are ignored in the actual if (1) there are too many
of them, and (2) they do not appear explicitly in the pattern.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter The documentation generator (ocamldoc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc167">Chapter&#XA0;15</A>&#XA0;&#XA0;The documentation generator (ocamldoc)</H1><!--SEC END --><P> <A NAME="c:ocamldoc"></A>
</P><P>This chapter describes OCamldoc, a tool that generates documentation from
special comments embedded in source files. The comments used by OCamldoc
are of the form <TT>(**</TT>&#X2026;<TT>*)</TT> and follow the format described
in section <A HREF="#s:ocamldoc-comments">15.2</A>.</P><P>OCamldoc can produce documentation in various formats: HTML, L<sup>A</sup>T<sub>E</sub>X,
TeXinfo, Unix man pages, and <TT>dot</TT> dependency graphs. Moreover,
users can add their own custom generators, as explained in
section <A HREF="#s:ocamldoc-custom-generators">15.3</A>.</P><P>In this chapter, we use the word <EM>element</EM> to refer to any of the
following parts of an OCaml source file: a type declaration, a value,
a module, an exception, a module type, a type constructor, a record
field, a class, a class type, a class method, a class value or a class
inheritance clause.</P><!--TOC section Usage-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc168">15.1</A>&#XA0;&#XA0;Usage</H2><!--SEC END --><P> <A NAME="s:ocamldoc-usage"></A></P><!--TOC subsection Invocation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc169">15.1.1</A>&#XA0;&#XA0;Invocation</H3><!--SEC END --><P>OCamldoc is invoked via the command <TT>ocamldoc</TT>, as follows:
</P><PRE>
        ocamldoc <I>options sourcefiles</I>
</PRE><!--TOC subsubsection Options for choosing the output format-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for choosing the output format</H4><!--SEC END --><P>The following options determine the format for the generated
documentation.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-html</B></TT></DT><DD CLASS="dd-description">
Generate documentation in HTML default format. The generated HTML pages
are stored in the current directory, or in the directory specified
with the <TT><B>-d</B></TT> option. You can customize the style of the
generated pages by editing the generated <TT>style.css</TT> file, or by providing
your own style sheet using option <TT>-css-style</TT>.
The file <TT>style.css</TT> is not generated if it already exists.</DD><DT CLASS="dt-description"><TT><B>-latex</B></TT></DT><DD CLASS="dd-description">
Generate documentation in L<sup>A</sup>T<sub>E</sub>X default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <TT>ocamldoc.out</TT>, or in the file
specified with the <TT><B>-o</B></TT> option. The document uses the style file
<TT>ocamldoc.sty</TT>. This file is generated when using the <TT>-latex</TT> option,
if it does not already exist.
You can change this file to customize the style of your L<sup>A</sup>T<sub>E</sub>X documentation.</DD><DT CLASS="dt-description"><TT><B>-texi</B></TT></DT><DD CLASS="dd-description">
Generate documentation in TeXinfo default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <TT>ocamldoc.out</TT>, or in the file
specified with the <TT><B>-o</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-man</B></TT></DT><DD CLASS="dd-description">
Generate documentation as a set of Unix <TT>man</TT> pages. The generated pages
are stored in the current directory, or in the directory specified
with the <TT><B>-d</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-dot</B></TT></DT><DD CLASS="dd-description">
Generate a dependency graph for the toplevel modules, in a format suitable
for displaying and processing by <TT>dot</TT>. The <TT>dot</TT> tool is available from
<TT><A HREF="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</A></TT>.
The textual representation of the graph is written to the file
<TT>ocamldoc.out</TT>, or to the file specified with the <TT><B>-o</B></TT> option.
Use <TT>dot ocamldoc.out</TT> to display it.</DD><DT CLASS="dt-description"><B><TT>-g</TT> <I>file.cm[o,a,xs]</I></B></DT><DD CLASS="dd-description">
Dynamically load the given file, which defines a custom documentation
generator. See section <A HREF="#s:ocamldoc-compilation-and-usage">15.4.1</A>. This
option is supported by the <TT>ocamldoc</TT> command (to load <TT>.cmo</TT> and <TT>.cma</TT> files)
and by its native-code version <TT>ocamldoc.opt</TT> (to load <TT>.cmxs</TT> files).
If the given file is a simple one and does not exist in
the current directory, then ocamldoc looks for it in the custom
generators default directory, and in the directories specified with
optional <TT>-i</TT> options.</DD><DT CLASS="dt-description"><TT><B>-customdir</B></TT></DT><DD CLASS="dd-description">
Display the custom generators default directory.</DD><DT CLASS="dt-description"><B><TT>-i</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the path where to look for custom generators.</DD></DL><!--TOC subsubsection General options-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->General options</H4><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-d</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Generate files in directory <I>dir</I>, rather than the current directory.</DD><DT CLASS="dt-description"><B><TT>-dump</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Dump collected information into <I>file</I>. This information can be
read with the <TT>-load</TT> option in a subsequent invocation of <TT>ocamldoc</TT>.</DD><DT CLASS="dt-description"><B><TT>-hide</TT> <I>modules</I></B></DT><DD CLASS="dd-description">
Hide the given complete module names in the generated documentation.
<I>modules</I> is a list of complete module names separated
by &#X2019;<TT>,</TT>&#X2019;, without blanks. For instance: <TT>Pervasives,M2.M3</TT>.</DD><DT CLASS="dt-description"><TT><B>-inv-merge-ml-mli</B></TT></DT><DD CLASS="dd-description">
Reverse the precedence of implementations and interfaces when merging.
All elements
in implementation files are kept, and the <TT><B>-m</B></TT> option
indicates which parts of the comments in interface files are merged
with the comments in implementation files.</DD><DT CLASS="dt-description"><TT><B>-keep-code</B></TT></DT><DD CLASS="dd-description">
Always keep the source code for values, methods and instance variables,
when available.
The source code is always kept when a <TT>.ml</TT>
file is given, but is by default discarded when a <TT>.mli</TT> is given.
This option keeps the source code in all cases.</DD><DT CLASS="dt-description"><B><TT>-load</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Load information from <I>file</I>, which has been produced by
<TT>ocamldoc -dump</TT>. Several <TT>-load</TT> options can be given.</DD><DT CLASS="dt-description"><B><TT>-m</TT> <I>flags</I></B></DT><DD CLASS="dd-description">
Specify merge options between interfaces and implementations.
(see section <A HREF="#s:ocamldoc-merge">15.1.2</A> for details).
<I>flags</I> can be one or several of the following characters:
<DL CLASS="description"><DT CLASS="dt-description">
<TT><B>d</B></TT></DT><DD CLASS="dd-description"> merge description
</DD><DT CLASS="dt-description"><TT><B>a</B></TT></DT><DD CLASS="dd-description"> merge <TT>@author</TT>
</DD><DT CLASS="dt-description"><TT><B>v</B></TT></DT><DD CLASS="dd-description"> merge <TT>@version</TT>
</DD><DT CLASS="dt-description"><TT><B>l</B></TT></DT><DD CLASS="dd-description"> merge <TT>@see</TT>
</DD><DT CLASS="dt-description"><TT><B>s</B></TT></DT><DD CLASS="dd-description"> merge <TT>@since</TT>
</DD><DT CLASS="dt-description"><TT><B>b</B></TT></DT><DD CLASS="dd-description"> merge <TT>@before</TT>
</DD><DT CLASS="dt-description"><TT><B>o</B></TT></DT><DD CLASS="dd-description"> merge <TT>@deprecated</TT>
</DD><DT CLASS="dt-description"><TT><B>p</B></TT></DT><DD CLASS="dd-description"> merge <TT>@param</TT>
</DD><DT CLASS="dt-description"><TT><B>e</B></TT></DT><DD CLASS="dd-description"> merge <TT>@raise</TT>
</DD><DT CLASS="dt-description"><TT><B>r</B></TT></DT><DD CLASS="dd-description"> merge <TT>@return</TT>
</DD><DT CLASS="dt-description"><TT><B>A</B></TT></DT><DD CLASS="dd-description"> merge everything
</DD></DL></DD><DT CLASS="dt-description"><TT><B>-no-custom-tags</B></TT></DT><DD CLASS="dd-description">
Do not allow custom @-tags (see section <A HREF="#s:ocamldoc-tags">15.2.5</A>).</DD><DT CLASS="dt-description"><TT><B>-no-stop</B></TT></DT><DD CLASS="dd-description">
Keep elements placed after/between the <TT>(**/**)</TT> special comment(s)
(see section <A HREF="#s:ocamldoc-comments">15.2</A>).</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Output the generated documentation to <I>file</I> instead of <TT>ocamldoc.out</TT>.
This option is meaningful only in conjunction with the
<TT><B>-latex</B></TT>, <TT><B>-texi</B></TT>, or <TT><B>-dot</B></TT> options.</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Pipe sources through preprocessor <I>command</I>.</DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-text</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as a text file, even if its
extension is not <TT>.txt</TT>.</DD><DT CLASS="dt-description"><TT><B>-sort</B></TT></DT><DD CLASS="dd-description">
Sort the list of top-level modules before generating the documentation.</DD><DT CLASS="dt-description"><TT><B>-stars</B></TT></DT><DD CLASS="dd-description">
Remove blank characters until the first asterisk (&#X2019;<TT>*</TT>&#X2019;) in each
line of comments.</DD><DT CLASS="dt-description"><B><TT>-t</TT> <I>title</I></B></DT><DD CLASS="dd-description">
Use <I>title</I> as the title for the generated documentation.</DD><DT CLASS="dt-description"><B><TT>-intro</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Use content of <I>file</I> as ocamldoc text to use as introduction (HTML,
L<sup>A</sup>T<sub>E</sub>X and TeXinfo only).
For HTML, the file is used to create the whole <TT>index.html</TT> file.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Verbose mode. Display progress information.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><TT><B>-warn-error</B></TT></DT><DD CLASS="dd-description">
Treat Ocamldoc warnings as errors.</DD><DT CLASS="dt-description"><TT><B>-hide-warnings</B></TT></DT><DD CLASS="dd-description">
Do not print OCamldoc warnings.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC subsubsection Type-checking options-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type-checking options</H4><!--SEC END --><P>OCamldoc calls the OCaml type-checker to obtain type
information. The following options impact the type-checking phase.
They have the same meaning as for the <TT>ocamlc</TT> and <TT>ocamlopt</TT> commands.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add <I>directory</I> to the list of directories search for compiled
interface files (<TT>.cmi</TT> files).</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types. (See the <TT>-rectypes</TT> option to <TT>ocamlc</TT>.)</DD></DL><!--TOC subsubsection Options for generating HTML pages-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating HTML pages</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-html</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-all-params</B></TT></DT><DD CLASS="dd-description">
Display the complete list of parameters for functions and methods.</DD><DT CLASS="dt-description"><B><TT>-charset</TT> <I>charset</I></B></DT><DD CLASS="dd-description">
Add information about character encoding being <I>charset</I>
(default is iso-8859-1).</DD><DT CLASS="dt-description"><TT><B>-colorize-code</B></TT></DT><DD CLASS="dd-description">
Colorize the OCaml code enclosed in <TT>[ ]</TT> and <TT>{[ ]}</TT>, using colors
to emphasize keywords, etc. If the code fragments are not
syntactically correct, no color is added.</DD><DT CLASS="dt-description"><B><TT>-css-style</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Use <I>filename</I> as the Cascading Style Sheet file.</DD><DT CLASS="dt-description"><TT><B>-index-only</B></TT></DT><DD CLASS="dd-description">
Generate only index files.</DD><DT CLASS="dt-description"><TT><B>-short-functors</B></TT></DT><DD CLASS="dd-description">
Use a short form to display functors:
<PRE>
module M : functor (A:Module) -&gt; functor (B:Module2) -&gt; sig .. end
</PRE>
is displayed as:
<PRE>
module M (A:Module) (B:Module2) : sig .. end
</PRE></DD></DL><!--TOC subsubsection Options for generating L<sup>A</sup>T<sub>E</sub>X files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating L<sup>A</sup>T<sub>E</sub>X files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-latex</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-latex-value-prefix</TT> <I>prefix</I></B></DT><DD CLASS="dd-description">
Give a prefix to use for the labels of the values in the generated
L<sup>A</sup>T<sub>E</sub>X document.
The default prefix is the empty string. You can also use the options
<TT>-latex-type-prefix</TT>, <TT>-latex-exception-prefix</TT>,
<TT>-latex-module-prefix</TT>,
<TT>-latex-module-type-prefix</TT>, <TT>-latex-class-prefix</TT>,
<TT>-latex-class-type-prefix</TT>,
<TT>-latex-attribute-prefix</TT> and <TT>-latex-method-prefix</TT>.<P>These options are useful when you have, for example, a type and a value with
the same name. If you do not specify prefixes, L<sup>A</sup>T<sub>E</sub>X will complain about
multiply defined labels.</P></DD><DT CLASS="dt-description"><B><TT>-latextitle</TT> <I>n,style</I></B></DT><DD CLASS="dd-description">
Associate style number <I>n</I> to the given L<sup>A</sup>T<sub>E</sub>X sectioning command
<I>style</I>, e.g. <TT>section</TT> or <TT>subsection</TT>. (L<sup>A</sup>T<sub>E</sub>X only.) This is
useful when including the generated document in another L<sup>A</sup>T<sub>E</sub>X document,
at a given sectioning level. The default association is 1 for <TT>section</TT>,
2 for <TT>subsection</TT>, 3 for <TT>subsubsection</TT>, 4 for <TT>paragraph</TT> and 5 for
<TT>subparagraph</TT>.</DD><DT CLASS="dt-description"><TT><B>-noheader</B></TT></DT><DD CLASS="dd-description">
Suppress header in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-notoc</B></TT></DT><DD CLASS="dd-description">
Do not generate a table of contents.</DD><DT CLASS="dt-description"><TT><B>-notrailer</B></TT></DT><DD CLASS="dd-description">
Suppress trailer in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-sepfiles</B></TT></DT><DD CLASS="dd-description">
Generate one <TT>.tex</TT> file per toplevel module, instead of the global
<TT>ocamldoc.out</TT> file.
</DD></DL><!--TOC subsubsection Options for generating TeXinfo files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating TeXinfo files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-texi</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-esc8</B></TT></DT><DD CLASS="dd-description">
Escape accented characters in Info files.</DD><DT CLASS="dt-description"><TT><B>-info-entry</B></TT></DT><DD CLASS="dd-description">
Specify Info directory entry.</DD><DT CLASS="dt-description"><TT><B>-info-section</B></TT></DT><DD CLASS="dd-description">
Specify section of Info directory.</DD><DT CLASS="dt-description"><TT><B>-noheader</B></TT></DT><DD CLASS="dd-description">
Suppress header in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-noindex</B></TT></DT><DD CLASS="dd-description">
Do not build index for Info files.</DD><DT CLASS="dt-description"><TT><B>-notrailer</B></TT></DT><DD CLASS="dd-description">
Suppress trailer in generated documentation.
</DD></DL><!--TOC subsubsection Options for generating <TT>dot</TT> graphs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating <TT>dot</TT> graphs</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-dot</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-dot-colors</TT> <I>colors</I></B></DT><DD CLASS="dd-description">
Specify the colors to use in the generated <TT>dot</TT> code.
When generating module dependencies, <TT>ocamldoc</TT> uses different colors
for modules, depending on the directories in which they reside.
When generating types dependencies, <TT>ocamldoc</TT> uses different colors
for types, depending on the modules in which they are defined.
<I>colors</I> is a list of color names separated by &#X2019;<TT>,</TT>&#X2019;, as
in <TT>Red,Blue,Green</TT>. The available colors are the ones supported by
the <TT>dot</TT> tool.</DD><DT CLASS="dt-description"><TT><B>-dot-include-all</B></TT></DT><DD CLASS="dd-description">
Include all modules in the <TT>dot</TT> output, not only modules given
on the command line or loaded with the <TT><B>-load</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-dot-reduce</B></TT></DT><DD CLASS="dd-description">
Perform a transitive reduction of the dependency graph before
outputting the <TT>dot</TT> code. This can be useful if there are
a lot of transitive dependencies that clutter the graph.</DD><DT CLASS="dt-description"><TT><B>-dot-types</B></TT></DT><DD CLASS="dd-description">
Output <TT>dot</TT> code describing the type dependency graph instead of
the module dependency graph.
</DD></DL><!--TOC subsubsection Options for generating man files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating man files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-man</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-man-mini</B></TT></DT><DD CLASS="dd-description">
Generate man pages only for modules, module types, clases and class
types, instead of pages for all elements.</DD><DT CLASS="dt-description"><B><TT>-man-suffix</TT> <I>suffix</I></B></DT><DD CLASS="dd-description">
Set the suffix used for generated man filenames. Default is &#X2019;<TT>3o</TT>&#X2019;,
as in <TT>List.3o</TT>.</DD><DT CLASS="dt-description"><B><TT>-man-section</TT> <I>section</I></B></DT><DD CLASS="dd-description">
Set the section number used for generated man filenames. Default is &#X2019;<TT>3</TT>&#X2019;.</DD></DL><!--TOC subsection Merging of module information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc170">15.1.2</A>&#XA0;&#XA0;Merging of module information</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-merge"></A></P><P>Information on a module can be extracted either from the <TT>.mli</TT> or <TT>.ml</TT>
file, or both, depending on the files given on the command line.
When both <TT>.mli</TT> and <TT>.ml</TT> files are given for the same module,
information extracted from these files is merged according to the
following rules:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Only elements (values, types, classes, ...) declared in the <TT>.mli</TT>
file are kept. In other terms, definitions from the <TT>.ml</TT> file that are
not exported in the <TT>.mli</TT> file are not documented.
</LI><LI CLASS="li-itemize">Descriptions of elements and descriptions in @-tags are handled
as follows. If a description for the same element or in the same
@-tag of the same element is present in both files, then the
description of the <TT>.ml</TT> file is concatenated to the one in the <TT>.mli</TT> file,
if the corresponding <TT>-m</TT> flag is given on the command line.
If a description is present in the <TT>.ml</TT> file and not in the
<TT>.mli</TT> file, the <TT>.ml</TT> description is kept.
In either case, all the information given in the <TT>.mli</TT> file is kept.
</LI></UL><!--TOC subsection Coding rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc171">15.1.3</A>&#XA0;&#XA0;Coding rules</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-rules"></A>
The following rules must be respected in order to avoid name clashes
resulting in cross-reference errors:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
In a module, there must not be two modules, two module types or
a module and a module type with the same name.
In the default HTML generator, modules <TT>ab</TT> and <TT>AB</TT> will be printed
to the same file on case insensitive file systems.
</LI><LI CLASS="li-itemize">In a module, there must not be two classes, two class types or
a class and a class type with the same name.
</LI><LI CLASS="li-itemize">In a module, there must not be two values, two types, or two
exceptions with the same name.
</LI><LI CLASS="li-itemize">Values defined in tuple, as in <TT>let (x,y,z) = (1,2,3)</TT>
are not kept by OCamldoc.
</LI><LI CLASS="li-itemize">Avoid the following construction:
<PRE>open Foo (* which has a module Bar with a value x *)
module Foo =
  struct
    module Bar =
      struct
        let x = 1
      end
  end
  let dummy = Bar.x
</PRE>In this case, OCamldoc will associate <TT>Bar.x</TT> to the <TT>x</TT> of module
<TT>Foo</TT> defined just above, instead of to the <TT>Bar.x</TT> defined in the
opened module <TT>Foo</TT>.
</LI></UL><!--TOC section Syntax of documentation comments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc172">15.2</A>&#XA0;&#XA0;Syntax of documentation comments</H2><!--SEC END --><P>
<A NAME="s:ocamldoc-comments"></A></P><P>Comments containing documentation material are called <EM>special
comments</EM> and are written between <TT>(**</TT> and <TT>*)</TT>. Special comments
must start exactly with <TT>(**</TT>. Comments beginning with <TT>(</TT> and more
than two <TT>*</TT> are ignored.</P><!--TOC subsection Placement of documentation comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc173">15.2.1</A>&#XA0;&#XA0;Placement of documentation comments</H3><!--SEC END --><P>
OCamldoc can associate comments to some elements of the language
encountered in the source files. The association is made according to
the locations of comments with respect to the language elements. The
locations of comments in <TT>.mli</TT> and <TT>.ml</TT> files are different.</P><!--TOC subsubsection Comments in <TT>.mli</TT> files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments in <TT>.mli</TT> files</H4><!--SEC END --><P>
A special comment is associated to an element if it is placed before or
after the element.<BR>
A special comment before an element is associated to this element if&#XA0;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
There is no blank line or another special comment between the special
comment and the element. However, a regular comment can occur between
the special comment and the element.
</LI><LI CLASS="li-itemize">The special comment is not already associated to the previous element.
</LI><LI CLASS="li-itemize">The special comment is not the first one of a toplevel module.
</LI></UL><P>A special comment after an element is associated to this element if
there is no blank line or comment between the special comment and the
element.</P><P>There are two exceptions: for constructors and record fields in
type definitions, the associated comment can only be placed after the
constructor or field definition, without blank lines or other comments
between them. The special comment for a constructor
with another constructor following must be placed before the &#X2019;<TT>|</TT>&#X2019;
character separating the two constructors.</P><P>The following sample interface file <TT>foo.mli</TT> illustrates the
placement rules for comments in <TT>.mli</TT> files.</P><PRE>(** The first special comment of the file is the comment associated
    with the whole module.*)


(** Special comments can be placed between elements and are kept
    by the OCamldoc tool, but are not associated to any element.
    @-tags in these comments are ignored.*)

(*******************************************************************)
(** Comments like the one above, with more than two asterisks,
    are ignored. *)

(** The comment for function f. *)
val f : int -&gt; int -&gt; int
(** The continuation of the comment for function f. *)

(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)
(* Hello, I'm a simple comment :-) *)
exception My_exception of (int -&gt; int) * int

(** Comment for type weather  *)
type weather =
| Rain of int (** The comment for construtor Rain *)
| Sun (** The comment for constructor Sun *)

(** Comment for type weather2  *)
type weather2 =
| Rain of int (** The comment for construtor Rain *)
| Sun (** The comment for constructor Sun *)
(** I can continue the comment for type weather2 here
  because there is already a comment associated to the last constructor.*)

(** The comment for type my_record *)
type my_record = {
    val foo : int ;    (** Comment for field foo *)
    val bar : string ; (** Comment for field bar *)
  }
  (** Continuation of comment for type my_record *)

(** Comment for foo *)
val foo : string
(** This comment is associated to foo and not to bar. *)
val bar : string
(** This comment is assciated to bar. *)

(** The comment for class my_class *)
class my_class :
  object
    (** A comment to describe inheritance from cl *)
    inherit cl

    (** The comment for attribute tutu *)
    val mutable tutu : string

    (** The comment for attribute toto. *)
    val toto : int

    (** This comment is not attached to titi since
        there is a blank line before titi, but is kept
        as a comment in the class. *)

    val titi : string

    (** Comment for method toto *)
    method toto : string

    (** Comment for method m *)
    method m : float -&gt; int
  end

(** The comment for the class type my_class_type *)
class type my_class_type =
  object
    (** The comment for variable x. *)
    val mutable x : int

    (** The commend for method m. *)
    method m : int -&gt; int
end

(** The comment for module Foo *)
module Foo =
  struct
    (** The comment for x *)
    val x : int

    (** A special comment that is kept but not associated to any element *)
  end

(** The comment for module type my_module_type. *)
module type my_module_type =
  sig
    (** The comment for value x. *)
    val x : int

    (** The comment for module M. *)
    module M =
      struct
        (** The comment for value y. *)
        val y : int

        (* ... *)
      end

  end

</PRE><!--TOC subsubsection Comments in <TT>.ml</TT> files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments in <TT>.ml</TT> files</H4><!--SEC END --><P>A special comment is associated to an element if it is placed before
the element and there is no blank line between the comment and the
element. Meanwhile, there can be a simple comment between the special
comment and the element. There are two exceptions, for
constructors and record fields in type definitions, whose associated
comment must be placed after the constructor or field definition,
without blank line between them. The special comment for a constructor
with another constructor following must be placed before the &#X2019;<TT>|</TT>&#X2019;
character separating the two constructors.</P><P>The following example of file <TT>toto.ml</TT> shows where to place comments
in a <TT>.ml</TT> file.</P><PRE>(** The first special comment of the file is the comment associated
    to the whole module. *)

(** The comment for function f *)
let f x y = x + y

(** This comment is not attached to any element since there is another
    special comment just before the next element. *)

(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)
(* A simple comment. *)
exception My_exception of (int -&gt; int) * int

(** Comment for type weather  *)
type weather =
| Rain of int (** The comment for constructor Rain *)
| Sun (** The comment for constructor Sun *)

(** The comment for type my_record *)
type my_record = {
    val foo : int ;    (** Comment for field foo *)
    val bar : string ; (** Comment for field bar *)
  }

(** The comment for class my_class *)
class my_class =
    object
      (** A comment to describe inheritance from cl *)
      inherit cl

      (** The comment for the instance variable tutu *)
      val mutable tutu = "tutu"
      (** The comment for toto *)
      val toto = 1
      val titi = "titi"
      (** Comment for method toto *)
      method toto = tutu ^ "!"
      (** Comment for method m *)
      method m (f : float) = 1
    end

(** The comment for class type my_class_type *)
class type my_class_type =
  object
    (** The comment for the instance variable x. *)
    val mutable x : int
    (** The commend for method m. *)
    method m : int -&gt; int
  end

(** The comment for module Foo *)
module Foo =
  struct
    (** The comment for x *)
    val x : int
    (** A special comment in the class, but not associated to any element. *)
  end

(** The comment for module type my_module_type. *)
module type my_module_type =
  sig
    (* Comment for value x. *)
    val x : int
    (* ... *)
  end
</PRE><!--TOC subsection The Stop special comment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc174">15.2.2</A>&#XA0;&#XA0;The Stop special comment</H3><!--SEC END --><P>
The special comment <TT>(**/**)</TT> tells OCamldoc to discard
elements placed after this comment, up to the end of the current
class, class type, module or module type, or up to the next stop comment.
For instance:
</P><PRE>class type foo =
  object
    (** comment for method m *)
    method m : string

    (**/**)

    (** This method won't appear in the documentation *)
    method bar : int
  end

(** This value appears in the documentation, since the Stop special comment
    in the class does not affect the parent module of the class.*)
val foo : string

(**/**)
(** The value bar does not appear in the documentation.*)
val bar : string
(**/**)

(** The type t appears since in the documentation since the previous stop comment
toggled off the "no documentation mode". *)
type t = string
</PRE><P>
The <TT><B>-no-stop</B></TT> option to <TT>ocamldoc</TT> causes the Stop special
comments to be ignored.</P><!--TOC subsection Syntax of documentation comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc175">15.2.3</A>&#XA0;&#XA0;Syntax of documentation comments</H3><!--SEC END --><P>The inside of documentation comments <TT>(**</TT>&#X2026;<TT>*)</TT> consists of
free-form text with optional formatting annotations, followed by
optional <EM>tags</EM> giving more specific information about parameters,
version, authors, &#X2026; The tags are distinguished by a leading <TT>@</TT>
character. Thus, a documentation comment has the following shape:
</P><PRE>(** The comment begins with a description, which is text formatted
   according to the rules described in the next section.
   The description continues until the first non-escaped '@' character.
   @author Mr Smith
   @param x description for parameter x
*)
</PRE><P>Some elements support only a subset of all @-tags. Tags that are not
relevant to the documented element are simply ignored. For instance,
all tags are ignored when documenting type constructors, record
fields, and class inheritance clauses. Similarly, a <TT>@param</TT> tag on a
class instance variable is ignored.</P><P>At last, <TT>(**)</TT> is the empty documentation comment.</P><!--TOC subsection Text formatting-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc176">15.2.4</A>&#XA0;&#XA0;Text formatting</H3><!--SEC END --><P>Here is the BNF grammar for the simple markup language used to format
text descriptions.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>&#XA0;{<I><A href="#text-element" class="syntax"><FONT COLOR=maroon>text-element</FONT></A></I>}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="text-element" class="syntax"><FONT COLOR=maroon>text-element</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD></TR>
</TABLE><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> { <FONT COLOR=blue><TT>0</TT></FONT> &#X2026; <FONT COLOR=blue><TT>9</TT></FONT> }<SUP>+</SUP> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>format <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> as a section header;
the integer following <TT>{</TT> indicates the sectioning level.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> { <FONT COLOR=blue><TT>0</TT></FONT> &#X2026; <FONT COLOR=blue><TT>9</TT></FONT> }<SUP>+</SUP> <FONT COLOR=blue><TT>:</TT></FONT>  <I><FONT COLOR=maroon>label</FONT>  <A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left> same, but also associate the name <FONT COLOR=maroon><I>label</I></FONT> to the current point.
This point can be referenced by its fully-qualified label in a
<TT>{!</TT> command, just like any other element.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{b</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> in bold.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{i</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> in italic.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{e</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>emphasize <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{C</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>center <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{L</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>left align <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{R</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>right align <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{ul</TT></FONT> <I><A href="#list" class="syntax"><FONT COLOR=maroon>list</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>build a list.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{ol</TT></FONT> <I><A href="#list" class="syntax"><FONT COLOR=maroon>list</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>build an enumerated list.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{{:</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>}</TT></FONT> &#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>put a link to the given address
(given as <FONT COLOR=maroon><I>string</I></FONT>) on the given <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>]</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set the given <FONT COLOR=maroon><I>string</I></FONT> in source code style.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{[</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>]}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set the given <FONT COLOR=maroon><I>string</I></FONT> in preformatted
				source code style.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{v</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>v}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set the given <FONT COLOR=maroon><I>string</I></FONT> in verbatim style.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{%</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>%}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>take the given <FONT COLOR=maroon><I>string</I></FONT> as raw L<sup>A</sup>T<sub>E</sub>X code.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{!</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>insert a reference to the element named
<FONT COLOR=maroon><I>string</I></FONT>. <FONT COLOR=maroon><I>string</I></FONT> must be a fully qualified element name,
for example <TT>Foo.Bar.t</TT>. The kind of the referenced element can be forced
(useful when various elements have the same qualified name) with the following
syntax:  <FONT COLOR=blue><TT>{!</TT>  <FONT COLOR=maroon><I>kind</I></FONT>  <TT>:</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>}</TT></FONT>  where <FONT COLOR=maroon><I>kind</I></FONT> can be
<TT>module</TT>, <TT>modtype</TT>, <TT>class</TT>, <TT>classtype</TT>, <TT>val</TT>,
<TT>type</TT>, <TT>exception</TT>, <TT>attribute</TT>, <TT>method</TT> or <TT>section</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{!modules:</TT></FONT> <FONT COLOR=maroon><I>string</I></FONT> &#XA0;<FONT COLOR=maroon><I>string</I></FONT> ... <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>insert an index table
for the given module names. Used in HTML only.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{!indexlist}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>insert a table of links to the various indexes
(types, values, modules, ...). Used in HTML only.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{^</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set text in superscript.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{_</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> </TD><TD VALIGN=top ALIGN=left>set text in subscript.</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=maroon><I>escaped-string</I></FONT></TD><TD VALIGN=top ALIGN=left>typeset the given string as is;
special characters (&#X2019;<TT>{</TT>&#X2019;, &#X2019;<TT>}</TT>&#X2019;, &#X2019;<TT>[</TT>&#X2019;, &#X2019;<TT>]</TT>&#X2019; and &#X2019;<TT>@</TT>&#X2019;)
must be	escaped by a &#X2019;<TT>\</TT>&#X2019;</TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>&#X2223; </TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=maroon><I>blank-line</I></FONT></TD><TD VALIGN=top ALIGN=left>force a new line.</TD></TR>
</TABLE><P><BR>

</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="list" class="syntax"><FONT COLOR=maroon>list</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<FONT COLOR=blue><TT>{-</TT></FONT>&#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>&#XA0;}<SUP>+</SUP>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<FONT COLOR=blue><TT>{li</TT></FONT>&#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>}</TT></FONT>&#XA0;}<SUP>+</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A shortcut syntax exists for lists and enumerated lists:
</P><PRE>(** Here is a {b list}
- item 1
- item 2
- item 3

The list is ended by the blank line.*)
</PRE><P>is equivalent to:
</P><PRE>(** Here is a {b list}
{ul {- item 1}
{- item 2}
{- item 3}}
The list is ended by the blank line.*)
</PRE><P>
The same shortcut is available for enumerated lists, using &#X2019;<TT>+</TT>&#X2019;
instead of &#X2019;<TT>-</TT>&#X2019;.
Note that only one list can be defined by this shortcut in nested lists.</P><P>In the description of a value, type, exception, module, module type, class
or class type, the <EM>first sentence</EM> is sometimes used in indexes, or
when just a part of the description is needed. The first sentence
is composed of the first characters of the description, until
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the first dot followed by a blank, or
</LI><LI CLASS="li-itemize">the first blank line
</LI></UL><P>
outside of the following text formatting :
 <FONT COLOR=blue><TT>{ul</TT></FONT> <I><A href="#list" class="syntax"><FONT COLOR=maroon>list</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> ,
 <FONT COLOR=blue><TT>{ol</TT></FONT> <I><A href="#list" class="syntax"><FONT COLOR=maroon>list</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> ,
 <FONT COLOR=blue><TT>[</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>]</TT></FONT> ,
 <FONT COLOR=blue><TT>{[</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>]}</TT></FONT> ,
 <FONT COLOR=blue><TT>{v</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>v}</TT></FONT> ,
 <FONT COLOR=blue><TT>{%</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>%}</TT></FONT> ,
 <FONT COLOR=blue><TT>{!</TT> <FONT COLOR=maroon><I>string</I></FONT> <TT>}</TT></FONT> ,
 <FONT COLOR=blue><TT>{^</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> ,
 <FONT COLOR=blue><TT>{_</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> <FONT COLOR=blue><TT>}</TT></FONT> .</P><!--TOC subsection Documentation tags (@-tags)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc177">15.2.5</A>&#XA0;&#XA0;Documentation tags (@-tags)</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-tags"></A></P><!--TOC subsubsection Predefined tags-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Predefined tags</H4><!--SEC END --><P>
The following table gives the list of predefined @-tags, with their
syntax and meaning.<BR>

</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left> <FONT COLOR=blue><TT>@author</TT></FONT> <FONT COLOR=maroon><I>string</I></FONT> </TD><TD VALIGN=top ALIGN=left>The author of the element. One author per
<TT>@author</TT> tag.
There may be several <TT>@author</TT> tags for the same element.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@deprecated</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>The <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> should describe when the element was
deprecated, what to use as a replacement, and possibly the reason
for deprecation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@param</TT></FONT> <FONT COLOR=maroon><I>id</I></FONT> &#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Associate the given description (<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>) to the
given parameter name <FONT COLOR=maroon><I>id</I></FONT>. This tag is used for functions,
methods, classes and functors.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@raise</TT></FONT> <FONT COLOR=maroon><I>Exc</I></FONT> &#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Explain that the element may raise
the exception <FONT COLOR=maroon><I>Exc</I></FONT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@return</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Describe the return value and
its possible values. This tag is used for functions
and methods.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@see</TT> <TT>&lt;</TT> <FONT COLOR=maroon><I>URL</I></FONT> <TT>&gt;</TT></FONT> &#XA0;<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Add a reference to the <FONT COLOR=maroon><I>URL</I></FONT>
with the given <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@see</TT> <TT>'</TT><FONT COLOR=maroon><I>filename</I></FONT><TT>'</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Add a reference to the given file name
(written between single quotes), with the given <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@see</TT> <TT>"</TT><FONT COLOR=maroon><I>document-name</I></FONT><TT>"</TT></FONT> <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Add a reference to the given
document name (written between double quotes), with the given <I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>
as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@since</TT></FONT> <FONT COLOR=maroon><I>string</I></FONT> </TD><TD VALIGN=top ALIGN=left>Indicate when the element was introduced.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@before</TT></FONT>  <I><FONT COLOR=maroon>version</FONT>  <A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I> </TD><TD VALIGN=top ALIGN=left>Associate the given description (<I><A href="#text" class="syntax"><FONT COLOR=maroon>text</FONT></A></I>)
to the given <FONT COLOR=maroon><I>version</I></FONT> in order to document compatibility issues.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
 <FONT COLOR=blue><TT>@version</TT></FONT> <FONT COLOR=maroon><I>string</I></FONT> </TD><TD VALIGN=top ALIGN=left>The version number for the element.</TD></TR>
</TABLE><!--TOC subsubsection Custom tags-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Custom tags</H4><!--SEC END --><P>
<A NAME="s:ocamldoc-custom-tags"></A>
You can use custom tags in the documentation comments, but they will
have no effect if the generator used does not handle them. To use a
custom tag, for example <TT>foo</TT>, just put <TT>@foo</TT> with some text in your
comment, as in:
</P><PRE>(** My comment to show you a custom tag.
@foo this is the text argument to the [foo] custom tag.
*)
</PRE><P>
To handle custom tags, you need to define a custom generator,
as explained in section <A HREF="#s:ocamldoc-handling-custom-tags">15.3.2</A>.</P><!--TOC section Custom generators-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc178">15.3</A>&#XA0;&#XA0;Custom generators</H2><!--SEC END --><P>
<A NAME="s:ocamldoc-custom-generators"></A></P><P>OCamldoc operates in two steps:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
analysis of the source files;
</LI><LI CLASS="li-enumerate">generation of documentation, through a documentation generator,
	which is an object of class <TT>Odoc_args.class_generator</TT>.
</LI></OL><P>
Users can provide their own documentation generator to be used during
step 2 instead of the default generators.
All the information retrieved during the analysis step is available through
the <TT>Odoc_info</TT> module, which gives access to all the types and functions
representing the elements found in the given modules, with their associated
description.</P><P>The files you can use to define custom generators are installed in the
<TT>ocamldoc</TT> sub-directory of the OCaml standard library.</P><!--TOC subsection The generator modules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc179">15.3.1</A>&#XA0;&#XA0;The generator modules</H3><!--SEC END --><P>
The type of a generator module depends on the kind of generated documentation.
Here is the list of generator module types, with the name of the generator
class in the module&#XA0;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
for HTML&#XA0;: <TT>Odoc_html.Html_generator</TT> (class <TT>html</TT>),
</LI><LI CLASS="li-itemize">for L<sup>A</sup>T<sub>E</sub>X&#XA0;: <TT>Odoc_latex.Latex_generator</TT> (class <TT>latex</TT>),
</LI><LI CLASS="li-itemize">for TeXinfo&#XA0;: <TT>Odoc_texi.Texi_generator</TT> (class <TT>texi</TT>),
</LI><LI CLASS="li-itemize">for man pages&#XA0;: <TT>Odoc_man.Man_generator</TT> (class <TT>man</TT>),
</LI><LI CLASS="li-itemize">for graphviz (dot)&#XA0;: <TT>Odoc_dot.Dot_generator</TT> (class <TT>dot</TT>),
</LI><LI CLASS="li-itemize">for other kinds&#XA0;: <TT>Odoc_gen.Base</TT> (class <TT>doc_generator</TT>).
</LI></UL><P>
That is, to define a new generator, one must implement a module with
the expected signature, and with the given generator class, providing
the <TT>generate</TT> method as entry point to make the generator generates
documentation for a given list of modules&#XA0;:</P><PRE>        method generate : Odoc_info.Module.t_module list -&gt; unit
</PRE><P>
This method will be called with the list of analysed and possibly
merged <TT>Odoc_info.t_module</TT> structures.</P><P>It is recommanded to inherit from the current generator of the same
kind as the one you want to define. Doing so, it is possible to
load various custom generators to combine improvments brought by each one.</P><P>This is done using first class modules (see chapter <A HREF="#s-first-class-modules">7.14</A>).</P><P>The easiest way to define a custom generator is the following this example,
here extending the current HTML generator. We don&#X2019;t have to know if this is
the original HTML generator defined in ocamldoc or if it has been extended
already by a previously loaded custom generator&#XA0;:</P><PRE>module Generator (G : Odoc_html.Html_generator) =
struct
  class html =
    object(self)
      inherit G.html as html
      (* ... *)

      method generate module_list =
        (* ... *)
        ()

      (* ... *)
  end
end;;

let _ = Odoc_args.extend_html_generator (module Generator : Odoc_gen.Html_functor);;
</PRE><P>
To know which methods to override and/or which methods are available,
have a look at the different base implementations, depending on the
kind of generator you are extending&#XA0;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
for HTML&#XA0;: <TT><A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_html.ml?view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_html.ml?view=markup</A>odoc_html.ml</TT>,
</LI><LI CLASS="li-itemize">for L<sup>A</sup>T<sub>E</sub>X&#XA0;: <TT><A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_latex.ml?view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_latex.ml?view=markup</A>odoc_latex.ml</TT>,
</LI><LI CLASS="li-itemize">for TeXinfo&#XA0;: <TT><A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_texi.ml?view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_texi.ml?view=markup</A>odoc_texi.ml</TT>,
</LI><LI CLASS="li-itemize">for man pages&#XA0;: <TT><A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_man.ml?view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_man.ml?view=markup</A>odoc_man.ml</TT>,
</LI><LI CLASS="li-itemize">for graphviz (dot)&#XA0;: <TT><A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_dot.ml?view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/version/4.00/ocamldoc/odoc_dot.ml?view=markup</A>odoc_dot.ml</TT>.
</LI></UL><!--TOC subsection Handling custom tags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc180">15.3.2</A>&#XA0;&#XA0;Handling custom tags</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-handling-custom-tags"></A></P><P>Making a custom generator handle custom tags (see
<A HREF="#s:ocamldoc-custom-tags">15.2.5</A>) is very simple.</P><!--TOC subsubsection For HTML-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->For HTML</H4><!--SEC END --><P>
Here is how to develop a HTML generator handling your custom tags.</P><P>The class <TT>Odoc_html.Generator.html</TT> inherits
from the class <TT>Odoc_html.info</TT>, containing a field <TT>tag_functions</TT> which is a
list pairs composed of a custom tag (e.g. <TT>"foo"</TT>) and a function taking
a <TT>text</TT> and returning HTML code (of type <TT>string</TT>).
To handle a new tag <TT>bar</TT>, extend the current HTML generator
and complete the <TT>tag_functions</TT> field:
</P><PRE>module Generator (G : Odoc_html.Html_generator) =
struct
  class html =
    object(self)
      inherit G.html

      (** Return HTML code for the given text of a bar tag. *)
      method html_of_bar t = (* your code here *)

      initializer
        tag_functions &lt;- ("bar", self#html_of_bar) :: tag_functions
  end
end
let _ = Odoc_args.extend_html_generator (module Generator : Odoc_gen.Html_functor);;
</PRE><P>
Another method of the class <TT>Odoc_html.info</TT> will look for the
function associated to a custom tag and apply it to the text given to
the tag. If no function is associated to a custom tag, then the method
prints a warning message on <TT>stderr</TT>.</P><!--TOC subsubsection For other generators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->For other generators</H4><!--SEC END --><P>
You can act the same way for other kinds of generators.</P><!--TOC section Adding command line options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc181">15.4</A>&#XA0;&#XA0;Adding command line options</H2><!--SEC END --><P>
The command line analysis is performed after loading the module containing the
documentation generator, thus allowing command line options to be added to the
list of existing ones. Adding an option can be done with the function
</P><PRE>        Odoc_args.add_option : string * Arg.spec * string -&gt; unit
</PRE><P>Note: Existing command line options can be redefined using
this function.</P><!--TOC subsection Compilation and usage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc182">15.4.1</A>&#XA0;&#XA0;Compilation and usage</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-compilation-and-usage"></A></P><!--TOC subsubsection Defining a custom generator class in one file-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Defining a custom generator class in one file</H4><!--SEC END --><P>
Let <TT>custom.ml</TT> be the file defining a new generator class.
Compilation of <TT>custom.ml</TT> can be performed by the following command&#XA0;:
</P><PRE>
        ocamlc -I +ocamldoc -c custom.ml
</PRE><P>
The file <TT>custom.cmo</TT> is created and can be used this way&#XA0;:
</P><PRE>
        ocamldoc -g custom.cmo <I>other-options source-files</I>
</PRE><P>
It is important not to give the <TT>-html</TT> or any other option
selecting a built-in generator to <TT>ocamldoc</TT>,
which would result in using this generator instead of the one you just loaded.</P><!--TOC subsubsection Defining a custom generator class in several files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Defining a custom generator class in several files</H4><!--SEC END --><P>
It is possible to define a generator class in several modules, which
are defined in several files <I>file<SUB>1</SUB></I><TT>.ml</TT>[<TT>i</TT>],
<I>file<SUB>2</SUB></I><TT>.ml</TT>[<TT>i</TT>], ..., <I>file<SUB>n</SUB></I><TT>.ml</TT>[<TT>i</TT>]. A <TT>.cma</TT>
library file must be created, including all these files.</P><P>The following commands create the <TT>custom.cma</TT> file from files
<I>file<SUB>1</SUB></I><TT>.ml</TT>[<TT>i</TT>], ..., <I>file<SUB>n</SUB></I><TT>.ml</TT>[<TT>i</TT>]&#XA0;:
</P><PRE>
ocamlc -I +ocamldoc -c <I>file<SUB>1</SUB></I>.ml[i]
ocamlc -I +ocamldoc -c <I>file<SUB>2</SUB></I>.ml[i]
...
ocamlc -I +ocamldoc -c <I>file<SUB>n</SUB></I>.ml[i]
ocamlc -o custom.cma -a <I>file<SUB>1</SUB></I>.cmo <I>file<SUB>2</SUB></I>.cmo ... <I>file<SUB>n</SUB></I>.cmo
</PRE><P>
Then, the following command uses <TT>custom.cma</TT> as custom generator:
</P><PRE>
        ocamldoc -g custom.cma <I>other-options source-files</I>
</PRE><P>
Again, it is important not to give the <TT>-html</TT> or any other
option selecting a built-in generator to <TT>ocamldoc</TT>,
which would result in using this generator instead of the one you just loaded.

</P><!--TOC chapter The debugger (ocamldebug)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc183">Chapter&#XA0;16</A>&#XA0;&#XA0;The debugger (ocamldebug)</H1><!--SEC END --><P> <A NAME="c:debugger"></A>
</P><P>This chapter describes the OCaml source-level replay debugger
<TT>ocamldebug</TT>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0; The debugger is available on Unix systems that provide
BSD sockets.
</BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0; The debugger is available under the Cygwin port of
OCaml, but not under the native Win32 ports.
</BLOCKQUOTE><!--TOC section Compiling for debugging-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc184">16.1</A>&#XA0;&#XA0;Compiling for debugging</H2><!--SEC END --><P>Before the debugger can be used, the program must be compiled and
linked with the <TT>-g</TT> option: all <TT>.cmo</TT> and <TT>.cma</TT> files that are part
of the program should have been created with <TT>ocamlc -g</TT>, and they
must be linked together with <TT>ocamlc -g</TT>.</P><P>Compiling with <TT>-g</TT> entails no penalty on the running time of
programs: object files and bytecode executable files are bigger and
take longer to produce, but the executable files run at
exactly the same speed as if they had been compiled without <TT>-g</TT>.</P><!--TOC section Invocation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc185">16.2</A>&#XA0;&#XA0;Invocation</H2><!--SEC END --><!--TOC subsection Starting the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc186">16.2.1</A>&#XA0;&#XA0;Starting the debugger</H3><!--SEC END --><P>The OCaml debugger is invoked by running the program
<TT>ocamldebug</TT> with the name of the bytecode executable file as first
argument:
</P><PRE>
        ocamldebug [<I>options</I>] <I>program</I> [<I>arguments</I>]
</PRE><P>
The arguments following <I>program</I> are optional, and are passed as
command-line arguments to the program being debugged. (See also the
<TT>set arguments</TT> command.)</P><P>The following command-line options are recognized:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-c </TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the maximum number of simultaneously live checkpoints to <I>count</I>.</DD><DT CLASS="dt-description"><B><TT>-cd </TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Run the debugger program from the working directory <I>dir</I>,
instead of the current directory. (See also the <TT>cd</TT> command.)</DD><DT CLASS="dt-description"><TT><B>-emacs</B></TT></DT><DD CLASS="dd-description">
Tell the debugger it is executed under Emacs. (See
section&#XA0;<A HREF="#s:inf-debugger">16.10</A> for information on how to run the
debugger under Emacs.)</DD><DT CLASS="dt-description"><B><TT>-I </TT><I>directory</I></B></DT><DD CLASS="dd-description">
Add <I>directory</I> to the list of directories searched for source
files and compiled files. (See also the <TT>directory</TT> command.)</DD><DT CLASS="dt-description"><B><TT>-s </TT><I>socket</I></B></DT><DD CLASS="dd-description">
Use <I>socket</I> for communicating with the debugged program. See the
description of the command <TT>set socket</TT> (section&#XA0;<A HREF="#s:communication">16.8.6</A>)
for the format of <I>socket</I>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC subsection Exiting the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc187">16.2.2</A>&#XA0;&#XA0;Exiting the debugger</H3><!--SEC END --><P>The command <TT>quit</TT> exits the debugger. You can also exit the debugger
by typing an end-of-file character (usually <TT>ctrl-D</TT>).</P><P>Typing an interrupt character (usually <TT>ctrl-C</TT>) will not exit the
debugger, but will terminate the action of any debugger command that is in
progress and return to the debugger command level. </P><!--TOC section Commands-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc188">16.3</A>&#XA0;&#XA0;Commands</H2><!--SEC END --><P> <A NAME="s:debugger-commands"></A></P><P>A debugger command is a single line of input. It starts with a command
name, which is followed by arguments depending on this name. Examples:
</P><PRE>        run
        goto 1000
        set arguments arg1 arg2
</PRE><P>
A command name can be truncated as long as there is no ambiguity. For
instance, <TT>go 1000</TT> is understood as <TT>goto 1000</TT>, since there are no
other commands whose name starts with <TT>go</TT>. For the most frequently
used commands, ambiguous abbreviations are allowed. For instance, <TT>r</TT>
stands for <TT>run</TT> even though there are others commands starting with
<TT>r</TT>. You can test the validity of an abbreviation using the <TT>help</TT> command.</P><P>If the previous command has been successful, a blank line (typing just
<TT>RET</TT>) will repeat it.</P><!--TOC subsection Getting help-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc189">16.3.1</A>&#XA0;&#XA0;Getting help</H3><!--SEC END --><P>The OCaml debugger has a simple on-line help system, which gives
a brief description of each command and variable.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>help</B></TT></DT><DD CLASS="dd-description">
Print the list of commands.</DD><DT CLASS="dt-description"><B><TT>help </TT><I>command</I></B></DT><DD CLASS="dd-description">
Give help about the command <I>command</I>.</DD><DT CLASS="dt-description"><B><TT>help set </TT><I>variable</I>, <TT>help show </TT><I>variable</I></B></DT><DD CLASS="dd-description">
Give help about the variable <I>variable</I>. The list of all debugger
variables can be obtained with <TT>help set</TT>.</DD><DT CLASS="dt-description"><B><TT>help info </TT><I>topic</I></B></DT><DD CLASS="dd-description">
Give help about <I>topic</I>. Use <TT>help info</TT> to get a list of known topics.
</DD></DL><!--TOC subsection Accessing the debugger state-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc190">16.3.2</A>&#XA0;&#XA0;Accessing the debugger state</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set </TT><I>variable value</I></B></DT><DD CLASS="dd-description">
Set the debugger variable <I>variable</I> to the value <I>value</I>.</DD><DT CLASS="dt-description"><B><TT>show </TT><I>variable</I></B></DT><DD CLASS="dd-description">
Print the value of the debugger variable <I>variable</I>.</DD><DT CLASS="dt-description"><B><TT>info </TT><I>subject</I></B></DT><DD CLASS="dd-description">
Give information about the given subject.
For instance, <TT>info breakpoints</TT> will print the list of all breakpoints.
</DD></DL><!--TOC section Executing a program-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc191">16.4</A>&#XA0;&#XA0;Executing a program</H2><!--SEC END --><!--TOC subsection Events-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc192">16.4.1</A>&#XA0;&#XA0;Events</H3><!--SEC END --><P>Events are &#X201C;interesting&#X201D; locations in the source code, corresponding
to the beginning or end of evaluation of &#X201C;interesting&#X201D;
sub-expressions. Events are the unit of single-stepping (stepping goes
to the next or previous event encountered in the program execution).
Also, breakpoints can only be set at events. Thus, events play the
role of line numbers in debuggers for conventional languages.</P><P>During program execution, a counter is incremented at each event
encountered. The value of this counter is referred as the <EM>current
time</EM>. Thanks to reverse execution, it is possible to jump back and
forth to any time of the execution.</P><P>Here is where the debugger events (written &#XA7;&#XA7;) are located in
the source code:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Following a function application:
<PRE>
(f arg)&#XA7;&#XA7;
</PRE>
</LI><LI CLASS="li-itemize">On entrance to a function:
<PRE>
fun x y z -&gt; &#XA7;&#XA7; ...
</PRE>
</LI><LI CLASS="li-itemize">On each case of a pattern-matching definition (function,
<TT>match</TT>&#X2026;<TT>with</TT> construct, <TT>try</TT>&#X2026;<TT>with</TT> construct):
<PRE>
function pat1 -&gt; &#XA7;&#XA7; expr1
       | ...
       | patN -&gt; &#XA7;&#XA7; exprN
</PRE>
</LI><LI CLASS="li-itemize">Between subexpressions of a sequence:
<PRE>
expr1; &#XA7;&#XA7; expr2; &#XA7;&#XA7; ...; &#XA7;&#XA7; exprN
</PRE>
</LI><LI CLASS="li-itemize">In the two branches of a conditional expression:
<PRE>
if cond then &#XA7;&#XA7; expr1 else &#XA7;&#XA7; expr2
</PRE>
</LI><LI CLASS="li-itemize">At the beginning of each iteration of a loop:
<PRE>
while cond do &#XA7;&#XA7; body done
for i = a to b do &#XA7;&#XA7; body done
</PRE>
</LI></UL><P>
Exceptions: A function application followed by a function return is replaced
by the compiler by a jump (tail-call optimization). In this case, no
event is put after the function application.
</P><!--TOC subsection Starting the debugged program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc193">16.4.2</A>&#XA0;&#XA0;Starting the debugged program</H3><!--SEC END --><P>The debugger starts executing the debugged program only when needed.
This allows setting breapoints or assigning debugger variables before
execution starts. There are several ways to start execution:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>run</B></TT></DT><DD CLASS="dd-description"> Run the program until a breakpoint is hit, or the program
terminates.
</DD><DT CLASS="dt-description"><TT><B>step 0</B></TT></DT><DD CLASS="dd-description"> Load the program and stop on the first event.
</DD><DT CLASS="dt-description"><B><TT>goto </TT><I>time</I></B></DT><DD CLASS="dd-description"> Load the program and execute it until the
given time. Useful when you already know approximately at what time
the problem appears. Also useful to set breakpoints on function values
that have not been computed at time 0 (see section&#XA0;<A HREF="#s:breakpoints">16.5</A>).
</DD></DL><P>The execution of a program is affected by certain information it
receives when the debugger starts it, such as the command-line
arguments to the program and its working directory. The debugger
provides commands to specify this information (<TT>set arguments</TT> and <TT>cd</TT>).
These commands must be used before program execution starts. If you try
to change the arguments or the working directory after starting your
program, the debugger will kill the program (after asking for confirmation).</P><!--TOC subsection Running the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc194">16.4.3</A>&#XA0;&#XA0;Running the program</H3><!--SEC END --><P>The following commands execute the program forward or backward,
starting at the current time. The execution will stop either when
specified by the command or when a breakpoint is encountered.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>run</B></TT></DT><DD CLASS="dd-description"> Execute the program forward from current time. Stops at
next breakpoint or when the program terminates.
</DD><DT CLASS="dt-description"><TT><B>reverse</B></TT></DT><DD CLASS="dd-description"> Execute the program backward from current time.
Mostly useful to go to the last breakpoint encountered before the
current time.
</DD><DT CLASS="dt-description"><B><TT>step </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program and stop at the next event. With
an argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>backstep </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program backward and stop at
the previous event. With an argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>next </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program and stop at the next
event, skipping over function calls. With an argument, do it
<I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>previous </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program backward and stop at
the previous event, skipping over function calls. With an argument, do
it <I>count</I> times.
</DD><DT CLASS="dt-description"><TT><B>finish</B></TT></DT><DD CLASS="dd-description"> Run the program until the current function returns.
</DD><DT CLASS="dt-description"><TT><B>start</B></TT></DT><DD CLASS="dd-description"> Run the program backward and stop at the first event
before the current function invocation.
</DD></DL><!--TOC subsection Time travel-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc195">16.4.4</A>&#XA0;&#XA0;Time travel</H3><!--SEC END --><P>You can jump directly to a given time, without stopping on
breakpoints, using the <TT>goto</TT> command.</P><P>As you move through the program, the debugger maintains an history of
the successive times you stop at. The <TT>last</TT> command can be used to
revisit these times: each <TT>last</TT> command moves one step back through
the history. That is useful mainly to undo commands such as <TT>step</TT>
and <TT>next</TT>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>goto </TT><I>time</I></B></DT><DD CLASS="dd-description">
Jump to the given time.
</DD><DT CLASS="dt-description"><B><TT>last </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Go back to the latest time recorded in the execution history. With an
argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>set history </TT><I>size</I></B></DT><DD CLASS="dd-description">
Set the size of the execution history.
</DD></DL><!--TOC subsection Killing the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc196">16.4.5</A>&#XA0;&#XA0;Killing the program</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>kill</B></TT></DT><DD CLASS="dd-description"> Kill the program being executed. This command is mainly
useful if you wish to recompile the program without leaving the debugger.
</DD></DL><!--TOC section Breakpoints-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc197">16.5</A>&#XA0;&#XA0;Breakpoints</H2><!--SEC END --><P> <A NAME="s:breakpoints"></A></P><P>A breakpoint causes the program to stop whenever a certain point in
the program is reached. It can be set in several ways using the
<TT>break</TT> command. Breakpoints are assigned numbers when set, for
further reference. The most comfortable way to set breakpoints is
through the Emacs interface (see section&#XA0;<A HREF="#s:inf-debugger">16.10</A>).</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>break</B></TT></DT><DD CLASS="dd-description">
Set a breakpoint at the current position in the program execution. The
current position must be on an event (i.e., neither at the beginning,
nor at the end of the program).</DD><DT CLASS="dt-description"><B><TT>break </TT><I>function</I></B></DT><DD CLASS="dd-description">
Set a breakpoint at the beginning of <I>function</I>. This works only
when the functional value of the identifier <I>function</I> has been
computed and assigned to the identifier. Hence this command cannot be
used at the very beginning of the program execution, when all
identifiers are still undefined; use <TT>goto</TT> <I>time</I> to advance
execution until the functional value is available.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <I>line</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> (or in the current module if
<I>module</I> is not given), at the first event of line <I>line</I>.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <I>line column</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> (or in the current module if
<I>module</I> is not given), at the event closest to line <I>line</I>,
column <I>column</I>.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <TT>#</TT> <I>character</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> at the event closest to
character number <I>character</I>.</DD><DT CLASS="dt-description"><B><TT>break </TT><I>address</I></B></DT><DD CLASS="dd-description">
Set a breakpoint at the code address <I>address</I>.</DD><DT CLASS="dt-description"><B><TT>delete </TT>[<I>breakpoint-numbers</I>]</B></DT><DD CLASS="dd-description">
Delete the specified breakpoints. Without argument, all breakpoints
are deleted (after asking for confirmation).</DD><DT CLASS="dt-description"><TT><B>info breakpoints</B></TT></DT><DD CLASS="dd-description"> Print the list of all breakpoints.
</DD></DL><!--TOC section The call stack-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc198">16.6</A>&#XA0;&#XA0;The call stack</H2><!--SEC END --><P>Each time the program performs a function application, it saves the
location of the application (the return address) in a block of data
called a stack frame. The frame also contains the local variables of
the caller function. All the frames are allocated in a region of
memory called the call stack. The command <TT>backtrace</TT> (or <TT>bt</TT>)
displays parts of the call stack.</P><P>At any time, one of the stack frames is &#X201C;selected&#X201D; by the debugger; several
debugger commands refer implicitly to the selected frame. In particular,
whenever you ask the debugger for the value of a local variable, the
value is found in the selected frame. The commands <TT>frame</TT>, <TT>up</TT> and <TT>down</TT>
select whichever frame you are interested in.</P><P>When the program stops, the debugger automatically selects the
currently executing frame and describes it briefly as the <TT>frame</TT>
command does.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>frame</B></TT></DT><DD CLASS="dd-description">
Describe the currently selected stack frame.</DD><DT CLASS="dt-description"><B><TT>frame</TT> <I>frame-number</I></B></DT><DD CLASS="dd-description">
Select a stack frame by number and describe it. The frame currently
executing when the program stopped has number 0; its caller has number
1; and so on up the call stack.</DD><DT CLASS="dt-description"><B><TT>backtrace </TT>[<I>count</I>], <TT>bt </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Print the call stack. This is useful to see which sequence of function
calls led to the currently executing frame. With a positive argument,
print only the innermost <I>count</I> frames.
With a negative argument, print only the outermost -<I>count</I> frames.</DD><DT CLASS="dt-description"><B><TT>up</TT> [<I>count</I>]</B></DT><DD CLASS="dd-description">
Select and display the stack frame just &#X201C;above&#X201D; the selected frame,
that is, the frame that called the selected frame. An argument says how
many frames to go up.</DD><DT CLASS="dt-description"><B><TT>down </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Select and display the stack frame just &#X201C;below&#X201D; the selected frame,
that is, the frame that was called by the selected frame. An argument
says how many frames to go down.
</DD></DL><!--TOC section Examining variable values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc199">16.7</A>&#XA0;&#XA0;Examining variable values</H2><!--SEC END --><P>The debugger can print the current value of simple expressions. The
expressions can involve program variables: all the identifiers that
are in scope at the selected program point can be accessed.</P><P>Expressions that can be printed are a subset of OCaml
expressions, as described by the following grammar:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;{&#XA0;<FONT COLOR=maroon><I>capitalized-ident</I></FONT>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;}&#XA0;&#XA0;<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>*</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>$</TT></FONT>&#XA0;<FONT COLOR=maroon><I>integer</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.</TT></FONT>&#XA0;&#XA0;<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.(</TT></FONT>&#XA0;&#XA0;<FONT COLOR=maroon><I>integer</I></FONT>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<I><A href="#simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>.[</TT></FONT>&#XA0;&#XA0;<FONT COLOR=maroon><I>integer</I></FONT>&#XA0;<FONT COLOR=blue><TT>]</TT></FONT>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>!</TT></FONT>&#XA0;<I><A href="#simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I>
&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>&#XA0;<FONT COLOR=blue><TT>(</TT></FONT>&#XA0;<I><A href="#simple-expr" class="syntax"><FONT COLOR=maroon>simple-expr</FONT></A></I>&#XA0;<FONT COLOR=blue><TT>)</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
The first two cases refer to a value identifier, either unqualified or
qualified by the path to the structure that define it.
<TT>*</TT> refers to the result just computed (typically, the value of a
function application), and is valid only if the selected event is an
&#X201C;after&#X201D; event (typically, a function application).
<FONT COLOR=blue><TT>$</TT></FONT> <FONT COLOR=maroon><I>integer</I></FONT> refer to a previously printed value. The remaining four
forms select part of an expression: respectively, a record field, an
array element, a string element, and the current contents of a
reference.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>print </TT><I>variables</I></B></DT><DD CLASS="dd-description">
Print the values of the given variables. <TT>print</TT> can be abbreviated as
<TT>p</TT>.
</DD><DT CLASS="dt-description"><B><TT>display </TT><I>variables</I></B></DT><DD CLASS="dd-description">
Same as <TT>print</TT>, but limit the depth of printing to 1. Useful to
browse large data structures without printing them in full.
<TT>display</TT> can be abbreviated as <TT>d</TT>.
</DD></DL><P>When printing a complex expression, a name of the form <TT>$</TT><I>integer</I>
is automatically assigned to its value. Such names are also assigned
to parts of the value that cannot be printed because the maximal
printing depth is exceeded. Named values can be printed later on
with the commands <TT>p $</TT><I>integer</I> or <TT>d $</TT><I>integer</I>.
Named values are valid only as long as the program is stopped. They
are forgotten as soon as the program resumes execution.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set print_depth</TT> <I>d</I></B></DT><DD CLASS="dd-description">
Limit the printing of values to a maximal depth of <I>d</I>. 
</DD><DT CLASS="dt-description"><B><TT>set print_length</TT> <I>l</I></B></DT><DD CLASS="dd-description">
Limit the printing of values to at most <I>l</I> nodes printed.
</DD></DL><!--TOC section Controlling the debugger-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc200">16.8</A>&#XA0;&#XA0;Controlling the debugger</H2><!--SEC END --><!--TOC subsection Setting the program name and arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc201">16.8.1</A>&#XA0;&#XA0;Setting the program name and arguments</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set program</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Set the program name to <I>file</I>.
</DD><DT CLASS="dt-description"><B><TT>set arguments</TT> <I>arguments</I></B></DT><DD CLASS="dd-description">
Give <I>arguments</I> as command-line arguments for the program.
</DD></DL><P>A shell is used to pass the arguments to the debugged program. You can
therefore use wildcards, shell variables, and file redirections inside
the arguments. To debug programs that read from standard input, it is
recommended to redirect their input from a file (using
<TT>set arguments &lt; input-file</TT>), otherwise input to the program and
input to the debugger are not properly separated, and inputs are not
properly replayed when running the program backwards.</P><!--TOC subsection How programs are loaded-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc202">16.8.2</A>&#XA0;&#XA0;How programs are loaded</H3><!--SEC END --><P>The <TT>loadingmode</TT> variable controls how the program is executed.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>set loadingmode direct</B></TT></DT><DD CLASS="dd-description">
The program is run directly by the debugger. This is the default mode.
</DD><DT CLASS="dt-description"><TT><B>set loadingmode runtime</B></TT></DT><DD CLASS="dd-description">
The debugger execute the OCaml runtime <TT>ocamlrun</TT> on the program.
Rarely useful; moreover it prevents the debugging of programs compiled
in &#X201C;custom runtime&#X201D; mode.
</DD><DT CLASS="dt-description"><TT><B>set loadingmode manual</B></TT></DT><DD CLASS="dd-description">
The user starts manually the program, when asked by the debugger.
Allows remote debugging (see section&#XA0;<A HREF="#s:communication">16.8.6</A>).
</DD></DL><!--TOC subsection Search path for files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc203">16.8.3</A>&#XA0;&#XA0;Search path for files</H3><!--SEC END --><P>The debugger searches for source files and compiled interface files in
a list of directories, the search path. The search path initially
contains the current directory <TT>.</TT> and the standard library directory.
The <TT>directory</TT> command adds directories to the path.</P><P>Whenever the search path is modified, the debugger will clear any
information it may have cached about the files.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>directory</TT> <I>directorynames</I></B></DT><DD CLASS="dd-description">
Add the given directories to the search path. These directories are
added at the front, and will therefore be searched first.</DD><DT CLASS="dt-description"><B><TT>directory</TT> <I>directorynames</I> <TT>for</TT> <I>modulename</I></B></DT><DD CLASS="dd-description">
Same as <TT>directory</TT> <I>directorynames</I>, but the given directories will be
searched only when looking for the source file of a module that has 
been packed into <I>modulename</I>.</DD><DT CLASS="dt-description"><TT><B>directory</B></TT></DT><DD CLASS="dd-description">
Reset the search path. This requires confirmation.
</DD></DL><!--TOC subsection Working directory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc204">16.8.4</A>&#XA0;&#XA0;Working directory</H3><!--SEC END --><P>Each time a program is started in the debugger, it inherits its working
directory from the current working directory of the debugger. This
working directory is initially whatever it inherited from its parent
process (typically the shell), but you can specify a new working
directory in the debugger with the <TT>cd</TT> command or the <TT>-cd</TT>
command-line option.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>cd</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Set the working directory for <TT>ocamldebug</TT> to <I>directory</I>.</DD><DT CLASS="dt-description"><TT><B>pwd</B></TT></DT><DD CLASS="dd-description">
Print the working directory for <TT>ocamldebug</TT>.
</DD></DL><!--TOC subsection Turning reverse execution on and off-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc205">16.8.5</A>&#XA0;&#XA0;Turning reverse execution on and off</H3><!--SEC END --><P>In some cases, you may want to turn reverse execution off. This speeds
up the program execution, and is also sometimes useful for interactive
programs.</P><P>Normally, the debugger takes checkpoints of the program state from
time to time. That is, it makes a copy of the current state of the
program (using the Unix system call <TT>fork</TT>). If the variable
<I>checkpoints</I> is set to <TT>off</TT>, the debugger will not take any
checkpoints.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set checkpoints</TT> <I>on/off</I></B></DT><DD CLASS="dd-description">
Select whether the debugger makes checkpoints or not.
</DD></DL><!--TOC subsection Communication between the debugger and the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc206">16.8.6</A>&#XA0;&#XA0;Communication between the debugger and the program</H3><!--SEC END --><P>
<A NAME="s:communication"></A></P><P>The debugger communicate with the program being debugged through a
Unix socket. You may need to change the socket name, for example if
you need to run the debugger on a machine and your program on another.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set socket</TT> <I>socket</I></B></DT><DD CLASS="dd-description">
Use <I>socket</I> for communication with the program. <I>socket</I> can be
either a file name, or an Internet port specification
<I>host</I>:<I>port</I>, where <I>host</I> is a host name or an Internet
address in dot notation, and <I>port</I> is a port number on the host.
</DD></DL><P>On the debugged program side, the socket name is passed through the
<TT>CAML_DEBUG_SOCKET</TT> environment variable.</P><!--TOC subsection Fine-tuning the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc207">16.8.7</A>&#XA0;&#XA0;Fine-tuning the debugger</H3><!--SEC END --><P> <A NAME="s:fine-tuning"></A></P><P>Several variables enables to fine-tune the debugger. Reasonable
defaults are provided, and you should normally not have to change them.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set processcount</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the maximum number of checkpoints to <I>count</I>. More checkpoints
facilitate going far back in time, but use more memory and create more
Unix processes.
</DD></DL><P>As checkpointing is quite expensive, it must not be done too often. On
the other hand, backward execution is faster when checkpoints are
taken more often. In particular, backward single-stepping is more
responsive when many checkpoints have been taken just before the
current time. To fine-tune the checkpointing strategy, the debugger
does not take checkpoints at the same frequency for long displacements
(e.g. <TT>run</TT>) and small ones (e.g. <TT>step</TT>). The two variables <TT>bigstep</TT>
and <TT>smallstep</TT> contain the number of events between two checkpoints
in each case.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set bigstep</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the number of events between two checkpoints for long displacements.
</DD><DT CLASS="dt-description"><B><TT>set smallstep</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the number of events between two checkpoints for small
displacements.
</DD></DL><P>The following commands display information on checkpoints and events:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>info checkpoints</B></TT></DT><DD CLASS="dd-description">
Print a list of checkpoints.
</DD><DT CLASS="dt-description"><B><TT>info events</TT> [<I>module</I>]</B></DT><DD CLASS="dd-description">
Print the list of events in the given module (the current module, by default).
</DD></DL><!--TOC subsection User-defined printers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc208">16.8.8</A>&#XA0;&#XA0;User-defined printers</H3><!--SEC END --><P>Just as in the toplevel system (section&#XA0;<A HREF="#s:toplevel-directives">9.2</A>),
the user can register functions for printing values of certain types.
For technical reasons, the debugger cannot call printing functions
that reside in the program being debugged. The code for the printing
functions must therefore be loaded explicitly in the debugger.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>load_printer "</TT><I>file-name</I><TT>"</TT></B></DT><DD CLASS="dd-description">
Load in the debugger the indicated <TT>.cmo</TT> or <TT>.cma</TT> object file. The
file is loaded in an environment consisting only of the OCaml
standard library plus the definitions provided by object files
previously loaded using <TT>load_printer</TT>. If this file depends on other
object files not yet loaded, the debugger automatically loads them if
it is able to find them in the search path. The loaded file does not
have direct access to the modules of the program being debugged.</DD><DT CLASS="dt-description"><B><TT>install_printer </TT><I>printer-name</I></B></DT><DD CLASS="dd-description">
Register the function named <I>printer-name</I> (a
value path) as a printer for objects whose types match the argument
type of the function. That is, the debugger will call
<I>printer-name</I> when it has such an object to print.
The printing function <I>printer-name</I> must use the <TT>Format</TT> library
module to produce its output, otherwise its output will not be
correctly located in the values printed by the toplevel loop.<P>The value path <I>printer-name</I> must refer to one of the functions
defined by the object files loaded using <TT>load_printer</TT>. It cannot
reference the functions of the program being debugged.</P></DD><DT CLASS="dt-description"><B><TT>remove_printer </TT><I>printer-name</I></B></DT><DD CLASS="dd-description">
Remove the named function from the table of value printers.
</DD></DL><!--TOC section Miscellaneous commands-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc209">16.9</A>&#XA0;&#XA0;Miscellaneous commands</H2><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>list</TT> [<I>module</I>] [<I>beginning</I>] [<I>end</I>]</B></DT><DD CLASS="dd-description">
List the source of module <I>module</I>, from line number
<I>beginning</I> to line number <I>end</I>. By default, 20 lines of the
current module are displayed, starting 10 lines before the current
position.
</DD><DT CLASS="dt-description"><B><TT>source</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Read debugger commands from the script <I>filename</I>.
</DD></DL><!--TOC section Running the debugger under Emacs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc210">16.10</A>&#XA0;&#XA0;Running the debugger under Emacs</H2><!--SEC END --><P> <A NAME="s:inf-debugger"></A></P><P>The most user-friendly way to use the debugger is to run it under Emacs.
See the file <TT>emacs/README</TT> in the distribution for information on how
to load the Emacs Lisp files for OCaml support.</P><P>The OCaml debugger is started under Emacs by the command <TT>M-x camldebug</TT>, with argument the name of the executable file
<I>progname</I> to debug. Communication with the debugger takes place
in an Emacs buffer named <TT>*camldebug-</TT><I>progname</I><TT>*</TT>. The editing
and history facilities of Shell mode are available for interacting
with the debugger.</P><P>In addition, Emacs displays the source files containing the current
event (the current position in the program execution) and highlights
the location of the event. This display is updated synchronously with
the debugger action.</P><P>The following bindings for the most common debugger commands are
available in the <TT>*camldebug-</TT><I>progname</I><TT>*</TT> buffer:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>C-c C-s</B></TT></DT><DD CLASS="dd-description"> (command <TT>step</TT>): execute the program one step forward.
</DD><DT CLASS="dt-description"><TT><B>C-c C-k</B></TT></DT><DD CLASS="dd-description"> (command <TT>backstep</TT>): execute the program one step backward.
</DD><DT CLASS="dt-description"><TT><B>C-c C-n</B></TT></DT><DD CLASS="dd-description"> (command <TT>next</TT>): execute the program one step
forward, skipping over function calls.
</DD><DT CLASS="dt-description"><B>Middle mouse button</B></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display named value.
<TT>$</TT><I>n</I> under mouse cursor (support incremental browsing of large
data structures).
</DD><DT CLASS="dt-description"><TT><B>C-c C-p</B></TT></DT><DD CLASS="dd-description"> (command <TT>print</TT>): print value of identifier at point.
</DD><DT CLASS="dt-description"><TT><B>C-c C-d</B></TT></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display value of identifier at point.
</DD><DT CLASS="dt-description"><TT><B>C-c C-r</B></TT></DT><DD CLASS="dd-description"> (command <TT>run</TT>): execute the program forward to next
breakpoint.
</DD><DT CLASS="dt-description"><TT><B>C-c C-v</B></TT></DT><DD CLASS="dd-description"> (command <TT>reverse</TT>): execute the program backward to
latest breakpoint.
</DD><DT CLASS="dt-description"><TT><B>C-c C-l</B></TT></DT><DD CLASS="dd-description"> (command <TT>last</TT>): go back one step in the command history.
</DD><DT CLASS="dt-description"><TT><B>C-c C-t</B></TT></DT><DD CLASS="dd-description"> (command <TT>backtrace</TT>): display backtrace of function calls.
</DD><DT CLASS="dt-description"><TT><B>C-c C-f</B></TT></DT><DD CLASS="dd-description"> (command <TT>finish</TT>): run forward till the current
function returns.
</DD><DT CLASS="dt-description"><TT><B>C-c &lt;</B></TT></DT><DD CLASS="dd-description"> (command <TT>up</TT>): select the stack frame below the
current frame.
</DD><DT CLASS="dt-description"><TT><B>C-c &gt;</B></TT></DT><DD CLASS="dd-description"> (command <TT>down</TT>): select the stack frame above the
current frame.
</DD></DL><P>In all buffers in OCaml editing mode, the following debugger commands
are also available:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>C-x C-a C-b</B></TT></DT><DD CLASS="dd-description"> (command <TT>break</TT>): set a breakpoint at event closest
to point
</DD><DT CLASS="dt-description"><TT><B>C-x C-a C-p</B></TT></DT><DD CLASS="dd-description"> (command <TT>print</TT>): print value of identifier at point
</DD><DT CLASS="dt-description"><TT><B>C-x C-a C-d</B></TT></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display value of identifier at point
</DD></DL><!--TOC chapter Profiling (ocamlprof)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc211">Chapter&#XA0;17</A>&#XA0;&#XA0;Profiling (ocamlprof)</H1><!--SEC END --><P> <A NAME="c:profiler"></A>
</P><P>This chapter describes how the execution of OCaml
programs can be profiled, by recording how many times functions are
called, branches of conditionals are taken, &#X2026;</P><!--TOC section Compiling for profiling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc212">17.1</A>&#XA0;&#XA0;Compiling for profiling</H2><!--SEC END --><P>Before profiling an execution, the program must be compiled in
profiling mode, using the <TT>ocamlcp</TT> front-end to the <TT>ocamlc</TT> compiler
(see chapter&#XA0;<A HREF="#c:camlc">8</A>) or the <TT>ocamloptp</TT> front-end to the
<TT>ocamlopt</TT> compiler (see chapter&#XA0;<A HREF="#c:nativecomp">11</A>). When compiling
modules separately, <TT>ocamlcp</TT> or <TT>ocamloptp</TT> must be used when
compiling the modules (production of <TT>.cmo</TT> or <TT>.cmx</TT> files), and can
also be used (though this is not strictly necessary) when linking them
together.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> If a module (<TT>.ml</TT> file) doesn&#X2019;t have a corresponding
interface (<TT>.mli</TT> file), then compiling it with <TT>ocamlcp</TT> will produce
object files (<TT>.cmi</TT> and <TT>.cmo</TT>) that are not compatible with the ones
produced by <TT>ocamlc</TT>, which may lead to problems (if the <TT>.cmi</TT> or
<TT>.cmo</TT> is still around) when switching between profiling and
non-profiling compilations. To avoid this problem, you should always
have a <TT>.mli</TT> file for each <TT>.ml</TT> file. The same problem exists with
<TT>ocamloptp</TT>.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> To make sure your programs can be compiled in
profiling mode, avoid using any identifier that begins with
<TT>__ocaml_prof</TT>.</P><P>The amount of profiling information can be controlled through the <TT>-P</TT>
option to <TT>ocamlcp</TT> or <TT>ocamloptp</TT>, followed by one or several letters
indicating which parts of the program should be profiled:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>a</B></TT></DT><DD CLASS="dd-description"> all options
</DD><DT CLASS="dt-description"><TT><B>f</B></TT></DT><DD CLASS="dd-description"> function calls : a count point is set at the beginning of
each function body
</DD><DT CLASS="dt-description"><TT><B>i</B></TT></DT><DD CLASS="dd-description"> <B>if &#X2026;then &#X2026;else &#X2026;</B> : count points are set in
both <B>then</B> branch and <B>else</B> branch
</DD><DT CLASS="dt-description"><TT><B>l</B></TT></DT><DD CLASS="dd-description"> <B>while, for</B> loops: a count point is set at the beginning of
the loop body
</DD><DT CLASS="dt-description"><TT><B>m</B></TT></DT><DD CLASS="dd-description"> <B>match</B> branches: a count point is set at the beginning of the
body of each branch
</DD><DT CLASS="dt-description"><TT><B>t</B></TT></DT><DD CLASS="dd-description"> <B>try &#X2026;with &#X2026;</B> branches: a count point is set at the
beginning of the body of each branch
</DD></DL><P>For instance, compiling with <TT>ocamlcp -P film</TT> profiles function calls,
if&#X2026;then&#X2026;else&#X2026;, loops and pattern matching.</P><P>Calling <TT>ocamlcp</TT> or <TT>ocamloptp</TT> without the <TT>-P</TT> option defaults to
<TT>-P fm</TT>, meaning that only function calls and pattern matching are
profiled.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> For compatibility with previous releases, <TT>ocamlcp</TT>
also accepts the <TT>-p</TT> option, with the same arguments and behaviour as
<TT>-P</TT>.</P><P>The <TT>ocamlcp</TT> and <TT>ocamloptp</TT> commands also accept all the options of
the corresponding <TT>ocamlc</TT> or <TT>ocamlopt</TT> compiler, except the <TT>-pp</TT>
(preprocessing) option.</P><!--TOC section Profiling an execution-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc213">17.2</A>&#XA0;&#XA0;Profiling an execution</H2><!--SEC END --><P>Running an executable that has been compiled with <TT>ocamlcp</TT> or
<TT>ocamloptp</TT> records the execution counts for the specified parts of
the program and saves them in a file called <TT>ocamlprof.dump</TT> in the
current directory.</P><P>If the environment variable <TT>OCAMLPROF_DUMP</TT> is set when the program
exits, its value is used as the file name instead of <TT>ocamlprof.dump</TT>.</P><P>The dump file is written only if the program terminates
normally (by calling <TT>exit</TT> or by falling through). It is not written
if the program terminates with an uncaught exception.</P><P>If a compatible dump file already exists in the current directory, then the
profiling information is accumulated in this dump file. This allows, for
instance, the profiling of several executions of a program on
different inputs. Note that dump files produced by byte-code
executables (compiled with <TT>ocamlcp</TT>) are compatible with the dump
files produced by native executables (compiled with <TT>ocamloptp</TT>).</P><!--TOC section Printing profiling information-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc214">17.3</A>&#XA0;&#XA0;Printing profiling information</H2><!--SEC END --><P>The <TT>ocamlprof</TT> command produces a source listing of the program modules
where execution counts have been inserted as comments. For instance,
</P><PRE>        ocamlprof foo.ml
</PRE><P>prints the source code for the <TT>foo</TT> module, with comments indicating
how many times the functions in this module have been called. Naturally,
this information is accurate only if the source file has not been modified
after it was compiled.</P><P>The following options are recognized by <TT>ocamlprof</TT>:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-f</TT> <I>dumpfile</I></B></DT><DD CLASS="dd-description">
Specifies an alternate dump file of profiling information to be read.</DD><DT CLASS="dt-description"><B><TT>-F</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Specifies an additional string to be output with profiling information.
By default, <TT>ocamlprof</TT> will annotate programs with comments of the form
<TT>(* <I>n</I> *)</TT> where <I>n</I> is the counter value for a profiling
point. With option <TT>-F <I>s</I></TT>, the annotation will be
<TT>(* <I>sn</I> *)</TT>.</DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Time profiling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc215">17.4</A>&#XA0;&#XA0;Time profiling</H2><!--SEC END --><P>Profiling with <TT>ocamlprof</TT> only records execution counts, not the actual
time spent within each function. There is currently no way to perform
time profiling on bytecode programs generated by <TT>ocamlc</TT>.</P><P>Native-code programs generated by <TT>ocamlopt</TT> can be profiled for time
and execution counts using the <TT>-p</TT> option and the standard Unix
profiler <TT>gprof</TT>. Just add the <TT>-p</TT> option when compiling and linking
the program:
</P><PRE>
        ocamlopt -o myprog -p <I>other-options files</I>
        ./myprog
        gprof myprog
</PRE><P>
OCaml function names in the output of <TT>gprof</TT> have the following format:
</P><PRE>
        <I>Module-name</I>_<I>function-name</I>_<I>unique-number</I>
</PRE><P>
Other functions shown are either parts of the OCaml run-time system or
external C functions linked with the program.</P><P>The output of <TT>gprof</TT> is described in the Unix manual page for
<TT>gprof(1)</TT>. It generally consists of two parts: a &#X201C;flat&#X201D; profile
showing the time spent in each function and the number of invocation
of each function, and a &#X201C;hierarchical&#X201D; profile based on the call
graph. Currently, only the Intel x86 ports of <TT>ocamlopt</TT> under
Linux, BSD and MacOS X support the two profiles. On other platforms,
<TT>gprof</TT> will report only the &#X201C;flat&#X201D; profile with just time
information. When reading the output of <TT>gprof</TT>, keep in mind that
the accumulated times computed by <TT>gprof</TT> are based on heuristics and
may not be exact.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> The <TT>ocamloptp</TT> command also accepts the <TT>-p</TT>
option. In that case, both kinds of profiling are performed by the
program, and you can display the results with the <TT>gprof</TT> and <TT>ocamlprof</TT>
commands, respectively.

</P><!--TOC chapter The ocamlbuild compilation manager-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc216">Chapter&#XA0;18</A>&#XA0;&#XA0;The ocamlbuild compilation manager</H1><!--SEC END --><P> <A NAME="c:ocamlbuild"></A>
</P><P><I>(Chapter written by Berke Durak and Nicolas Pouillard)</I></P><P><BR>
<BR>
</P><P><TT>ocamlbuild</TT> is a tool automating the compilation of most OCaml projects with minimal
user input. Its use is not restricted to projects having a simple structure &#X2013;
the extra effort needed to make it work with the more complex projects is in
reasonable proportion with their added complexity. In practice, one will use a
set of small text files, and, if needed, an OCaml compilation module that can
fine-tune the behaviour and define custom rules.</P><!--TOC section Features of <TT>ocamlbuild</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc217">18.1</A>&#XA0;&#XA0;Features of <TT>ocamlbuild</TT></H2><!--SEC END --><P>
<EM>This section is intended to read like a sales brochure or a datasheet.</EM></P><UL CLASS="itemize"><LI CLASS="li-itemize">
Built-in compilation rules for OCaml projects handle all the nasty cases:
native and byte-code, missing <TT>.mli</TT> files, preprocessor rules,
libraries, package (-pack) debugging and profiling flags, C stubs.
</LI><LI CLASS="li-itemize">Plugin mechanism for writing compilation rules and actions in a real programming language,
OCaml itself.
</LI><LI CLASS="li-itemize">Automatic inference of dependencies.
</LI><LI CLASS="li-itemize">Correct handling of dynamically discovered dependencies.
</LI><LI CLASS="li-itemize">Object files and other temporary files are created in a specific directory, leaving your main directory uncluttered.
</LI><LI CLASS="li-itemize">Sanity checks ensure that object files are where they are supposed to be: in the build directory.
</LI><LI CLASS="li-itemize">Regular projects are built using a single command with no extra files.
</LI><LI CLASS="li-itemize">Parallel compilation to speed up things on multi-core systems.
</LI><LI CLASS="li-itemize">Sophisticated display mode to keep your screen free of boring and repetitive compilation message
while giving you important progress information in a glimpse, and correctly multiplexing the error messages.
</LI><LI CLASS="li-itemize">Tags and flags provide a concise and convenient mechanism for automatic selection of compilation, preprocessing and
other options.
</LI><LI CLASS="li-itemize">Extended shell-like glob patterns, that can be combined using boolean operators,
allow you to concisely define the tags that apply to a given file.
</LI><LI CLASS="li-itemize">Mechanisms for defining the mutual visibility of subdirectories.
</LI><LI CLASS="li-itemize">Cache mechanism avoiding unnecessary compilations where reasonably computable.
</LI></UL><!--TOC section Limitations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc218">18.2</A>&#XA0;&#XA0;Limitations</H2><!--SEC END --><P>
<EM>Not perfect nor complete yet, but already pretty damn useful.</EM></P><P>We were not expecting to write the ultimate compilation tool in a few man-months, however we believe we have
a tool that solves many compilation problems, especially our own, in a satisfactory way. Hence there are a
lot of missing features, incomplete options and hideous bugs lurking in <TT>ocamlbuild</TT>, and we hope that the OCaml community
will find our first try at <TT>ocamlbuild</TT> useful and hopefully help it grow into a tool that satisfies most needs of most users
by providing feedback, bug reports and patches.</P><P>The plugin API maybe somewhat lacking in maturity, as it has only been tested
by a few people. We believe a good API can only evolve under pressure from
many peers and the courage to rewrite things cleanly when time is ripe by the
developers. Most of the important functions a user will need are encapsulated
in the plugin API, which is the <TT>Ocamlbuild_plugin</TT> module pack. We
intend to keep that API backwards compatible. It may happen that intricate
projects need features not available in that module &#X2013; you may then use
functions or values directly from the core <TT>ocamlbuild</TT> modules. We ask you to report
such usage to the authors so that we may make the necessary changes to the API;
you may also want to isolate calls to the non-API parts of the <TT>ocamlbuild</TT> library
from the rest of your plugin to be able to keep the later when incompatible
changes arise.</P><P>The way that <TT>ocamlbuild</TT> handles the command-line options, the <TT>_tags</TT> file,
the target names, names of the tags, and so on, are not expected to change in
incompatible ways. We intend to keep a project that compiles without a plugin
compilable without modifications in the future.
</P><!--TOC section Using <TT>ocamlbuild</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc219">18.3</A>&#XA0;&#XA0;Using <TT>ocamlbuild</TT></H2><!--SEC END --><P>
<EM>Learn how to use <TT>ocamlbuild</TT> with short, specific, straight-to-the-point examples.</EM></P><P>The amount of time and effort spent on the compilation process of a project
should be proportionate to that spent on the project itself. It should be easy
to set up a small project, maybe a little harder for a medium-sized project,
and it may take some more time, but not too much, for a big project. Ideally
setting up a big project would be as easy as setting up a small project. However,
as projects grow, modularization techniques start to be used, and the probability
of using meta programming or multiple programming languages increases, thus making
the compilation process more delicate.</P><P><TT>ocamlbuild</TT> is intended to be very easy to use for projects, large or small, with a simple
compilation process: typing
<TT>ocamlbuild foo.native</TT> should be enough to compile the native version
of a program whose top module is <TT>foo.ml</TT> and whose dependencies are in
the same directory. As your project gets more complex, you will gradually
start to use command-line options to specify libraries to link with, then
configuration files, ultimately culminating in a custom OCaml plugin for
complex projects with arbitrary dependencies and actions.</P><!--TOC subsection Hygiene &amp; where is my code ?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc220">18.3.1</A>&#XA0;&#XA0;Hygiene &amp; where is my code ?</H3><!--SEC END --><P>
Your code is in the <TT>_build</TT> directory, but <TT>ocamlbuild</TT> automatically creates
a symbolic link to the executables it produces in the current directory.
<TT>ocamlbuild</TT> copies the source files and compiles them in a separate directory
which is <TT>_build</TT> by default.</P><P>For <TT>ocamlbuild</TT>, any file that is not in the build directory is a source file.
It is not unreasonable to think that some users may have bought binary object files
they keep in their project directory. Usually binary files cluttering the project
directory are due to previous builds using other systems. <TT>ocamlbuild</TT> has so-called
&#X201C;hygiene&#X201D; rules that state that object files (<TT>.cmo</TT>, <TT>.cmi</TT>,
or <TT>.o</TT> files, for instance) must not appear outside of the build
directory. These rules are enforced at startup; any violations will be reported
and <TT>ocamlbuild</TT> will exit. You must then remove these files by hand or run, with caution,
the script <TT>sanitize.sh</TT>, which is generated in your source directory.
This script will contain commands to remove them for you.</P><P>To disable these checks, you can use the <TT>-no-hygiene</TT> flag. If you have
files that must elude the hygiene squad, just tag them with <TT>precious</TT>
or <TT>not_hygienic</TT>.
</P><!--TOC subsection Hello, world !-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc221">18.3.2</A>&#XA0;&#XA0;Hello, world !</H3><!--SEC END --><P>
Assuming we are in a directory named <TT>example1</TT> containing one file <TT>hello.ml</TT>
whose contents are
</P><PRE>let _ =
  Printf.printf "Hello, %s ! My name is %s\n"
    (if Array.length Sys.argv &gt; 1 then Sys.argv.(1) else "stranger")
    Sys.argv.(0)
;;
</PRE><P>we can compile and link it into a native executable by invoking <TT>ocamlbuild hello.native</TT>.
Here, <TT>hello</TT> is the basename of the top-level module and <TT>native</TT> is an extension used
by <TT>ocamlbuild</TT> to denote native code executables.
</P><PRE>% ls
hello.ml
% ocamlbuild hello.native
Finished, 4 targets (0 cached) in 00:00:00.
% ls -l
total 12
drwxrwx&#X2014; 2 linus gallium 4096 2007-01-17 16:24 _build/
-rw-rw&#X2014;- 1 linus gallium   43 2007-01-17 16:23 hello.ml
lrwxrwxrwx 1 linus gallium   19 2007-01-17 16:24 hello.native -&gt; _build/hello.native*
</PRE><P>What&#X2019;s this funny <TT>_build</TT> directory ? Well that&#X2019;s where <TT>ocamlbuild</TT> does its dirty work
of compiling. You usually won&#X2019;t have to look very often into this directory. Source files are copied
into <TT>_build</TT> and this is where the compilers will be run. Various cache files are also stored
there. Its contents may look like this:
</P><PRE>% ls -l _build
total 208
-rw-rw&#X2014;- 1 linus gallium    337 2007-01-17 16:24 _digests
-rw-rw&#X2014;- 1 linus gallium    191 2007-01-17 16:24 hello.cmi
-rw-rw&#X2014;- 1 linus gallium    262 2007-01-17 16:24 hello.cmo
-rw-rw&#X2014;- 1 linus gallium    225 2007-01-17 16:24 hello.cmx
-rw-rw&#X2014;- 1 linus gallium     43 2007-01-17 16:23 hello.ml
-rw-rw&#X2014;- 1 linus gallium     17 2007-01-17 16:24 hello.ml.depends
-rwxrwx&#X2014; 1 linus gallium 173528 2007-01-17 16:24 hello.native*
-rw-rw&#X2014;- 1 linus gallium    936 2007-01-17 16:24 hello.o
-rw-rw&#X2014;- 1 linus gallium     22 2007-01-17 16:24 ocamlc.where
</PRE><!--TOC subsection Executing my code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc222">18.3.3</A>&#XA0;&#XA0;Executing my code</H3><!--SEC END --><P>
You can execute your code the old-fashioned way (<TT>./hello.native</TT>).
You may also type
</P><PRE>ocamlbuild hello.native &#X2013; Caesar
</PRE><P>and it will compile and then run <TT>hello.native</TT> with the arguments following <TT>--</TT>,
which should display:
</P><PRE>% ocamlbuild hello.native &#X2013; Caesar
Finished, 4 targets (0 cached) in 00:00:00.
Hello, Caesar ! My name is _build/hello.native
</PRE><!--TOC subsection The log file, verbosity and debugging-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc223">18.3.4</A>&#XA0;&#XA0;The log file, verbosity and debugging</H3><!--SEC END --><P>
By default, if you run <TT>ocamlbuild</TT> on a terminal, it will use some ANSI escape sequences
to display a nice, one-line progress indicator. To see what commands <TT>ocamlbuild</TT> has actually run,
you can check the contents of the <TT>_build/_log</TT> file. To change the name of the
log file or to disable logging, use the <TT>-log &lt;file&gt;</TT> or <TT>-no-log</TT> options.
Note that the log file is truncated at each execution of <TT>ocamlbuild</TT>.</P><P>The log file contains all the external commands that <TT>ocamlbuild</TT> ran or intended to
run along with the target name and the computed tags. With the
<TT>-verbose &lt;level&gt;</TT> option, <TT>ocamlbuild</TT> will also write more or less useful
debugging information; a verbosity level of 1 (which can also be specified
using the <TT>-verbose</TT> switch) prints generally useful information; higher
levels produce much more output.
</P><!--TOC subsection Cleaning-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc224">18.3.5</A>&#XA0;&#XA0;Cleaning</H3><!--SEC END --><P>
<TT>ocamlbuild</TT> may leave a <TT>_build</TT> directory and symbolic links to executables in
that directory (unless when using -no-links). All of these can be removed safely
by hand, or by invoking <TT>ocamlbuild</TT> with the <TT>-clean</TT> flag.
</P><!--TOC subsection Where and how to run <TT>ocamlbuild</TT>?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc225">18.3.6</A>&#XA0;&#XA0;Where and how to run <TT>ocamlbuild</TT>?</H3><!--SEC END --><P>
An important point is that <TT>ocamlbuild</TT> must be invoked from the root of the project,
even if this project has multiple, nested subdirectories. This is because <TT>ocamlbuild</TT> likes to store the object files in a single <TT>_build</TT> directory. You
can change the name of that directory with the <TT>-build-dir</TT> option.</P><P><TT>ocamlbuild</TT> can be either invoked manually from the UNIX or Windows shell, or
automatically from a build script or a Makefile. Unless run with the
<TT>-no-hygiene</TT> option, there is the possibility that <TT>ocamlbuild</TT> will prompt the
user for a response. By default, on UNIX systems, if <TT>ocamlbuild</TT> senses that the
standard output is a terminal, it will use a nice progress indicator using ANSI
codes, instrumenting the output of the processes it spawns to have a consistent
display. Under non-UNIX systems, or if the standard output is not a terminal,
it will run in classic mode where it will echo the executed commands on its
standard output. This selection can be overridden with the <TT>-classic-display</TT> option.
</P><!--TOC subsection Dependencies-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc226">18.3.7</A>&#XA0;&#XA0;Dependencies</H3><!--SEC END --><P>
<EM>Dependencies are automatically discovered.</EM></P><P>Most of the value of <TT>ocamlbuild</TT> lies in the fact that it often needs no extra
information to compile a project besides the name of the top-level module.
<TT>ocamlbuild</TT> calls <TT>ocamldep</TT> to automatically find the dependencies of any
modules it wants to compile. These dependencies are dynamically incorporated
in the dependency graph, something <TT>make</TT> cannot do.
For instance, let&#X2019;s add a module <TT>Greet</TT> that implements various ways of
greeting people.
</P><PRE>% cat greet.ml
type how = Nicely | Badly;;

let greet how who =
  match how with Nicely -&gt; Printf.printf "Hello, %s !\n" who
               | Badly  -&gt; Printf.printf "Oh, here is that %s again.\n" who
;;
% cat hello.ml
open Greet

let _ =
  let name =
    if Array.length Sys.argv &gt; 1 then
      Sys.argv.(1)
    else
      "stranger"
  in
  greet
    (if name = "Caesar" then Nicely else Badly)
    name;
  Printf.printf "My name is %s\n" Sys.argv.(0)
;;
</PRE><P>Then the module <TT>Hello</TT> depends on the module <TT>Greet</TT> and <TT>ocamlbuild</TT> can
figure this out for himself &#X2013; we still only have to invoke <TT>ocamlbuild hello.native</TT>. Needless to say, this works for any number of modules.
</P><!--TOC subsection Native and byte-code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc227">18.3.8</A>&#XA0;&#XA0;Native and byte-code</H3><!--SEC END --><P>
If we want to compile byte-code instead of native, we just a target name of
<TT>hello.byte</TT> instead of <TT>hello.native</TT>, i.e., we type
<TT>ocamlbuild hello.byte</TT>.
</P><!--TOC subsection Compile flags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc228">18.3.9</A>&#XA0;&#XA0;Compile flags</H3><!--SEC END --><P>
To pass a flag to the compiler, such as the <TT>-rectypes</TT> option,
use the <TT>-cflag</TT> option as in:
</P><PRE>ocamlbuild -cflag -rectypes hello.native
</PRE><P>You can put multiple <TT>-cflag</TT> options, they will be passed to the compiler
in the same order. You can also give them in a comma-separated list with the
<TT>-cflags</TT> option (notice the plural):
</P><PRE>ocamlbuild -cflags -I,+lablgtk,-rectypes hello.native
</PRE><P>These flags apply when compiling, that is, when producing <TT>.cmi</TT>,
<TT>.cmo</TT>,<TT>.cmx</TT> and <TT>.o</TT> files from <TT>.ml</TT> or
<TT>.mli</TT> files.
</P><!--TOC subsection Link flags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc229">18.3.10</A>&#XA0;&#XA0;Link flags</H3><!--SEC END --><P>
Link flags apply when the various object files are collected and linked into
one executable. These will typically be include directories for libraries.
They are given using the <TT>-lflag</TT> and <TT>-lflags</TT> options, which
work in the same way as the <TT>-cflag</TT> and <TT>-cflags</TT> options.
</P><!--TOC subsection Linking with external libraries-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc230">18.3.11</A>&#XA0;&#XA0;Linking with external libraries</H3><!--SEC END --><P>
In our third example, we use one Unix system call and functions from the <TT>num</TT>
library:
</P><PRE>% cat epoch.ml
let _ =
  let s = Num.num_of_string (Printf.sprintf "%.0f" (Unix.gettimeofday ())) in
  let ps = Num.mult_num (Num.num_of_string "1000000000000") s in
  Printf.printf "%s picoseconds have passed since January 1st, 1970.\n"
    (Num.string_of_num ps)
;;
</PRE><P>This requires linking with the <TT>unix</TT> and <TT>num</TT> modules, which is accomplished
by using the <TT>-lib unix</TT> and <TT>-lib num</TT> flags, or, alternatively, <TT>-libs unix,num</TT>:
</P><PRE>% ocamlbuild -libs nums,unix epoch.native &#X2013;
Finished, 4 targets (4 cached) in 00:00:00.
1169051647000000000000 picoseconds have passed since January 1st, 1970.
</PRE><P>You may need to add options such as <TT>-cflags -I,/usr/local/lib/ocaml/</TT>
and <TT>-lflags -I,/usr/local/lib/ocaml/</TT> if the libraries you wish to
link with are not in OCaml&#X2019;s default search path.
</P><!--TOC subsection The <TT>_tags</TT> files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc231">18.3.12</A>&#XA0;&#XA0;The <TT>_tags</TT> files</H3><!--SEC END --><P>
Finer control over the compiler flags applied to each source file, such as
preprocessing, debugging, profiling and linking options, can be gained using
<TT>ocamlbuild</TT>&#X2019;s tagging mechanism.</P><P>Every source file has a set of tags which tells <TT>ocamlbuild</TT> what kind of file it is
and what to do with it. A tag is simply a string, usually lowercase, for
example <TT>ocaml</TT> or <TT>native</TT>. The set of tags attached to a file
is computed by applying the tagging rules to the filename. Tagging rules are
defined in <TT>_tags</TT> files in any parent directory of a file, up to the main
project directory.</P><P>Each line in the <TT>_tags</TT> file is made of a glob pattern (see subsection
<A HREF="#subsec:glob">18.3.13</A>) and a list of tags. More than one rule can apply to a file
and rules are applied in the order in which they appear in a file.
By preceding a tag with a minus sign, one may remove tags from one or more files.</P><!--TOC subsubsection Example: the built-in <TT>_tags</TT> file-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Example: the built-in <TT>_tags</TT> file</H4><!--SEC END --><PRE>     &lt;**/*.ml&gt; or &lt;**/*.mli&gt; or &lt;**/*.mlpack&gt; or &lt;**/*.ml.depends&gt;: ocaml
     &lt;**/*.byte&gt;: ocaml, byte, program
     &lt;**/*.odoc&gt;: ocaml, doc
     &lt;**/*.native&gt;: ocaml, native, program
     &lt;**/*.cma&gt;: ocaml, byte, library
     &lt;**/*.cmxa&gt;: ocaml, native, library
     &lt;**/*.cmo&gt;: ocaml, byte
     &lt;**/*.cmi&gt;: ocaml, byte, native
     &lt;**/*.cmx&gt;: ocaml, native
</PRE><P>
Two special tags made from the path name of the file relative to the toplevel
of the project are automatically defined for each file. For a file
<TT>foo/bar.ml</TT> those tags will be <TT>file:foo/bar.ml</TT>, and
<TT>extension:ml</TT>.</P><P>If you do not have subdirectories, you can put <TT>*.ml</TT> instead of
<TT>**/*.ml</TT>.
</P><!--TOC subsection Glob patterns and expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc232">18.3.13</A>&#XA0;&#XA0;Glob patterns and expressions</H3><!--SEC END --><P>
<A NAME="subsec:glob"></A>
Glob patterns have a syntax similar to those used by UNIX shells to select path
names (like <TT>foo_*.ba?</TT>). They are used in <TT>ocamlbuild</TT> to define the files
and directories to which tags apply. Glob expressions are glob patterns
enclosed in brackets <TT>&lt;</TT> and <TT>&gt;</TT> combined using the standard
boolean operators <TT>and</TT>, <TT>or</TT>, <TT>not</TT>. This allows one to
describe sets of path names in more concise and more readable ways.</P><P>Please note that file and directory names are supposed to be made of the
following characters: <TT>a</TT>, &#X2026;, <TT>z</TT>, <TT>A</TT>,
&#X2026;, <TT>Z</TT>, <TT>0</TT>, &#X2026;, <TT>9</TT>, <TT>_</TT>,
<TT>-</TT> and <TT>.</TT>. This is called the pathname alphabet <I>P</I>.</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left> <EM>Formal syntax</EM></TD><TD VALIGN=top ALIGN=left NOWRAP> <EM>Example</EM></TD><TD VALIGN=top ALIGN=left><EM>Matches</EM></TD><TD VALIGN=top ALIGN=left><EM>Does not match</EM></TD><TD VALIGN=top ALIGN=left> <EM>Meaning (formal meaning)</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=left><I>u</I> <BR>
 A string of pathname characters</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>fo.ml</TT>, <TT>bar/foo.ml</TT></TD><TD VALIGN=top ALIGN=left> The exact string <I>u</I>
({ <I>u</I> }, where <I>u</I> &#X2208; <I>P</I><SUP>*</SUP>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>*</TT> <BR>
 The wild-card star</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>*</TT></TD><TD VALIGN=top ALIGN=left> &#X3B5;, <TT>foo</TT>, <TT>bar</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo/bar</TT>, <TT>/bar</TT></TD><TD VALIGN=top ALIGN=left> Any string not containing a slash
(<I>P</I><SUP>*</SUP>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>?</TT> <BR>
 The joker</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>?</TT></TD><TD VALIGN=top ALIGN=left> <TT>a</TT>, <TT>b</TT>, <TT>z</TT></TD><TD VALIGN=top ALIGN=left> <TT>/</TT>, <TT>bar</TT></TD><TD VALIGN=top ALIGN=left> Any one-letter string, excluding the slash</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>**/</TT> <BR>
 The prefix inter-directory star</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>**/foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo.ml</TT>, <TT>bar/foo.ml</TT>, <TT>bar/baz/foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo/bar</TT>, <TT>/bar</TT></TD><TD VALIGN=top ALIGN=left> The empty string, or any string ending with a slash
(&#X3B5; &#X222A; <I>P</I><SUP>*</SUP><TT>/</TT>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>/**</TT> <BR>
 The suffix inter-directory star</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>foo/**</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo</TT>, <TT>foo/bar</TT></TD><TD VALIGN=top ALIGN=left> <TT>bar/foo</TT></TD><TD VALIGN=top ALIGN=left> Any string starting with a slash, or the empty string
(&#X3B5; &#X222A; <TT>/</TT><I>P</I><SUP>*</SUP>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>/**/</TT> <BR>
 The infix inter-directory star</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>bar/**/foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>bar/foo.ml</TT>, <TT>bar/baz/foo.ml</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo.ml</TT></TD><TD VALIGN=top ALIGN=left> Any string starting and ending with a slash
(&#X3B5; &#X222A; <TT>/</TT><I>P</I><SUP>*</SUP><TT>/</TT>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>[</TT> <I>r</I><SUB>1</SUB> <I>r</I><SUB>2</SUB> &#X22EF; <I>r<SUB>k</SUB></I> <TT>]</TT>
where <I>r<SUB>i</SUB></I> is either <I>c</I> or <I>c</I><SUB>1</SUB>&#X2212;<I>c</I><SUB>2</SUB> (1 &#X2264; <I>i</I> &#X2264; <I>k</I>)
<BR>
 The positive character class</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>[a-fA-F0-9_.]</TT></TD><TD VALIGN=top ALIGN=left> <TT>3</TT>, <TT>F</TT>, <TT>.</TT></TD><TD VALIGN=top ALIGN=left> <TT>z</TT>, <TT>bar</TT></TD><TD VALIGN=top ALIGN=left> Any one-letter string made of characters from one of the ranges
<I>r<SUB>i</SUB></I> (1 &#X2264; <I>i</I> &#X2264; <I>n</I>).
(<FONT COLOR=red><I>L</I></FONT>(<I>r</I><SUB>1</SUB>) &#X222A; &#X22EF; &#X222A; <FONT COLOR=red><I>L</I></FONT>(<I>r<SUB>n</SUB></I>))</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>[^</TT><I>r</I><SUB>1</SUB> <I>r</I><SUB>2</SUB> &#X22EF; <I>r<SUB>k</SUB></I> <TT>]</TT>
where <I>r<SUB>i</SUB></I> is either <I>c</I> or <I>c</I><SUB>1</SUB>&#X2212;<I>c</I><SUB>2</SUB> (1 &#X2264; <I>i</I> &#X2264; <I>k</I>)
<BR>
 The negative character class</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>[^a-fA-F0-9_.]</TT></TD><TD VALIGN=top ALIGN=left> <TT>z</TT>, <TT>bar</TT></TD><TD VALIGN=top ALIGN=left> <TT>3</TT>, <TT>F</TT>, <TT>.</TT></TD><TD VALIGN=top ALIGN=left> Any one-letter string NOT made of characters from one of the ranges
<I>r<SUB>i</SUB></I> (1 &#X2264; <I>i</I> &#X2264; <I>n</I>).
(&#X3A3;<SUP>*</SUP> &#X2216; (<FONT COLOR=red><I>L</I></FONT>(<I>r</I><SUB>1</SUB>) &#X222A; &#X22EF; &#X222A; <FONT COLOR=red><I>L</I></FONT>(<I>r<SUB>n</SUB></I>)))</TD></TR>
<TR><TD VALIGN=top ALIGN=left><I>p</I><SUB>1</SUB> <I>p</I><SUB>2</SUB> <BR>
 A concatenation of patterns</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>foo*</TT></TD><TD VALIGN=top ALIGN=left> <TT>foo</TT>, <TT>foob</TT>, <TT>foobar</TT></TD><TD VALIGN=top ALIGN=left> <TT>fo</TT>, <TT>bar</TT></TD><TD VALIGN=top ALIGN=left> Any string with a prefix matching <I>p</I><SUB>1</SUB> and the corresponding suffix
matching <I>p</I><SUB>2</SUB>,
({ <I>uv</I> &#X2223; <I>u</I> &#X2208; <FONT COLOR=red><I>L</I></FONT>(<I>p</I><SUB>1</SUB>), <I>v</I> &#X2208; <FONT COLOR=red><I>L</I></FONT>(<I>p</I><SUB>2</SUB>) })</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>{</TT> <I>p</I><SUB>1</SUB> <TT>,</TT> <I>p</I><SUB>2</SUB> <TT>,</TT> &#X22EF; <TT>,</TT> <I>p<SUB>k</SUB></I> <TT>}</TT> <BR>
 A union of patterns</TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>toto.{ml,mli}</TT></TD><TD VALIGN=top ALIGN=left> <TT>toto.ml</TT>, <TT>toto.mli</TT></TD><TD VALIGN=top ALIGN=left> <TT>toto.</TT></TD><TD VALIGN=top ALIGN=left> Any string matching one of the patterns <I>p<SUB>i</SUB></I> for 1 &#X2264; <I>i</I> &#X2264; <I>k</I>.
(<FONT COLOR=red><I>L</I></FONT>(<I>p</I><SUB>1</SUB>) &#X222A; &#X22EF; &#X222A; <FONT COLOR=red><I>L</I></FONT>(<I>p<SUB>k</SUB></I>))</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 18.1: 
Syntax and semantics of glob patterns.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left> <EM>Formal syntax</EM></TD><TD VALIGN=top ALIGN=left NOWRAP> <EM>Example</EM></TD><TD VALIGN=top ALIGN=left> <EM>Meaning (formal meaning)</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=left> <TT>&lt;</TT><I>p</I><TT>&gt;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>&lt;foo.ml&gt;</TT></TD><TD VALIGN=top ALIGN=left> Pathnames matching the pattern <I>p</I></TD></TR>
<TR><TD VALIGN=top ALIGN=left> <I>e</I><SUB>1</SUB> &#XA0; <I><TT>or</TT></I> &#XA0; <I>e</I><SUB>2</SUB></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>&lt;*.ml&gt; or &lt;foo/bar.ml&gt;</TT></TD><TD VALIGN=top ALIGN=left> Pathnames matching at least one of the expressions <I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB></TD></TR>
<TR><TD VALIGN=top ALIGN=left> <I>e</I><SUB>1</SUB> &#XA0; <I><TT>and</TT></I> &#XA0; <I>e</I><SUB>2</SUB></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>&lt;*.ml&gt; and &lt;foo_*&gt;</TT></TD><TD VALIGN=top ALIGN=left> Pathnames matching both expressions <I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB></TD></TR>
<TR><TD VALIGN=top ALIGN=left> <I><TT>not</TT></I> &#XA0; <I>e</I></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>not &lt;*.mli&gt;</TT></TD><TD VALIGN=top ALIGN=left> Pathnames not matching the expression <I>e</I></TD></TR>
<TR><TD VALIGN=top ALIGN=left> <I><TT>true</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>true</TT></TD><TD VALIGN=top ALIGN=left> All pathnames</TD></TR>
<TR><TD VALIGN=top ALIGN=left> <I><TT>false</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP> <TT>false</TT></TD><TD VALIGN=top ALIGN=left> No pathnames</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 18.2: 
Syntax and semantics of glob expressions.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Subdirectories-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc233">18.3.14</A>&#XA0;&#XA0;Subdirectories</H3><!--SEC END --><P>
If the files of your project are held in one or more subdirectories,
<TT>ocamlbuild</TT> must be made aware of that fact using the <TT>-I</TT> or <TT>-Is</TT> options
or by adding an <TT>include</TT> tag. For instance, assume your project is made
of three subdirectories, <TT>foo</TT>, <TT>bar</TT> and <TT>baz</TT> containing
various <TT>.ml</TT> files, the main file being <TT>foo/main.ml</TT>. Then you can
either type:
</P><PRE>% ocamlbuild -Is foo,bar,baz foo/main.native
</PRE><P>or add the following line in the <TT>_tags</TT> file
</P><PRE>&lt;foo&gt; or &lt;bar&gt; or &lt;baz&gt;: include
</PRE><P>and call
</P><PRE>% ocamlbuild foo/main.native
</PRE><P>
There are then two cases. If no other modules named <TT>Bar</TT> or
<TT>Baz</TT> exist elsewhere in the project, then you are done. Just use
<TT>Foo</TT>, <TT>Foo.Bar</TT> and <TT>Foo.Baz</TT> in your code.
Otherwise, you will need to use the plugin mechanism and define the mutual
visibility of the subdirectories using the <TT>Pathname.define_context</TT>
function.</P><!--TOC subsubsection Note on subdirectory traversal-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Note on subdirectory traversal</H4><!--SEC END --><P>
<TT>ocamlbuild</TT> used to traverse by default any subdirectory not explicitly excluded.
This is no longer the case. Note that you can still have a fine grained
control using your <TT>_tags</TT> file and the <TT>traverse</TT> tag.</P><P>There is no longer the <TT>true: traverse</TT> tag declaration by default. To
make <TT>ocamlbuild</TT> recursive use one of these:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Give the <TT>-r</TT> flag to ocamlbuild.
</LI><LI CLASS="li-enumerate">Have a <TT>_tags</TT> or myocamlbuild.ml file in your top directory.
</LI></OL><!--TOC subsection Grouping targets with <TT>.itarget</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc234">18.3.15</A>&#XA0;&#XA0;Grouping targets with <TT>.itarget</TT></H3><!--SEC END --><P>
You can create a file named <TT>foo.itarget</TT> containing
a list of targets, one per line, such as
</P><PRE>main.native
main.byte
stuff.docdir/index.html
</PRE><P>Requesting the target <TT>foo.otarget</TT> will then build every target
listed in the file <TT>foo.itarget</TT>. Blank lines and lines starting
with a sharp (<TT>#</TT>) are ignored.
</P><!--TOC subsection Packing subdirectories into modules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc235">18.3.16</A>&#XA0;&#XA0;Packing subdirectories into modules</H3><!--SEC END --><P>
OCaml&#X2019;s <TT>-pack</TT> option allows you to structure the contents of a
module in a subdirectory. For instance, assume you have a directory
<TT>foo</TT> containing two modules <TT>bar.ml</TT> and <TT>baz.ml</TT>.
You want from these to build a module <TT>Foo</TT> containing <TT>Bar</TT>
and <TT>Baz</TT> as submodules. In the case where no modules named
<TT>Bar</TT> or <TT>Baz</TT> exist outside of <TT>Foo</TT>, to do this you
must write a file <TT>foo.mlpack</TT>, preferably sitting in the same
directory as the directory <TT>Foo</TT> and containing the list of modules
(one per line) it must contain:
</P><PRE>Bar
Baz
</PRE><P>Then when you will request for building <TT>foo.cmo</TT> the package will be
made from <TT>bar.cmo</TT> and <TT>baz.cmo</TT>.
</P><!--TOC subsection Making an OCaml library-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc236">18.3.17</A>&#XA0;&#XA0;Making an OCaml library</H3><!--SEC END --><P>
In a similar way than for packaged modules you can make a library by putting
it&#X2019;s contents in a file (with the mllib extension). For instance, assume you
have a two modules <TT>bar.ml</TT> and <TT>baz.ml</TT>. You want from these to
build a library <TT>foo.cmx?a</TT> containing <TT>Bar</TT> and <TT>Baz</TT>
modules. To do this you must write a file <TT>foo.mllib</TT> containing the
list of modules (one per line) it must contain:
</P><PRE>Bar
Baz
</PRE><P>Then when you will request for building <TT>foo.cma</TT> the library will be
made from <TT>bar.cmo</TT> and <TT>baz.cmo</TT>.
</P><!--TOC subsection Making an OCaml toplevel-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc237">18.3.18</A>&#XA0;&#XA0;Making an OCaml toplevel</H3><!--SEC END --><P>
Making a toplevel is almost the same thing than making a packaged module or a
library. Just write a file with the <TT>mltop</TT> extension (like
<TT>foo.mltop</TT>) and request for building the toplevel using the
<TT>top</TT> extension (<TT>foo.top</TT> in this example).
</P><!--TOC subsection Preprocessor options and tags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc238">18.3.19</A>&#XA0;&#XA0;Preprocessor options and tags</H3><!--SEC END --><P>
You can specify preprocessor options with <TT>-pp</TT> followed by the
preprocessor string, for instance <TT>ocamlbuild -pp camlp4o.opt -unsafe</TT>
would run your sources through CamlP4 with the <TT>-unsafe</TT> option.
Another way is to use the tags file.
</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>Tag</B></TD><TD ALIGN=left NOWRAP><B>Preprocessor command</B></TD><TD ALIGN=left NOWRAP><B>Remark</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>pp(cmd...)</TT></TD><TD ALIGN=left NOWRAP><TT>cmd...</TT></TD><TD ALIGN=left NOWRAP>Arbitrary
preprocessor command<SUP><A NAME="text3" HREF="#note3">1</A></SUP></TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>camlp4o</TT></TD><TD ALIGN=left NOWRAP><TT>camlp4o</TT></TD><TD ALIGN=left NOWRAP>Original OCaml syntax</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>camlp4r</TT></TD><TD ALIGN=left NOWRAP><TT>camlp4r</TT></TD><TD ALIGN=left NOWRAP>Revised OCaml syntax</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>camlp4of</TT></TD><TD ALIGN=left NOWRAP><TT>camlp4of</TT></TD><TD ALIGN=left NOWRAP>Original OCaml syntax with extensions</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>camlp4rf</TT></TD><TD ALIGN=left NOWRAP><TT>camlp4rf</TT></TD><TD ALIGN=left NOWRAP>Revised OCaml syntax with extensions</TD></TR>
</TABLE>
</DIV><!--TOC subsection Debugging byte code and profiling native code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc239">18.3.20</A>&#XA0;&#XA0;Debugging byte code and profiling native code</H3><!--SEC END --><P>
The preferred way of compiling code suitable for debugging with <TT>ocamldebug</TT> or
profiling native code with <TT>ocamlprof</TT> is to use the appropriate target
extensions, <TT>.d.byte</TT> for debugging or <TT>.p.native</TT>.</P><P>Another way is to add use the <TT>debug</TT> or <TT>profile</TT> tags.
Note that these tags must be applied at the compilation and linking stages.
Hence you must either use <TT>-tag debug</TT> or <TT>-tag profile</TT>
on the command line, or add a
</P><PRE>true: debug
</PRE><P>line to your <TT>_tags</TT> file.
Please note that the byte-code profiler works in a wholly different way
and is not supported by <TT>ocamlbuild</TT>.
</P><!--TOC subsection Generating documentation using <TT>ocamldoc</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc240">18.3.21</A>&#XA0;&#XA0;Generating documentation using <TT>ocamldoc</TT></H3><!--SEC END --><P>
Write the names of the modules whose interfaces will be documented in a file
whose extension is <TT>.odocl</TT>, for example <TT>foo.odocl</TT>, then invoke
<TT>ocamlbuild</TT> on the target <TT>foo.docdir/index.html</TT>. This will collect all the
documentation from the interfaces (which will be build, if necessary) using
<TT>ocamldoc</TT> and generate a set of HTML files under the directory
<TT>foo.docdir/</TT>, which is actually a link to <TT>_build/foo.docdir/</TT>.
As for packing subdirectories into modules, the module names must be written
one per line, without extensions and correctly capitalized. Note that
generating documentation in formats other than HTML or from implementations is
not supported.
</P><!--TOC subsection The display line-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc241">18.3.22</A>&#XA0;&#XA0;The display line</H3><!--SEC END --><P>
Provided <TT>ocamlbuild</TT> runs in a terminal under a POSIX environment, it will
display a sophisticated progress-indicator line that graciously interacts
with the output of subcommands. This line looks like this:
</P><PRE>00:00:02 210  (180 ) main.cmx                             ONbp&#X2013;il /
</PRE><P>Here, 00:00:02 is the elapsed time in hour:minute:second format since <TT>ocamlbuild</TT> has
been invoked; 210 is the number of external commands, typically calls to the
compiler or the like, that may or may not have been invoked; 180 is the number
of external commands that have not been invoked since their result is already
in the build directory; <TT>main.cmx</TT> is the name of the last target built;
<TT>ONbp--il</TT> is a short string that describes the tags that have been
encountered and the slash at the end is a frame from a rotating ticker. Hence,
the display line has the following structure:
</P><PRE>HH:MM:SS JOBS (CACHED) PATHNAME                           TAGS TICKER
</PRE><P>
The tag string is made of 8 indicators which each monitor a tag. These tags
are <TT>ocaml</TT>, <TT>native</TT>, <TT>byte</TT>, <TT>program</TT>,
<TT>pp</TT>, <TT>debug</TT>, <TT>interf</TT> and <TT>link</TT>. Initially,
each indicator displays a dash <TT>-</TT>. If the current target has the
monitored tag, then the indicator displays the corresponding character
(see table <A HREF="#tab:tag-chars">18.3</A>) in uppercase. Otherwise, it displays that
character in lowercase. This allows you to see the set of tags that have
been applied to files in your project during the current invocation of <TT>ocamlbuild</TT>.</P><P>Hence the tag string <TT>ONbp--il</TT> means that the current target
<TT>main.cmx</TT> has the tags <TT>ocaml</TT> and <TT>native</TT>, and that
the tags <TT>ocaml</TT>, <TT>native</TT>, <TT>byte</TT>, <TT>program</TT>,
<TT>interf</TT> and <TT>link</TT> have already been seen.</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>Tag</B></TD><TD ALIGN=center NOWRAP><B>Display character</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> ocaml</TD><TD ALIGN=center NOWRAP>O</TD></TR>
<TR><TD ALIGN=left NOWRAP> native</TD><TD ALIGN=center NOWRAP>N</TD></TR>
<TR><TD ALIGN=left NOWRAP> byte</TD><TD ALIGN=center NOWRAP>B</TD></TR>
<TR><TD ALIGN=left NOWRAP> program</TD><TD ALIGN=center NOWRAP>P</TD></TR>
<TR><TD ALIGN=left NOWRAP> pp</TD><TD ALIGN=center NOWRAP>R</TD></TR>
<TR><TD ALIGN=left NOWRAP> debug</TD><TD ALIGN=center NOWRAP>D</TD></TR>
<TR><TD ALIGN=left NOWRAP> interf</TD><TD ALIGN=center NOWRAP>I</TD></TR>
<TR><TD ALIGN=left NOWRAP> link</TD><TD ALIGN=center NOWRAP>L</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 18.3: <A NAME="tab:tag-chars"></A> Relation between the characters displayed in
the tag string and the tags.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection <TT>ocamllex</TT>, <TT>ocamlyacc</TT> and <TT>menhir</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc242">18.3.23</A>&#XA0;&#XA0;<TT>ocamllex</TT>, <TT>ocamlyacc</TT> and <TT>menhir</TT></H3><!--SEC END --><P>
<TT>ocamlbuild</TT> knows how to run the standard lexer and parser generator tools
<TT>ocamllex</TT> and <TT>ocamlyacc</TT> when your files have the
standard <TT>.mll</TT> and <TT>.mly</TT> extensions. If you want to
use <TT>menhir</TT> instead of <TT>ocamlyacc</TT>, you can either
launch <TT>ocamlbuild</TT> with the <TT>-use-menhir</TT> option or add a
</P><PRE>true: use_menhir
</PRE><P>line to your <TT>_tags</TT> file. Note that there is currently no way
of using <TT>menhir</TT> and <TT>ocamlyacc</TT> in the same execution
of <TT>ocamlbuild</TT>.
</P><!--TOC subsection Changing the compilers or tools-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc243">18.3.24</A>&#XA0;&#XA0;Changing the compilers or tools</H3><!--SEC END --><P>
As <TT>ocamlbuild</TT> is part of your OCaml distribution, it knows if it can call the
native compilers and tools (<TT>ocamlc.opt</TT>, <TT>ocamlopt.opt</TT>...)
or not. However you may want <TT>ocamlbuild</TT> to use another <TT>ocaml</TT> compiler
for different reasons (such as cross-compiling or using a wrapper such as
<TT>ocamlfind</TT>). Here is the list of relevant options:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>-ocamlc &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamlopt &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamldep &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamlyacc &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-menhir &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamllex &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamlmktop &lt;command&gt;</TT>
</LI><LI CLASS="li-itemize"><TT>-ocamlrun &lt;command&gt;</TT>
</LI></UL><!--TOC subsection Interaction with version control systems-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc244">18.3.25</A>&#XA0;&#XA0;Interaction with version control systems</H3><!--SEC END --><P>
Here are tips for configuring your version control system to ignore the files
and directories generated by <TT>ocamlbuild</TT>.</P><P>The directory <TT>_build</TT> and any symbolic links
pointing into <TT>_build</TT> should be ignored.
To do this, you must add the following ignore patterns to your version
control system&#X2019;s ignore set:
</P><PRE>_build
*.native
*.byte
*.d.native
*.p.byte
</PRE><P>
For CVS, add the above lines to the <TT>.cvsignore</TT> file.
For Subversion (SVN), type <TT>svn propedit svn:ignore .</TT> and add the
above lines.
</P><!--TOC subsection A shell script for driving it all?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc245">18.3.26</A>&#XA0;&#XA0;A shell script for driving it all?</H3><!--SEC END --><P>
<EM>To shell or to make ?</EM>
Traditionally, makefiles have two major functions. The first one
is the dependency-ordering, rule-matching logic used for compiling.
The second one is as a dispatcher for various actions defined using
phony targets with shell script actions. These actions include cleaning,
cleaning really well, archiving, uploading and so on. Their characteristic
is that they rely little or not on the building process &#X2013; they either need
the building to have been completed, or they don&#X2019;t need anything.
As <TT>/bin/sh</TT> scripts have been here for three to four decades and are
not going anywhere, why not replace that functionality of makefiles with a
shell script ? We have thought of three bad reasons:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Typing <TT>make</TT> to compile is now an automatism,
</LI><LI CLASS="li-itemize">We need to share variable definitions between rules and actions,
</LI><LI CLASS="li-itemize">Escaping already way too special-character-sensitive shell code with
invisible tabs and backslashes is a dangerously fun game.
</LI></UL><P>
We also have bad reasons for not using an OCaml script to drive everything:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Sys.command</TT> calls the <TT>/bin/sh</TT> anyway,
</LI><LI CLASS="li-itemize">Shell scripts can execute partial commands or commands with badly formed arguments.
</LI><LI CLASS="li-itemize">Shell scripts are more concise for expressing... shell scripts.
</LI></UL><P>
Anyway you are of course free to use a makefile or an OCaml script to call ocamlbuild.
Here is an example shell driver script:
</P><PRE>#!/bin/sh

set -e

TARGET=epoch
FLAGS="-libs unix,nums"
OCAMLBUILD=ocamlbuild

ocb()
{
  $OCAMLBUILD $FLAGS $*
}

rule() {
  case $1 in
    clean)  ocb -clean;;
    native) ocb $TARGET.native;;
    byte)   ocb $TARGET.byte;;
    all)    ocb $TARGET.native $TARGET.byte;;
    depend) echo "Not needed.";;
    *)      echo "Unknown action $1";;
  esac;
}

if [ $# -eq 0 ]; then
  rule all
else
  while [ $# -gt 0 ]; do
    rule $1;
    shift
  done
fi
</PRE><!--TOC section Appendix: Motivations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc246">18.4</A>&#XA0;&#XA0;Appendix: Motivations</H2><!--SEC END --><P>
<EM>This inflammatory appendix describes the frustration that led us to write <TT>ocamlbuild</TT>.</EM></P><P>Many people have painfully found that the utilities of the <TT>make</TT>
family, namely GNU Make, BSD Make, and their derivatives, fail to scale to
large projects, especially when using multi-stage compilation rules, such as
custom pre-processors, unless dependencies are hand-defined. But as your
project gets larger, more modular, and uses more diverse pre-processing tools,
it becomes increasingly difficult to correctly define dependencies by hand.
Hence people tend to use language-specific tools that attempt to extract
dependencies. However another problem then appears: <TT>make</TT> was designed
with the idea of a static dependency graph. Dependency extracting tools,
however, are typically run by a rule in <TT>make</TT> itself; this means that
make has to reload the dependency information. This is the origin of the
<TT>make clean; make depend; make</TT> mantra. This approach tends to work
quite well as long as all the files sit in a single directory and there is only
one stage of pre-processing. If there are two or more stages, then dependency
extracting tools must be run two or more times - and this means multiple
invocations of <TT>make</TT>. Also, if one distributes the modules of a large
project into multiple subdirectories, it becomes difficult to distribute the
makefiles themselves, because the language of <TT>make</TT> was not conceived
to be modular; the only two mechanisms permitted, inclusion of makefile
fragments, and invocation of other make instances, must be skillfully
coordinated with phony target names (<TT>depend1, depend2...</TT>) to insure
inclusion of generated dependencies with multi-stage programming; changes in
the structure of the project must be reflected by hand and the order of
variable definitions must be well-thought ahead to avoid long afternoons spent
combinatorially fiddling makefiles until it works but no one understands why.</P><P>These problems become especially apparent with OCaml: to ensure type safety and
to allow a small amount of cross-unit optimization when compiling native code,
interface and object files include cryptographical digests of interfaces they
are to be linked with. This means that linking is safer, but that makefile sloppiness
leads to messages such as:
</P><PRE>Files foo.cmo and bar.cmo
make inconsistent assumptions over interface Bar
</PRE><P>
The typical reaction is then to issue the mantra <TT>make clean; make
depend; make</TT> and everything compiles just fine... from the beginning. Hence
on medium projects, the programmer often has to wait for minutes instead of the
few seconds that would be taken if <TT>make</TT> could correctly guess the
small number of files that really had to be recompiled.</P><P>It is not surprising that hacking a build tool such as <TT>make</TT> to include
a programming language while retaining the original syntax and semantics gives
an improvised and cumbersome macro language of dubious expressive power. For
example, using GNU make, suppose you have a list of <TT>.ml</TT>s that you want
to convert into a list including both <TT>.cmo</TT>s and <TT>.cmi</TT>s, that
is you want to transform <TT>a.ml b.ml c.ml</TT> into <TT>a.cmi a.cmo b.cmi
b.cmo c.cmi c.cmo</TT> while preserving the dependency order which must be hand
specified for linking <SUP><A NAME="text4" HREF="#note4">2</A></SUP>.
Unfortunately <TT>$patsubst %.ml, %.cmi %.cmo, a.ml b.ml c.ml</TT> won&#X2019;t
work since the %-sign in the right-hand of a <TT>patsubst</TT> gets
substituted only once. You then have to delve into something that is hardly
lambda calculus: an intricate network of <TT>foreach</TT>, <TT>eval</TT>,
<TT>call</TT> and <TT>define</TT>s may get you the job done, unless you chicken
out and opt for an external <TT>awk</TT>, <TT>sed</TT> or <TT>perl</TT> call.
People who at this point have not lost their temper or sanity usually resort to
metaprogramming by writing Makefile generators using a mixture of shell and m4.
One such an attempt gave something that is the nightmare of wannabe package
maintainers: it&#X2019;s called <TT>autotools</TT>.</P><P>Note that it is also difficult to write <TT>Makefiles</TT> to build object
files in a separate directory. It is not impossible since the language of
<TT>make</TT> is Turing-complete, a proof of which is left as an exercise.
Note that building things in a separate directory is not necessarily a young
enthusiast&#X2019;s way of giving a different look and feel to his projects &#X2013; it may
be a good way of telling the computer that <TT>foo.mli</TT> is generated by
<TT>ocamlyacc</TT> using <TT>foo.mly</TT> and can thus be removed.
</P><!--TOC section Appendix: Summary of default rules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc247">18.5</A>&#XA0;&#XA0;Appendix: Summary of default rules</H2><!--SEC END --><P>
The contents of this table give a summary of the most important default rules.
To get the most accurate and up-to-date information, launch <TT>ocamlbuild</TT> with the
<TT>-documentation</TT> option.
</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Tags</B></TD><TD VALIGN=top ALIGN=left NOWRAP><B>Dependencies</B></TD><TD VALIGN=top ALIGN=left><B>Targets</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.itarget</TD><TD VALIGN=top ALIGN=left>%.otarget</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mli %.mli.depends</TD><TD VALIGN=top ALIGN=left>%.cmi</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, debug, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mlpack %.cmi</TD><TD VALIGN=top ALIGN=left>%.d.cmo</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mlpack</TD><TD VALIGN=top ALIGN=left>%.cmo %.cmi</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mli %.ml %.ml.depends %.cmi</TD><TD VALIGN=top ALIGN=left>%.d.cmo</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mli %.ml %.ml.depends %.cmi</TD><TD VALIGN=top ALIGN=left>%.cmo</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml, profile</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mlpack %.cmi</TD><TD VALIGN=top ALIGN=left>%.p.cmx %.p.o</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mlpack %.cmi</TD><TD VALIGN=top ALIGN=left>%.cmx %.o</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml, profile</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml %.ml.depends %.cmi</TD><TD VALIGN=top ALIGN=left>%.p.cmx %.p.o</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml %.ml.depends %.cmi</TD><TD VALIGN=top ALIGN=left>%.cmx %.o</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> debug, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml %.ml.depends %.cmi</TD><TD VALIGN=top ALIGN=left>%.d.cmo</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml %.ml.depends</TD><TD VALIGN=top ALIGN=left>%.cmo %.cmi</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, debug, ocaml, program</TD><TD VALIGN=top ALIGN=left NOWRAP>%.d.cmo</TD><TD VALIGN=top ALIGN=left>%.d.byte</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, ocaml, program</TD><TD VALIGN=top ALIGN=left NOWRAP>%.cmo</TD><TD VALIGN=top ALIGN=left>%.byte</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml, profile, program</TD><TD VALIGN=top ALIGN=left NOWRAP>%.p.cmx %.p.o</TD><TD VALIGN=top ALIGN=left>%.p.native</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> native, ocaml, program</TD><TD VALIGN=top ALIGN=left NOWRAP>%.cmx %.o</TD><TD VALIGN=top ALIGN=left>%.native</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, debug, library, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mllib</TD><TD VALIGN=top ALIGN=left>%.d.cma</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, library, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mllib</TD><TD VALIGN=top ALIGN=left>%.cma</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, debug, library, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.d.cmo</TD><TD VALIGN=top ALIGN=left>%.d.cma</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> byte, library, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.cmo</TD><TD VALIGN=top ALIGN=left>%.cma</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>lib%(libname).clib</TD><TD VALIGN=top ALIGN=left>lib%(libname).a dll%(libname).so</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%(path)/lib%(libname).clib</TD><TD VALIGN=top ALIGN=left>%(path)/lib%(libname).a %(path)/dll%(libname).so</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> library, native, ocaml, profile</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mllib</TD><TD VALIGN=top ALIGN=left>%.p.cmxa %.p.a</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> library, native, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mllib</TD><TD VALIGN=top ALIGN=left>%.cmxa %.a</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> library, native, ocaml, profile</TD><TD VALIGN=top ALIGN=left NOWRAP>%.p.cmx %.p.o</TD><TD VALIGN=top ALIGN=left>%.p.cmxa %.p.a</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> library, native, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.cmx %.o</TD><TD VALIGN=top ALIGN=left>%.cmxa %.a</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml</TD><TD VALIGN=top ALIGN=left>%.ml.depends</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mli</TD><TD VALIGN=top ALIGN=left>%.mli.depends</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mll</TD><TD VALIGN=top ALIGN=left>%.ml</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> doc, ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mli %.mli.depends</TD><TD VALIGN=top ALIGN=left>%.odoc</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.odocl</TD><TD VALIGN=top ALIGN=left>%.docdir/index.html</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> ocaml</TD><TD VALIGN=top ALIGN=left NOWRAP>%.mly</TD><TD VALIGN=top ALIGN=left>%.ml %.mli</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.c</TD><TD VALIGN=top ALIGN=left>%.o</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>%.ml %.ml.depends</TD><TD VALIGN=top ALIGN=left>%.inferred.mli</TD></TR>
</TABLE>
</DIV><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note3" HREF="#text3">1</A></DT><DD CLASS="dd-thefootnotes">The command must not contain newlines or parentheses.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">2</A></DT><DD CLASS="dd-thefootnotes">By the way, what&#X2019;s the point of having a
declarative language if <TT>make</TT> can&#X2019;t sort the dependencies in
topological order for giving them to <TT>gcc</TT> or whatever ?
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Interfacing C with OCaml-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc248">Chapter&#XA0;19</A>&#XA0;&#XA0;Interfacing<A NAME="c:intf-c"></A> C with OCaml</H1><!--SEC END --><P>This chapter describes how user-defined primitives, written in C, can
be linked with OCaml code and called from OCaml functions.</P><!--TOC section Overview and compilation information-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc249">19.1</A>&#XA0;&#XA0;Overview and compilation information</H2><!--SEC END --><!--TOC subsection Declaring primitives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc250">19.1.1</A>&#XA0;&#XA0;Declaring primitives</H3><!--SEC END --><P>
User primitives are declared in an implementation file or
<TT>struct</TT>&#X2026;<TT>end</TT> module expression using the <TT>external</TT> keyword:
</P><PRE>
        external <I>name</I> : <I>type</I> = <I>C-function-name</I>
</PRE><P>
This defines the value name <I>name</I> as a function with type
<I>type</I> that executes by calling the given C function.
For instance, here is how the <TT>input</TT> primitive is declared in the
standard library module <TT>Pervasives</TT>:
</P><PRE>        external input : in_channel -&gt; string -&gt; int -&gt; int -&gt; int
                       = "input"
</PRE><P>Primitives with several arguments are always curried. The C function
does not necessarily have the same name as the ML function.</P><P>External functions thus defined can be specified in interface files or
<TT>sig</TT>&#X2026;<TT>end</TT> signatures either as regular values
</P><PRE>
        val <I>name</I> : <I>type</I>
</PRE><P>
thus hiding their implementation as a C function, or explicitly as
&#X201C;manifest&#X201D; external functions
</P><PRE>
        external <I>name</I> : <I>type</I> = <I>C-function-name</I>
</PRE><P>
The latter is slightly more efficient, as it allows clients of the
module to call directly the C function instead of going through the
corresponding OCaml function.</P><P>The arity (number of arguments) of a primitive is automatically
determined from its OCaml type in the <TT>external</TT> declaration, by
counting the number of function arrows in the type. For instance,
<TT>input</TT> above has arity 4, and the <TT>input</TT> C function is called with
four arguments. Similarly,
</P><PRE>    external input2 : in_channel * string * int * int -&gt; int = "input2"
</PRE><P>has arity 1, and the <TT>input2</TT> C function receives one argument (which
is a quadruple of OCaml values).</P><P>Type abbreviations are not expanded when determining the arity of a
primitive. For instance,
</P><PRE>        type int_endo = int -&gt; int
        external f : int_endo -&gt; int_endo = "f"
        external g : (int -&gt; int) -&gt; (int -&gt; int) = "f"
</PRE><P><TT>f</TT> has arity 1, but <TT>g</TT> has arity 2. This allows a primitive to
return a functional value (as in the <TT>f</TT> example above): just remember
to name the functional return type in a type abbreviation.</P><!--TOC subsection Implementing primitives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc251">19.1.2</A>&#XA0;&#XA0;Implementing primitives</H3><!--SEC END --><P>User primitives with arity <I>n</I> &#X2264; 5 are implemented by C functions
that take <I>n</I> arguments of type <TT>value</TT>, and return a result of type
<TT>value</TT>. The type <TT>value</TT> is the type of the representations for OCaml
values. It encodes objects of several base types (integers,
floating-point numbers, strings, &#X2026;), as well as OCaml data
structures. The type <TT>value</TT> and the associated conversion
functions and macros are described in details below. For instance,
here is the declaration for the C function implementing the <TT>input</TT>
primitive:
</P><PRE>CAMLprim value input(value channel, value buffer, value offset, value length)
{
  ...
}
</PRE><P>When the primitive function is applied in an OCaml program, the C
function is called with the values of the expressions to which the
primitive is applied as arguments. The value returned by the function is
passed back to the OCaml program as the result of the function
application.</P><P>User primitives with arity greater than 5 should be implemented by two
C functions. The first function, to be used in conjunction with the
bytecode compiler <TT>ocamlc</TT>, receives two arguments: a pointer to an
array of OCaml values (the values for the arguments), and an
integer which is the number of arguments provided. The other function,
to be used in conjunction with the native-code compiler <TT>ocamlopt</TT>,
takes its arguments directly. For instance, here are the two C
functions for the 7-argument primitive <TT>Nat.add_nat</TT>:
</P><PRE>CAMLprim value add_nat_native(value nat1, value ofs1, value len1,
                              value nat2, value ofs2, value len2,
                              value carry_in)
{
  ...
}
CAMLprim value add_nat_bytecode(value * argv, int argn)
{
  return add_nat_native(argv[0], argv[1], argv[2], argv[3],
                        argv[4], argv[5], argv[6]);
}
</PRE><P>The names of the two C functions must be given in the primitive
declaration, as follows:
</P><PRE>
        external <I>name</I> : <I>type</I> =
                 <I>bytecode-C-function-name native-code-C-function-name</I>
</PRE><P>
For instance, in the case of <TT>add_nat</TT>, the declaration is:
</P><PRE>        external add_nat: nat -&gt; int -&gt; int -&gt; nat -&gt; int -&gt; int -&gt; int -&gt; int
                        = "add_nat_bytecode" "add_nat_native"
</PRE><P>
Implementing a user primitive is actually two separate tasks: on the
one hand, decoding the arguments to extract C values from the given
OCaml values, and encoding the return value as an OCaml
value; on the other hand, actually computing the result from the arguments.
Except for very simple primitives, it is often preferable to have two
distinct C functions to implement these two tasks. The first function
actually implements the primitive, taking native C values as
arguments and returning a native C value. The second function,
often called the &#X201C;stub code&#X201D;, is a simple wrapper around the first
function that converts its arguments from OCaml values to C values,
call the first function, and convert the returned C value to OCaml
value. For instance, here is the stub code for the <TT>input</TT>
primitive:
</P><PRE>CAMLprim value input(value channel, value buffer, value offset, value length)
{
  return Val_long(getblock((struct channel *) channel,
                           &amp;Byte(buffer, Long_val(offset)),
                           Long_val(length)));
}
</PRE><P>(Here, <TT>Val_long</TT>, <TT>Long_val</TT> and so on are conversion macros for the
type <TT>value</TT>, that will be described later. The <TT>CAMLprim</TT> macro
expands to the required compiler directives to ensure that the
function following it is exported and accessible from OCaml.)
The hard work is performed by the function <TT>getblock</TT>, which is
declared as:
</P><PRE>long getblock(struct channel * channel, char * p, long n)
{
  ...
}
</PRE><P>
To write C code that operates on OCaml values, the following
include files are provided:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Include file</B></TD><TD ALIGN=center NOWRAP><B>Provides</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>caml/mlvalues.h</TT></TD><TD VALIGN=top ALIGN=left>definition of the <TT>value</TT> type, and conversion macros</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/alloc.h</TT></TD><TD VALIGN=top ALIGN=left>allocation functions (to create structured OCaml
objects)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/memory.h</TT></TD><TD VALIGN=top ALIGN=left>miscellaneous memory-related functions
and macros (for GC interface, in-place modification of structures, etc).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/fail.h</TT></TD><TD VALIGN=top ALIGN=left>functions for raising exceptions
(see section&#XA0;<A HREF="#s:c-exceptions">19.4.5</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/callback.h</TT></TD><TD VALIGN=top ALIGN=left>callback from C to OCaml (see
section&#XA0;<A HREF="#s:callback">19.7</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/custom.h</TT></TD><TD VALIGN=top ALIGN=left>operations on custom blocks (see
section&#XA0;<A HREF="#s:custom">19.9</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/intext.h</TT></TD><TD VALIGN=top ALIGN=left>operations for writing user-defined
serialization and deserialization functions for custom blocks
(see section&#XA0;<A HREF="#s:custom">19.9</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/threads.h</TT></TD><TD VALIGN=top ALIGN=left>operations for interfacing in the presence
of multiple threads (see section&#XA0;<A HREF="#s:C-multithreading">19.10</A>).</TD></TR>
</TABLE></DIV><P>
These files reside in the <TT>caml/</TT> subdirectory of the OCaml
standard library directory (usually <TT>/usr/local/lib/ocaml</TT>).</P><!--TOC subsection Statically linking C code with OCaml code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc252">19.1.3</A>&#XA0;&#XA0;Statically linking C code with OCaml code</H3><!--SEC END --><P>
<A NAME="staticlink-c-code"></A></P><P>The OCaml runtime system comprises three main parts: the bytecode
interpreter, the memory manager, and a set of C functions that
implement the primitive operations. Some bytecode instructions are
provided to call these C functions, designated by their offset in a
table of functions (the table of primitives).</P><P>In the default mode, the OCaml linker produces bytecode for the
standard runtime system, with a standard set of primitives. References
to primitives that are not in this standard set result in the
&#X201C;unavailable C primitive&#X201D; error. (Unless dynamic loading of C
libraries is supported &#X2013; see section&#XA0;<A HREF="#dynlink-c-code">19.1.4</A> below.)</P><P>In the &#X201C;custom runtime&#X201D; mode, the OCaml linker scans the
object files and determines the set of required primitives. Then, it
builds a suitable runtime system, by calling the native code linker with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the table of the required primitives;
</LI><LI CLASS="li-itemize">a library that provides the bytecode interpreter, the
memory manager, and the standard primitives;
</LI><LI CLASS="li-itemize">libraries and object code files (<TT>.o</TT> files) mentioned on the
command line for the OCaml linker, that provide implementations
for the user&#X2019;s primitives.
</LI></UL><P>
This builds a runtime system with the required primitives. The OCaml
linker generates bytecode for this custom runtime system. The
bytecode is appended to the end of the custom runtime system, so that
it will be automatically executed when the output file (custom
runtime + bytecode) is launched.</P><P>To link in &#X201C;custom runtime&#X201D; mode, execute the <TT>ocamlc</TT> command with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the <TT>-custom</TT> option;
</LI><LI CLASS="li-itemize">the names of the desired OCaml object files (<TT>.cmo</TT> and <TT>.cma</TT> files) ;
</LI><LI CLASS="li-itemize">the names of the C object files and libraries (<TT>.o</TT> and <TT>.a</TT>
files) that implement the required primitives. Under Unix and Windows,
a library named <TT>lib</TT><I>name</I><TT>.a</TT> (respectively, <TT>.lib</TT>) residing in one of the standard library directories can also be specified as <TT>-cclib -l</TT><I>name</I>.
</LI></UL><P>If you are using the native-code compiler <TT>ocamlopt</TT>, the <TT>-custom</TT>
flag is not needed, as the final linking phase of <TT>ocamlopt</TT> always
builds a standalone executable. To build a mixed OCaml/C executable,
execute the <TT>ocamlopt</TT> command with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the names of the desired OCaml native object files (<TT>.cmx</TT> and
<TT>.cmxa</TT> files);
</LI><LI CLASS="li-itemize">the names of the C object files and libraries (<TT>.o</TT>, <TT>.a</TT>,
<TT>.so</TT> or <TT>.dll</TT> files) that implement the required primitives.
</LI></UL><P>Starting with Objective Caml 3.00, it is possible to record the
<TT>-custom</TT> option as well as the names of C libraries in an OCaml
library file <TT>.cma</TT> or <TT>.cmxa</TT>. For instance, consider an OCaml library
<TT>mylib.cma</TT>, built from the OCaml object files <TT>a.cmo</TT> and <TT>b.cmo</TT>,
which reference C code in <TT>libmylib.a</TT>. If the library is
built as follows:
</P><PRE>
        ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</PRE><P>
users of the library can simply link with <TT>mylib.cma</TT>:
</P><PRE>
        ocamlc -o myprog mylib.cma ...
</PRE><P>
and the system will automatically add the <TT>-custom</TT> and <TT>-cclib -lmylib</TT> options, achieving the same effect as
</P><PRE>
        ocamlc -o myprog -custom a.cmo b.cmo ... -cclib -lmylib
</PRE><P>
The alternative, of course, is to build the library without extra
options:
</P><PRE>
        ocamlc -a -o mylib.cma a.cmo b.cmo
</PRE><P>
and then ask users to provide the <TT>-custom</TT> and <TT>-cclib -lmylib</TT>
options themselves at link-time:
</P><PRE>
        ocamlc -o myprog -custom mylib.cma ... -cclib -lmylib
</PRE><P>
The former alternative is more convenient for the final users of the
library, however.</P><!--TOC subsection Dynamically linking C code with OCaml code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc253">19.1.4</A>&#XA0;&#XA0;Dynamically linking C code with OCaml code</H3><!--SEC END --><P>
<A NAME="dynlink-c-code"></A></P><P>Starting with Objective Caml 3.03, an alternative to static linking of C code
using the <TT>-custom</TT> code is provided. In this mode, the OCaml linker
generates a pure bytecode executable (no embedded custom runtime
system) that simply records the names of dynamically-loaded libraries
containing the C code. The standard OCaml runtime system <TT>ocamlrun</TT>
then loads dynamically these libraries, and resolves references to the
required primitives, before executing the bytecode.</P><P>This facility is currently supported and known to work well under
Linux, MacOS&#XA0;X, and Windows. It is supported, but not
fully tested yet, under FreeBSD, Tru64, Solaris and Irix. It is not
supported yet under other Unixes.</P><P>To dynamically link C code with OCaml code, the C code must first be
compiled into a shared library (under Unix) or DLL (under Windows).
This involves 1- compiling the C files with appropriate C compiler
flags for producing position-independent code (when required by the
operating system), and 2- building a
shared library from the resulting object files. The resulting shared
library or DLL file must be installed in a place where <TT>ocamlrun</TT> can
find it later at program start-up time (see
section&#XA0;<A HREF="#s-ocamlrun-dllpath">10.3</A>).
Finally (step 3), execute the <TT>ocamlc</TT> command with
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the names of the desired OCaml object files (<TT>.cmo</TT> and <TT>.cma</TT> files) ;
</LI><LI CLASS="li-itemize">the names of the C shared libraries (<TT>.so</TT> or <TT>.dll</TT> files) that
implement the required primitives. Under Unix and Windows,
a library named <TT>dll</TT><I>name</I><TT>.so</TT> (respectively, <TT>.dll</TT>) residing
in one of the standard library directories can also be specified as
<TT>-dllib -l</TT><I>name</I>.
</LI></UL><P>
Do <EM>not</EM> set the <TT>-custom</TT> flag, otherwise you&#X2019;re back to static linking
as described in section&#XA0;<A HREF="#staticlink-c-code">19.1.3</A>.
The <TT>ocamlmklib</TT> tool (see section&#XA0;<A HREF="#s-ocamlmklib">19.11</A>)
automates steps 2 and 3.</P><P>As in the case of static linking, it is possible (and recommended) to
record the names of C libraries in an OCaml <TT>.cma</TT> library archive.
Consider again an OCaml library
<TT>mylib.cma</TT>, built from the OCaml object files <TT>a.cmo</TT> and <TT>b.cmo</TT>,
which reference C code in <TT>dllmylib.so</TT>. If the library is
built as follows:
</P><PRE>
        ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</PRE><P>
users of the library can simply link with <TT>mylib.cma</TT>:
</P><PRE>
        ocamlc -o myprog mylib.cma ...
</PRE><P>
and the system will automatically add the <TT>-dllib -lmylib</TT> option,
achieving the same effect as
</P><PRE>
        ocamlc -o myprog a.cmo b.cmo ... -dllib -lmylib
</PRE><P>
Using this mechanism, users of the library <TT>mylib.cma</TT> do not need to
known that it references C code, nor whether this C code must be
statically linked (using <TT>-custom</TT>) or dynamically linked.</P><!--TOC subsection Choosing between static linking and dynamic linking-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc254">19.1.5</A>&#XA0;&#XA0;Choosing between static linking and dynamic linking</H3><!--SEC END --><P>After having described two different ways of linking C code with OCaml
code, we now review the pros and cons of each, to help developers of
mixed OCaml/C libraries decide.</P><P>The main advantage of dynamic linking is that it preserves the
platform-independence of bytecode executables. That is, the bytecode
executable contains no machine code, and can therefore be compiled on
platform <I>A</I> and executed on other platforms <I>B</I>, <I>C</I>, &#X2026;, as long
as the required shared libraries are available on all these
platforms. In contrast, executables generated by <TT>ocamlc -custom</TT> run
only on the platform on which they were created, because they embark a
custom-tailored runtime system specific to that platform. In
addition, dynamic linking results in smaller executables.</P><P>Another advantage of dynamic linking is that the final users of the
library do not need to have a C compiler, C linker, and C runtime
libraries installed on their machines. This is no big deal under
Unix and Cygwin, but many Windows users are reluctant to install
Microsoft Visual C just to be able to do <TT>ocamlc -custom</TT>.</P><P>There are two drawbacks to dynamic linking. The first is that the
resulting executable is not stand-alone: it requires the shared
libraries, as well as <TT>ocamlrun</TT>, to be installed on the machine
executing the code. If you wish to distribute a stand-alone
executable, it is better to link it statically, using <TT>ocamlc -custom -ccopt -static</TT> or <TT>ocamlopt -ccopt -static</TT>. Dynamic linking also
raises the &#X201C;DLL hell&#X201D; problem: some care must be taken to ensure
that the right versions of the shared libraries are found at start-up
time.</P><P>The second drawback of dynamic linking is that it complicates the
construction of the library. The C compiler and linker flags to
compile to position-independent code and build a shared library vary
wildly between different Unix systems. Also, dynamic linking is not
supported on all Unix systems, requiring a fall-back case to static
linking in the Makefile for the library. The <TT>ocamlmklib</TT> command
(see section&#XA0;<A HREF="#s-ocamlmklib">19.11</A>) tries to hide some of these system
dependencies.</P><P>In conclusion: dynamic linking is highly recommended under the native
Windows port, because there are no portability problems and it is much
more convenient for the end users. Under Unix, dynamic linking should
be considered for mature, frequently used libraries because it
enhances platform-independence of bytecode executables. For new or
rarely-used libraries, static linking is much simpler to set up in a
portable way.</P><!--TOC subsection Building standalone custom runtime systems-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc255">19.1.6</A>&#XA0;&#XA0;Building standalone custom runtime systems</H3><!--SEC END --><P>
<A NAME="s:custom-runtime"></A></P><P>It is sometimes inconvenient to build a custom runtime system each
time OCaml code is linked with C libraries, like <TT>ocamlc -custom</TT> does.
For one thing, the building of the runtime system is slow on some
systems (that have bad linkers or slow remote file systems); for
another thing, the platform-independence of bytecode files is lost,
forcing to perform one <TT>ocamlc -custom</TT> link per platform of interest.</P><P>An alternative to <TT>ocamlc -custom</TT> is to build separately a custom
runtime system integrating the desired C libraries, then generate
&#X201C;pure&#X201D; bytecode executables (not containing their own runtime
system) that can run on this custom runtime. This is achieved by the
<TT>-make_runtime</TT> and <TT>-use_runtime</TT> flags to <TT>ocamlc</TT>. For example,
to build a custom runtime system integrating the C parts of the
&#X201C;Unix&#X201D; and &#X201C;Threads&#X201D; libraries, do:
</P><PRE>        ocamlc -make-runtime -o /home/me/ocamlunixrun unix.cma threads.cma
</PRE><P>To generate a bytecode executable that runs on this runtime system,
do:
</P><PRE>
        ocamlc -use-runtime /home/me/ocamlunixrun -o myprog \
                unix.cma threads.cma <I>your .cmo and .cma files</I>
</PRE><P>
The bytecode executable <TT>myprog</TT> can then be launched as usual:
<TT>myprog</TT> <I>args</I> or <TT>/home/me/ocamlunixrun myprog</TT> <I>args</I>.</P><P>Notice that the bytecode libraries <TT>unix.cma</TT> and <TT>threads.cma</TT> must
be given twice: when building the runtime system (so that <TT>ocamlc</TT>
knows which C primitives are required) and also when building the
bytecode executable (so that the bytecode from <TT>unix.cma</TT> and
<TT>threads.cma</TT> is actually linked in).</P><!--TOC section The <TT>value</TT> type-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc256">19.2</A>&#XA0;&#XA0;The <TT>value</TT> type</H2><!--SEC END --><P>All OCaml objects are represented by the C type <TT>value</TT>,
defined in the include file <TT>caml/mlvalues.h</TT>, along with macros to
manipulate values of that type. An object of type <TT>value</TT> is either:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
an unboxed integer;
</LI><LI CLASS="li-itemize">a pointer to a block inside the heap (such as the blocks
allocated through one of the <CODE>caml_alloc_*</CODE> functions below);
</LI><LI CLASS="li-itemize">a pointer to an object outside the heap (e.g., a pointer to a block
allocated by <TT>malloc</TT>, or to a C variable).
</LI></UL><!--TOC subsection Integer values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc257">19.2.1</A>&#XA0;&#XA0;Integer values</H3><!--SEC END --><P>Integer values encode 31-bit signed integers (63-bit on 64-bit
architectures). They are unboxed (unallocated).</P><!--TOC subsection Blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc258">19.2.2</A>&#XA0;&#XA0;Blocks</H3><!--SEC END --><P>Blocks in the heap are garbage-collected, and therefore have strict
structure constraints. Each block includes a header containing the
size of the block (in words), and the tag of the block.
The tag governs how the contents of the blocks are structured. A tag
lower than <TT>No_scan_tag</TT> indicates a structured block, containing
well-formed values, which is recursively traversed by the garbage
collector. A tag greater than or equal to <TT>No_scan_tag</TT> indicates a
raw block, whose contents are not scanned by the garbage collector.
For the benefits of ad-hoc polymorphic primitives such as equality and
structured input-output, structured and raw blocks are further
classified according to their tags as follows:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Tag</B></TD><TD ALIGN=center NOWRAP><B>Contents of the block</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
0 to <TT>No_scan_tag</TT>&#X2212;1</TD><TD VALIGN=top ALIGN=left>A structured block (an array of
OCaml objects). Each field is a <TT>value</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Closure_tag</TT></TD><TD VALIGN=top ALIGN=left>A closure representing a functional value. The first
word is a pointer to a piece of code, the remaining words are
<TT>value</TT> containing the environment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>String_tag</TT></TD><TD VALIGN=top ALIGN=left>A character string.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Double_tag</TT></TD><TD VALIGN=top ALIGN=left>A double-precision floating-point number.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Double_array_tag</TT></TD><TD VALIGN=top ALIGN=left>An array or record of double-precision
floating-point numbers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Abstract_tag</TT></TD><TD VALIGN=top ALIGN=left>A block representing an abstract datatype.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Custom_tag</TT></TD><TD VALIGN=top ALIGN=left>A block representing an abstract datatype
with user-defined finalization, comparison, hashing,
serialization and deserialization functions atttached.</TD></TR>
</TABLE></DIV><!--TOC subsection Pointers outside the heap-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc259">19.2.3</A>&#XA0;&#XA0;Pointers outside the heap</H3><!--SEC END --><P>Any word-aligned pointer to an address outside the heap can be safely
cast to and from the type <TT>value</TT>. This includes pointers returned by
<TT>malloc</TT>, and pointers to C variables (of size at least one word)
obtained with the <CODE>&amp;</CODE> operator.</P><P>Caution: if a pointer returned by <TT>malloc</TT> is cast to the type <TT>value</TT>
and returned to OCaml, explicit deallocation of the pointer using
<TT>free</TT> is potentially dangerous, because the pointer may still be
accessible from the OCaml world. Worse, the memory space deallocated
by <TT>free</TT> can later be reallocated as part of the OCaml heap; the
pointer, formerly pointing outside the OCaml heap, now points inside
the OCaml heap, and this can confuse the garbage collector. To avoid
these problems, it is preferable to wrap the pointer in a OCaml block
with tag <TT>Abstract_tag</TT> or <TT>Custom_tag</TT>.</P><!--TOC section Representation of OCaml data types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc260">19.3</A>&#XA0;&#XA0;Representation of OCaml data types</H2><!--SEC END --><P>This section describes how OCaml data types are encoded in the
<TT>value</TT> type.</P><!--TOC subsection Atomic types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc261">19.3.1</A>&#XA0;&#XA0;Atomic types</H3><!--SEC END --><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>OCaml type</B></TD><TD ALIGN=center NOWRAP><B>Encoding</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>int</TT></TD><TD ALIGN=left NOWRAP>Unboxed integer values.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>char</TT></TD><TD ALIGN=left NOWRAP>Unboxed integer values (ASCII code).</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>float</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Double_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>string</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>String_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>int32</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>int64</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>nativeint</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
</TABLE></DIV><!--TOC subsection Tuples and records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc262">19.3.2</A>&#XA0;&#XA0;Tuples and records</H3><!--SEC END --><P>Tuples are represented by pointers to blocks, with tag&#XA0;0.</P><P>Records are also represented by zero-tagged blocks. The ordering of
labels in the record type declaration determines the layout of
the record fields: the value associated to the label
declared first is stored in field&#XA0;0 of the block, the value associated
to the label declared next goes in field&#XA0;1, and so on.</P><P>As an optimization, records whose fields all have static type <TT>float</TT>
are represented as arrays of floating-point numbers, with tag
<TT>Double_array_tag</TT>. (See the section below on arrays.)</P><!--TOC subsection Arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc263">19.3.3</A>&#XA0;&#XA0;Arrays</H3><!--SEC END --><P>Arrays of integers and pointers are represented like tuples,
that is, as pointers to blocks tagged&#XA0;0. They are accessed with the
<TT>Field</TT> macro for reading and the <TT>caml_modify</TT> function for writing.</P><P>Arrays of floating-point numbers (type <TT>float array</TT>)
have a special, unboxed, more efficient representation.
These arrays are represented by pointers to blocks with tag
<TT>Double_array_tag</TT>. They should be accessed with the <TT>Double_field</TT>
and <TT>Store_double_field</TT> macros.</P><!--TOC subsection Concrete data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc264">19.3.4</A>&#XA0;&#XA0;Concrete data types</H3><!--SEC END --><P>Constructed terms are represented either by unboxed integers (for
constant constructors) or by blocks whose tag encode the constructor
(for non-constant constructors). The constant constructors and the
non-constant constructors for a given concrete type are numbered
separately, starting from 0, in the order in which they appear in the
concrete type declaration. Constant constructors are represented by
unboxed integers equal to the constructor number. A non-constant
constructors declared with <I>n</I> arguments is represented by
a block of size <I>n</I>, tagged with the constructor number; the <I>n</I>
fields contain its arguments. Example:</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constructed term</B></TD><TD ALIGN=center NOWRAP><B>Representation</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>()</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>false</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>true</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(1)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>[]</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>h::t</TT></TD><TD VALIGN=top ALIGN=left>Block with size = 2 and tag = 0; first field
contains <TT>h</TT>, second field <TT>t</TT>.</TD></TR>
</TABLE></DIV><P>As a convenience, <TT>caml/mlvalues.h</TT> defines the macros <TT>Val_unit</TT>,
<TT>Val_false</TT> and <TT>Val_true</TT> to refer to <TT>()</TT>, <TT>false</TT> and <TT>true</TT>.</P><P>The following artificial example illustrates the assignment of
integers and block tags to constructors:
</P><PRE>type t =
  | A             (* First constant constructor -&gt; integer "Val_int(0)" *)
  | B of string   (* First non-constant constructor -&gt; block with tag 0 *)
  | C             (* Second constant constructor -&gt; integer "Val_int(1)" *)
  | D of bool     (* Second non-constant constructor -&gt; block with tag 1 *)
  | E of t * t    (* Third non-constant constructor -&gt; block with tag 2 *)
</PRE><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc265">19.3.5</A>&#XA0;&#XA0;Objects</H3><!--SEC END --><P>Objects are represented as blocks with tag <TT>Object_tag</TT>. The first
field of the block refers to the object class and associated method
suite, in a format that cannot easily be exploited from C. The second
field contains a unique object ID, used for comparisons. The remaining
fields of the object contain the values of the instance variables of
the object. It is unsafe to access directly instance variables, as the
type system provides no guaranteee about the instance variables
contained by an object.
</P><P>One may extract a public method from an object using the C function
<TT>caml_get_public_method</TT> (declared in <TT>&lt;caml/mlvalues.h&gt;</TT>.)
Since public method tags are hashed in the same way as variant tags,
and methods are functions taking self as first argument, if you want
to do the method call <TT>foo#bar</TT> from the C side, you should call:
</P><PRE>  callback(caml_get_public_method(foo, hash_variant("bar")), foo);
</PRE><!--TOC subsection Polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc266">19.3.6</A>&#XA0;&#XA0;Polymorphic variants</H3><!--SEC END --><P>Like constructed terms, polymorphic variant values are represented either
as integers (for polymorphic variants without arguments), or as blocks
(for polymorphic variants with an argument). Unlike constructed
terms, variant constructors are not numbered starting from 0, but
identified by a hash value (an OCaml integer), as computed by the C function
<TT>hash_variant</TT> (declared in <TT>&lt;caml/mlvalues.h&gt;</TT>):
the hash value for a variant constructor named, say, <TT>VConstr</TT>
is <TT>hash_variant("VConstr")</TT>.</P><P>The variant value <TT>`VConstr</TT> is represented by
<TT>hash_variant("VConstr")</TT>. The variant value <TT>`VConstr(</TT><I>v</I><TT>)</TT> is
represented by a block of size 2 and tag 0, with field number 0
containing <TT>hash_variant("VConstr")</TT> and field number 1 containing
<I>v</I>.</P><P>Unlike constructed values, polymorphic variant values taking several
arguments are not flattened.
That is, <TT>`VConstr(</TT><I>v</I><TT>, </TT><I>w</I><TT>)</TT> is represented by a block
of size 2, whose field number 1 contains the representation of the
pair <TT>(</TT><I>v</I><TT>, </TT><I>w</I><TT>)</TT>, rather than a block of size 3
containing <I>v</I> and <I>w</I> in fields 1 and 2.</P><!--TOC section Operations on values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc267">19.4</A>&#XA0;&#XA0;Operations on values</H2><!--SEC END --><!--TOC subsection Kind tests-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc268">19.4.1</A>&#XA0;&#XA0;Kind tests</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Is_long(</TT><I>v</I><TT>)</TT> is true if value <I>v</I> is an immediate integer,
false otherwise
</LI><LI CLASS="li-itemize"><TT>Is_block(</TT><I>v</I><TT>)</TT> is true if value <I>v</I> is a pointer to a block,
and false if it is an immediate integer.
</LI></UL><!--TOC subsection Operations on integers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc269">19.4.2</A>&#XA0;&#XA0;Operations on integers</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Val_long(</TT><I>l</I><TT>)</TT> returns the value encoding the <TT>long int</TT> <I>l</I>.
</LI><LI CLASS="li-itemize"><TT>Long_val(</TT><I>v</I><TT>)</TT> returns the <TT>long int</TT> encoded in value <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Val_int(</TT><I>i</I><TT>)</TT> returns the value encoding the <TT>int</TT> <I>i</I>.
</LI><LI CLASS="li-itemize"><TT>Int_val(</TT><I>v</I><TT>)</TT> returns the <TT>int</TT> encoded in value <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Val_bool(</TT><I>x</I><TT>)</TT> returns the OCaml boolean representing the
truth value of the C integer <I>x</I>.
</LI><LI CLASS="li-itemize"><TT>Bool_val(</TT><I>v</I><TT>)</TT> returns 0 if <I>v</I> is the OCaml boolean
<TT>false</TT>, 1 if <I>v</I> is <TT>true</TT>.
</LI><LI CLASS="li-itemize"><TT>Val_true</TT>, <TT>Val_false</TT> represent the OCaml booleans <TT>true</TT> and <TT>false</TT>.
</LI></UL><!--TOC subsection Accessing blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc270">19.4.3</A>&#XA0;&#XA0;Accessing blocks</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Wosize_val(</TT><I>v</I><TT>)</TT> returns the size of the block <I>v</I>, in words,
excluding the header.
</LI><LI CLASS="li-itemize"><TT>Tag_val(</TT><I>v</I><TT>)</TT> returns the tag of the block <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the value contained in the
<I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> field of the structured block <I>v</I>. Fields are numbered from 0 to
<TT>Wosize_val</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>Store_field(</TT><I>b</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT> stores the value
<I>v</I> in the field number <I>n</I> of value <I>b</I>, which must be a
structured block.
</LI><LI CLASS="li-itemize"><TT>Code_val(</TT><I>v</I><TT>)</TT> returns the code part of the closure <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>caml_string_length(</TT><I>v</I><TT>)</TT> returns the length (number of characters)
of the string <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Byte(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> character of the string
<I>v</I>, with type <TT>char</TT>. Characters are numbered from 0 to
<TT>string_length</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>Byte_u(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> character of the string
<I>v</I>, with type <TT>unsigned char</TT>. Characters are numbered from 0 to
<TT>string_length</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>String_val(</TT><I>v</I><TT>)</TT> returns a pointer to the first byte of the string
<I>v</I>, with type <TT>char *</TT>. This pointer is a valid C string: there is a
null character after the last character in the string. However, OCaml
strings can contain embedded null characters, that will confuse
the usual C functions over strings.
</LI><LI CLASS="li-itemize"><TT>Double_val(</TT><I>v</I><TT>)</TT> returns the floating-point number contained in
value <I>v</I>, with type <TT>double</TT>.
</LI><LI CLASS="li-itemize"><TT>Double_field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns
the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> element of the array of floating-point numbers <I>v</I> (a
block tagged <TT>Double_array_tag</TT>).
</LI><LI CLASS="li-itemize"><TT>Store_double_field(</TT><I>v</I><TT>, </TT><I>n</I><TT>, </TT><I>d</I><TT>)</TT> stores the double precision floating-point number <I>d</I>
in the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> element of the array of floating-point numbers <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Data_custom_val(</TT><I>v</I><TT>)</TT> returns a pointer to the data part
of the custom block <I>v</I>. This pointer has type <TT>void *</TT> and must
be cast to the type of the data contained in the custom block.
</LI><LI CLASS="li-itemize"><TT>Int32_val(</TT><I>v</I><TT>)</TT> returns the 32-bit integer contained
in the <TT>int32</TT> <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Int64_val(</TT><I>v</I><TT>)</TT> returns the 64-bit integer contained
in the <TT>int64</TT> <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Nativeint_val(</TT><I>v</I><TT>)</TT> returns the long integer contained
in the <TT>nativeint</TT> <I>v</I>.
</LI></UL><P>
The expressions <TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT>,
<TT>Byte(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> and
<TT>Byte_u(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT>
are valid l-values. Hence, they can be assigned to, resulting in an
in-place modification of value <I>v</I>.
Assigning directly to <TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> must
be done with care to avoid confusing the garbage collector (see
below).</P><!--TOC subsection Allocating blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc271">19.4.4</A>&#XA0;&#XA0;Allocating blocks</H3><!--SEC END --><!--TOC subsubsection Simple interface-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple interface</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Atom(</TT><I>t</I><TT>)</TT> returns an &#X201C;atom&#X201D; (zero-sized block) with tag <I>t</I>.
Zero-sized blocks are preallocated outside of the heap. It is
incorrect to try and allocate a zero-sized block using the functions below.
For instance, <TT>Atom(0)</TT> represents the empty array.
</LI><LI CLASS="li-itemize"><TT>caml_alloc(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh block of size <I>n</I>
with tag <I>t</I>. If <I>t</I> is less than <TT>No_scan_tag</TT>, then the
fields of the block are initialized with a valid value in order to
satisfy the GC constraints.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_tuple(</TT><I>n</I><TT>)</TT> returns a fresh block of size
<I>n</I> words, with tag 0.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_string(</TT><I>n</I><TT>)</TT> returns a string value of length <I>n</I> characters.
The string initially contains garbage.
</LI><LI CLASS="li-itemize"><TT>caml_copy_string(</TT><I>s</I><TT>)</TT> returns a string value containing a copy of
the null-terminated C string <I>s</I> (a <TT>char *</TT>).
</LI><LI CLASS="li-itemize"><TT>caml_copy_double(</TT><I>d</I><TT>)</TT> returns a floating-point value initialized
with the <TT>double</TT> <I>d</I>.
</LI><LI CLASS="li-itemize"><TT>caml_copy_int32(</TT><I>i</I><TT>)</TT>, <TT>copy_int64(</TT><I>i</I><TT>)</TT> and
<TT>caml_copy_nativeint(</TT><I>i</I><TT>)</TT> return a value of OCaml type <TT>int32</TT>,
<TT>int64</TT> and <TT>nativeint</TT>, respectively, initialized with the integer
<I>i</I>.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_array(</TT><I>f</I><TT>, </TT><I>a</I><TT>)</TT> allocates an array of values, calling
function <I>f</I> over each element of the input array <I>a</I> to transform it
into a value. The array <I>a</I> is an array of pointers terminated by the
null pointer. The function <I>f</I> receives each pointer as argument, and
returns a value. The zero-tagged block returned by
<TT>alloc_array(</TT><I>f</I><TT>, </TT><I>a</I><TT>)</TT> is filled with the values returned by the
successive calls to <I>f</I>. (This function must not be used to build
an array of floating-point numbers.)
</LI><LI CLASS="li-itemize"><TT>caml_copy_string_array(</TT><I>p</I><TT>)</TT> allocates an array of strings, copied from
the pointer to a string array <I>p</I> (a <CODE>char **</CODE>). <I>p</I> must
be NULL-terminated.
</LI></UL><!--TOC subsubsection Low-level interface-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Low-level interface</H4><!--SEC END --><P>The following functions are slightly more efficient than <TT>caml_alloc</TT>, but
also much more difficult to use.</P><P>From the standpoint of the allocation functions, blocks are divided
according to their size as zero-sized blocks, small blocks (with size
less than or equal to <CODE>Max_young_wosize</CODE>), and large blocks (with
size greater than <CODE>Max_young_wosize</CODE>). The constant
<CODE>Max_young_wosize</CODE> is declared in the include file <TT>mlvalues.h</TT>. It
is guaranteed to be at least 64 (words), so that any block with
constant size less than or equal to 64 can be assumed to be small. For
blocks whose size is computed at run-time, the size must be compared
against <CODE>Max_young_wosize</CODE> to determine the correct allocation procedure.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_alloc_small(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh small block of size
<I>n</I> &#X2264; <TT>Max_young_wosize</TT> words, with tag <I>t</I>.
If this block is a structured block (i.e. if <I>t</I> &lt; <TT>No_scan_tag</TT>), then
the fields of the block (initially containing garbage) must be initialized
with legal values (using direct assignment to the fields of the block)
before the next allocation.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_shr(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh block of size
<I>n</I>, with tag <I>t</I>.
The size of the block can be greater than <CODE>Max_young_wosize</CODE>. (It
can also be smaller, but in this case it is more efficient to call
<TT>caml_alloc_small</TT> instead of <TT>caml_alloc_shr</TT>.)
If this block is a structured block (i.e. if <I>t</I> &lt; <TT>No_scan_tag</TT>), then
the fields of the block (initially containing garbage) must be initialized
with legal values (using the <TT>caml_initialize</TT> function described below)
before the next allocation.
</LI></UL><!--TOC subsection Raising exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc272">19.4.5</A>&#XA0;&#XA0;Raising exceptions</H3><!--SEC END --><P> <A NAME="s:c-exceptions"></A></P><P>Two functions are provided to raise two standard exceptions:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_failwith(</TT><I>s</I><TT>)</TT>, where <I>s</I> is a null-terminated C string (with
type <CODE>char *</CODE>), raises exception <TT>Failure</TT> with argument <I>s</I>.
</LI><LI CLASS="li-itemize"><TT>caml_invalid_argument(</TT><I>s</I><TT>)</TT>, where <I>s</I> is a null-terminated C
string (with type <CODE>char *</CODE>), raises exception <TT>Invalid_argument</TT>
with argument <I>s</I>.
</LI></UL><P>Raising arbitrary exceptions from C is more delicate: the
exception identifier is dynamically allocated by the OCaml program, and
therefore must be communicated to the C function using the
registration facility described below in section&#XA0;<A HREF="#s:register-exn">19.7.3</A>.
Once the exception identifier is recovered in C, the following
functions actually raise the exception:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_raise_constant(</TT><I>id</I><TT>)</TT> raises the exception <I>id</I> with
no argument;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_arg(</TT><I>id</I><TT>, </TT><I>v</I><TT>)</TT> raises the exception
<I>id</I> with the OCaml value <I>v</I> as argument;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_args(</TT><I>id</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT>
raises the exception <I>id</I> with the OCaml values
<I>v</I><TT>[0]</TT>, &#X2026;, <I>v</I><TT>[</TT><I>n</I><TT>-1]</TT> as arguments;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_string(</TT><I>id</I><TT>, </TT><I>s</I><TT>)</TT>, where <I>s</I> is a
null-terminated C string, raises the exception <I>id</I> with a copy of
the C string <I>s</I> as argument.
</LI></UL><!--TOC section Living in harmony with the garbage collector-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc273">19.5</A>&#XA0;&#XA0;Living in harmony with the garbage collector</H2><!--SEC END --><P>Unused blocks in the heap are automatically reclaimed by the garbage
collector. This requires some cooperation from C code that
manipulates heap-allocated blocks.</P><!--TOC subsection Simple interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc274">19.5.1</A>&#XA0;&#XA0;Simple interface</H3><!--SEC END --><P>All the macros described in this section are declared in the
<TT>memory.h</TT> header file.</P><DIV CLASS="theorem"><B>Rule&#XA0;1</B>&#XA0;&#XA0;<EM>
A function that has parameters or local variables of type <TT>value</TT> must
begin with a call to one of the <TT>CAMLparam</TT> macros and return with
<TT>CAMLreturn</TT>, <TT>CAMLreturn0</TT>, or <TT>CAMLreturnT</TT>.
</EM></DIV><P>There are six <TT>CAMLparam</TT> macros: <TT>CAMLparam0</TT> to <TT>CAMLparam5</TT>, which
take zero to five arguments respectively. If your function has fewer
than 5 parameters of type <TT>value</TT>, use the corresponding macros
with these parameters as arguments. If your function has more than 5
parameters of type <TT>value</TT>, use <TT>CAMLparam5</TT> with five of these
parameters, and use one or more calls to the <TT>CAMLxparam</TT> macros for
the remaining parameters (<TT>CAMLxparam1</TT> to <TT>CAMLxparam5</TT>).</P><P>The macros <TT>CAMLreturn</TT>, <TT>CAMLreturn0</TT>, and <TT>CAMLreturnT</TT> are used to
replace the C
keyword <TT>return</TT>. Every occurence of <TT>return x</TT> must be replaced by
<TT>CAMLreturn (x)</TT> if <TT>x</TT> has type <TT>value</TT>, or <TT>CAMLreturnT (t, x)</TT>
(where <TT>t</TT> is the type of <TT>x</TT>); every occurence of <TT>return</TT> without
argument must be
replaced by <TT>CAMLreturn0</TT>. If your C function is a procedure (i.e. if
it returns void), you must insert <TT>CAMLreturn0</TT> at the end (to replace
C&#X2019;s implicit <TT>return</TT>).</P><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> some C compilers give bogus warnings about unused
variables <TT>caml__dummy_xxx</TT> at each use of <TT>CAMLparam</TT> and
<TT>CAMLlocal</TT>. You should ignore them.</P><P><BR>
</P><P>Example:
</P><PRE>void foo (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  ...
  CAMLreturn0;
}
</PRE><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> if your function is a primitive with more than 5 arguments
for use with the byte-code runtime, its arguments are not <TT>value</TT>s and
must not be declared (they have types <TT>value *</TT> and <TT>int</TT>).</P><DIV CLASS="theorem"><B>Rule&#XA0;2</B>&#XA0;&#XA0;<EM>
Local variables of type <TT>value</TT> must be declared with one of the
<TT>CAMLlocal</TT> macros. Arrays of <TT>value</TT>s are declared with
<TT>CAMLlocalN</TT>. These macros must be used at the beginning of the
function, not in a nested block.
</EM></DIV><P>The macros <TT>CAMLlocal1</TT> to <TT>CAMLlocal5</TT> declare and initialize one to
five local variables of type <TT>value</TT>. The variable names are given as
arguments to the macros. <TT>CAMLlocalN(</TT><I>x</I><TT>, </TT><I>n</I><TT>)</TT> declares
and initializes a local variable of type <TT>value [</TT><I>n</I><TT>]</TT>. You can
use several calls to these macros if you have more than 5 local
variables.</P><P>Example:
</P><PRE>value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  ...
  CAMLreturn (result);
}
</PRE><DIV CLASS="theorem"><B>Rule&#XA0;3</B>&#XA0;&#XA0;<EM>
Assignments to the fields of structured blocks must be done with the
<TT>Store_field</TT> macro (for normal blocks) or <TT>Store_double_field</TT> macro
(for arrays and records of floating-point numbers). Other assignments
must not use <TT>Store_field</TT> nor <TT>Store_double_field</TT>.
</EM></DIV><P><TT>Store_field (</TT><I>b</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT> stores the value
<I>v</I> in the field number <I>n</I> of value <I>b</I>, which must be a
block (i.e. <TT>Is_block(</TT><I>b</I><TT>)</TT> must be true).</P><P>Example:
</P><PRE>value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  Store_field (result, 0, v1);
  Store_field (result, 1, v2);
  Store_field (result, 2, v3);
  CAMLreturn (result);
}
</PRE><!--TOC paragraph Warning:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Warning:</H5><!--SEC END --><P> The first argument of <TT>Store_field</TT> and
<TT>Store_double_field</TT> must be a variable declared by <TT>CAMLparam*</TT> or
a parameter declared by <TT>CAMLlocal*</TT> to ensure that a garbage
collection triggered by the evaluation of the other arguments will not
invalidate the first argument after it is computed.</P><DIV CLASS="theorem"><B>Rule&#XA0;4</B>&#XA0;&#XA0;<EM> Global variables containing values must be registered
with the garbage collector using the <TT>caml_register_global_root</TT> function.
</EM></DIV><P>Registration of a global variable <TT>v</TT> is achieved by calling
<TT>caml_register_global_root(&amp;v)</TT> just before or just after a valid
value is stored in <TT>v</TT> for the first time. You must not call any
of the OCaml runtime functions or macros between registering and
storing the value.</P><P>A registered global variable <TT>v</TT> can be un-registered by calling
<TT>caml_remove_global_root(&amp;v)</TT>.</P><P>If the contents of the global variable <TT>v</TT> are not modified after
registration, better performance can be achieved by calling
<TT>caml_register_generational_global_root(&amp;v)</TT> to register <TT>v</TT>,
and <TT>caml_remove_generational_global_root(&amp;v)</TT> to un-register it.
The garbage collector takes advantage of the guarantee that <TT>v</TT> is not
modified to scan it less often. This improves performance if many
global variables need to be registered.</P><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> The <TT>CAML</TT> macros use identifiers (local variables, type
identifiers, structure tags) that start with <TT>caml__</TT>. Do not use any
identifier starting with <TT>caml__</TT> in your programs.</P><!--TOC subsection Low-level interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc275">19.5.2</A>&#XA0;&#XA0;Low-level interface</H3><!--SEC END --><P>We now give the GC rules corresponding to the low-level allocation
functions <TT>caml_alloc_small</TT> and <TT>caml_alloc_shr</TT>. You can ignore those rules
if you stick to the simplified allocation function <TT>caml_alloc</TT>.</P><DIV CLASS="theorem"><B>Rule&#XA0;5</B>&#XA0;&#XA0;<EM> After a structured block (a block with tag less than
<TT>No_scan_tag</TT>) is allocated with the low-level functions, all fields
of this block must be filled with well-formed values before the next
allocation operation. If the block has been allocated with
<TT>caml_alloc_small</TT>, filling is performed by direct assignment to the fields
of the block:
</EM><PRE><EM>
        Field(<I>v</I>, <I>n</I>) = <I>v<SUB>n</SUB></I>;
</EM></PRE><EM>
If the block has been allocated with <TT>caml_alloc_shr</TT>, filling is performed
through the <TT>caml_initialize</TT> function:
</EM><PRE><EM>
        caml_initialize(&amp;Field(<I>v</I>, <I>n</I>), <I>v<SUB>n</SUB></I>);
</EM></PRE>
</DIV><P>The next allocation can trigger a garbage collection. The garbage
collector assumes that all structured blocks contain well-formed
values. Newly created blocks contain random data, which generally do
not represent well-formed values.</P><P>If you really need to allocate before the fields can receive their
final value, first initialize with a constant value (e.g.
<TT>Val_unit</TT>), then allocate, then modify the fields with the correct
value (see rule&#XA0;6).</P><DIV CLASS="theorem"><B>Rule&#XA0;6</B>&#XA0;&#XA0;<EM> Direct assignment to a field of a block, as in
</EM><PRE><EM>
        Field(<I>v</I>, <I>n</I>) = <I>w</I>;
</EM></PRE><EM>
is safe only if <I>v</I> is a block newly allocated by <TT>caml_alloc_small</TT>;
that is, if no allocation took place between the
allocation of <I>v</I> and the assignment to the field. In all other cases,
never assign directly. If the block has just been allocated by <TT>caml_alloc_shr</TT>,
use <TT>caml_initialize</TT> to assign a value to a field for the first time:
</EM><PRE><EM>
        caml_initialize(&amp;Field(<I>v</I>, <I>n</I>), <I>w</I>);
</EM></PRE><EM>
Otherwise, you are updating a field that previously contained a
well-formed value; then, call the <TT>caml_modify</TT> function:
</EM><PRE><EM>
        caml_modify(&amp;Field(<I>v</I>, <I>n</I>), <I>w</I>);
</EM></PRE>
</DIV><P>To illustrate the rules above, here is a C function that builds and
returns a list containing the two integers given as parameters.
First, we write it using the simplified allocation functions:
</P><PRE>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc(2, 0);                   /* Allocate a cons cell */
  Store_field(r, 0, Val_int(i2));         /* car = the integer i2 */
  Store_field(r, 1, Val_int(0));          /* cdr = the empty list [] */
  result = caml_alloc(2, 0);              /* Allocate the other cons cell */
  Store_field(result, 0, Val_int(i1));    /* car = the integer i1 */
  Store_field(result, 1, r);              /* cdr = the first cons cell */
  CAMLreturn (result);
}
</PRE><P>Here, the registering of <TT>result</TT> is not strictly needed, because no
allocation takes place after it gets its value, but it&#X2019;s easier and
safer to simply register all the local variables that have type <TT>value</TT>.</P><P>Here is the same function written using the low-level allocation
functions. We notice that the cons cells are small blocks and can be
allocated with <TT>caml_alloc_small</TT>, and filled by direct assignments on
their fields.
</P><PRE>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
  Field(r, 0) = Val_int(i2);              /* car = the integer i2 */
  Field(r, 1) = Val_int(0);               /* cdr = the empty list [] */
  result = caml_alloc_small(2, 0);        /* Allocate the other cons cell */
  Field(result, 0) = Val_int(i1);         /* car = the integer i1 */
  Field(result, 1) = r;                   /* cdr = the first cons cell */
  CAMLreturn (result);
}
</PRE><P>In the two examples above, the list is built bottom-up. Here is an
alternate way, that proceeds top-down. It is less efficient, but
illustrates the use of <TT>caml_modify</TT>.
</P><PRE>value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (tail, r);

  r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
  Field(r, 0) = Val_int(i1);              /* car = the integer i1 */
  Field(r, 1) = Val_int(0);               /* A dummy value
  tail = caml_alloc_small(2, 0);          /* Allocate the other cons cell */
  Field(tail, 0) = Val_int(i2);           /* car = the integer i2 */
  Field(tail, 1) = Val_int(0);            /* cdr = the empty list [] */
  caml_modify(&amp;Field(r, 1), tail);        /* cdr of the result = tail */
  CAMLreturn (r);
}
</PRE><P>It would be incorrect to perform
<TT>Field(r, 1) = tail</TT> directly, because the allocation of <TT>tail</TT>
has taken place since <TT>r</TT> was allocated.</P><!--TOC section A complete example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc276">19.6</A>&#XA0;&#XA0;A complete example</H2><!--SEC END --><P>This section outlines how the functions from the Unix <TT>curses</TT> library
can be made available to OCaml programs. First of all, here is
the interface <TT>curses.mli</TT> that declares the <TT>curses</TT> primitives and
data types:
</P><PRE>type window                   (* The type "window" remains abstract *)
external initscr: unit -&gt; window = "curses_initscr"
external endwin: unit -&gt; unit = "curses_endwin"
external refresh: unit -&gt; unit = "curses_refresh"
external wrefresh : window -&gt; unit = "curses_wrefresh"
external newwin: int -&gt; int -&gt; int -&gt; int -&gt; window = "curses_newwin"
external addch: char -&gt; unit = "curses_addch"
external mvwaddch: window -&gt; int -&gt; int -&gt; char -&gt; unit = "curses_mvwaddch"
external addstr: string -&gt; unit = "curses_addstr"
external mvwaddstr: window -&gt; int -&gt; int -&gt; string -&gt; unit = "curses_mvwaddstr"
(* lots more omitted *)
</PRE><P>To compile this interface:
</P><PRE>        ocamlc -c curses.mli
</PRE><P>
To implement these functions, we just have to provide the stub code;
the core functions are already implemented in the <TT>curses</TT> library.
The stub code file, <TT>curses_stubs.c</TT>, looks like this:
</P><PRE>#include &lt;curses.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/custom.h&gt;

/* Encapsulation of opaque window handles (of type WINDOW *)
   as OCaml custom blocks. */

static struct custom_operations curses_window_ops = {
  "fr.inria.caml.curses_windows",
  custom_finalize_default,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default
};

/* Accessing the WINDOW * part of an OCaml custom block */
#define Window_val(v) (*((WINDOW **) Data_custom_val(v)))

/* Allocating an OCaml custom block to hold the given WINDOW * */
static value alloc_window(WINDOW * w)
{
  value v = alloc_custom(&amp;curses_window_ops, sizeof(WINDOW *), 0, 1);
  Window_val(v) = w;
  return v;
}

value caml_curses_initscr(value unit)
{
  CAMLparam1 (unit);
  CAMLreturn (alloc_window(initscr()));
}

value caml_curses_endwin(value unit)
{
  CAMLparam1 (unit);
  endwin();
  CAMLreturn (Val_unit);
}

value caml_curses_refresh(value unit)
{
  CAMLparam1 (unit);
  refresh();
  CAMLreturn (Val_unit);
}

value caml_curses_wrefresh(value win)
{
  CAMLparam1 (win);
  wrefresh(Window_val(win));
  CAMLreturn (Val_unit);
}

value caml_curses_newwin(value nlines, value ncols, value x0, value y0)
{
  CAMLparam4 (nlines, ncols, x0, y0);
  CAMLreturn (alloc_window(newwin(Int_val(nlines), Int_val(ncols),
                                  Int_val(x0), Int_val(y0))));
}

value caml_curses_addch(value c)
{
  CAMLparam1 (c);
  addch(Int_val(c));            /* Characters are encoded like integers */
  CAMLreturn (Val_unit);
}

value caml_curses_mvwaddch(value win, value x, value y, value c)
{
  CAMLparam4 (win, x, y, c);
  mvwaddch(Window_val(win), Int_val(x), Int_val(y), Int_val(c));
  CAMLreturn (Val_unit);
}

value caml_curses_addstr(value s)
{
  CAMLparam1 (s);
  addstr(String_val(s));
  CAMLreturn (Val_unit);
}

value caml_curses_mvwaddstr(value win, value x, value y, value s)
{
  CAMLparam4 (win, x, y, s);
  mvwaddstr(Window_val(win), Int_val(x), Int_val(y), String_val(s));
  CAMLreturn (Val_unit);
}

/* This goes on for pages. */
</PRE><P>
The file <TT>curses_stubs.c</TT> can be compiled with:
</P><PRE>        cc -c -I`ocamlc -where` curses.c
</PRE><P>or, even simpler,
</P><PRE>        ocamlc -c curses.c
</PRE><P>(When passed a <TT>.c</TT> file, the <TT>ocamlc</TT> command simply calls the C
compiler on that file, with the right <TT>-I</TT> option.)</P><P>Now, here is a sample OCaml program <TT>test.ml</TT> that uses the <TT>curses</TT>
module:
</P><PRE>open Curses
let main_window = initscr () in
let small_window = newwin 10 5 20 10 in
  mvwaddstr main_window 10 2 "Hello";
  mvwaddstr small_window 4 3 "world";
  refresh();
  Unix.sleep 5;
  endwin()
</PRE><P>To compile and link this program, run:
</P><PRE>        ocamlc -custom -o test unix.cma test.ml curses_stubs.o -cclib -lcurses
</PRE><P>(On some machines, you may need to put
<TT>-cclib -lcurses -cclib -ltermcap</TT> or <TT>-cclib -ltermcap</TT>
instead of <TT>-cclib -lcurses</TT>.)</P><!--TOC section Advanced topic: callbacks from C to OCaml-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc277">19.7</A>&#XA0;&#XA0;Advanced topic: callbacks from C to OCaml</H2><!--SEC END --><P> <A NAME="s:callback"></A>
</P><P>So far, we have described how to call C functions from OCaml. In this
section, we show how C functions can call OCaml functions, either as
callbacks (OCaml calls C which calls OCaml), or because the main program
is written in C.</P><!--TOC subsection Applying OCaml closures from C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc278">19.7.1</A>&#XA0;&#XA0;Applying OCaml closures from C</H3><!--SEC END --><P> <A NAME="s:callbacks"></A></P><P>C functions can apply OCaml function values (closures) to OCaml values.
The following functions are provided to perform the applications:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_callback(</TT><I>f, a</I><TT>)</TT> applies the functional value <I>f</I> to
the value <I>a</I> and return the value returned by&#XA0;<I>f</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callback2(</TT><I>f, a, b</I><TT>)</TT> applies the functional value <I>f</I>
(which is assumed to be a curried OCaml function with two arguments) to
<I>a</I> and <I>b</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callback3(</TT><I>f, a, b, c</I><TT>)</TT> applies the functional value <I>f</I>
(a curried OCaml function with three arguments) to <I>a</I>, <I>b</I> and <I>c</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callbackN(</TT><I>f, n, args</I><TT>)</TT> applies the functional value <I>f</I>
to the <I>n</I> arguments contained in the array of values <I>args</I>.
</LI></UL><P>
If the function <I>f</I> does not return, but raises an exception that
escapes the scope of the application, then this exception is
propagated to the next enclosing OCaml code, skipping over the C
code. That is, if an OCaml function <I>f</I> calls a C function <I>g</I> that
calls back an OCaml function <I>h</I> that raises a stray exception, then the
execution of <I>g</I> is interrupted and the exception is propagated back
into <I>f</I>.</P><P>If the C code wishes to catch exceptions escaping the OCaml function,
it can use the functions <TT>caml_callback_exn</TT>, <TT>caml_callback2_exn</TT>,
<TT>caml_callback3_exn</TT>, <TT>caml_callbackN_exn</TT>. These functions take the same
arguments as their non-<TT>_exn</TT> counterparts, but catch escaping
exceptions and return them to the C code. The return value <I>v</I> of the
<TT>caml_callback*_exn</TT> functions must be tested with the macro
<TT>Is_exception_result(</TT><I>v</I><TT>)</TT>. If the macro returns &#X201C;false&#X201D;, no
exception occured, and <I>v</I> is the value returned by the OCaml
function. If <TT>Is_exception_result(</TT><I>v</I><TT>)</TT> returns &#X201C;true&#X201D;,
an exception escaped, and its value (the exception descriptor) can be
recovered using <TT>Extract_exception(</TT><I>v</I><TT>)</TT>.</P><!--TOC paragraph Warning:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Warning:</H5><!--SEC END --><P> If the OCaml function returned with an exception,
<TT>Extract_exception</TT> should be applied to the exception result prior
to calling a function that may trigger garbage collection.
Otherwise, if <I>v</I> is reachable during garbage collection, the runtime
can crash since <I>v</I> does not contain a valid value.</P><P>Example:
</P><PRE>    value call_caml_f_ex(value closure, value arg)
    {
      CAMLparam2(closure, arg);
      CAMLlocal2(res, tmp);
      res = caml_callback_exn(closure, arg);
      if(Is_exception_result(res)) {
        res = Extract_exception(res);
        tmp = caml_alloc(3, 0); /* Safe to allocate: res contains valid value. */
        ...
      }
      CAMLreturn (res);
    }
</PRE><!--TOC subsection Obtaining or registering OCaml closures for use in C functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc279">19.7.2</A>&#XA0;&#XA0;Obtaining or registering OCaml closures for use in C functions</H3><!--SEC END --><P>There are two ways to obtain OCaml function values (closures) to
be passed to the <TT>callback</TT> functions described above. One way is to
pass the OCaml function as an argument to a primitive function. For
example, if the OCaml code contains the declaration
</P><PRE>    external apply : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = "caml_apply"
</PRE><P>the corresponding C stub can be written as follows:
</P><PRE>    CAMLprim value caml_apply(value vf, value vx)
    {
      CAMLparam2(vf, vx);
      CAMLlocal1(vy);
      vy = caml_callback(vf, vx);
      CAMLreturn(vy);
    }
</PRE><P>
Another possibility is to use the registration mechanism provided by
OCaml. This registration mechanism enables OCaml code to register
OCaml functions under some global name, and C code to retrieve the
corresponding closure by this global name.</P><P>On the OCaml side, registration is performed by evaluating
<TT>Callback.register</TT> <I>n v</I>. Here, <I>n</I> is the global name
(an arbitrary string) and <I>v</I> the OCaml value. For instance:
</P><PRE>    let f x = print_string "f is applied to "; print_int x; print_newline()
    let _ = Callback.register "test function" f
</PRE><P>
On the C side, a pointer to the value registered under name <I>n</I> is
obtained by calling <TT>caml_named_value(</TT><I>n</I><TT>)</TT>. The returned
pointer must then be dereferenced to recover the actual OCaml value.
If no value is registered under the name <I>n</I>, the null pointer is
returned. For example, here is a C wrapper that calls the OCaml function <TT>f</TT>
above:
</P><PRE>    void call_caml_f(int arg)
    {
        caml_callback(*caml_named_value("test function"), Val_int(arg));
    }
</PRE><P>
The pointer returned by <TT>caml_named_value</TT> is constant and can safely
be cached in a C variable to avoid repeated name lookups. On the other
hand, the value pointed to can change during garbage collection and
must always be recomputed at the point of use. Here is a more
efficient variant of <TT>call_caml_f</TT> above that calls <TT>caml_named_value</TT>
only once:
</P><PRE>    void call_caml_f(int arg)
    {
        static value * closure_f = NULL;
        if (closure_f == NULL) {
            /* First time around, look up by name */
            closure_f = caml_named_value("test function");
        }
        caml_callback(*closure_f, Val_int(arg));
    }
</PRE><!--TOC subsection Registering OCaml exceptions for use in C functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc280">19.7.3</A>&#XA0;&#XA0;Registering OCaml exceptions for use in C functions</H3><!--SEC END --><P> <A NAME="s:register-exn"></A></P><P>The registration mechanism described above can also be used to
communicate exception identifiers from OCaml to C. The OCaml code
registers the exception by evaluating
<TT>Callback.register_exception</TT> <I>n exn</I>, where <I>n</I> is an
arbitrary name and <I>exn</I> is an exception value of the
exception to register. For example:
</P><PRE>    exception Error of string
    let _ = Callback.register_exception "test exception" (Error "any string")
</PRE><P>The C code can then recover the exception identifier using
<TT>caml_named_value</TT> and pass it as first argument to the functions
<TT>raise_constant</TT>, <TT>raise_with_arg</TT>, and <TT>raise_with_string</TT> (described
in section&#XA0;<A HREF="#s:c-exceptions">19.4.5</A>) to actually raise the exception. For
example, here is a C function that raises the <TT>Error</TT> exception with
the given argument:
</P><PRE>    void raise_error(char * msg)
    {
        caml_raise_with_string(*caml_named_value("test exception"), msg);
    }
</PRE><!--TOC subsection Main program in C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc281">19.7.4</A>&#XA0;&#XA0;Main program in C</H3><!--SEC END --><P> <A NAME="s:main-c"></A></P><P>In normal operation, a mixed OCaml/C program starts by executing the
OCaml initialization code, which then may proceed to call C
functions. We say that the main program is the OCaml code. In some
applications, it is desirable that the C code plays the role of the
main program, calling OCaml functions when needed. This can be achieved as
follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The C part of the program must provide a <TT>main</TT> function,
which will override the default <TT>main</TT> function provided by the OCaml
runtime system. Execution will start in the user-defined <TT>main</TT> function
just like for a regular C program.</LI><LI CLASS="li-itemize">At some point, the C code must call <TT>caml_main(argv)</TT> to
initialize the OCaml code. The <TT>argv</TT> argument is a C array of strings
(type <TT>char **</TT>), terminated with a <TT>NULL</TT> pointer,
which represents the command-line arguments, as
passed as second argument to <TT>main</TT>. The OCaml array <TT>Sys.argv</TT> will
be initialized from this parameter. For the bytecode compiler,
<TT>argv[0]</TT> and <TT>argv[1]</TT> are also consulted to find the file containing
the bytecode.</LI><LI CLASS="li-itemize">The call to <TT>caml_main</TT> initializes the OCaml runtime system,
loads the bytecode (in the case of the bytecode compiler), and
executes the initialization code of the OCaml program. Typically, this
initialization code registers callback functions using <TT>Callback.register</TT>.
Once the OCaml initialization code is complete, control returns to the
C code that called <TT>caml_main</TT>.</LI><LI CLASS="li-itemize">The C code can then invoke OCaml functions using the callback
mechanism (see section&#XA0;<A HREF="#s:callbacks">19.7.1</A>).
</LI></UL><!--TOC subsection Embedding the OCaml code in the C code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc282">19.7.5</A>&#XA0;&#XA0;Embedding the OCaml code in the C code</H3><!--SEC END --><P> <A NAME="s:embedded-code"></A></P><P>The bytecode compiler in custom runtime mode (<TT>ocamlc -custom</TT>)
normally appends the bytecode to the executable file containing the
custom runtime. This has two consequences. First, the final linking
step must be performed by <TT>ocamlc</TT>. Second, the OCaml runtime library
must be able to find the name of the executable file from the
command-line arguments. When using <TT>caml_main(argv)</TT> as in
section&#XA0;<A HREF="#s:main-c">19.7.4</A>, this means that <TT>argv[0]</TT> or <TT>argv[1]</TT> must
contain the executable file name.</P><P>An alternative is to embed the bytecode in the C code. The
<TT>-output-obj</TT> option to <TT>ocamlc</TT> is provided for this purpose. It
causes the <TT>ocamlc</TT> compiler to output a C object file (<TT>.o</TT> file,
<TT>.obj</TT> under Windows) containing the bytecode for the OCaml part of the
program, as well as a <TT>caml_startup</TT> function. The C object file
produced by <TT>ocamlc -output-obj</TT> can then be linked with C code using
the standard C compiler, or stored in a C library.</P><P>The <TT>caml_startup</TT> function must be called from the main C program in
order to initialize the OCaml runtime and execute the OCaml
initialization code. Just like <TT>caml_main</TT>, it takes one <TT>argv</TT>
parameter containing the command-line parameters. Unlike <TT>caml_main</TT>,
this <TT>argv</TT> parameter is used only to initialize <TT>Sys.argv</TT>, but not
for finding the name of the executable file.</P><P>The <TT>-output-obj</TT> option can also be used to obtain the C source file.
More interestingly, the same option can also produce directly a shared
library (<TT>.so</TT> file, <TT>.dll</TT> under Windows) that contains the OCaml
code, the OCaml runtime system and any other static C code given to
<TT>ocamlc</TT> (<TT>.o</TT>, <TT>.a</TT>, respectively, <TT>.obj</TT>, <TT>.lib</TT>). This use of
<TT>-output-obj</TT> is very similar to a normal linking step, but instead of
producing a main program that automatically runs the OCaml code, it
produces a shared library that can run the OCaml code on demand. The
three possible behaviors of <TT>-output-obj</TT> are selected according
to the extension of the resulting file (given with <TT>-o</TT>).</P><P>The native-code compiler <TT>ocamlopt</TT> also supports the <TT>-output-obj</TT>
option, causing it to output a C object file or a shared library
containing the native code for all OCaml modules on the command-line,
as well as the OCaml startup code. Initialization is performed by
calling <TT>caml_startup</TT> as in the case of the bytecode compiler.</P><P>For the final linking phase, in addition to the object file produced
by <TT>-output-obj</TT>, you will have to provide the OCaml runtime
library (<TT>libcamlrun.a</TT> for bytecode, <TT>libasmrun.a</TT> for native-code),
as well as all C libraries that are required by the OCaml libraries
used. For instance, assume the OCaml part of your program uses the
Unix library. With <TT>ocamlc</TT>, you should do:
</P><PRE>
        ocamlc -output-obj -o camlcode.o unix.cma <I>other</I> .cmo <I>and</I> .cma <I>files</I>
        cc -o myprog <I>C objects and libraries</I> \
           camlcode.o -L/usr/local/lib/ocaml -lunix -lcamlrun
</PRE><P>
With <TT>ocamlopt</TT>, you should do:
</P><PRE>
        ocamlopt -output-obj -o camlcode.o unix.cmxa <I>other</I> .cmx <I>and</I> .cmxa <I>files</I>
        cc -o myprog <I>C objects and libraries</I> \
           camlcode.o -L/usr/local/lib/ocaml -lunix -lasmrun
</PRE><P>The shared libraries produced by <TT>ocamlc -output-obj</TT> or by <TT>ocamlopt -output-obj</TT> already contains the OCaml runtime library as
well as all the needed C libraries.</P><!--TOC paragraph Warning:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Warning:</H5><!--SEC END --><P> On some ports, special options are required on the final
linking phase that links together the object file produced by the
<TT>-output-obj</TT> option and the remainder of the program. Those options
are shown in the configuration file <TT>config/Makefile</TT> generated during
compilation of OCaml, as the variables <TT>BYTECCLINKOPTS</TT>
(for object files produced by <TT>ocamlc -output-obj</TT>) and
<TT>NATIVECCLINKOPTS</TT> (for object files produced by <TT>ocamlopt -output-obj</TT>). Currently, the only ports that require special
attention are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Windows with the MSVC compiler: the object file produced by
OCaml have been compiled with the <TT>/MD</TT> flag, and therefore
all other object files linked with it should also be compiled with
<TT>/MD</TT>.
</LI></UL><!--TOC paragraph Stack backtraces.-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Stack backtraces.</H5><!--SEC END --><P> When OCaml bytecode produced by
<TT>ocamlc -g</TT> is embedded in a C program, no debugging information is
included, and therefore it is impossible to print stack backtraces on
uncaught exceptions. This is not the case when native code produced
by <TT>ocamlopt -g</TT> is embedded in a C program: stack backtrace
information is available, but the backtrace mechanism needs to be
turned on programmatically. This can be achieved from the OCaml side
by calling <TT>Printexc.record_backtrace true</TT> in the initialization of
one of the OCaml modules. This can also be achieved from the C side
by calling <TT>caml_record_backtrace(Val_int(1));</TT> in the OCaml-C glue code.</P><!--TOC section Advanced example with callbacks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc283">19.8</A>&#XA0;&#XA0;Advanced example with callbacks</H2><!--SEC END --><P>This section illustrates the callback facilities described in
section&#XA0;<A HREF="#s:callback">19.7</A>. We are going to package some OCaml functions
in such a way that they can be linked with C code and called from C
just like any C functions. The OCaml functions are defined in the
following <TT>mod.ml</TT> OCaml source:</P><PRE>(* File mod.ml &#X2013; some "useful" OCaml functions *)

let rec fib n = if n &lt; 2 then 1 else fib(n-1) + fib(n-2)

let format_result n = Printf.sprintf "Result is: %d\n" n

(* Export those two functions to C *)

let _ = Callback.register "fib" fib
let _ = Callback.register "format_result" format_result
</PRE><P>
Here is the C stub code for calling these functions from C:</P><PRE>/* File modwrap.c &#X2013; wrappers around the OCaml functions */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/callback.h&gt;

int fib(int n)
{
  static value * fib_closure = NULL;
  if (fib_closure == NULL) fib_closure = caml_named_value("fib");
  return Int_val(caml_callback(*fib_closure, Val_int(n)));
}

char * format_result(int n)
{
  static value * format_result_closure = NULL;
  if (format_result_closure == NULL)
    format_result_closure = caml_named_value("format_result");
  return strdup(String_val(caml_callback(*format_result_closure, Val_int(n))));
  /* We copy the C string returned by String_val to the C heap
     so that it remains valid after garbage collection. */
}
</PRE><P>
We now compile the OCaml code to a C object file and put it in a C
library along with the stub code in <TT>modwrap.c</TT> and the OCaml runtime system:
</P><PRE>        ocamlc -custom -output-obj -o modcaml.o mod.ml
        ocamlc -c modwrap.c
        cp /usr/local/lib/ocaml/libcamlrun.a mod.a
        ar r mod.a modcaml.o modwrap.o
</PRE><P>(One can also use <TT>ocamlopt -output-obj</TT> instead of <TT>ocamlc -custom -output-obj</TT>. In this case, replace <TT>libcamlrun.a</TT> (the bytecode
runtime library) by <TT>libasmrun.a</TT> (the native-code runtime library).)</P><P>Now, we can use the two functions <TT>fib</TT> and <TT>format_result</TT> in any C
program, just like regular C functions. Just remember to call
<TT>caml_startup</TT> once before.</P><PRE>/* File main.c &#X2013; a sample client for the OCaml functions */

#include &lt;stdio.h&gt;

int main(int argc, char ** argv)
{
  int result;

  /* Initialize OCaml code */
  caml_startup(argv);
  /* Do some computation */
  result = fib(10);
  printf("fib(10) = %s\n", format_result(result));
  return 0;
}
</PRE><P>
To build the whole program, just invoke the C compiler as follows:
</P><PRE>        cc -o prog main.c mod.a -lcurses
</PRE><P>(On some machines, you may need to put <TT>-ltermcap</TT> or
<TT>-lcurses -ltermcap</TT> instead of <TT>-lcurses</TT>.)</P><!--TOC section Advanced topic: custom blocks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc284">19.9</A>&#XA0;&#XA0;Advanced topic: custom blocks</H2><!--SEC END --><P> <A NAME="s:custom"></A>
</P><P>Blocks with tag <TT>Custom_tag</TT> contain both arbitrary user data and a
pointer to a C struct, with type <TT>struct custom_operations</TT>, that
associates user-provided finalization, comparison, hashing,
serialization and deserialization functions to this block.</P><!--TOC subsection The <TT>struct custom</TT><TT>_</TT><TT>operations</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc285">19.9.1</A>&#XA0;&#XA0;The <TT>struct custom_operations</TT></H3><!--SEC END --><P>The <TT>struct custom_operations</TT> is defined in <TT>&lt;caml/custom.h&gt;</TT> and
contains the following fields:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>char *identifier</TT><BR>
A zero-terminated character string serving as an identifier for
serialization and deserialization operations.</LI><LI CLASS="li-itemize"><TT>void  (*finalize)(value v)</TT><BR>
The <TT>finalize</TT> field contains a pointer to a C function that is called
when the block becomes unreachable and is about to be reclaimed.
The block is passed as first argument to the function.
The <TT>finalize</TT> field can also be <TT>custom_finalize_default</TT> to indicate that no
finalization function is associated with the block.</LI><LI CLASS="li-itemize"><TT>int (*compare)(value v1, value v2)</TT><BR>
The <TT>compare</TT> field contains a pointer to a C function that is
called whenever two custom blocks are compared using OCaml&#X2019;s generic
comparison operators (<TT>=</TT>, <TT>&lt;&gt;</TT>, <TT>&lt;=</TT>, <TT>&gt;=</TT>, <TT>&lt;</TT>, <TT>&gt;</TT> and
<TT>compare</TT>). The C function should return 0 if the data contained in
the two blocks are structurally equal, a negative integer if the data
from the first block is less than the data from the second block, and
a positive integer if the data from the first block is greater than
the data from the second block.<P>The <TT>compare</TT> field can be set to <TT>custom_compare_default</TT>; this
default comparison function simply raises <TT>Failure</TT>.</P></LI><LI CLASS="li-itemize"><TT>int (*compare_ext)(value v1, value v2)</TT><BR>
(Since 3.12.1.) 
The <TT>compare_ext</TT> field contains a pointer to a C function that is
called whenever one custom block and one unboxed integer are compared using OCaml&#X2019;s generic
comparison operators (<TT>=</TT>, <TT>&lt;&gt;</TT>, <TT>&lt;=</TT>, <TT>&gt;=</TT>, <TT>&lt;</TT>, <TT>&gt;</TT> and
<TT>compare</TT>). As in the case of the <TT>compare</TT> field, the C function
should return 0 if the two arguments are structurally equal, a
negative integer if the first argument compares less than the second
argument, and a positive integer if the first argument compares
greater than the second argument.<P>The <TT>compare_ext</TT> field can be set to <TT>custom_compare_ext_default</TT>; this
default comparison function simply raises <TT>Failure</TT>.</P></LI><LI CLASS="li-itemize"><TT>long (*hash)(value v)</TT><BR>
The <TT>hash</TT> field contains a pointer to a C function that is called
whenever OCaml&#X2019;s generic hash operator (see module <TT>Hashtbl</TT>) is
applied to a custom block. The C function can return an arbitrary
long integer representing the hash value of the data contained in the
given custom block. The hash value must be compatible with the
<TT>compare</TT> function, in the sense that two structurally equal data
(that is, two custom blocks for which <TT>compare</TT> returns 0) must have
the same hash value.<P>The <TT>hash</TT> field can be set to <TT>custom_hash_default</TT>, in which case
the custom block is ignored during hash computation.</P></LI><LI CLASS="li-itemize"><TT>void (*serialize)(value v, unsigned long * wsize_32, unsigned long * wsize_64)</TT><BR>
The <TT>serialize</TT> field contains a pointer to a C function that is
called whenever the custom block needs to be serialized (marshaled)
using the OCaml functions <TT>output_value</TT> or <TT>Marshal.to_...</TT>.
For a custom block, those functions first write the identifier of the
block (as given by the <TT>identifier</TT> field) to the output stream,
then call the user-provided <TT>serialize</TT> function. That function is
responsible for writing the data contained in the custom block, using
the <TT>serialize_...</TT> functions defined in <TT>&lt;caml/intext.h&gt;</TT> and listed
below. The user-provided <TT>serialize</TT> function must then store in its
<TT>wsize_32</TT> and <TT>wsize_64</TT> parameters the sizes in bytes of the data
part of the custom block on a 32-bit architecture and on a 64-bit
architecture, respectively.<P>The <TT>serialize</TT> field can be set to <TT>custom_serialize_default</TT>,
in which case the <TT>Failure</TT> exception is raised when attempting to
serialize the custom block.</P></LI><LI CLASS="li-itemize"><TT>unsigned long (*deserialize)(void * dst)</TT><BR>
The <TT>deserialize</TT> field contains a pointer to a C function that is
called whenever a custom block with identifier <TT>identifier</TT> needs to
be deserialized (un-marshaled) using the OCaml functions <TT>input_value</TT>
or <TT>Marshal.from_...</TT>. This user-provided function is responsible for
reading back the data written by the <TT>serialize</TT> operation, using the
<TT>deserialize_...</TT> functions defined in <TT>&lt;caml/intext.h&gt;</TT> and listed
below. It must then rebuild the data part of the custom block
and store it at the pointer given as the <TT>dst</TT> argument. Finally, it
returns the size in bytes of the data part of the custom block.
This size must be identical to the <TT>wsize_32</TT> result of
the <TT>serialize</TT> operation if the architecture is 32 bits, or
<TT>wsize_64</TT> if the architecture is 64 bits.<P>The <TT>deserialize</TT> field can be set to <TT>custom_deserialize_default</TT>
to indicate that deserialization is not supported. In this case,
do not register the <TT>struct custom_operations</TT> with the deserializer
using <TT>register_custom_operations</TT> (see below).
</P></LI></UL><P>Note: the <TT>finalize</TT>, <TT>compare</TT>, <TT>hash</TT>, <TT>serialize</TT> and <TT>deserialize</TT>
functions attached to custom block descriptors must never trigger a
garbage collection. Within these functions, do not call any of the
OCaml allocation functions, and do not perform a callback into OCaml
code. Do not use <TT>CAMLparam</TT> to register the parameters to these
functions, and do not use <TT>CAMLreturn</TT> to return the result.</P><!--TOC subsection Allocating custom blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc286">19.9.2</A>&#XA0;&#XA0;Allocating custom blocks</H3><!--SEC END --><P>Custom blocks must be allocated via the <TT>caml_alloc_custom</TT> function:
</P><DIV CLASS="center">
<TT>caml_alloc_custom(</TT><I>ops</I><TT>, </TT><I>size</I><TT>, </TT><I>used</I><TT>, </TT><I>max</I><TT>)</TT>
</DIV><P>
returns a fresh custom block, with room for <I>size</I> bytes of user
data, and whose associated operations are given by <I>ops</I> (a
pointer to a <TT>struct custom_operations</TT>, usually statically allocated
as a C global variable).</P><P>The two parameters <I>used</I> and <I>max</I> are used to control the
speed of garbage collection when the finalized object contains
pointers to out-of-heap resources. Generally speaking, the
OCaml incremental major collector adjusts its speed relative to the
allocation rate of the program. The faster the program allocates, the
harder the GC works in order to reclaim quickly unreachable blocks
and avoid having large amount of &#X201C;floating garbage&#X201D; (unreferenced
objects that the GC has not yet collected).</P><P>Normally, the allocation rate is measured by counting the in-heap size
of allocated blocks. However, it often happens that finalized
objects contain pointers to out-of-heap memory blocks and other resources
(such as file descriptors, X Windows bitmaps, etc.). For those
blocks, the in-heap size of blocks is not a good measure of the
quantity of resources allocated by the program.</P><P>The two arguments <I>used</I> and <I>max</I> give the GC an idea of how
much out-of-heap resources are consumed by the finalized block
being allocated: you give the amount of resources allocated to this
object as parameter <I>used</I>, and the maximum amount that you want
to see in floating garbage as parameter <I>max</I>. The units are
arbitrary: the GC cares only about the ratio <I>used</I> / <I>max</I>.</P><P>For instance, if you are allocating a finalized block holding an X
Windows bitmap of <I>w</I> by <I>h</I> pixels, and you&#X2019;d rather not
have more than 1 mega-pixels of unreclaimed bitmaps, specify
<I>used</I> = <I>w</I> * <I>h</I> and <I>max</I> = 1000000.</P><P>Another way to describe the effect of the <I>used</I> and <I>max</I>
parameters is in terms of full GC cycles. If you allocate many custom
blocks with <I>used</I> / <I>max</I> = 1 / <I>N</I>, the GC will then do one
full cycle (examining every object in the heap and calling
finalization functions on those that are unreachable) every <I>N</I>
allocations. For instance, if <I>used</I> = 1 and <I>max</I> = 1000,
the GC will do one full cycle at least every 1000 allocations of
custom blocks.</P><P>If your finalized blocks contain no pointers to out-of-heap resources,
or if the previous discussion made little sense to you, just take
<I>used</I> = 0 and <I>max</I> = 1. But if you later find that the
finalization functions are not called &#X201C;often enough&#X201D;, consider
increasing the <I>used</I> / <I>max</I> ratio.</P><!--TOC subsection Accessing custom blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc287">19.9.3</A>&#XA0;&#XA0;Accessing custom blocks</H3><!--SEC END --><P>The data part of a custom block <I>v</I> can be
accessed via the pointer <TT>Data_custom_val(</TT><I>v</I><TT>)</TT>. This pointer
has type <TT>void *</TT> and should be cast to the actual type of the data
stored in the custom block.</P><P>The contents of custom blocks are not scanned by the garbage
collector, and must therefore not contain any pointer inside the OCaml
heap. In other terms, never store an OCaml <TT>value</TT> in a custom block,
and do not use <TT>Field</TT>, <TT>Store_field</TT> nor <TT>caml_modify</TT> to access the data
part of a custom block. Conversely, any C data structure (not
containing heap pointers) can be stored in a custom block.</P><!--TOC subsection Writing custom serialization and deserialization functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc288">19.9.4</A>&#XA0;&#XA0;Writing custom serialization and deserialization functions</H3><!--SEC END --><P>The following functions, defined in <TT>&lt;caml/intext.h&gt;</TT>, are provided to
write and read back the contents of custom blocks in a portable way.
Those functions handle endianness conversions when e.g. data is
written on a little-endian machine and read back on a big-endian machine.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Function</B></TD><TD ALIGN=center NOWRAP><B>Action</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>caml_serialize_int_1</TT></TD><TD VALIGN=top ALIGN=left>Write a 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_2</TT></TD><TD VALIGN=top ALIGN=left>Write a 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_4</TT></TD><TD VALIGN=top ALIGN=left>Write a 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_8</TT></TD><TD VALIGN=top ALIGN=left>Write a 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_float_4</TT></TD><TD VALIGN=top ALIGN=left>Write a 4-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_float_8</TT></TD><TD VALIGN=top ALIGN=left>Write a 8-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_1</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 1-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_2</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 2-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_4</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 4-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_8</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 8-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_1</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_1</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_2</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_2</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_4</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_4</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_8</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_8</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_float_4</TT></TD><TD VALIGN=top ALIGN=left>Read a 4-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_float_8</TT></TD><TD VALIGN=top ALIGN=left>Read an 8-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_1</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 1-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_2</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 2-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_4</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 4-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_8</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 8-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_error</TT></TD><TD VALIGN=top ALIGN=left>Signal an error during deserialization;
<TT>input_value</TT> or <TT>Marshal.from_...</TT> raise a <TT>Failure</TT> exception after
cleaning up their internal data structures</TD></TR>
</TABLE></DIV><P>Serialization functions are attached to the custom blocks to which
they apply. Obviously, deserialization functions cannot be attached
this way, since the custom block does not exist yet when
deserialization begins! Thus, the <TT>struct custom_operations</TT> that
contain deserialization functions must be registered with the
deserializer in advance, using the <TT>register_custom_operations</TT>
function declared in <TT>&lt;caml/custom.h&gt;</TT>. Deserialization proceeds by
reading the identifier off the input stream, allocating a custom block
of the size specified in the input stream, searching the registered
<TT>struct custom_operation</TT> blocks for one with the same identifier, and
calling its <TT>deserialize</TT> function to fill the data part of the custom block.</P><!--TOC subsection Choosing identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc289">19.9.5</A>&#XA0;&#XA0;Choosing identifiers</H3><!--SEC END --><P>Identifiers in <TT>struct custom_operations</TT> must be chosen carefully,
since they must identify uniquely the data structure for serialization
and deserialization operations. In particular, consider including a
version number in the identifier; this way, the format of the data can
be changed later, yet backward-compatible deserialisation functions
can be provided.</P><P>Identifiers starting with <TT>_</TT> (an underscore character) are reserved
for the OCaml runtime system; do not use them for your custom
data. We recommend to use a URL
(<TT>http://mymachine.mydomain.com/mylibrary/version-number</TT>)
or a Java-style package name
(<TT>com.mydomain.mymachine.mylibrary.version-number</TT>)
as identifiers, to minimize the risk of identifier collision.</P><!--TOC subsection Finalized blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc290">19.9.6</A>&#XA0;&#XA0;Finalized blocks</H3><!--SEC END --><P>Custom blocks generalize the finalized blocks that were present in
OCaml prior to version 3.00. For backward compatibility, the
format of custom blocks is compatible with that of finalized blocks,
and the <TT>alloc_final</TT> function is still available to allocate a custom
block with a given finalization function, but default comparison,
hashing and serialization functions. <TT>caml_alloc_final(</TT><I>n</I><TT>, </TT><I>f</I><TT>, </TT><I>used</I><TT>, </TT><I>max</I><TT>)</TT> returns a fresh custom block of
size <I>n</I> words, with finalization function <I>f</I>. The first
word is reserved for storing the custom operations; the other
<I>n</I>-1 words are available for your data. The two parameters
<I>used</I> and <I>max</I> are used to control the speed of garbage
collection, as described for <TT>caml_alloc_custom</TT>.</P><!--TOC section Advanced topic: multithreading-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc291">19.10</A>&#XA0;&#XA0;Advanced topic: multithreading</H2><!--SEC END --><P>
<A NAME="s:C-multithreading"></A></P><P>Using multiple threads (shared-memory concurrency) in a mixed OCaml/C
application requires special precautions, which are described in this
section.</P><!--TOC subsection Registering threads created from C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc292">19.10.1</A>&#XA0;&#XA0;Registering threads created from C</H3><!--SEC END --><P>Callbacks from C to OCaml are possible only if the calling thread is
known to the OCaml run-time system. Threads created from OCaml (through
the <TT>Thread.create</TT> function of the system threads library) are
automatically known to the run-time system. If the application
creates additional threads from C and wishes to callback into OCaml
code from these threads, it must first register them with the run-time
system. The following functions are declared in the include file
<TT>&lt;caml/threads.h&gt;</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_c_thread_register()</TT> registers the calling thread with the OCaml
run-time system. Returns 1 on success, 0 on error. Registering an
already-register thread does nothing and returns 0.
</LI><LI CLASS="li-itemize"><TT>caml_c_thread_unregister()</TT> must be called before the thread
terminates, to unregister it from the OCaml run-time system.
Returns 1 on success, 0 on error. If the calling thread was not
previously registered, does nothing and returns 0.
</LI></UL><!--TOC subsection Parallel execution of long-running C code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc293">19.10.2</A>&#XA0;&#XA0;Parallel execution of long-running C code</H3><!--SEC END --><P>The OCaml run-time system is not reentrant: at any time, at most one
thread can be executing OCaml code or C code that uses the OCaml
run-time system. Technically, this is enforced by a &#X201C;master lock&#X201D;
that any thread must hold while executing such code.</P><P>When OCaml calls the C code implementing a primitive, the master lock
is held, therefore the C code has full access to the facilities of the
run-time system. However, no other thread can execute OCaml code
concurrently with the C code of the primitive.</P><P>If a C primitive runs for a long time or performs potentially blocking
input-output operations, it can explicitly release the master lock,
enabling other OCaml threads to run concurrently with its operations.
The C code must re-acquire the master lock before returning to OCaml.
This is achieved with the following functions, declared in
the include file <TT>&lt;caml/threads.h&gt;</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_release_runtime_system()</TT>
The calling thread releases the master lock and other OCaml resources,
enabling other threads to run OCaml code in parallel with the execution
of the calling thread.
</LI><LI CLASS="li-itemize"><TT>caml_acquire_runtime_system()</TT>
The calling thread re-acquires the master lock and other OCaml
resources. It may block until no other thread uses the OCaml run-time
system.
</LI></UL><P>After <TT>caml_release_runtime_system()</TT> was called and until
<TT>caml_acquire_runtime_system()</TT> is called, the C code must not access
any OCaml data, nor call any function of the run-time system, nor call
back into OCaml code. Consequently, arguments provided by OCaml to the
C primitive must be copied into C data structures before calling
<TT>caml_release_runtime_system()</TT>, and results to be returned to OCaml
must be encoded as OCaml values after <TT>caml_acquire_runtime_system()</TT>
returns.</P><P>Example: the following C primitive invokes <TT>gethostbyname</TT> to find the
IP address of a host name. The <TT>gethostbyname</TT> function can block for
a long time, so we choose to release the OCaml run-time system while it
is running.
</P><PRE>CAMLprim stub_gethostbyname(value vname)
{
  CAMLparam1 (vname);
  CAMLlocal1 (vres);
  struct hostent * h;

  /* Copy the string argument to a C string, allocated outside the
     OCaml heap. */
  name = stat_alloc(caml_string_length(vname) + 1);
  strcpy(name, String_val(vname));
  /* Release the OCaml run-time system */
  caml_release_runtime_system();
  /* Resolve the name */
  h = gethostbyname(name);
  /* Re-acquire the OCaml run-time system */
  caml_acquire_runtime_system();
  /* Encode the relevant fields of h as the OCaml value vres */
  ... /* Omitted */
  /* Return to OCaml */
  CAMLreturn (vres);
}
</PRE><P>
Callbacks from C to OCaml must be performed while holding the master
lock to the OCaml run-time system. This is naturally the case if the
callback is performed by a C primitive that did not release the
run-time system. If the C primitive released the run-time system
previously, or the callback is performed from other C code that was
not invoked from OCaml (e.g. an event loop in a GUI application), the
run-time system must be acquired before the callback and released
after:
</P><PRE>  caml_acquire_runtime_system();
  /* Resolve OCaml function vfun to be invoked */
  /* Build OCaml argument varg to the callback */
  vres = callback(vfun, varg);
  /* Copy relevant parts of result vres to C data structures */
  caml_release_runtime_system();
</PRE><P>
Note: the <TT>acquire</TT> and <TT>release</TT> functions described above were
introduced in OCaml 3.12. Older code uses the following historical
names, declared in <TT>&lt;caml/signals.h&gt;</TT>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_enter_blocking_section</TT> as an alias for
<TT>caml_release_runtime_system</TT>
</LI><LI CLASS="li-itemize"><TT>caml_leave_blocking_section</TT> as an alias for
<TT>caml_acquire_runtime_system</TT>
</LI></UL><P>
Intuition: a &#X201C;blocking section&#X201D; is a piece of C code that does not
use the OCaml run-time system, typically a blocking input/output operation.</P><!--TOC section Building mixed C/OCaml libraries: <TT>ocamlmklib</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc294">19.11</A>&#XA0;&#XA0;Building mixed C/OCaml libraries: <TT>ocamlmklib</TT></H2><!--SEC END --><P>
<A NAME="s-ocamlmklib"></A></P><P>The <TT>ocamlmklib</TT> command facilitates the construction of libraries
containing both OCaml code and C code, and usable both in static
linking and dynamic linking modes. This command is available under
Windows since Objective Caml 3.11 and under other operating systems since
Objective Caml 3.03.</P><P>The <TT>ocamlmklib</TT> command takes three kinds of arguments:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
OCaml source files and object files (<TT>.cmo</TT>, <TT>.cmx</TT>, <TT>.ml</TT>)
comprising the OCaml part of the library;
</LI><LI CLASS="li-itemize">C object files (<TT>.o</TT>, <TT>.a</TT>, respectively, <TT>.obj</TT>, <TT>.lib</TT>)
comprising the C part of the library;
</LI><LI CLASS="li-itemize">Support libraries for the C part (<TT>-l</TT><I>lib</I>).
</LI></UL><P>
It generates the following outputs:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
An OCaml bytecode library <TT>.cma</TT> incorporating the <TT>.cmo</TT> and
<TT>.ml</TT> OCaml files given as arguments, and automatically referencing the
C library generated with the C object files.
</LI><LI CLASS="li-itemize">An OCaml native-code library <TT>.cmxa</TT> incorporating the <TT>.cmx</TT> and
<TT>.ml</TT> OCaml files given as arguments, and automatically referencing the
C library generated with the C object files.
</LI><LI CLASS="li-itemize">If dynamic linking is supported on the target platform, a
<TT>.so</TT> (respectively, <TT>.dll</TT>) shared library built from the C object files given as arguments,
and automatically referencing the support libraries.
</LI><LI CLASS="li-itemize">A C static library <TT>.a</TT>(respectively, <TT>.lib</TT>) built from the C object files.
</LI></UL><P>
In addition, the following options are recognized:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-cclib</TT>, <TT>-ccopt</TT>, <TT>-I</TT>, <TT>-linkall</TT></B></DT><DD CLASS="dd-description">
These options are passed as is to <TT>ocamlc</TT> or <TT>ocamlopt</TT>.
See the documentation of these commands.
</DD><DT CLASS="dt-description"><B><TT>-rpath</TT>, <TT>-R</TT>, <TT>-Wl,-rpath</TT>, <TT>-Wl,-R</TT></B></DT><DD CLASS="dd-description">
These options are passed as is to the C compiler. Refer to the
documentation of the C compiler.
</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description"> Force the construction of a statically linked library
only, even if dynamic linking is supported.
</DD><DT CLASS="dt-description"><TT><B>-failsafe</B></TT></DT><DD CLASS="dd-description"> Fall back to building a statically linked library
if a problem occurs while building the shared library (e.g. some of
the support libraries are not available as shared libraries).
</DD><DT CLASS="dt-description"><B><TT>-L</TT><I>dir</I></B></DT><DD CLASS="dd-description"> Add <I>dir</I> to the search path for support
libraries (<TT>-l</TT><I>lib</I>).
</DD><DT CLASS="dt-description"><B><TT>-ocamlc</TT> <I>cmd</I></B></DT><DD CLASS="dd-description"> Use <I>cmd</I> instead of <TT>ocamlc</TT> to call
the bytecode compiler.
</DD><DT CLASS="dt-description"><B><TT>-ocamlopt</TT> <I>cmd</I></B></DT><DD CLASS="dd-description"> Use <I>cmd</I> instead of <TT>ocamlopt</TT> to call
the native-code compiler.
</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>output</I></B></DT><DD CLASS="dd-description"> Set the name of the generated OCaml library.
<TT>ocamlmklib</TT> will generate <I>output</I><TT>.cma</TT> and/or <I>output</I><TT>.cmxa</TT>.
If not specified, defaults to <TT>a</TT>.
</DD><DT CLASS="dt-description"><B><TT>-oc</TT> <I>outputc</I></B></DT><DD CLASS="dd-description"> Set the name of the generated C library.
<TT>ocamlmklib</TT> will generate <TT>lib</TT><I>outputc</I><TT>.so</TT> (if shared
libraries are supported) and <TT>lib</TT><I>outputc</I><TT>.a</TT>.
If not specified, defaults to the output name given with <TT>-o</TT>.
</DD></DL><!--TOC paragraph Example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Example</H5><!--SEC END --><P> Consider an OCaml interface to the standard <TT>libz</TT>
C library for reading and writing compressed files. Assume this
library resides in <TT>/usr/local/zlib</TT>. This interface is
composed of an OCaml part <TT>zip.cmo</TT>/<TT>zip.cmx</TT> and a C part <TT>zipstubs.o</TT>
containing the stub code around the <TT>libz</TT> entry points. The
following command builds the OCaml libraries <TT>zip.cma</TT> and <TT>zip.cmxa</TT>,
as well as the companion C libraries <TT>dllzip.so</TT> and <TT>libzip.a</TT>:
</P><PRE>ocamlmklib -o zip zip.cmo zip.cmx zipstubs.o -lz -L/usr/local/zlib
</PRE><P>If shared libraries are supported, this performs the following
commands:
</P><PRE>ocamlc -a -o zip.cma zip.cmo -dllib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -cclib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
gcc -shared -o dllzip.so zipstubs.o -lz -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</PRE><P>If shared libraries are not supported, the following commands are
performed instead:
</P><PRE>ocamlc -a -custom -o zip.cma zip.cmo -cclib -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</PRE><P>Instead of building simultaneously the bytecode library, the
native-code library and the C libraries, <TT>ocamlmklib</TT> can be called
three times to build each separately. Thus,
</P><PRE>ocamlmklib -o zip zip.cmo -lz -L/usr/local/zlib
</PRE><P>builds the bytecode library <TT>zip.cma</TT>, and
</P><PRE>ocamlmklib -o zip zip.cmx -lz -L/usr/local/zlib
</PRE><P>builds the native-code library <TT>zip.cmxa</TT>, and
</P><PRE>ocamlmklib -o zip zipstubs.o -lz -L/usr/local/zlib
</PRE><P>builds the C libraries <TT>dllzip.so</TT> and <TT>libzip.a</TT>. Notice that the
support libraries (<TT>-lz</TT>) and the corresponding options
(<TT>-L/usr/local/zlib</TT>) must be given on all three invocations of <TT>ocamlmklib</TT>,
because they are needed at different times depending on whether shared
libraries are supported.</P><!--TOC part The OCaml library-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc295">Part&#XA0;IV</A><BR>
The OCaml library</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:library"></A>
</P><!--TOC chapter The core library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc296">Chapter&#XA0;20</A>&#XA0;&#XA0;The core library</H1><!--SEC END --><P> <A NAME="c:corelib"></A>
</P><P>This chapter describes the OCaml core library, which is
composed of declarations for built-in types and exceptions, plus
the module <TT>Pervasives</TT> that provides basic operations on these
built-in types. The <TT>Pervasives</TT> module is special in two
ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
It is automatically linked with the user&#X2019;s object code files by
the <TT>ocamlc</TT> command (chapter&#XA0;<A HREF="#c:camlc">8</A>).</LI><LI CLASS="li-itemize">It is automatically &#X201C;opened&#X201D; when a compilation starts, or
when the toplevel system is launched. Hence, it is possible to use
unqualified identifiers to refer to the functions provided by the
<TT>Pervasives</TT> module, without adding a <TT>open Pervasives</TT> directive.
</LI></UL><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>The declarations of the built-in types and the components of module
<TT>Pervasives</TT> are printed one by one in typewriter font, followed by a
short comment. All library modules and the components they provide are
indexed at the end of this report.</P><!--TOC section Built-in types and predefined exceptions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc297">20.1</A>&#XA0;&#XA0;Built-in types and predefined exceptions</H2><!--SEC END --><P>The following built-in types and predefined exceptions are always
defined in the
compilation environment, but are not part of any module. As a
consequence, they can only be referred by their short names.</P><!--TOC subsection Built-in types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Built-in types</H3><!--SEC END --><PRE> type int
</PRE><P><A NAME="@manual9"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of integer numbers.
</BLOCKQUOTE><PRE> type char
</PRE><P><A NAME="@manual10"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of characters.
</BLOCKQUOTE><PRE> type string
</PRE><P><A NAME="@manual11"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of character strings.
</BLOCKQUOTE><PRE> type float
</PRE><P><A NAME="@manual12"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of floating-point numbers.
</BLOCKQUOTE><PRE> type bool = false | true
</PRE><P><A NAME="@manual13"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of booleans (truth values).
</BLOCKQUOTE><PRE> type unit = ()
</PRE><P><A NAME="@manual14"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of the unit value.
</BLOCKQUOTE><PRE> type exn
</PRE><P><A NAME="@manual15"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of exception values.
</BLOCKQUOTE><PRE> type 'a array
</PRE><P><A NAME="@manual16"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of arrays whose elements have type <TT>'a</TT>.
</BLOCKQUOTE><PRE> type 'a list = [] | :: of 'a * 'a list
</PRE><P><A NAME="@manual17"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of lists whose elements have type <TT>'a</TT>.
</BLOCKQUOTE><PRE>type 'a option = None | Some of 'a
</PRE><P><A NAME="@manual18"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of optional values of type <TT>'a</TT>.
</BLOCKQUOTE><PRE>type int32
</PRE><P><A NAME="@manual19"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed 32-bit integers.
See the <TT>Int32</TT>[<TT><A HREF="libref/Int32.html">Int32</A></TT>] module.
</BLOCKQUOTE><PRE>type int64
</PRE><P><A NAME="@manual20"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed 64-bit integers.
See the <TT>Int64</TT>[<TT><A HREF="libref/Int64.html">Int64</A></TT>] module.
</BLOCKQUOTE><PRE>type nativeint
</PRE><P><A NAME="@manual21"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed, platform-native integers (32 bits on 32-bit
processors, 64 bits on 64-bit processors).
See the <TT>Nativeint</TT>[<TT><A HREF="libref/Nativeint.html">Nativeint</A></TT>] module.
</BLOCKQUOTE><PRE>type ('a, 'b, 'c, 'd, 'e, 'f) format6
</PRE><P><A NAME="@manual22"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of format strings. <TT>'a</TT> is the type of the parameters of
the format, <TT>'f</TT> is the result type for the <TT>printf</TT>-style
functions, <TT>'b</TT> is the type of the first argument given to <TT>%a</TT> and
<TT>%t</TT> printing functions (see module <TT>Printf</TT>[<TT><A HREF="libref/Printf.html">Printf</A></TT>]),
<TT>'c</TT> is the result type of these functions, and also the type of the
argument transmitted to the first argument of <TT>kprintf</TT>-style
functions, <TT>'d</TT> is the result type for the <TT>scanf</TT>-style functions
(see module <TT>Scanf</TT>[<TT><A HREF="libref/Scanf.html">Scanf</A></TT>]),
and <TT>'e</TT> is the type of the receiver function for the <TT>scanf</TT>-style
functions.
</BLOCKQUOTE><PRE>type 'a lazy_t
</PRE><P><A NAME="@manual23"></A>
</P><BLOCKQUOTE CLASS="quote">
This type is used to implement the <TT>Lazy</TT>[<TT><A HREF="libref/Lazy.html">Lazy</A></TT>] module.
It should not be used directly.
</BLOCKQUOTE><!--TOC subsection Predefined exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Predefined exceptions</H3><!--SEC END --><PRE>exception Match_failure of (string * int * int)
</PRE><P><A NAME="@manual24"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when none of the cases of a pattern-matching
apply. The arguments are the location of the <TT>match</TT> keyword
in the source code (file name, line number, column number).
</BLOCKQUOTE><PRE>exception Assert_failure of (string * int * int)
</PRE><P><A NAME="@manual25"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when an assertion fails. The arguments are
the location of the <TT>assert</TT> keyword in the source code
(file name, line number, column number).
</BLOCKQUOTE><PRE>exception Invalid_argument of string
</PRE><P><A NAME="@manual26"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by library functions to signal that the given
arguments do not make sense.
</BLOCKQUOTE><PRE>exception Failure of string
</PRE><P><A NAME="@manual27"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by library functions to signal that they are
undefined on the given arguments.
</BLOCKQUOTE><PRE>exception Not_found
</PRE><P><A NAME="@manual28"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by search functions when the desired object
could not be found.
</BLOCKQUOTE><PRE>exception Out_of_memory
</PRE><P><A NAME="@manual29"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the garbage collector
when there is insufficient memory to complete the computation.
</BLOCKQUOTE><PRE>exception Stack_overflow
</PRE><P><A NAME="@manual30"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the bytecode interpreter when the evaluation
stack reaches its maximal size. This often indicates infinite
or excessively deep recursion in the user&#X2019;s program.
(Not fully implemented by the native-code compiler;
see section&#XA0;<A HREF="#s:compat-native-bytecode">11.5</A>.)
</BLOCKQUOTE><PRE>exception Sys_error of string
</PRE><P><A NAME="@manual31"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the input/output functions to report
an operating system error.
</BLOCKQUOTE><PRE>exception End_of_file
</PRE><P><A NAME="@manual32"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by input functions to signal that the
end of file has been reached.
</BLOCKQUOTE><PRE>exception Division_by_zero
</PRE><P><A NAME="@manual33"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by integer division and remainder operations
when their second argument is zero.
</BLOCKQUOTE><PRE>exception Sys_blocked_io
</PRE><P><A NAME="@manual34"></A>
</P><BLOCKQUOTE CLASS="quote">
A special case of <TT>Sys_error</TT> raised when no I/O is possible
on a non-blocking I/O channel.
</BLOCKQUOTE><PRE>exception Undefined_recursive_module of (string * int * int)
</PRE><P><A NAME="@manual35"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when an ill-founded recursive module definition
is evaluated. (See section&#XA0;<A HREF="#s-recursive-modules">7.8</A>.)
The arguments are the location of the definition in the source code
(file name, line number, column number).
</BLOCKQUOTE><!--TOC section Module <TT>Pervasives</TT>: the initially opened module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc298">20.2</A>&#XA0;&#XA0;Module <TT>Pervasives</TT>: the initially opened module</H2><!--SEC END --><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Pervasives.html">Module <TT>Pervasives</TT>: the initially opened module</A>
</LI></UL><!--TOC chapter The standard library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc299">Chapter&#XA0;21</A>&#XA0;&#XA0;The standard library</H1><!--SEC END --><P> <A NAME="c:stdlib"></A>
</P><P>This chapter describes the functions provided by the OCaml
standard library. The modules from the standard library are
automatically linked with the user&#X2019;s object code files by the <TT>ocamlc</TT>
command. Hence, these modules can be used in standalone programs without
having to add any <TT>.cmo</TT> file on the command line for the linking
phase. Similarly, in interactive use, these globals can be used in
toplevel phrases without having to load any <TT>.cmo</TT> file in memory.</P><P>Unlike the <TT>Pervasives</TT> module from the core library, the modules from the
standard library are not automatically &#X201C;opened&#X201D; when a compilation
starts, or when the toplevel system is launched. Hence it is necessary
to use qualified identifiers to refer to the functions provided by these
modules, or to add <TT>open</TT> directives.</P><P><A NAME="stdlib:top"></A></P><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>For easy reference, the modules are listed below in alphabetical order
of module names.
For each module, the declarations from its signature are printed
one by one in typewriter font, followed by a short comment.
All modules and the identifiers they export are indexed at the end of
this report.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Arg.html">Module <TT>Arg</TT>: parsing of command line arguments</A>
</LI><LI CLASS="li-links"><A HREF="libref/Array.html">Module <TT>Array</TT>: array operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/ArrayLabels.html">Module <TT>ArrayLabels</TT>: array operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Buffer.html">Module <TT>Buffer</TT>: extensible string buffers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Callback.html">Module <TT>Callback</TT>: registering OCaml values with the C runtime</A>
</LI><LI CLASS="li-links"><A HREF="libref/Char.html">Module <TT>Char</TT>: character operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/Complex.html">Module <TT>Complex</TT>: Complex numbers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Digest.html">Module <TT>Digest</TT>: MD5 message digest</A>
</LI><LI CLASS="li-links"><A HREF="libref/Filename.html">Module <TT>Filename</TT>: operations on file names</A>
</LI><LI CLASS="li-links"><A HREF="libref/Format.html">Module <TT>Format</TT>: pretty printing</A>
</LI><LI CLASS="li-links"><A HREF="libref/Gc.html">Module <TT>Gc</TT>: memory management control and statistics; finalised values</A>
</LI><LI CLASS="li-links"><A HREF="libref/Genlex.html">Module <TT>Genlex</TT>: a generic lexical analyzer</A>
</LI><LI CLASS="li-links"><A HREF="libref/Hashtbl.html">Module <TT>Hashtbl</TT>: hash tables and hash functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Int32.html">Module <TT>Int32</TT>: 32-bit integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Int64.html">Module <TT>Int64</TT>: 64-bit integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Lazy.html">Module <TT>Lazy</TT>: deferred computations</A>
</LI><LI CLASS="li-links"><A HREF="libref/Lexing.html">Module <TT>Lexing</TT>: the run-time library for lexers generated by <TT>ocamllex</TT></A>
</LI><LI CLASS="li-links"><A HREF="libref/List.html">Module <TT>List</TT>: list operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/ListLabels.html">Module <TT>ListLabels</TT>: list operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Map.html">Module <TT>Map</TT>: association tables over ordered types</A>
</LI><LI CLASS="li-links"><A HREF="libref/Marshal.html">Module <TT>Marshal</TT>: marshaling of data structures</A>
</LI><LI CLASS="li-links"><A HREF="libref/MoreLabels.html">Module <TT>MoreLabels</TT>: Include modules <TT>Hashtbl</TT>, <TT>Map</TT> and <TT>Set</TT> with labels</A>
</LI><LI CLASS="li-links"><A HREF="libref/Nativeint.html">Module <TT>Nativeint</TT>: processor-native integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Oo.html">Module <TT>Oo</TT>: object-oriented extension</A>
</LI><LI CLASS="li-links"><A HREF="libref/Parsing.html">Module <TT>Parsing</TT>: the run-time library for parsers generated by <TT>ocamlyacc</TT></A>
</LI><LI CLASS="li-links"><A HREF="libref/Printexc.html">Module <TT>Printexc</TT>: facilities for printing exceptions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Printf.html">Module <TT>Printf</TT>: formatting printing functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Queue.html">Module <TT>Queue</TT>: first-in first-out queues</A>
</LI><LI CLASS="li-links"><A HREF="libref/Random.html">Module <TT>Random</TT>: pseudo-random number generator (PRNG)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Scanf.html">Module <TT>Scanf</TT>: formatted input functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Set.html">Module <TT>Set</TT>: sets over ordered types</A>
</LI><LI CLASS="li-links"><A HREF="libref/Sort.html">Module <TT>Sort</TT>: sorting and merging lists</A>
</LI><LI CLASS="li-links"><A HREF="libref/Stack.html">Module <TT>Stack</TT>: last-in first-out stacks</A>
</LI><LI CLASS="li-links"><A HREF="libref/StdLabels.html">Module <TT>StdLabels</TT>: Include modules <TT>Array</TT>, <TT>List</TT> and <TT>String</TT> with labels</A>
</LI><LI CLASS="li-links"><A HREF="libref/Stream.html">Module <TT>Stream</TT>: streams and parsers</A>
</LI><LI CLASS="li-links"><A HREF="libref/String.html">Module <TT>String</TT>: string operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/StringLabels.html">Module <TT>StringLabels</TT>: string operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Sys.html">Module <TT>Sys</TT>: system interface</A>
</LI><LI CLASS="li-links"><A HREF="libref/Weak.html">Module <TT>Weak</TT>: arrays of weak pointers</A>
</LI></UL><!--TOC chapter The unix library: Unix system calls-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc300">Chapter&#XA0;22</A>&#XA0;&#XA0;The unix library: Unix system calls</H1><!--SEC END --><P>The <TT>unix</TT> library makes many Unix
system calls and system-related library functions available to
OCaml programs. This chapter describes briefly the functions
provided. Refer to sections 2&#XA0;and&#XA0;3 of the Unix manual for more
details on the behavior of these functions.</P><P>Not all functions are provided by all Unix variants. If some functions
are not available, they will raise <TT>Invalid_arg</TT> when called.</P><P>Programs that use the <TT>unix</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> unix.cma <I>other files</I>
        ocamlopt <I>other options</I> unix.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>unix</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop unix.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "unix.cma";;</TT>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
A fairly complete emulation of the Unix system calls is provided in
the Windows version of OCaml. The end of this chapter gives
more information on the functions that are not supported under Windows.
</BLOCKQUOTE><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Unix.html">Module <TT>Unix</TT>: Unix system calls</A>
</LI><LI CLASS="li-links"><A HREF="libref/UnixLabels.html">Module <TT>UnixLabels</TT>: Labeled
Unix system calls</A>
</LI></UL><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
The Cygwin port of OCaml fully implements all functions from
the Unix module. The native Win32 ports implement a subset of them.
Below is a list of the functions that are not implemented, or only
partially implemented, by the Win32 ports. Functions not mentioned are
fully implemented and behave as described previously in this chapter.<DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Functions</B></TD><TD ALIGN=center NOWRAP><B>Comment</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fork</TT></TD><TD VALIGN=top ALIGN=left>not implemented, use <TT>create_process</TT> or threads</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>wait</TT></TD><TD VALIGN=top ALIGN=left>not implemented, use <TT>waitpid</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>waitpid</TT></TD><TD VALIGN=top ALIGN=left>can only wait for a given PID, not any child process</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getppid</TT></TD><TD VALIGN=top ALIGN=left>not implemented (meaningless under Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>nice</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>truncate</TT>, <TT>ftruncate</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>link</TT>, <TT>symlink</TT>, <TT>readlink</TT></TD><TD VALIGN=top ALIGN=left>not implemented (no links under
Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>access</TT></TD><TD VALIGN=top ALIGN=left>execute permission <TT>X_OK</TT> cannot be tested,
it just tests for read permission instead</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>fchmod</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>chown</TT>, <TT>fchown</TT></TD><TD VALIGN=top ALIGN=left>not implemented (make no sense on a DOS
file system)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>umask</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>mkfifo</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>kill</TT>, <TT>pause</TT></TD><TD VALIGN=top ALIGN=left>not implemented (no inter-process signals in Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>alarm</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>times</TT></TD><TD VALIGN=top ALIGN=left>partially implemented, will not report timings for child
processes</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getitimer</TT>, <TT>setitimer</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getuid</TT>, <TT>getgid</TT></TD><TD VALIGN=top ALIGN=left>always return 1</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getgid</TT>, <TT>getegid</TT>, <TT>getgroups</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>setuid</TT>, <TT>setgid</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getpwnam</TT>, <TT>getpwuid</TT></TD><TD VALIGN=top ALIGN=left>always raise <TT>Not_found</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getgrnam</TT>, <TT>getgrgid</TT></TD><TD VALIGN=top ALIGN=left>always raise <TT>Not_found</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>type <TT>socket_domain</TT></TD><TD VALIGN=top ALIGN=left>the domains <TT>PF_UNIX</TT> and <TT>PF_INET6</TT>
are not supported; <TT>PF_INET</TT> is fully supported</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>establish_server</TT></TD><TD VALIGN=top ALIGN=left>not implemented; use threads</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>terminal functions (<TT>tc*</TT>)</TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
</TABLE></DIV></BLOCKQUOTE><!--TOC chapter The num library: arbitrary-precision rational arithmetic-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc301">Chapter&#XA0;23</A>&#XA0;&#XA0;The num library: arbitrary-precision rational arithmetic</H1><!--SEC END --><P>The <TT>num</TT> library implements integer arithmetic and rational
arithmetic in arbitrary precision.</P><P>More documentation on the functions provided in this library can be found
in <EM>The CAML Numbers Reference Manual</EM> by
Val&#XE9;rie M&#XE9;nissier-Morain, technical report 141, INRIA, july 1992
(available electronically,
<TT><A HREF="http://hal.inria.fr/docs/00/07/00/27/PDF/RT-0141.pdf">http://hal.inria.fr/docs/00/07/00/27/PDF/RT-0141.pdf</A></TT>).</P><P>Programs that use the <TT>num</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> nums.cma <I>other files</I>
        ocamlopt <I>other options</I> nums.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>nums</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop nums.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "nums.cma";;</TT>.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Num.html">Module <TT>Num</TT>: operation on arbitrary-precision numbers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Big_int.html">Module <TT>Big_int</TT>: operations on arbitrary-precision integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Arith_status.html">Module <TT>Arith_status</TT>: flags that control rational arithmetic</A>
</LI></UL><!--TOC chapter The str library: regular expressions and string processing-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc302">Chapter&#XA0;24</A>&#XA0;&#XA0;The str library: regular expressions and string processing</H1><!--SEC END --><P>The <TT>str</TT> library provides high-level string processing functions,
some based on regular expressions. It is intended to support the kind
of file processing that is usually performed with scripting languages
such as <TT>awk</TT>, <TT>perl</TT> or <TT>sed</TT>.</P><P>Programs that use the <TT>str</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> str.cma <I>other files</I>
        ocamlopt <I>other options</I> str.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>str</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop str.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "str.cma";;</TT>.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Str.html">Module <TT>Str</TT>: regular expressions and string processing</A>
</LI></UL><!--TOC chapter The threads library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc303">Chapter&#XA0;25</A>&#XA0;&#XA0;The threads library</H1><!--SEC END --><P>
<A NAME="c:threads"></A>
</P><P>The <TT>threads</TT> library allows concurrent programming in OCaml.
It provides multiple threads of control (also called lightweight
processes) that execute concurrently in the same memory space. Threads
communicate by in-place modification of shared data structures, or by
sending and receiving data on communication channels.</P><P>The <TT>threads</TT> library is implemented by time-sharing on a single
processor. It will not take advantage of multi-processor machines.
Using this library will therefore never make programs run
faster. However, many programs are easier to write when structured as
several communicating processes.</P><P>Two implementations of the <TT>threads</TT> library are available, depending
on the capabilities of the operating system:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
System threads. This implementation builds on the OS-provided threads
facilities: POSIX 1003.1c threads for Unix, and Win32 threads for
Windows. When available, system threads support both bytecode and
native-code programs.
</LI><LI CLASS="li-itemize">VM-level threads. This implementation performs time-sharing and
context switching at the level of the OCaml virtual machine (bytecode
interpreter). It is available on Unix systems, and supports only
bytecode programs. It cannot be used with native-code programs.
</LI></UL><P>
Programs that use system threads must be linked as follows:
</P><PRE>
        ocamlc -thread <I>other options</I> unix.cma threads.cma <I>other files</I>
        ocamlopt -thread <I>other options</I> unix.cmxa threads.cmxa <I>other files</I>
</PRE><P>
Compilation units that use the <TT>threads</TT> library must also be compiled with
the <TT>-thread</TT> option (see chapter&#XA0;<A HREF="#c:camlc">8</A>).</P><P>Programs that use VM-level threads must be compiled with the <TT>-vmthread</TT>
option to <TT>ocamlc</TT> (see chapter&#XA0;<A HREF="#c:camlc">8</A>), and be linked as follows:
</P><PRE>
        ocamlc -vmthread <I>other options</I> threads.cma <I>other files</I>
</PRE><P>
Compilation units that use <TT>threads</TT> library must also be compiled with
the <TT>-vmthread</TT> option (see chapter&#XA0;<A HREF="#c:camlc">8</A>).</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Thread.html">Module <TT>Thread</TT>: lightweight threads</A>
</LI><LI CLASS="li-links"><A HREF="libref/Mutex.html">Module <TT>Mutex</TT>: locks for mutual exclusion</A>
</LI><LI CLASS="li-links"><A HREF="libref/Condition.html">Module <TT>Condition</TT>: condition variables to synchronize between threads</A>
</LI><LI CLASS="li-links"><A HREF="libref/Event.html">Module <TT>Event</TT>: first-class synchronous communication</A>
</LI><LI CLASS="li-links"><A HREF="libref/ThreadUnix.html">Module <TT>ThreadUnix</TT>: thread-compatible system calls</A>
</LI></UL><!--TOC chapter The graphics library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc304">Chapter&#XA0;26</A>&#XA0;&#XA0;The graphics library</H1><!--SEC END --><P>The <TT>graphics</TT> library provides a set of portable drawing primitives.
Drawing takes place
in a separate window that is created when <TT>Graphics.open_graph</TT> is called.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0;
This library is implemented under the X11 windows system. 
Programs that use the <TT>graphics</TT> library must be linked as follows:
<PRE>
        ocamlc <I>other options</I> graphics.cma <I>other files</I>
</PRE>
For interactive use of the <TT>graphics</TT> library, do:
<PRE>
        ocamlmktop -o mytop graphics.cma
        ./mytop
</PRE>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "graphics.cma";;</TT>.<P>Here are the graphics mode specifications supported by
<TT>Graphics.open_graph</TT> on
the X11 implementation of this library:
the argument to <TT>Graphics.open_graph</TT> has the format
<TT>"</TT><I>display-name geometry</I><TT>"</TT>,
where <I>display-name</I> is the name of the X-windows display to
connect to, and <I>geometry</I> is a standard X-windows geometry
specification. The two components are separated by a space. Either can
be omitted, or both. Examples:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>Graphics.open_graph "foo:0"</TT></B></DT><DD CLASS="dd-description">
connects to the display <TT>foo:0</TT> and creates a window with the default geometry
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph "foo:0 300x100+50-0"</TT></B></DT><DD CLASS="dd-description">
connects to the display <TT>foo:0</TT> and creates a window 300 pixels wide
by 100 pixels tall, at location (50,0)
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph " 300x100+50-0"</TT></B></DT><DD CLASS="dd-description">
connects to the default display and creates a window 300 pixels wide
by 100 pixels tall, at location (50,0)
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph ""</TT></B></DT><DD CLASS="dd-description">
connects to the default display and creates a window with the default
geometry.
</DD></DL></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
This library is available both for standalone compiled programs and
under the toplevel application <TT>ocamlwin.exe</TT>. For the latter, this
library must be loaded in-core by typing
<PRE>        #load "graphics.cma";;
</PRE></BLOCKQUOTE><P>The screen coordinates are interpreted as shown in the figure below.
Notice that the coordinate system used is the same as in mathematics:
<I>y</I> increases from the bottom of the screen to the top of the screen,
and angles are measured counterclockwise (in degrees).
Drawing is clipped to the screen.
</P><DIV CLASS="center">
<IMG SRC="libgraph.gif">
</DIV><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Graphics.html">Module <TT>Graphics</TT>: machine-independent graphics primitives</A>
</LI></UL><!--TOC chapter The dynlink library: dynamic loading and linking of object files-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc305">Chapter&#XA0;27</A>&#XA0;&#XA0;The dynlink library: dynamic loading and linking of object files</H1><!--SEC END --><P>The <TT>dynlink</TT> library supports type-safe dynamic loading and linking
of bytecode object files (<TT>.cmo</TT> and <TT>.cma</TT> files) in a running
bytecode program, or of native plugins (usually <TT>.cmxs</TT> files) in a
running native program. Type safety is ensured by limiting the set of
modules from the running program that the loaded object file can
access, and checking that the running program and the loaded object
file have been compiled against the same interfaces for these modules.
In native code, there are also some compatibility checks on the
implementations (to avoid errors with cross-module optimizations); it
might be useful to hide <TT>.cmx</TT> files when building native plugins so
that they remain independent of the implementation of modules in the
main program.</P><P>Programs that use the <TT>dynlink</TT> library simply need to link
<TT>dynlink.cma</TT> or <TT>dynlink.cmxa</TT> with their object files and other libraries. </P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Dynlink.html">Module <TT>Dynlink</TT>: dynamic loading of bytecode object files</A>
</LI></UL><!--TOC chapter The LablTk library: Tcl/Tk GUI interface-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc306">Chapter&#XA0;28</A>&#XA0;&#XA0;The LablTk library: Tcl/Tk GUI interface</H1><!--SEC END --><P>The <TT>labltk</TT> library provides access to the Tcl/Tk GUI from
OCaml programs. This interface is generated in an automated way, and
you should refer to Tcl/Tk books and man pages for detailed
information on the behavior of the numerous functions. We also suggest
to use <TT>ocamlbrowser</TT> to see the types of the various functions, that
are the best documentation for the library itself.</P><P><BR>
Programs that use the <TT>labltk</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> -I +labltk labltk.cma <I>other files</I>
        ocamlopt <I>other options</I> -I +labltk labltk.cmxa <I>other files</I>
</PRE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>&#XA0;&#XA0;
The <TT>labltk</TT> library is available for any system with Tcl/Tk installed,
starting from Tcl 7.5/Tk 4.1 up to Tcl/Tk 8.4. Beware that some beta
versions may have compatibility problems.<P>If the library was not compiled correctly, try to run again the
<TT>configure</TT> script with the option <TT>-tkdefs</TT> <I>switches</I>,
where <I>switches</I> is a list of C-style inclusion paths leading to
the right <TT>tcl.h</TT> and <TT>tk.h</TT>, for instance
<TT>"-I/usr/local/include/tcl8.4 -I/usr/local/include/tk8.4"</TT>.</P><P>A script is installed, to make easier the use of the <TT>labltk</TT>
library as toplevel.
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>labltk</B></TT></DT><DD CLASS="dd-description">
This is a toplevel including the <TT>labltk</TT> library, and the path is
already set as to allow the use of the various modules. It also
includes code for the Unix and Str libraries. You can use it
in place of <TT>ocaml</TT>.
</DD></DL></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>&#XA0;&#XA0;
The <TT>labltk</TT> library has been precompiled for use with Tcl/Tk 8.4.
You must first have it installed on your system.
It can be downloaded from<BR>
<TT>http://www.activestate.com/products/ActiveTcl/</TT>.
After installing it, you must put the dynamically loaded libraries
<TT>tcl84.dll</TT> and <TT>tk84.dll</TT> (from the <TT>bin</TT> directory of the Tcl
installation) in a directory included in you path.<P>No toplevel is available, but you can load the library from the
standard toplevel with the following commands.
</P><BLOCKQUOTE CLASS="quote">
<PRE># #directory "+labltk";;
# #load "labltk.cma";;
</PRE></BLOCKQUOTE><P>
You can also load it directly from the command line.
</P><BLOCKQUOTE CLASS="quote">
<PRE>C:\ocaml\bin&gt; ocaml -I +labltk labltk.cma
</PRE></BLOCKQUOTE></BLOCKQUOTE><P>The <TT>labltk</TT> library is composed of a large number of modules.
</P><BLOCKQUOTE CLASS="quote">
<PRE>Bell                Imagebitmap         Place
Button              Imagephoto          Radiobutton
Canvas              Label               Scale
Checkbutton         Listbox             Scrollbar
Clipboard           Menu                Selection
Dialog              Menubutton          Text
Entry               Message             Tk
Focus               Option              Tkwait
Frame               Optionmenu          Toplevel
Grab                Pack                Winfo
Grid                Palette             Wm
</PRE></BLOCKQUOTE><P>Giving a detailed account of each of these module would be impractical
here. We will just present some of the basic functions in the module
<TT>Tk</TT>. Note that for most other modules information can be found in the
Tcl <TT>man</TT> page of their name.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Tk.html">The <TT>Tk</TT> library: Basic functions and types for LablTk</A>
</LI></UL><!--TOC chapter The bigarray library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc307">Chapter&#XA0;29</A>&#XA0;&#XA0;The bigarray library</H1><!--SEC END --><P>The <TT>bigarray</TT> library implements large, multi-dimensional, numerical
arrays. These arrays are called &#X201C;big arrays&#X201D; to distinguish them
from the standard OCaml arrays described in
<A HREF="libref/Array.html">Module <TT>Array</TT></A>.
The main differences between &#X201C;big arrays&#X201D; and standard OCaml arrays
are as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Big arrays are not limited in size, unlike OCaml arrays
(<TT>float array</TT> are limited to 2097151 elements on a 32-bit platform,
other <TT>array</TT> types to 4194303 elements).
</LI><LI CLASS="li-itemize">Big arrays are multi-dimensional. Any number of dimensions
between 1 and 16 is supported. In contrast, OCaml arrays are
mono-dimensional and require encoding multi-dimensional arrays as
arrays of arrays.
</LI><LI CLASS="li-itemize">Big arrays can only contain integers and floating-point
numbers, while OCaml arrays can contain arbitrary OCaml data types.
However, big arrays provide more space-efficient storage of integer
and floating-point elements, in particular because they support
&#X201C;small&#X201D; types such as single-precision floats and 8 and 16-bit
integers, in addition to the standard OCaml types of double-precision
floats and 32 and 64-bit integers.
</LI><LI CLASS="li-itemize">The memory layout of big arrays is entirely compatible with that
of arrays in C and Fortran, allowing large arrays to be passed back
and forth between OCaml code and C / Fortran code with no data copying
at all.
</LI><LI CLASS="li-itemize">Big arrays support interesting high-level operations that normal
arrays do not provide efficiently, such as extracting sub-arrays and
&#X201C;slicing&#X201D; a multi-dimensional array along certain dimensions, all
without any copying.
</LI></UL><P>
Programs that use the <TT>bigarray</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> bigarray.cma <I>other files</I>
        ocamlopt <I>other options</I> bigarray.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>bigarray</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop bigarray.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "bigarray.cma";;</TT>.</P><!--TOC section Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc308">29.1</A>&#XA0;&#XA0;Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays</H2><!--SEC END --><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Bigarray.html">Module <TT>Bigarray</TT></A>
</LI></UL><!--TOC section Big arrays in the OCaml-C interface-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc309">29.2</A>&#XA0;&#XA0;Big arrays in the OCaml-C interface</H2><!--SEC END --><P>C stub code that interface C or Fortran code with OCaml code, as
described in chapter&#XA0;<A HREF="#c:intf-c">19</A>, can exploit big arrays as
follows.</P><!--TOC subsection Include file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc310">29.2.1</A>&#XA0;&#XA0;Include file</H3><!--SEC END --><P>The include file <TT>&lt;caml/bigarray.h&gt;</TT> must be included in the C stub
file. It declares the functions, constants and macros discussed
below.</P><!--TOC subsection Accessing an OCaml bigarray from C or Fortran-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc311">29.2.2</A>&#XA0;&#XA0;Accessing an OCaml bigarray from C or Fortran</H3><!--SEC END --><P>If <I>v</I> is a OCaml <TT>value</TT> representing a big array, the expression
<TT>Data_bigarray_val(</TT><I>v</I><TT>)</TT> returns a pointer to the data part of the array.
This pointer is of type <TT>void *</TT> and can be cast to the appropriate C
type for the array (e.g. <TT>double []</TT>, <TT>char [][10]</TT>, etc).</P><P>Various characteristics of the OCaml big array can be consulted from C
as follows:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>C expression</B></TD><TD ALIGN=center NOWRAP><B>Returns</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;num_dims</TT></TD><TD ALIGN=left NOWRAP>number of dimensions</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;dim[</TT><I>i</I><TT>]</TT></TD><TD ALIGN=left NOWRAP><I>i</I>-th dimension</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;flags &amp; BIGARRAY_KIND_MASK</TT></TD><TD ALIGN=left NOWRAP>kind of array elements</TD></TR>
</TABLE></DIV><P>
The kind of array elements is one of the following constants:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constant</B></TD><TD ALIGN=center NOWRAP><B>Element kind</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>BIGARRAY_FLOAT32</TT></TD><TD ALIGN=left NOWRAP>32-bit single-precision floats</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_FLOAT64</TT></TD><TD ALIGN=left NOWRAP>64-bit double-precision floats</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_SINT8</TT></TD><TD ALIGN=left NOWRAP>8-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_UINT8</TT></TD><TD ALIGN=left NOWRAP>8-bit unsigned integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_SINT16</TT></TD><TD ALIGN=left NOWRAP>16-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_UINT16</TT></TD><TD ALIGN=left NOWRAP>16-bit unsigned integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_INT32</TT></TD><TD ALIGN=left NOWRAP>32-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_INT64</TT></TD><TD ALIGN=left NOWRAP>64-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_CAML_INT</TT></TD><TD ALIGN=left NOWRAP>31- or 63-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_NATIVE_INT</TT></TD><TD ALIGN=left NOWRAP>32- or 64-bit (platform-native) integers</TD></TR>
</TABLE></DIV><P>
The following example shows the passing of a two-dimensional big array
to a C function and a Fortran function.
</P><PRE>    extern void my_c_function(double * data, int dimx, int dimy);
    extern void my_fortran_function_(double * data, int * dimx, int * dimy);

    value caml_stub(value bigarray)
    {
      int dimx = Bigarray_val(bigarray)-&gt;dim[0];
      int dimy = Bigarray_val(bigarray)-&gt;dim[1];
      /* C passes scalar parameters by value */
      my_c_function(Data_bigarray_val(bigarray), dimx, dimy);
      /* Fortran passes all parameters by reference */
      my_fortran_function_(Data_bigarray_val(bigarray), &amp;dimx, &amp;dimy);
      return Val_unit;
    }
</PRE><!--TOC subsection Wrapping a C or Fortran array as an OCaml big array-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc312">29.2.3</A>&#XA0;&#XA0;Wrapping a C or Fortran array as an OCaml big array</H3><!--SEC END --><P>A pointer <I>p</I> to an already-allocated C or Fortran array can be
wrapped and returned to OCaml as a big array using the <TT>alloc_bigarray</TT>
or <TT>alloc_bigarray_dims</TT> functions.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>alloc_bigarray(</TT><I>kind</I> <TT>|</TT> <I>layout</I>, <I>numdims</I>, <I>p</I>, <I>dims</I><TT>)</TT><P>Return an OCaml big array wrapping the data pointed to by <I>p</I>.
<I>kind</I> is the kind of array elements (one of the <TT>BIGARRAY_</TT>
kind constants above). <I>layout</I> is <TT>BIGARRAY_C_LAYOUT</TT> for an
array with C layout and <TT>BIGARRAY_FORTRAN_LAYOUT</TT> for an array with
Fortran layout. <I>numdims</I> is the number of dimensions in the
array. <I>dims</I> is an array of <I>numdims</I> long integers, giving
the sizes of the array in each dimension.</P></LI><LI CLASS="li-itemize"><TT>alloc_bigarray_dims(</TT><I>kind</I> <TT>|</TT> <I>layout</I>, <I>numdims</I>,
<I>p</I>, <TT>(long) </TT><I>dim</I><SUB>1</SUB>, <TT>(long) </TT><I>dim</I><SUB>2</SUB>, &#X2026;, <TT>(long) </TT><I>dim<SUB>numdims</SUB></I><TT>)</TT><P>Same as <TT>alloc_bigarray</TT>, but the sizes of the array in each dimension
are listed as extra arguments in the function call, rather than being
passed as an array.
</P></LI></UL><P>
The following example illustrates how statically-allocated C and
Fortran arrays can be made available to OCaml.
</P><PRE>    extern long my_c_array[100][200];
    extern float my_fortran_array_[300][400];

    value caml_get_c_array(value unit)
    {
      long dims[2];
      dims[0] = 100; dims[1] = 200;
      return alloc_bigarray(BIGARRAY_NATIVE_INT | BIGARRAY_C_LAYOUT,
                            2, my_c_array, dims);
    }

    value caml_get_fortran_array(value unit)
    {
      return alloc_bigarray_dims(BIGARRAY_FLOAT32 | BIGARRAY_FORTRAN_LAYOUT,
                                 2, my_fortran_array_, 300L, 400L);
    }
</PRE><!--TOC part Appendix-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc313">Part&#XA0;V</A><BR>
Appendix</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:appendix"></A></P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/index_modules.html">Index of modules</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_module_types.html">Index of module types</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_types.html">Index of types</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_exceptions.html">Index of exceptions</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_values.html">Index of values</A>
</LI></UL><!--TOC chapter Index of keywords-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index of keywords</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
<TT>and</TT>, see <I><TT>let</TT>, <TT>type</TT>, <TT>class</TT></I>, <A HREF="#@manual.kwd84">6.9.2</A>, <A HREF="#@manual.kwd109">6.9.3</A>, <A HREF="#@manual.kwd113">6.9.4</A>, <A HREF="#@manual.kwd117">6.9.5</A>
</LI><LI CLASS="li-indexenv"><TT>as</TT>, <A HREF="#@manual.kwd2">6.4</A>, <A HREF="#@manual.kwd3">6.4</A>, <A HREF="#@manual.kwd4">6.4</A>, <A HREF="#@manual.kwd5">6.6</A>, <A HREF="#@manual.kwd6">6.6</A>, <A HREF="#@manual.kwd7">6.6</A>, <A HREF="#@manual.kwd86">6.9.2</A>, <A HREF="#@manual.kwd95">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>assert</TT>, <A HREF="#@manual.kwd173">7.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>begin</TT>, <A HREF="#@manual.kwd27">6.7</A>, <A HREF="#@manual.kwd39">6.7.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>class</TT>, <A HREF="#@manual.kwd108">6.9.3</A>, <A HREF="#@manual.kwd112">6.9.4</A>, <A HREF="#@manual.kwd115">6.9.5</A>, <A HREF="#@manual.kwd127">6.10</A>, <A HREF="#@manual.kwd137">6.10.2</A>, <A HREF="#@manual.kwd138">6.10.2</A>, <A HREF="#@manual.kwd154">6.11</A>, <A HREF="#@manual.kwd164">6.11.2</A>, <A HREF="#@manual.kwd165">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>constraint</TT>, <A HREF="#@manual.kwd55">6.8.1</A>, <A HREF="#@manual.kwd57">6.8.1</A>, <A HREF="#@manual.kwd67">6.9.1</A>, <A HREF="#@manual.kwd77">6.9.1</A>, <A HREF="#@manual.kwd92">6.9.2</A>, <A HREF="#@manual.kwd106">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>do</TT>, see <I><TT>while</TT>, <TT>for</TT></I>
</LI><LI CLASS="li-indexenv"><TT>done</TT>, see <I><TT>while</TT>, <TT>for</TT></I>
</LI><LI CLASS="li-indexenv"><TT>downto</TT>, see <TT><I>for</I></TT>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>else</TT>, see <TT><I>if</I></TT>
</LI><LI CLASS="li-indexenv"><TT>end</TT>, <A HREF="#@manual.kwd28">6.7</A>, <A HREF="#@manual.kwd40">6.7.1</A>, <A HREF="#@manual.kwd60">6.9.1</A>, <A HREF="#@manual.kwd79">6.9.2</A>, <A HREF="#@manual.kwd120">6.10</A>, <A HREF="#@manual.kwd132">6.10.2</A>, <A HREF="#@manual.kwd148">6.11</A>, <A HREF="#@manual.kwd159">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>exception</TT>, <A HREF="#@manual.kwd58">6.8.2</A>, <A HREF="#@manual.kwd126">6.10</A>, <A HREF="#@manual.kwd136">6.10.2</A>, <A HREF="#@manual.kwd153">6.11</A>, <A HREF="#@manual.kwd163">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>external</TT>, <A HREF="#@manual.kwd124">6.10</A>, <A HREF="#@manual.kwd134">6.10.2</A>, <A HREF="#@manual.kwd151">6.11</A>, <A HREF="#@manual.kwd161">6.11.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>false</TT>, <A HREF="#@manual.kwd0">6.3</A>
</LI><LI CLASS="li-indexenv"><TT>for</TT>, <A HREF="#@manual.kwd20">6.7</A>, <A HREF="#@manual.kwd49">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>fun</TT>, <A HREF="#@manual.kwd14">6.7</A>, <A HREF="#@manual.kwd34">6.7</A>, <A HREF="#@manual.kwd42">6.7.1</A>, <A HREF="#@manual.kwd80">6.9.2</A>, <A HREF="#@manual.kwd185">7.13</A>
</LI><LI CLASS="li-indexenv"><TT>function</TT>, <A HREF="#@manual.kwd13">6.7</A>, <A HREF="#@manual.kwd35">6.7</A>, <A HREF="#@manual.kwd41">6.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>functor</TT>, <A HREF="#@manual.kwd121">6.10</A>, <A HREF="#@manual.kwd145">6.10.3</A>, <A HREF="#@manual.kwd149">6.11</A>, <A HREF="#@manual.kwd172">6.11.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>if</TT>, <A HREF="#@manual.kwd23">6.7</A>, <A HREF="#@manual.kwd33">6.7</A>, <A HREF="#@manual.kwd45">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>in</TT>, see <TT><I>let</I></TT>, <A HREF="#@manual.kwd83">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>include</TT>, <A HREF="#@manual.kwd130">6.10</A>, <A HREF="#@manual.kwd144">6.10.2</A>, <A HREF="#@manual.kwd157">6.11</A>, <A HREF="#@manual.kwd171">6.11.2</A>, <A HREF="#@manual.kwd191">7.15</A>
</LI><LI CLASS="li-indexenv"><TT>inherit</TT>, <A HREF="#@manual.kwd61">6.9.1</A>, <A HREF="#@manual.kwd68">6.9.1</A>, <A HREF="#@manual.kwd85">6.9.2</A>, <A HREF="#@manual.kwd94">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>inherit!</TT>, <A HREF="#@manual.kwd197">7.17</A>
</LI><LI CLASS="li-indexenv"><TT>initializer</TT>, <A HREF="#@manual.kwd93">6.9.2</A>, <A HREF="#@manual.kwd107">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>lazy</TT>, <A HREF="#@manual.kwd174">7.6</A>
</LI><LI CLASS="li-indexenv"><TT>let</TT>, <A HREF="#@manual.kwd11">6.7</A>, <A HREF="#@manual.kwd38">6.7</A>, <A HREF="#@manual.kwd44">6.7.1</A>, <A HREF="#@manual.kwd81">6.9.2</A>, <A HREF="#@manual.kwd150">6.11</A>, <A HREF="#@manual.kwd160">6.11.2</A>, <A HREF="#@manual.kwd175">7.7</A>, <A HREF="#@manual.kwd181">7.10</A>, <A HREF="#@manual.kwd183">7.12</A>
<BR>
<BR>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv"><TT>match</TT>, <A HREF="#@manual.kwd26">6.7</A>, <A HREF="#@manual.kwd36">6.7</A>, <A HREF="#@manual.kwd46">6.7.2</A>, <A HREF="#@manual.kwd199">7.18</A>
</LI><LI CLASS="li-indexenv"><TT>method</TT>, <A HREF="#@manual.kwd64">6.9.1</A>, <A HREF="#@manual.kwd72">6.9.1</A>, <A HREF="#@manual.kwd75">6.9.1</A>, <A HREF="#@manual.kwd89">6.9.2</A>, <A HREF="#@manual.kwd101">6.9.2</A>, <A HREF="#@manual.kwd104">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>method!</TT>, <A HREF="#@manual.kwd195">7.17</A>
</LI><LI CLASS="li-indexenv"><TT>module</TT>, <A HREF="#@manual.kwd128">6.10</A>, <A HREF="#@manual.kwd140">6.10.2</A>, <A HREF="#@manual.kwd142">6.10.2</A>, <A HREF="#@manual.kwd155">6.11</A>, <A HREF="#@manual.kwd167">6.11.2</A>, <A HREF="#@manual.kwd169">6.11.2</A>, <A HREF="#@manual.kwd176">7.7</A>, <A HREF="#@manual.kwd177">7.8</A>, <A HREF="#@manual.kwd186">7.14</A>, <A HREF="#@manual.kwd189">7.15</A>, <A HREF="#@manual.kwd193">7.16</A>
</LI><LI CLASS="li-indexenv"><TT>mutable</TT>, <A HREF="#@manual.kwd54">6.8.1</A>, <A HREF="#@manual.kwd56">6.8.1</A>, <A HREF="#@manual.kwd63">6.9.1</A>, <A HREF="#@manual.kwd70">6.9.1</A>, <A HREF="#@manual.kwd88">6.9.2</A>, <A HREF="#@manual.kwd97">6.9.2</A>, <A HREF="#@manual.kwd100">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>new</TT>, <A HREF="#@manual.kwd30">6.7</A>, <A HREF="#@manual.kwd51">6.7.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>object</TT>, <A HREF="#@manual.kwd31">6.7</A>, <A HREF="#@manual.kwd52">6.7.5</A>, <A HREF="#@manual.kwd59">6.9.1</A>, <A HREF="#@manual.kwd78">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>of</TT>, see <I><TT>type</TT>, <TT>exception</TT></I>
</LI><LI CLASS="li-indexenv"><TT>open</TT>, <A HREF="#@manual.kwd129">6.10</A>, <A HREF="#@manual.kwd143">6.10.2</A>, <A HREF="#@manual.kwd156">6.11</A>, <A HREF="#@manual.kwd170">6.11.2</A>, <A HREF="#@manual.kwd182">7.10</A>
</LI><LI CLASS="li-indexenv"><TT>or</TT>, <A HREF="#@manual.kwd25">6.7</A>, <A HREF="#@manual.kwd32">6.7</A>, <A HREF="#@manual.kwd47">6.7.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>private</TT>, <A HREF="#@manual.kwd65">6.9.1</A>, <A HREF="#@manual.kwd73">6.9.1</A>, <A HREF="#@manual.kwd76">6.9.1</A>, <A HREF="#@manual.kwd90">6.9.2</A>, <A HREF="#@manual.kwd102">6.9.2</A>, <A HREF="#@manual.kwd105">6.9.2</A>, <A HREF="#@manual.kwd179">7.9</A>, <A HREF="#@manual.kwd180">7.9.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>rec</TT>, see <TT><I>let</I></TT>, <A HREF="#@manual.kwd82">6.9.2</A>, <A HREF="#@manual.kwd178">7.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>sig</TT>, <A HREF="#@manual.kwd119">6.10</A>, <A HREF="#@manual.kwd131">6.10.2</A>
</LI><LI CLASS="li-indexenv"><TT>struct</TT>, <A HREF="#@manual.kwd147">6.11</A>, <A HREF="#@manual.kwd158">6.11.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>then</TT>, see <TT><I>if</I></TT>
</LI><LI CLASS="li-indexenv"><TT>to</TT>, see <TT><I>for</I></TT>
</LI><LI CLASS="li-indexenv"><TT>true</TT>, <A HREF="#@manual.kwd1">6.3</A>
</LI><LI CLASS="li-indexenv"><TT>try</TT>, <A HREF="#@manual.kwd12">6.7</A>, <A HREF="#@manual.kwd37">6.7</A>, <A HREF="#@manual.kwd50">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>type</TT>, <A HREF="#@manual.kwd53">6.8.1</A>, <A HREF="#@manual.kwd116">6.9.5</A>, <A HREF="#@manual.kwd125">6.10</A>, <A HREF="#@manual.kwd135">6.10.2</A>, <A HREF="#@manual.kwd139">6.10.2</A>, <A HREF="#@manual.kwd141">6.10.2</A>, <A HREF="#@manual.kwd152">6.11</A>, <A HREF="#@manual.kwd162">6.11.2</A>, <A HREF="#@manual.kwd166">6.11.2</A>, <A HREF="#@manual.kwd168">6.11.2</A>, <A HREF="#@manual.kwd184">7.13</A>, <A HREF="#@manual.kwd190">7.15</A>, <A HREF="#@manual.kwd194">7.16</A>, <A HREF="#@manual.kwd198">7.18</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>val</TT>, <A HREF="#@manual.kwd62">6.9.1</A>, <A HREF="#@manual.kwd69">6.9.1</A>, <A HREF="#@manual.kwd87">6.9.2</A>, <A HREF="#@manual.kwd96">6.9.2</A>, <A HREF="#@manual.kwd99">6.9.2</A>, <A HREF="#@manual.kwd123">6.10</A>, <A HREF="#@manual.kwd133">6.10.2</A>, <A HREF="#@manual.kwd187">7.14</A>
</LI><LI CLASS="li-indexenv"><TT>val!</TT>, <A HREF="#@manual.kwd196">7.17</A>
</LI><LI CLASS="li-indexenv"><TT>virtual</TT>, <A HREF="#@manual.kwd66">6.9.1</A>, <A HREF="#@manual.kwd71">6.9.1</A>, <A HREF="#@manual.kwd74">6.9.1</A>, <A HREF="#@manual.kwd91">6.9.2</A>, <A HREF="#@manual.kwd98">6.9.2</A>, <A HREF="#@manual.kwd103">6.9.2</A>, <A HREF="#@manual.kwd110">6.9.3</A>, <A HREF="#@manual.kwd111">6.9.3</A>, <A HREF="#@manual.kwd114">6.9.4</A>, <A HREF="#@manual.kwd118">6.9.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>when</TT>, <A HREF="#@manual.kwd29">6.7</A>, <A HREF="#@manual.kwd43">6.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>while</TT>, <A HREF="#@manual.kwd48">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>with</TT>, see <I><TT>match</TT>, <TT>try</TT></I>, <A HREF="#@manual.kwd122">6.10</A>, <A HREF="#@manual.kwd146">6.10.4</A>, <A HREF="#@manual.kwd188">7.14</A>, <A HREF="#@manual.kwd192">7.16</A>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://hevea.inria.fr/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>

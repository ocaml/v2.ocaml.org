<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>The OCaml system, release 3.12
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.li-links{margin:0ex 0ex;}
BODY{background:white;}
.part{padding:1ex;background:#00CC00;}
.section{padding:.5ex;background:#66FF66;}
.subsection{padding:0.3ex;background:#7FFF7F;}
.subsubsection{padding:0.5ex;background:#99FF99;}
.chapter{padding:0.5ex;background:#2DE52D;}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background:#00CC00;}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00CC00;}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DE52D;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66FF66;}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #7FFF7F;}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -fix -exec xxdate.exe -O -I .. -I ../refman -I ../library -I ../cmds -I ../tutorials -I ../../styles -I ../texstuff manual.hva -e macros.tex ../manual.tex -->
<!--CUT DEF chapter 1 --><DIV CLASS="center">
 <FONT SIZE=7>The OCaml system<BR>
 release 3.12<BR>
</FONT><FONT SIZE=5>Documentation and user&#X2019;s manual<BR>
</FONT><FONT SIZE=4>Xavier Leroy,<BR>
 Damien Doligez, Alain Frisch, Jacques Garrigue, Didier Rémy and Jérôme Vouillon<BR>
 July 29, 2011<BR>
  
</FONT><FONT SIZE=3>Copyright © 2008 Institut National de
Recherche en Informatique et en Automatique
</FONT></DIV><BLOCKQUOTE CLASS="quote">
<HR SIZE=2>
This manual is also available in
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.pdf">PDF</A>.
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.ps.gz">Postscript</A>,
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.dvi.gz">DVI</A>,
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.txt">plain text</A>,
as a
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.html.tar.gz">bundle of HTML files</A>,
and as a
<A HREF="https://ocaml.org/releases/3.12/ocaml-3.12-refman.info.tar.gz">bundle of Emacs Info files</A>.
<HR SIZE=2>
</BLOCKQUOTE><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">Part I  An introduction to OCaml</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc2">Chapter 1  The core language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc3">1.1  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.2  Data types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.3  Functions as values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.4  Records and variants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">1.5  Imperative features</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.6  Exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.7  Symbolic processing of expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.8  Pretty-printing and parsing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">1.9  Standalone Caml programs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">Chapter 2  The module system</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc13">2.1  Structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.2  Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.3  Functors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">2.4  Functors and type abstraction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">2.5  Modules and separate compilation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">Chapter 3  Objects in Caml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc19">3.1  Classes and objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.2  Immediate objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.3  Reference to self</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.4  Initializers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.5  Virtual methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.6  Private methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.7  Class interfaces</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">3.8  Inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.9  Multiple inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.10  Parameterized classes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">3.11  Polymorphic methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.12  Using coercions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">3.13  Functional objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.14  Cloning objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.15  Recursive classes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">3.16  Binary methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">3.17  Friends</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">Chapter 4  Labels and variants</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc37">4.1  Labels</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc38">4.1.1  Optional arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4.1.2  Labels and type inference</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.1.3  Suggestions for labeling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">4.2  Polymorphic variants</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc42">4.2.1  Weaknesses of polymorphic variants</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">Chapter 5  Advanced examples with classes and modules</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc44">5.1  Extended example: bank accounts</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">5.2  Simple modules as classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc46">5.2.1  Strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">5.2.2  Hashtbl</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.2.3  Sets</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">5.3  The subject/observer pattern</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">Part II  The OCaml language</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc51">Chapter 6  The OCaml language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc52">6.1  Lexical conventions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">6.2  Values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc54">6.2.1  Base values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">6.2.2  Tuples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">6.2.3  Records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">6.2.4  Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">6.2.5  Variant values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">6.2.6  Polymorphic variants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">6.2.7  Functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">6.2.8  Objects</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">6.3  Names</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">6.4  Type expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">6.5  Constants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">6.6  Patterns</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">6.7  Expressions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc67">6.7.1  Basic expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">6.7.2  Control structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">6.7.3  Operations on data structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">6.7.4  Operators</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">6.7.5  Objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">6.7.6  Coercions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">6.8  Type and exception definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc74">6.8.1  Type definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">6.8.2  Exception definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">6.9  Classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc77">6.9.1  Class types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">6.9.2  Class expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">6.9.3  Class definitions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">6.9.4  Class specification</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">6.9.5  Class type definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">6.10  Module types (module specifications)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc83">6.10.1  Simple module types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">6.10.2  Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">6.10.3  Functor types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">6.10.4  The <TT>with</TT> operator</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">6.11  Module expressions (module implementations)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc88">6.11.1  Simple module expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">6.11.2  Structures</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">6.11.3  Functors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">6.12  Compilation units</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">Chapter 7  Language extensions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc93">7.1  Integer literals for types <TT>int32</TT>, <TT>int64</TT> and <TT>nativeint</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">7.2  Streams and stream parsers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">7.3  Recursive definitions of values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">7.4  Range patterns</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">7.5  Assertion checking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">7.6  Lazy evaluation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">7.7  Local modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">7.8  Recursive modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">7.9  Private types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc102">7.9.1  Private variant and record types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">7.9.2  Private type abbreviations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">7.9.3  Private row types</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">7.10  Local opens</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">7.11  Record notations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">7.12  Explicit polymorphic type annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">7.13  Explicit naming of type variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">7.14  First-class modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">7.15  Recovering the type of a module</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">7.16  Substituting inside a signature</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">7.17  Explicit overriding in class definitions</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">Part III  The OCaml tools</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc114">Chapter 8  Batch compilation (ocamlc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc115">8.1  Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">8.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">8.3  Modules and the file system</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">8.4  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">Chapter 9  The toplevel system (ocaml)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc120">9.1  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">9.2  Toplevel directives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">9.3  The toplevel and the module system</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">9.4  Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">9.5  Building custom toplevel systems: <TT>ocamlmktop</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">9.6  Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">Chapter 10  The runtime system (ocamlrun)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc127">10.1  Overview</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">10.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">10.3  Dynamic loading of shared libraries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">10.4  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">Chapter 11  Native-code compilation (ocamlopt)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc132">11.1  Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">11.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">11.3  Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">11.4  Running executables produced by ocamlopt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">11.5  Compatibility with the bytecode compiler</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">Chapter 12  Lexer and parser generators (ocamllex, ocamlyacc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc138">12.1  Overview of <TT>ocamllex</TT></A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc139">12.1.1  Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">12.2  Syntax of lexer definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc141">12.2.1  Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">12.2.2  Naming regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">12.2.3  Entry points</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">12.2.4  Regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">12.2.5  Actions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">12.2.6  Variables in regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">12.2.7  Reserved identifiers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">12.3  Overview of <TT>ocamlyacc</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">12.4  Syntax of grammar definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc150">12.4.1  Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">12.4.2  Declarations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">12.4.3  Rules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">12.4.4  Error handling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc154">12.5  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">12.6  A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">12.7  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">Chapter 13  Dependency generator (ocamldep)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc158">13.1  Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">13.2  A typical Makefile</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">Chapter 14  The browser/editor (ocamlbrowser)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc161">14.1  Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">14.2  Viewer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">14.3  Module browsing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">14.4  File editor</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">14.5  Shell</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc166">Chapter 15  The documentation generator (ocamldoc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc167">15.1  Usage</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc168">15.1.1  Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">15.1.2  Merging of module information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">15.1.3  Coding rules</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">15.2  Syntax of documentation comments</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc172">15.2.1  Placement of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc173">15.2.2  The Stop special comment</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">15.2.3  Syntax of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">15.2.4  Text formatting</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">15.2.5  Documentation tags (@-tags)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">15.3  Custom generators</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc178">15.3.1  The generator class</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc179">15.3.2  Handling custom tags</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc180">15.4  Adding command line options</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc181">15.4.1  Compilation and usage</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">Chapter 16  The debugger (ocamldebug)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc183">16.1  Compiling for debugging</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc184">16.2  Invocation</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc185">16.2.1  Starting the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc186">16.2.2  Exiting the debugger</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc187">16.3  Commands</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc188">16.3.1  Getting help</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc189">16.3.2  Accessing the debugger state</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">16.4  Executing a program</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc191">16.4.1  Events</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">16.4.2  Starting the debugged program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">16.4.3  Running the program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">16.4.4  Time travel</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">16.4.5  Killing the program</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc196">16.5  Breakpoints</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">16.6  The call stack</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">16.7  Examining variable values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">16.8  Controlling the debugger</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc200">16.8.1  Setting the program name and arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc201">16.8.2  How programs are loaded</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">16.8.3  Search path for files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">16.8.4  Working directory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">16.8.5  Turning reverse execution on and off</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">16.8.6  Communication between the debugger and the program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc206">16.8.7  Fine-tuning the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">16.8.8  User-defined printers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">16.9  Miscellaneous commands</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc209">16.10  Running the debugger under Emacs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">Chapter 17  Profiling (ocamlprof)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc211">17.1  Compiling for profiling</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc212">17.2  Profiling an execution</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">17.3  Printing profiling information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">17.4  Time profiling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc215">Chapter 18  Interfacing C with OCaml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc216">18.1  Overview and compilation information</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc217">18.1.1  Declaring primitives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc218">18.1.2  Implementing primitives</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc219">18.1.3  Statically linking C code with Caml code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc220">18.1.4  Dynamically linking C code with Caml code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc221">18.1.5  Choosing between static linking and dynamic linking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc222">18.1.6  Building standalone custom runtime systems</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc223">18.2  The <TT>value</TT> type</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc224">18.2.1  Integer values</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc225">18.2.2  Blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc226">18.2.3  Pointers outside the heap</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc227">18.3  Representation of Caml data types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc228">18.3.1  Atomic types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc229">18.3.2  Tuples and records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc230">18.3.3  Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc231">18.3.4  Concrete data types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc232">18.3.5  Objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc233">18.3.6  Polymorphic variants</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc234">18.4  Operations on values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc235">18.4.1  Kind tests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc236">18.4.2  Operations on integers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc237">18.4.3  Accessing blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc238">18.4.4  Allocating blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc239">18.4.5  Raising exceptions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc240">18.5  Living in harmony with the garbage collector</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc241">18.5.1  Simple interface</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc242">18.5.2  Low-level interface</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc243">18.6  A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc244">18.7  Advanced topic: callbacks from C to Caml</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc245">18.7.1  Applying Caml closures from C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc246">18.7.2  Registering Caml closures for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc247">18.7.3  Registering Caml exceptions for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc248">18.7.4  Main program in C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc249">18.7.5  Embedding the Caml code in the C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc250">18.8  Advanced example with callbacks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc251">18.9  Advanced topic: custom blocks</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc252">18.9.1  The <TT>struct custom_operations</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc253">18.9.2  Allocating custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc254">18.9.3  Accessing custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc255">18.9.4  Writing custom serialization and deserialization functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc256">18.9.5  Choosing identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc257">18.9.6  Finalized blocks</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc258">18.10  Advanced topic: multithreading</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc259">18.10.1  Registering threads created from C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc260">18.10.2  Parallel execution of long-running C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc261">18.11  Building mixed C/Caml libraries: <TT>ocamlmklib</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc262">Part IV  The OCaml library</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc263">Chapter 19  The core library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc264">19.1  Built-in types and predefined exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc265">19.2  Module <TT>Pervasives</TT>: the initially opened module</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc266">Chapter 20  The standard library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc267">Chapter 21  The unix library: Unix system calls</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc268">Chapter 22  The num library: arbitrary-precision rational arithmetic</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc269">Chapter 23  The str library: regular expressions and string processing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc270">Chapter 24  The threads library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc271">Chapter 25  The graphics library</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc272">Chapter 26  The dbm library: access to NDBM databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc273">Chapter 27  The dynlink library: dynamic loading and linking of object files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc274">Chapter 28  The LablTk library: Tcl/Tk GUI interface</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc275">Chapter 29  The bigarray library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc276">29.1  Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc277">29.2  Big arrays in the Caml-C interface</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="#htoc278">29.2.1  Include file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc279">29.2.2  Accessing a Caml bigarray from C or Fortran</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc280">29.2.3  Wrapping a C or Fortran array as a Caml big array</A>
</LI></UL>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc281">Part V  Appendix</A>
</LI></UL><!--TOC chapter Foreword-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Foreword</H1><!--SEC END --><P>This manual documents the release 3.12 of the OCaml
system. It is organized as follows.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Part <A HREF="#p:tutorials">I</A>, &#X201C;An introduction to OCaml&#X201D;,
gives an overview of the language.
</LI><LI CLASS="li-itemize">Part <A HREF="#p:refman">II</A>, &#X201C;The OCaml language&#X201D;, is the
reference description of the language.
</LI><LI CLASS="li-itemize">Part <A HREF="#p:commands">III</A>, &#X201C;The OCaml tools&#X201D;, documents
the compilers, toplevel system, and programming utilities.
</LI><LI CLASS="li-itemize">Part <A HREF="#p:library">IV</A>, &#X201C;The OCaml library&#X201D;, describes the
modules provided in the standard library.

</LI></UL><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>OCaml runs on several operating systems. The parts of
this manual that are specific to one operating system are presented as
shown below:</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>   This is material specific to the Unix family of operating
systems, including Linux and MacOS X.
</BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>   This is material specific to Microsoft Windows (2000,
XP, Vista).
</BLOCKQUOTE><!--TOC section License-->
<H2 CLASS="section"><!--SEC ANCHOR -->License</H2><!--SEC END --><P>The OCaml system is copyright © 1996&#X2013;2011
Institut National de Recherche en Informatique et en
Automatique (INRIA).
INRIA holds all ownership rights to the OCaml system. </P><P>The OCaml system is open source and can be freely
redistributed. See the file <TT>LICENSE</TT> in the distribution for
licensing information.</P><P>The present documentation is copyright © 2008 
Institut National de Recherche en Informatique et en
Automatique (INRIA). The OCaml documentation and user&#X2019;s
manual may be reproduced and distributed in whole or
in part, subject to the following conditions: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The copyright notice above and this permission notice must be
preserved complete on all complete or partial copies.
</LI><LI CLASS="li-itemize">Any translation or derivative work of the OCaml
documentation and user&#X2019;s manual must be approved by the authors in
writing before distribution. 
</LI><LI CLASS="li-itemize">If you distribute the OCaml
documentation and user&#X2019;s manual in part, instructions for obtaining
the complete version of this manual must be included, and a
means for obtaining a complete version provided.
</LI><LI CLASS="li-itemize">Small portions may be reproduced as illustrations for reviews or
quotes in other works without this permission notice if proper
citation is given.
</LI></UL><!--TOC section Availability-->
<H2 CLASS="section"><!--SEC ANCHOR -->Availability</H2><!--SEC END --><P>
The complete OCaml distribution can be accessed via the 
<TT><A HREF="http://caml.inria.fr/">http://caml.inria.fr/</A></TT>Caml Web site.
The <TT><A HREF="http://caml.inria.fr/">http://caml.inria.fr/</A></TT>Caml Web site
contains a lot of additional information on OCaml.

</P><!--TOC part An introduction to OCaml-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc1">Part I</A><BR>
An introduction to OCaml</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:tutorials"></A>
</P><!--TOC chapter The core language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc2">Chapter 1</A>  The core language</H1><!--SEC END --><P> <A NAME="c:core-xamples"></A>
</P><P>This part of the manual is a tutorial introduction to the
OCaml language. A good familiarity with programming in a conventional
languages (say, Pascal or C) is assumed, but no prior exposure to
functional languages is required. The present chapter introduces the
core language. Chapter <A HREF="#c:objectexamples">3</A> deals with the
object-oriented features, and chapter <A HREF="#c:moduleexamples">2</A> with the
module system.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.1</A>  Basics</H2><!--SEC END --><P>For this overview of Caml, we use the interactive system, which
is started by running <TT>ocaml</TT> from the Unix shell, or by launching the
<TT>OCamlwin.exe</TT> application under Windows. This tutorial is presented
as the transcript of a session with the interactive system:
lines starting with <TT>#</TT> represent user input; the system responses are
printed below, without a leading <TT>#</TT>.</P><P>Under the interactive system, the user types Caml phrases, terminated
by <TT>;;</TT>, in response to the <TT>#</TT> prompt, and the system compiles them
on the fly, executes them, and prints the outcome of evaluation.
Phrases are either simple expressions, or <TT>let</TT> definitions of
identifiers (either values or functions).
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>1+2*3;;
</FONT><FONT COLOR=maroon>- : int = 7
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let pi = 4.0 *. atan 1.0;;
</FONT>val pi : float = 3.14159265358979312
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let square x = x *. x;;
</FONT>val square : float -&gt; float = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>square(sin pi) +. square(cos pi);;
</FONT>- : float = 1.
</FONT></PRE><P>
The Caml system computes both the value and the type for
each phrase. Even function parameters need no explicit type declaration:
the system infers their types from their usage in the
function. Notice also that integers and floating-point numbers are
distinct types, with distinct operators: <TT>+</TT> and <TT>*</TT> operate on
integers, but <TT>+.</TT> and <TT>*.</TT> operate on floats.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue><U>1.0</U> * 2;;
</FONT><FONT COLOR=maroon>Error: This expression has type float but an expression was expected of type
         int
</FONT></PRE><P>Recursive functions are defined with the <TT>let rec</TT> binding:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec fib n =
   if n &lt; 2 then n else fib(n-1) + fib(n-2);;
</FONT><FONT COLOR=maroon>val fib : int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>fib 10;;
</FONT>- : int = 55
</FONT></PRE><!--TOC section Data types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.2</A>  Data types</H2><!--SEC END --><P>In addition to integers and floating-point numbers, Caml offers the
usual basic data types: booleans, characters, and character strings.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>(1 &lt; 2) = false;;
</FONT><FONT COLOR=maroon>- : bool = false
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>&#X2019;a&#X2019;;;
</FONT>- : char = &#X2019;a&#X2019;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>"Hello world";;
</FONT>- : string = "Hello world"
</FONT></PRE><P>Predefined data structures include tuples, arrays, and lists. General
mechanisms for defining your own data structures are also provided.
They will be covered in more details later; for now, we concentrate on lists.
Lists are either given in extension as a bracketed list of
semicolon-separated elements, or built from the empty list <TT>[]</TT>
(pronounce &#X201C;nil&#X201D;) by adding elements in front using the <TT>::</TT>
(&#X201C;cons&#X201D;) operator.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let l = ["is"; "a"; "tale"; "told"; "etc."];;
</FONT><FONT COLOR=maroon>val l : string list = ["is"; "a"; "tale"; "told"; "etc."]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>"Life" :: l;;
</FONT>- : string list = ["Life"; "is"; "a"; "tale"; "told"; "etc."]
</FONT></PRE><P>
As with all other Caml data structures, lists do not need to be
explicitly allocated and deallocated from memory: all memory
management is entirely automatic in Caml. Similarly, there is no
explicit handling of pointers: the Caml compiler silently introduces
pointers where necessary.</P><P>As with most Caml data structures, inspecting and destructuring lists
is performed by pattern-matching. List patterns have the exact same
shape as list expressions, with identifier representing unspecified
parts of the list. As an example, here is insertion sort on a list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec sort lst =
   match lst with
     [] -&gt; []
   | head :: tail -&gt; insert head (sort tail)
 and insert elt lst =
   match lst with
     [] -&gt; [elt]
   | head :: tail -&gt; if elt &lt;= head then elt :: lst else head :: insert elt tail
 ;;
</FONT><FONT COLOR=maroon>val sort : &#X2019;a list -&gt; &#X2019;a list = &lt;fun&gt;
val insert : &#X2019;a -&gt; &#X2019;a list -&gt; &#X2019;a list = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>sort l;;
</FONT>- : string list = ["a"; "etc."; "is"; "tale"; "told"]
</FONT></PRE><P>The type inferred for <TT>sort</TT>, <TT>&#X2019;a list -&gt; &#X2019;a list</TT>, means that <TT>sort</TT>
can actually apply to lists of any type, and returns a list of the
same type. The type <TT>&#X2019;a</TT> is a <EM>type variable</EM>, and stands for any
given type. The reason why <TT>sort</TT> can apply to lists of any type is
that the comparisons (<TT>=</TT>, <TT>&lt;=</TT>, etc.) are <EM>polymorphic</EM> in Caml:
they operate between any two values of the same type. This makes
<TT>sort</TT> itself polymorphic over all list types.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>sort [6;2;5;3];;
</FONT><FONT COLOR=maroon>- : int list = [2; 3; 5; 6]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>sort [3.14; 2.718];;
</FONT>- : float list = [2.718; 3.14]
</FONT></PRE><P>The <TT>sort</TT> function above does not modify its input list: it builds
and returns a new list containing the same elements as the input list,
in ascending order. There is actually no way in Caml to modify
in-place a list once it is built: we say that lists are <EM>immutable</EM>
data structures. Most Caml data structures are immutable, but a few
(most notably arrays) are <EM>mutable</EM>, meaning that they can be
modified in-place at any time.</P><!--TOC section Functions as values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.3</A>  Functions as values</H2><!--SEC END --><P>Caml is a functional language: functions in the full mathematical
sense are supported and can be passed around freely just as any other
piece of data. For instance, here is a <TT>deriv</TT> function that takes any
float function as argument and returns an approximation of its
derivative function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let deriv f dx = function x -&gt; (f(x +. dx) -. f(x)) /. dx;;
</FONT><FONT COLOR=maroon>val deriv : (float -&gt; float) -&gt; float -&gt; float -&gt; float = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let sin&#X2019; = deriv sin 1e-6;;
</FONT>val sin&#X2019; : float -&gt; float = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>sin&#X2019; pi;;
</FONT>- : float = -1.00000000013961143
</FONT></PRE><P>
Even function composition is definable:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let compose f g = function x -&gt; f(g(x));;
</FONT><FONT COLOR=maroon>val compose : (&#X2019;a -&gt; &#X2019;b) -&gt; (&#X2019;c -&gt; &#X2019;a) -&gt; &#X2019;c -&gt; &#X2019;b = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let cos2 = compose square cos;;
</FONT>val cos2 : float -&gt; float = &lt;fun&gt;
</FONT></PRE><P>Functions that take other functions as arguments are called
&#X201C;functionals&#X201D;, or &#X201C;higher-order functions&#X201D;. Functionals are
especially useful to provide iterators or similar generic operations
over a data structure. For instance, the standard Caml library
provides a <TT>List.map</TT> functional that applies a given function to each
element of a list, and returns the list of the results:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>List.map (function n -&gt; n * 2 + 1) [0;1;2;3;4];;
</FONT><FONT COLOR=maroon>- : int list = [1; 3; 5; 7; 9]
</FONT></PRE><P>
This functional, along with a number of other list and array
functionals, is predefined because it is often useful, but there is
nothing magic with it: it can easily be defined as follows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec map f l =
   match l with
     [] -&gt; []
   | hd :: tl -&gt; f hd :: map f tl;;
</FONT><FONT COLOR=maroon>val map : (&#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;a list -&gt; &#X2019;b list = &lt;fun&gt;
</FONT></PRE><!--TOC section Records and variants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.4</A>  Records and variants</H2><!--SEC END --><P>

<A NAME="s:tut-recvariants"></A></P><P>User-defined data structures include records and variants. Both are
defined with the <TT>type</TT> declaration. Here, we declare a record type to
represent rational numbers.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type ratio = {num: int; denum: int};;
</FONT><FONT COLOR=maroon>type ratio = { num : int; denum : int; }
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let add_ratio r1 r2 =
   {num = r1.num * r2.denum + r2.num * r1.denum;
    denum = r1.denum * r2.denum};;
</FONT>val add_ratio : ratio -&gt; ratio -&gt; ratio = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>add_ratio {num=1; denum=3} {num=2; denum=5};;
</FONT>- : ratio = {num = 11; denum = 15}
</FONT></PRE><P>The declaration of a variant type lists all possible shapes for values
of that type. Each case is identified by a name, called a constructor,
which serves both for constructing values of the variant type and
inspecting them by pattern-matching. Constructor names are capitalized
to distinguish them from variable names (which must start with a
lowercase letter). For instance, here is a variant
type for doing mixed arithmetic (integers and floats):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type number = Int of int | Float of float | Error;;
</FONT><FONT COLOR=maroon>type number = Int of int | Float of float | Error
</FONT></PRE><P>
This declaration expresses that a value of type <TT>number</TT> is either an
integer, a floating-point number, or the constant <TT>Error</TT> representing
the result of an invalid operation (e.g. a division by zero).</P><P>Enumerated types are a special case of variant types, where all
alternatives are constants:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type sign = Positive | Negative;;
</FONT><FONT COLOR=maroon>type sign = Positive | Negative
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let sign_int n = if n &gt;= 0 then Positive else Negative;;
</FONT>val sign_int : int -&gt; sign = &lt;fun&gt;
</FONT></PRE><P>To define arithmetic operations for the <TT>number</TT> type, we use
pattern-matching on the two numbers involved:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let add_num n1 n2 =
   match (n1, n2) with
     (Int i1, Int i2) -&gt;
       (* Check for overflow of integer addition *)
       if sign_int i1 = sign_int i2 &amp;&amp; sign_int(i1 + i2) &lt;&gt; sign_int i1
       then Float(float i1 +. float i2)
       else Int(i1 + i2)
   | (Int i1, Float f2) -&gt; Float(float i1 +. f2)
   | (Float f1, Int i2) -&gt; Float(f1 +. float i2)
   | (Float f1, Float f2) -&gt; Float(f1 +. f2)
   | (Error, _) -&gt; Error
   | (_, Error) -&gt; Error;;
</FONT><FONT COLOR=maroon>val add_num : number -&gt; number -&gt; number = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>add_num (Int 123) (Float 3.14159);;
</FONT>- : number = Float 126.14159
</FONT></PRE><P>The most common usage of variant types is to describe recursive data
structures. Consider for example the type of binary trees:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a btree = Empty | Node of &#X2019;a * &#X2019;a btree * &#X2019;a btree;;
</FONT><FONT COLOR=maroon>type &#X2019;a btree = Empty | Node of &#X2019;a * &#X2019;a btree * &#X2019;a btree
</FONT></PRE><P>
This definition reads as follow: a binary tree containing values of
type <TT>&#X2019;a</TT> (an arbitrary type) is either empty, or is a node containing
one value of type <TT>&#X2019;a</TT> and two subtrees containing also values of type
<TT>&#X2019;a</TT>, that is, two <TT>&#X2019;a btree</TT>.</P><P>Operations on binary trees are naturally expressed as recursive functions
following the same structure as the type definition itself. For
instance, here are functions performing lookup and insertion in
ordered binary trees (elements increase from left to right):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec member x btree =
   match btree with
     Empty -&gt; false
   | Node(y, left, right) -&gt;
       if x = y then true else
       if x &lt; y then member x left else member x right;;
</FONT><FONT COLOR=maroon>val member : &#X2019;a -&gt; &#X2019;a btree -&gt; bool = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec insert x btree =
   match btree with
     Empty -&gt; Node(x, Empty, Empty)
   | Node(y, left, right) -&gt;
       if x &lt;= y then Node(y, insert x left, right)
                 else Node(y, left, insert x right);;
</FONT>val insert : &#X2019;a -&gt; &#X2019;a btree -&gt; &#X2019;a btree = &lt;fun&gt;
</FONT></PRE><!--TOC section Imperative features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">1.5</A>  Imperative features</H2><!--SEC END --><P>Though all examples so far were written in purely applicative style,
Caml is also equipped with full imperative features. This includes the
usual <TT>while</TT> and <TT>for</TT> loops, as well as mutable data structures such
as arrays. Arrays are either given in extension between <TT>[|</TT> and <TT>|]</TT>
brackets, or allocated and initialized with the <TT>Array.create</TT>
function, then filled up later by assignments. For instance, the
function below sums two vectors (represented as float arrays) componentwise.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let add_vect v1 v2 =
   let len = min (Array.length v1) (Array.length v2) in
   let res = Array.create len 0.0 in
   for i = 0 to len - 1 do
     res.(i) &lt;- v1.(i) +. v2.(i)
   done;
   res;;
</FONT><FONT COLOR=maroon>val add_vect : float array -&gt; float array -&gt; float array = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>add_vect [| 1.0; 2.0 |] [| 3.0; 4.0 |];;
</FONT>- : float array = [|4.; 6.|]
</FONT></PRE><P>Record fields can also be modified by assignment, provided they are
declared <TT>mutable</TT> in the definition of the record type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type mutable_point = { mutable x: float; mutable y: float };;
</FONT><FONT COLOR=maroon>type mutable_point = { mutable x : float; mutable y : float; }
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let translate p dx dy =
   p.x &lt;- p.x +. dx; p.y &lt;- p.y +. dy;;
</FONT>val translate : mutable_point -&gt; float -&gt; float -&gt; unit = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let mypoint = { x = 0.0; y = 0.0 };;
</FONT>val mypoint : mutable_point = {x = 0.; y = 0.}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>translate mypoint 1.0 2.0;;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>mypoint;;
</FONT>- : mutable_point = {x = 1.; y = 2.}
</FONT></PRE><P>Caml has no built-in notion of variable &#X2013; identifiers whose current
value can be changed by assignment. (The <TT>let</TT> binding is not an
assignment, it introduces a new identifier with a new scope.)
However, the standard library provides references, which are mutable
indirection cells (or one-element arrays), with operators <TT>!</TT> to fetch
the current contents of the reference and <TT>:=</TT> to assign the contents.
Variables can then be emulated by <TT>let</TT>-binding a reference. For
instance, here is an in-place insertion sort over arrays:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let insertion_sort a =
   for i = 1 to Array.length a - 1 do
     let val_i = a.(i) in
     let j = ref i in
     while !j &gt; 0 &amp;&amp; val_i &lt; a.(!j - 1) do
       a.(!j) &lt;- a.(!j - 1);
       j := !j - 1
     done;
     a.(!j) &lt;- val_i
   done;;
</FONT><FONT COLOR=maroon>val insertion_sort : &#X2019;a array -&gt; unit = &lt;fun&gt;
</FONT></PRE><P>References are also useful to write functions that maintain a current
state between two calls to the function. For instance, the following
pseudo-random number generator keeps the last returned number in a
reference:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let current_rand = ref 0;;
</FONT><FONT COLOR=maroon>val current_rand : int ref = {contents = 0}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let random () =
   current_rand := !current_rand * 25713 + 1345;
   !current_rand;;
</FONT>val random : unit -&gt; int = &lt;fun&gt;
</FONT></PRE><P>Again, there is nothing magic with references: they are implemented as
a one-field mutable record, as follows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a ref = { mutable contents: &#X2019;a };;
</FONT><FONT COLOR=maroon>type &#X2019;a ref = { mutable contents : &#X2019;a; }
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let (!) r = r.contents;;
</FONT>val ( ! ) : &#X2019;a ref -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let (:=) r newval = r.contents &lt;- newval;;
</FONT>val ( := ) : &#X2019;a ref -&gt; &#X2019;a -&gt; unit = &lt;fun&gt;
</FONT></PRE><P>In some special cases, you may need to store a polymorphic function in
a data structure, keeping its polymorphism. Without user-provided
type annotations, this is not allowed, as polymorphism is only
introduced on a global level. However, you can give explicitly
polymorphic types to record fields.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type idref = { mutable id: &#X2019;a. &#X2019;a -&gt; &#X2019;a };;
</FONT><FONT COLOR=maroon>type idref = { mutable id : &#X2019;a. &#X2019;a -&gt; &#X2019;a; }
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let r = {id = fun x -&gt; x};;
</FONT>val r : idref = {id = &lt;fun&gt;}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let g s = (s.id 1, s.id true);;
</FONT>val g : idref -&gt; int * bool = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>r.id &lt;- (fun x -&gt; print_string "called id\n"; x);;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>g r;;
</FONT>called id
called id
- : int * bool = (1, true)
</FONT></PRE><!--TOC section Exceptions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">1.6</A>  Exceptions</H2><!--SEC END --><P>Caml provides exceptions for signalling and handling exceptional
conditions. Exceptions can also be used as a general-purpose non-local
control structure. Exceptions are declared with the <TT>exception</TT>
construct, and signalled with the <TT>raise</TT> operator. For instance, the
function below for taking the head of a list uses an exception to
signal the case where an empty list is given.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>exception Empty_list;;
</FONT><FONT COLOR=maroon>exception Empty_list
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let head l =
   match l with
     [] -&gt; raise Empty_list
   | hd :: tl -&gt; hd;;
</FONT>val head : &#X2019;a list -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>head [1;2];;
</FONT>- : int = 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>head [];;
</FONT>Exception: Empty_list.
</FONT></PRE><P>Exceptions are used throughout the standard library to signal cases
where the library functions cannot complete normally. For instance,
the <TT>List.assoc</TT> function, which returns the data associated with a
given key in a list of (key, data) pairs, raises the predefined
exception <TT>Not_found</TT> when the key does not appear in the list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>List.assoc 1 [(0, "zero"); (1, "one")];;
</FONT><FONT COLOR=maroon>- : string = "one"
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>List.assoc 2 [(0, "zero"); (1, "one")];;
</FONT>Exception: Not_found.
</FONT></PRE><P>Exceptions can be trapped with the <TT>try</TT>&#X2026;<TT>with</TT> construct:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let name_of_binary_digit digit =
   try
     List.assoc digit [0, "zero"; 1, "one"]
   with Not_found -&gt;
     "not a binary digit";;
</FONT><FONT COLOR=maroon>val name_of_binary_digit : int -&gt; string = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>name_of_binary_digit 0;;
</FONT>- : string = "zero"
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>name_of_binary_digit (-1);;
</FONT>- : string = "not a binary digit"
</FONT></PRE><P>The <TT>with</TT> part is actually a regular pattern-matching on the
exception value. Thus, several exceptions can be caught by one
<TT>try</TT>&#X2026;<TT>with</TT> construct. Also, finalization can be performed by
trapping all exceptions, performing the finalization, then raising
again the exception:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let temporarily_set_reference ref newval funct =
   let oldval = !ref in
   try
     ref := newval;
     let res = funct () in
     ref := oldval;
     res
   with x -&gt;
     ref := oldval;
     raise x;;
</FONT><FONT COLOR=maroon>val temporarily_set_reference : &#X2019;a ref -&gt; &#X2019;a -&gt; (unit -&gt; &#X2019;b) -&gt; &#X2019;b = &lt;fun&gt;
</FONT></PRE><!--TOC section Symbolic processing of expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">1.7</A>  Symbolic processing of expressions</H2><!--SEC END --><P>We finish this introduction with a more complete example
representative of the use of Caml for symbolic processing: formal
manipulations of arithmetic expressions containing variables. The
following variant type describes the expressions we shall manipulate:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type expression =
     Const of float
   | Var of string
   | Sum of expression * expression    (* e1 + e2 *)
   | Diff of expression * expression   (* e1 - e2 *)
   | Prod of expression * expression   (* e1 * e2 *)
   | Quot of expression * expression   (* e1 / e2 *)
 ;;
</FONT><FONT COLOR=maroon>type expression =
    Const of float
  | Var of string
  | Sum of expression * expression
  | Diff of expression * expression
  | Prod of expression * expression
  | Quot of expression * expression
</FONT></PRE><P>We first define a function to evaluate an expression given an
environment that maps variable names to their values. For simplicity,
the environment is represented as an association list.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>exception Unbound_variable of string;;
</FONT><FONT COLOR=maroon>exception Unbound_variable of string
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec eval env exp =
   match exp with
     Const c -&gt; c
   | Var v -&gt;
       (try List.assoc v env with Not_found -&gt; raise(Unbound_variable v))
   | Sum(f, g) -&gt; eval env f +. eval env g
   | Diff(f, g) -&gt; eval env f -. eval env g
   | Prod(f, g) -&gt; eval env f *. eval env g
   | Quot(f, g) -&gt; eval env f /. eval env g;;
</FONT>val eval : (string * float) list -&gt; expression -&gt; float = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>eval [("x", 1.0); ("y", 3.14)] (Prod(Sum(Var "x", Const 2.0), Var "y"));;
</FONT>- : float = 9.42
</FONT></PRE><P>Now for a real symbolic processing, we define the derivative of an
expression with respect to a variable <TT>dv</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec deriv exp dv =
   match exp with
     Const c -&gt; Const 0.0
   | Var v -&gt; if v = dv then Const 1.0 else Const 0.0
   | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)
   | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)
   | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
   | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                        Prod(g, g))
 ;;
</FONT><FONT COLOR=maroon>val deriv : expression -&gt; string -&gt; expression = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>deriv (Quot(Const 1.0, Var "x")) "x";;
</FONT>- : expression =
Quot (Diff (Prod (Const 0., Var "x"), Prod (Const 1., Const 1.)),
 Prod (Var "x", Var "x"))
</FONT></PRE><!--TOC section Pretty-printing and parsing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">1.8</A>  Pretty-printing and parsing</H2><!--SEC END --><P>As shown in the examples above, the internal representation (also
called <EM>abstract syntax</EM>) of expressions quickly becomes hard to
read and write as the expressions get larger. We need a printer and a
parser to go back and forth between the abstract syntax and the <EM>concrete syntax</EM>, which in the case of expressions is the familiar
algebraic notation (e.g. <TT>2*x+1</TT>).</P><P>For the printing function, we take into account the usual precedence
rules (i.e. <TT>*</TT> binds tighter than <TT>+</TT>) to avoid printing unnecessary
parentheses. To this end, we maintain the current operator precedence
and print parentheses around an operator only if its precedence is
less than the current precedence.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let print_expr exp =
   (* Local function definitions *)
   let open_paren prec op_prec =
     if prec &gt; op_prec then print_string "(" in
   let close_paren prec op_prec =
     if prec &gt; op_prec then print_string ")" in
   let rec print prec exp =     (* prec is the current precedence *)
     match exp with
       Const c -&gt; print_float c
     | Var v -&gt; print_string v
     | Sum(f, g) -&gt;
         open_paren prec 0;
         print 0 f; print_string " + "; print 0 g;
         close_paren prec 0
     | Diff(f, g) -&gt;
         open_paren prec 0;
         print 0 f; print_string " - "; print 1 g;
         close_paren prec 0
     | Prod(f, g) -&gt;
         open_paren prec 2;
         print 2 f; print_string " * "; print 2 g;
         close_paren prec 2
     | Quot(f, g) -&gt;
         open_paren prec 2;
         print 2 f; print_string " / "; print 3 g;
         close_paren prec 2
   in print 0 exp;;
</FONT><FONT COLOR=maroon>val print_expr : expression -&gt; unit = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let e = Sum(Prod(Const 2.0, Var "x"), Const 1.0);;
</FONT>val e : expression = Sum (Prod (Const 2., Var "x"), Const 1.)
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>print_expr e; print_newline();;
</FONT>2. * x + 1.
- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>print_expr (deriv e "x"); print_newline();;
</FONT>2. * 1. + 0. * x + 0.
- : unit = ()
</FONT></PRE><P>Parsing (transforming concrete syntax into abstract syntax) is usually
more delicate. Caml offers several tools to help write parsers:
on the one hand, Caml versions of the lexer generator Lex and the
parser generator Yacc (see chapter <A HREF="#c:ocamlyacc">12</A>), which handle
LALR(1) languages using push-down automata; on the other hand, a
predefined type of streams (of characters or tokens) and
pattern-matching over streams, which facilitate the writing of
recursive-descent parsers for LL(1) languages. An example using
<TT>ocamllex</TT> and <TT>ocamlyacc</TT> is given in
chapter <A HREF="#c:ocamlyacc">12</A>. Here, we will use stream parsers.
The syntactic support for stream parsers is provided by the Camlp4
preprocessor, which can be loaded into the interactive toplevel via
the <TT>#load</TT> directives below.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>#load "dynlink.cma";;
 
 #load "camlp4o.cma";;
</FONT><FONT COLOR=maroon>	Camlp4 Parsing version 3.12.1

 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>open Genlex;;
 
 let lexer = make_lexer ["("; ")"; "+"; "-"; "*"; "/"];;
</FONT>val lexer : char Stream.t -&gt; Genlex.token Stream.t = &lt;fun&gt;
</FONT></PRE><P>
For the lexical analysis phase (transformation of the input text into
a stream of tokens), we use a &#X201C;generic&#X201D; lexer provided in the
standard library module <TT>Genlex</TT>. The <TT>make_lexer</TT> function takes a
list of keywords and returns a lexing function that &#X201C;tokenizes&#X201D; an
input stream of characters. Tokens are either identifiers, keywords,
or literals (integer, floats, characters, strings). Whitespace and
comments are skipped.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let token_stream = lexer(Stream.of_string "1.0 +x");;
</FONT><FONT COLOR=maroon>val token_stream : Genlex.token Stream.t = &lt;abstr&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>Stream.next token_stream;;
</FONT>- : Genlex.token = Float 1.
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>Stream.next token_stream;;
</FONT>- : Genlex.token = Kwd "+"
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>Stream.next token_stream;;
</FONT>- : Genlex.token = Ident "x"
</FONT></PRE><P>The parser itself operates by pattern-matching on the stream of
tokens. As usual with recursive descent parsers, we use several
intermediate parsing functions to reflect the precedence and
associativity of operators. Pattern-matching over streams is more
powerful than on regular data structures, as it allows recursive calls
to parsing functions inside the patterns, for matching sub-components of
the input stream. See the Camlp4 documentation for more details.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec parse_expr = parser
     [&lt; e1 = parse_mult; e = parse_more_adds e1 &gt;] -&gt; e
 and parse_more_adds e1 = parser
     [&lt; &#X2019;Kwd "+"; e2 = parse_mult; e = parse_more_adds (Sum(e1, e2)) &gt;] -&gt; e
   | [&lt; &#X2019;Kwd "-"; e2 = parse_mult; e = parse_more_adds (Diff(e1, e2)) &gt;] -&gt; e
   | [&lt; &gt;] -&gt; e1
 and parse_mult = parser
     [&lt; e1 = parse_simple; e = parse_more_mults e1 &gt;] -&gt; e
 and parse_more_mults e1 = parser
     [&lt; &#X2019;Kwd "*"; e2 = parse_simple; e = parse_more_mults (Prod(e1, e2)) &gt;] -&gt; e
   | [&lt; &#X2019;Kwd "/"; e2 = parse_simple; e = parse_more_mults (Quot(e1, e2)) &gt;] -&gt; e
   | [&lt; &gt;] -&gt; e1
 and parse_simple = parser
     [&lt; &#X2019;Ident s &gt;] -&gt; Var s
   | [&lt; &#X2019;Int i &gt;] -&gt; Const(float i)
   | [&lt; &#X2019;Float f &gt;] -&gt; Const f
   | [&lt; &#X2019;Kwd "("; e = parse_expr; &#X2019;Kwd ")" &gt;] -&gt; e;;
</FONT><FONT COLOR=maroon>val parse_expr : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
val parse_more_adds : expression -&gt; Genlex.token Stream.t -&gt; expression =
  &lt;fun&gt;
val parse_mult : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
val parse_more_mults : expression -&gt; Genlex.token Stream.t -&gt; expression =
  &lt;fun&gt;
val parse_simple : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let parse_expression = parser [&lt; e = parse_expr; _ = Stream.empty &gt;] -&gt; e;;
</FONT>val parse_expression : Genlex.token Stream.t -&gt; expression = &lt;fun&gt;
</FONT></PRE><P>Composing the lexer and parser, we finally obtain a function to read
an expression from a character string:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let read_expression s = parse_expression(lexer(Stream.of_string s));;
</FONT><FONT COLOR=maroon>val read_expression : string -&gt; expression = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>read_expression "2*(x+y)";;
</FONT>- : expression = Prod (Const 2., Sum (Var "x", Var "y"))
</FONT></PRE><P>
A small puzzle: why do we get different results in the following two
examples?
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>read_expression "x - 1";;
</FONT><FONT COLOR=maroon>- : expression = Diff (Var "x", Const 1.)
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>read_expression "x-1";;
</FONT>Exception: Stream.Error "".
</FONT></PRE><P>
Answer: the generic lexer provided by <TT>Genlex</TT> recognizes negative
integer literals as one integer token. Hence, <TT>x-1</TT> is read as
the token <TT>Ident "x"</TT> followed by the token <TT>Int(-1)</TT>; this sequence
does not match any of the parser rules. On the other hand, 
the second space in <TT>x - 1</TT> causes the lexer to return the three
expected tokens: <TT>Ident "x"</TT>, then <TT>Kwd "-"</TT>, then <TT>Int(1)</TT>.</P><!--TOC section Standalone Caml programs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">1.9</A>  Standalone Caml programs</H2><!--SEC END --><P>All examples given so far were executed under the interactive system.
Caml code can also be compiled separately and executed
non-interactively using the batch compilers <TT>ocamlc</TT> or <TT>ocamlopt</TT>.
The source code must be put in a file with extension <TT>.ml</TT>. It
consists of a sequence of phrases, which will be evaluated at runtime
in their order of appearance in the source file. Unlike in interactive
mode, types and values are not printed automatically; the program must
call printing functions explicitly to produce some output. Here is a
sample standalone program to print Fibonacci numbers:
</P><PRE CLASS="verbatim">(* File fib.ml *)
let rec fib n =
  if n &lt; 2 then 1 else fib(n-1) + fib(n-2);;
let main () =
  let arg = int_of_string Sys.argv.(1) in
  print_int(fib arg);
  print_newline();
  exit 0;;
main ();;
</PRE><P><TT>Sys.argv</TT> is an array of strings containing the command-line
parameters. <TT>Sys.argv.(1)</TT> is thus the first command-line parameter. 
The program above is compiled and executed with the following shell
commands:
</P><PRE CLASS="verbatim">$ ocamlc -o fib fib.ml
$ ./fib 10
89
$ ./fib 20
10946
</PRE><!--TOC chapter The module system-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc12">Chapter 2</A>  The module system</H1><!--SEC END --><P> <A NAME="c:moduleexamples"></A>
</P><P>This chapter introduces the module system of OCaml.</P><!--TOC section Structures-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc13">2.1</A>  Structures</H2><!--SEC END --><P>A primary motivation for modules is to package together related
definitions (such as the definitions of a data type and associated
operations over that type) and enforce a consistent naming scheme for
these definitions. This avoids running out of names or accidentally
confusing names. Such a package is called a <EM>structure</EM> and
is introduced by the <TT>struct</TT>&#X2026;<TT>end</TT> construct, which contains an
arbitrary sequence of definitions. The structure is usually given a
name with the <TT>module</TT> binding. Here is for instance a structure
packaging together a type of priority queues and their operations:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module PrioQueue =
   struct
     type priority = int
     type &#X2019;a queue = Empty | Node of priority * &#X2019;a * &#X2019;a queue * &#X2019;a queue
     let empty = Empty
     let rec insert queue prio elt =
       match queue with
         Empty -&gt; Node(prio, elt, Empty, Empty)
       | Node(p, e, left, right) -&gt;
           if prio &lt;= p
           then Node(prio, elt, insert right p e, left)
           else Node(p, e, insert right prio elt, left)
     exception Queue_is_empty
     let rec remove_top = function
         Empty -&gt; raise Queue_is_empty
       | Node(prio, elt, left, Empty) -&gt; left
       | Node(prio, elt, Empty, right) -&gt; right
       | Node(prio, elt, (Node(lprio, lelt, _, _) as left),
                         (Node(rprio, relt, _, _) as right)) -&gt;
           if lprio &lt;= rprio
           then Node(lprio, lelt, remove_top left, right)
           else Node(rprio, relt, left, remove_top right)
     let extract = function
         Empty -&gt; raise Queue_is_empty
       | Node(prio, elt, _, _) as queue -&gt; (prio, elt, remove_top queue)
   end;;
</FONT><FONT COLOR=maroon>module PrioQueue :
  sig
    type priority = int
    type &#X2019;a queue = Empty | Node of priority * &#X2019;a * &#X2019;a queue * &#X2019;a queue
    val empty : &#X2019;a queue
    val insert : &#X2019;a queue -&gt; priority -&gt; &#X2019;a -&gt; &#X2019;a queue
    exception Queue_is_empty
    val remove_top : &#X2019;a queue -&gt; &#X2019;a queue
    val extract : &#X2019;a queue -&gt; priority * &#X2019;a * &#X2019;a queue
  end
</FONT></PRE><P>
Outside the structure, its components can be referred to using the
&#X201C;dot notation&#X201D;, that is, identifiers qualified by a structure name.
For instance, <TT>PrioQueue.insert</TT> in a value context is
the function <TT>insert</TT> defined inside the structure
<TT>PrioQueue</TT>. Similarly, <TT>PrioQueue.queue</TT> in a type context is the
type <TT>queue</TT> defined in <TT>PrioQueue</TT>. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>PrioQueue.insert PrioQueue.empty 1 "hello";;
</FONT><FONT COLOR=maroon>- : string PrioQueue.queue =
PrioQueue.Node (1, "hello", PrioQueue.Empty, PrioQueue.Empty)
</FONT></PRE><!--TOC section Signatures-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">2.2</A>  Signatures</H2><!--SEC END --><P>Signatures are interfaces for structures. A signature specifies
which components of a structure are accessible from the outside, and
with which type. It can be used to hide some components of a structure 
(e.g. local function definitions) or export some components with a
restricted type. For instance, the signature below specifies the three
priority queue operations <TT>empty</TT>, <TT>insert</TT> and <TT>extract</TT>, but not the
auxiliary function <TT>remove_top</TT>. Similarly, it makes the <TT>queue</TT> type
abstract (by not providing its actual representation as a concrete type).
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type PRIOQUEUE =
   sig
     type priority = int         (* still concrete *)
     type &#X2019;a queue               (* now abstract *)
     val empty : &#X2019;a queue
     val insert : &#X2019;a queue -&gt; int -&gt; &#X2019;a -&gt; &#X2019;a queue
     val extract : &#X2019;a queue -&gt; int * &#X2019;a * &#X2019;a queue
     exception Queue_is_empty
   end;;
</FONT><FONT COLOR=maroon>module type PRIOQUEUE =
  sig
    type priority = int
    type &#X2019;a queue
    val empty : &#X2019;a queue
    val insert : &#X2019;a queue -&gt; int -&gt; &#X2019;a -&gt; &#X2019;a queue
    val extract : &#X2019;a queue -&gt; int * &#X2019;a * &#X2019;a queue
    exception Queue_is_empty
  end
</FONT></PRE><P>
Restricting the <TT>PrioQueue</TT> structure by this signature results in
another view of the <TT>PrioQueue</TT> structure where the <TT>remove_top</TT>
function is not accessible and the actual representation of priority
queues is hidden:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;
</FONT><FONT COLOR=maroon>module AbstractPrioQueue : PRIOQUEUE
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue><U>AbstractPrioQueue.remove_top</U>;;
</FONT>Error: Unbound value AbstractPrioQueue.remove_top
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>AbstractPrioQueue.insert AbstractPrioQueue.empty 1 "hello";;
</FONT>- : string AbstractPrioQueue.queue = &lt;abstr&gt;
</FONT></PRE><P>
The restriction can also be performed during the definition of the
structure, as in
</P><PRE CLASS="verbatim">module PrioQueue = (struct ... end : PRIOQUEUE);;
</PRE><P>An alternate syntax is provided for the above:
</P><PRE CLASS="verbatim">module PrioQueue : PRIOQUEUE = struct ... end;;
</PRE><!--TOC section Functors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">2.3</A>  Functors</H2><!--SEC END --><P>Functors are &#X201C;functions&#X201D; from structures to structures. They are used to
express parameterized structures: a structure <I>A</I> parameterized by a
structure <I>B</I> is simply a functor <I>F</I> with a formal parameter
<I>B</I> (along with the expected signature for <I>B</I>) which returns
the actual structure <I>A</I> itself. The functor <I>F</I> can then be
applied to one or several implementations <I>B</I><SUB>1</SUB> &#X2026;<I>B<SUB>n</SUB></I>
of <I>B</I>, yielding the corresponding structures
<I>A</I><SUB>1</SUB> &#X2026;<I>A<SUB>n</SUB></I>.</P><P>For instance, here is a structure implementing sets as sorted lists,
parameterized by a structure providing the type of the set elements
and an ordering function over this type (used to keep the sets
sorted):
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type comparison = Less | Equal | Greater;;
</FONT><FONT COLOR=maroon>type comparison = Less | Equal | Greater
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module type ORDERED_TYPE =
   sig
     type t
     val compare: t -&gt; t -&gt; comparison
   end;;
</FONT>module type ORDERED_TYPE = sig type t val compare : t -&gt; t -&gt; comparison end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module Set =
   functor (Elt: ORDERED_TYPE) -&gt;
     struct
       type element = Elt.t
       type set = element list
       let empty = []
       let rec add x s =
         match s with
           [] -&gt; [x]
         | hd::tl -&gt;
            match Elt.compare x hd with
              Equal   -&gt; s         (* x is already in s *)
            | Less    -&gt; x :: s    (* x is smaller than all elements of s *)
            | Greater -&gt; hd :: add x tl
       let rec member x s =
         match s with
           [] -&gt; false
         | hd::tl -&gt;
             match Elt.compare x hd with
               Equal   -&gt; true     (* x belongs to s *)
             | Less    -&gt; false    (* x is smaller than all elements of s *)
             | Greater -&gt; member x tl
     end;;
</FONT>module Set :
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set = element list
      val empty : &#X2019;a list
      val add : Elt.t -&gt; Elt.t list -&gt; Elt.t list
      val member : Elt.t -&gt; Elt.t list -&gt; bool
    end
</FONT></PRE><P>
By applying the <TT>Set</TT> functor to a structure implementing an ordered
type, we obtain set operations for this type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module OrderedString =
   struct
     type t = string
     let compare x y = if x = y then Equal else if x &lt; y then Less else Greater
   end;;
</FONT><FONT COLOR=maroon>module OrderedString :
  sig type t = string val compare : &#X2019;a -&gt; &#X2019;a -&gt; comparison end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module StringSet = Set(OrderedString);;
</FONT>module StringSet :
  sig
    type element = OrderedString.t
    type set = element list
    val empty : &#X2019;a list
    val add : OrderedString.t -&gt; OrderedString.t list -&gt; OrderedString.t list
    val member : OrderedString.t -&gt; OrderedString.t list -&gt; bool
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>StringSet.member "bar" (StringSet.add "foo" StringSet.empty);;
</FONT>- : bool = false
</FONT></PRE><!--TOC section Functors and type abstraction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">2.4</A>  Functors and type abstraction</H2><!--SEC END --><P>As in the <TT>PrioQueue</TT> example, it would be good style to hide the
actual implementation of the type <TT>set</TT>, so that users of the
structure will not rely on sets being lists, and we can switch later
to another, more efficient representation of sets without breaking
their code. This can be achieved by restricting <TT>Set</TT> by a suitable
functor signature:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type SETFUNCTOR =
   functor (Elt: ORDERED_TYPE) -&gt;
     sig
       type element = Elt.t      (* concrete *)
       type set                  (* abstract *)
       val empty : set
       val add : element -&gt; set -&gt; set
       val member : element -&gt; set -&gt; bool
     end;;
</FONT><FONT COLOR=maroon>module type SETFUNCTOR =
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set
      val empty : set
      val add : element -&gt; set -&gt; set
      val member : element -&gt; set -&gt; bool
    end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module AbstractSet = (Set : SETFUNCTOR);;
</FONT>module AbstractSet : SETFUNCTOR
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module AbstractStringSet = AbstractSet(OrderedString);;
</FONT>module AbstractStringSet :
  sig
    type element = OrderedString.t
    type set = AbstractSet(OrderedString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>AbstractStringSet.add "gee" AbstractStringSet.empty;;
</FONT>- : AbstractStringSet.set = &lt;abstr&gt;
</FONT></PRE><P>In an attempt to write the type constraint above more elegantly,
one may wish to name the signature of the structure
returned by the functor, then use that signature in the constraint:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type SET =
   sig
     type element
     type set
     val empty : set
     val add : element -&gt; set -&gt; set
     val member : element -&gt; set -&gt; bool
   end;;
</FONT><FONT COLOR=maroon>module type SET =
  sig
    type element
    type set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module WrongSet = (Set : functor(Elt: ORDERED_TYPE) -&gt; SET);;
</FONT>module WrongSet : functor (Elt : ORDERED_TYPE) -&gt; SET
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module WrongStringSet = WrongSet(OrderedString);;
</FONT>module WrongStringSet :
  sig
    type element = WrongSet(OrderedString).element
    type set = WrongSet(OrderedString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>WrongStringSet.add <U>"gee"</U> WrongStringSet.empty;;
</FONT>Error: This expression has type string but an expression was expected of type
         WrongStringSet.element = WrongSet(OrderedString).element
</FONT></PRE><P>
The problem here is that <TT>SET</TT> specifies the type <TT>element</TT>
abstractly, so that the type equality between <TT>element</TT> in the result
of the functor and <TT>t</TT> in its argument is forgotten. Consequently,
<TT>WrongStringSet.element</TT> is not the same type as <TT>string</TT>, and the
operations of <TT>WrongStringSet</TT> cannot be applied to strings.
As demonstrated above, it is important that the type <TT>element</TT> in the
signature <TT>SET</TT> be declared equal to <TT>Elt.t</TT>; unfortunately, this is
impossible above since <TT>SET</TT> is defined in a context where <TT>Elt</TT> does
not exist. To overcome this difficulty, OCaml provides a
<TT>with type</TT> construct over signatures that allows to enrich a signature
with extra type equalities:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module AbstractSet = 
   (Set : functor(Elt: ORDERED_TYPE) -&gt; (SET with type element = Elt.t));;
</FONT><FONT COLOR=maroon>module AbstractSet :
  functor (Elt : ORDERED_TYPE) -&gt;
    sig
      type element = Elt.t
      type set
      val empty : set
      val add : element -&gt; set -&gt; set
      val member : element -&gt; set -&gt; bool
    end
</FONT></PRE><P>As in the case of simple structures, an alternate syntax is provided
for defining functors and restricting their result:
</P><PRE CLASS="verbatim">module AbstractSet(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
</PRE><P>Abstracting a type component in a functor result is a powerful
technique that provides a high degree of type safety, as we now
illustrate. Consider an ordering over character strings that is
different from the standard ordering implemented in the
<TT>OrderedString</TT> structure. For instance, we compare strings without
distinguishing upper and lower case.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module NoCaseString =
   struct
     type t = string
     let compare s1 s2 =
       OrderedString.compare (String.lowercase s1) (String.lowercase s2)
   end;;
</FONT><FONT COLOR=maroon>module NoCaseString :
  sig type t = string val compare : string -&gt; string -&gt; comparison end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module NoCaseStringSet = AbstractSet(NoCaseString);;
</FONT>module NoCaseStringSet :
  sig
    type element = NoCaseString.t
    type set = AbstractSet(NoCaseString).set
    val empty : set
    val add : element -&gt; set -&gt; set
    val member : element -&gt; set -&gt; bool
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>NoCaseStringSet.add "FOO" <U>AbstractStringSet.empty</U>;;
</FONT>Error: This expression has type
         AbstractStringSet.set = AbstractSet/1139(OrderedString).set
       but an expression was expected of type
         NoCaseStringSet.set = AbstractSet/1171(NoCaseString).set
</FONT></PRE><P>
Notice that the two types <TT>AbstractStringSet.set</TT> and 
<TT>NoCaseStringSet.set</TT> are not compatible, and values of these
two types do not match. This is the correct behavior: even though both
set types contain elements of the same type (strings), both are built
upon different orderings of that type, and different invariants need
to be maintained by the operations (being strictly increasing for the
standard ordering and for the case-insensitive ordering). Applying
operations from <TT>AbstractStringSet</TT> to values of type
<TT>NoCaseStringSet.set</TT> could give incorrect results, or build
lists that violate the invariants of <TT>NoCaseStringSet</TT>.</P><!--TOC section Modules and separate compilation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">2.5</A>  Modules and separate compilation</H2><!--SEC END --><P>All examples of modules so far have been given in the context of the
interactive system. However, modules are most useful for large,
batch-compiled programs. For these programs, it is a practical
necessity to split the source into several files, called compilation
units, that can be compiled separately, thus minimizing recompilation
after changes.</P><P>In OCaml, compilation units are special cases of structures
and signatures, and the relationship between the units can be
explained easily in terms of the module system. A compilation unit <I>A</I>
comprises two files:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the implementation file <I>A</I><TT>.ml</TT>, which contains a sequence
of definitions, analogous to the inside of a <TT>struct</TT>&#X2026;<TT>end</TT>
construct;
</LI><LI CLASS="li-itemize">the interface file <I>A</I><TT>.mli</TT>, which contains a sequence of
specifications, analogous to the inside of a <TT>sig</TT>&#X2026;<TT>end</TT>
construct.
</LI></UL><P>
Both files define a structure named <I>A</I> as if
the following definition was entered at top-level:
</P><PRE>
module <I>A</I>: sig (* contents of file <I>A</I>.mli *) end
        = struct (* contents of file <I>A</I>.ml *) end;;
</PRE><P>
The files defining the compilation units can be compiled separately
using the <TT>ocamlc -c</TT> command (the <TT>-c</TT> option means &#X201C;compile only, do
not try to link&#X201D;); this produces compiled interface files (with
extension <TT>.cmi</TT>) and compiled object code files (with extension
<TT>.cmo</TT>). When all units have been compiled, their <TT>.cmo</TT> files are
linked together using the <TT>ocaml</TT> command. For instance, the following
commands compile and link a program composed of two compilation units
<TT>Aux</TT> and <TT>Main</TT>:
</P><PRE CLASS="verbatim">$ ocamlc -c Aux.mli                     # produces aux.cmi
$ ocamlc -c Aux.ml                      # produces aux.cmo
$ ocamlc -c Main.mli                    # produces main.cmi
$ ocamlc -c Main.ml                     # produces main.cmo
$ ocamlc -o theprogram Aux.cmo Main.cmo
</PRE><P>The program behaves exactly as if the following phrases were entered
at top-level:
</P><PRE>
module Aux: sig (* contents of Aux.mli *) end
          = struct (* contents of Aux.ml *) end;;
module Main: sig (* contents of Main.mli *) end
           = struct (* contents of Main.ml *) end;;
</PRE><P>
In particular, <TT>Main</TT> can refer to <TT>Aux</TT>: the definitions and
declarations contained in <TT>Main.ml</TT> and <TT>Main.mli</TT> can refer to
definition in <TT>Aux.ml</TT>, using the <TT>Aux.</TT><I>ident</I> notation, provided
these definitions are exported in <TT>Aux.mli</TT>.</P><P>The order in which the <TT>.cmo</TT> files are given to <TT>ocaml</TT> during the
linking phase determines the order in which the module definitions
occur. Hence, in the example above, <TT>Aux</TT> appears first and <TT>Main</TT> can
refer to it, but <TT>Aux</TT> cannot refer to <TT>Main</TT>.</P><P>Notice that only top-level structures can be mapped to
separately-compiled files, but not functors nor module types.
However, all module-class objects can appear as components of a
structure, so the solution is to put the functor or module type
inside a structure, which can then be mapped to a file.

</P><!--TOC chapter Objects in Caml-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc18">Chapter 3</A>  Objects in Caml</H1><!--SEC END --><P>
<A NAME="c:objectexamples"></A>
</P><P><I>(Chapter written by Jérôme Vouillon, Didier Rémy and Jacques Garrigue)</I></P><P><BR>
<BR>
</P><P>This chapter gives an overview of the object-oriented features of
OCaml. Note that the relation between object, class and type
in OCaml is very different from that in main stream
object-oriented languages like Java or C++, so that you should not
assume that similar keywords mean the same thing.</P><P><A HREF="#ss:classes-and-objects">3.1</A> Classes and objects<BR>
<A HREF="#ss:immediate-objects">3.2</A> Immediate objects<BR>
<A HREF="#ss:reference-to-self">3.3</A> Reference to self<BR>
<A HREF="#ss:initializers">3.4</A> Initializers<BR>
<A HREF="#ss:virtual-methods">3.5</A> Virtual methods<BR>
<A HREF="#ss:private-methods">3.6</A> Private methods<BR>
<A HREF="#ss:class-interfaces">3.7</A> Class interfaces<BR>
<A HREF="#ss:inheritance">3.8</A> Inheritance<BR>
<A HREF="#ss:multiple-inheritance">3.9</A> Multiple inheritance<BR>
<A HREF="#ss:parameterized-classes">3.10</A> Parameterized classes<BR>
<A HREF="#ss:polymorphic-methods">3.11</A> Polymorphic methods<BR>
<A HREF="#ss:using-coercions">3.12</A> Using coercions<BR>
<A HREF="#ss:functional-objects">3.13</A> Functional objects<BR>
<A HREF="#ss:cloning-objects">3.14</A> Cloning objects<BR>
<A HREF="#ss:recursive-classes">3.15</A> Recursive classes<BR>
<A HREF="#ss:binary-methods">3.16</A> Binary methods<BR>
<A HREF="#ss:friends">3.17</A> Friends<BR>

</P><!--TOC section Classes and objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">3.1</A>  Classes and objects</H2><!--SEC END --><P>

<A NAME="ss:classes-and-objects"></A> </P><P>The class <TT>point</TT> below defines one instance variable <TT>x</TT> and two methods
<TT>get_x</TT> and <TT>move</TT>. The initial value of the instance variable is <TT>0</TT>.
The variable <TT>x</TT> is declared mutable, so the method <TT>move</TT> can change
its value.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point =
   object 
     val mutable x = 0
     method get_x = x
     method move d = x &lt;- x + d
   end;;
</FONT><FONT COLOR=maroon>class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>We now create a new point <TT>p</TT>, instance of the <TT>point</TT> class.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new point;;
</FONT><FONT COLOR=maroon>val p : point = &lt;obj&gt;
</FONT></PRE><P>
Note that the type of <TT>p</TT> is <TT>point</TT>. This is an abbreviation
automatically defined by the class definition above. It stands for the
object type <TT>&lt;get_x : int; move : int -&gt; unit&gt;</TT>, listing the methods
of class <TT>point</TT> along with their types.</P><P>We now invoke some methods to <TT>p</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT><FONT COLOR=maroon>- : int = 0
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#move 3;;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT>- : int = 3
</FONT></PRE><P>The evaluation of the body of a class only takes place at object
creation time. Therefore, in the following example, the instance
variable <TT>x</TT> is initialized to different values for two different
objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let x0 = ref 0;;
</FONT><FONT COLOR=maroon>val x0 : int ref = {contents = 0}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class point =
   object 
     val mutable x = incr x0; !x0
     method get_x = x
     method move d = x &lt;- x + d
   end;;
</FONT>class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>new point#get_x;;
</FONT>- : int = 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>new point#get_x;;
</FONT>- : int = 2
</FONT></PRE><P>The class <TT>point</TT> can also be abstracted over the initial values of
the <TT>x</TT> coordinate.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point = fun x_init -&gt; 
   object 
     val mutable x = x_init
     method get_x = x
     method move d = x &lt;- x + d
   end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>
Like in function definitions, the definition above can be
abbreviated as:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point x_init =
   object 
     val mutable x = x_init
     method get_x = x
     method move d = x &lt;- x + d
   end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end
</FONT></PRE><P>
An instance of the class <TT>point</TT> is now a function that expects an
initial parameter to create a point object:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>new point;;
</FONT><FONT COLOR=maroon>- : int -&gt; point = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new point 7;;
</FONT>val p : point = &lt;obj&gt;
</FONT></PRE><P>
The parameter <TT>x_init</TT> is, of course, visible in the whole body of the
definition, including methods. For instance, the method <TT>get_offset</TT>
in the class below returns the position of the object relative to its 
initial position.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point x_init =
   object 
     val mutable x = x_init
     method get_x = x
     method get_offset = x - x_init
     method move d = x &lt;- x + d 
   end;;
</FONT><FONT COLOR=maroon>class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
Expressions can be evaluated and bound before defining the object body
of the class. This is useful to enforce invariants. For instance,
points can be automatically adjusted to the nearest point on a grid,
as follows:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class adjusted_point x_init =
   let origin = (x_init / 10) * 10 in
   object 
     val mutable x = origin
     method get_x = x
     method get_offset = x - origin
     method move d = x &lt;- x + d
   end;;
</FONT><FONT COLOR=maroon>class adjusted_point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
(One could also raise an exception if the <TT>x_init</TT> coordinate is not
on the grid.) In fact, the same effect could here be obtained by
calling the definition of class <TT>point</TT> with the value of the
<TT>origin</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class adjusted_point x_init =  point ((x_init / 10) * 10);;
</FONT><FONT COLOR=maroon>class adjusted_point : int -&gt; point
</FONT></PRE><P>
An alternative solution would have been to define the adjustment in 
a special allocation function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
</FONT><FONT COLOR=maroon>val new_adjusted_point : int -&gt; point = &lt;fun&gt;
</FONT></PRE><P>
However, the former pattern is generally more appropriate, since 
the code for adjustment is part of the definition of the class and will be
inherited.</P><P>This ability provides class constructors as can be found in other
languages. Several constructors can be defined this way to build objects of
the same class but with different initialization patterns; an
alternative is to use initializers, as decribed below in section
<A HREF="#ss:initializers">3.4</A>.</P><!--TOC section Immediate objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">3.2</A>  Immediate objects</H2><!--SEC END --><P>

<A NAME="ss:immediate-objects"></A></P><P>There is another, more direct way to create an object: create it
without going through a class.</P><P>The syntax is exactly the same as for class expressions, but the
result is a single object rather than a class. All the constructs
described in the rest of this section also apply to immediate objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let p =
   object 
     val mutable x = 0
     method get_x = x
     method move d = x &lt;- x + d
   end;;
</FONT><FONT COLOR=maroon>val p : &lt; get_x : int; move : int -&gt; unit &gt; = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT>- : int = 0
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#move 3;;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT>- : int = 3
</FONT></PRE><P>Unlike classes, which cannot be defined inside an expression,
immediate objects can appear anywhere, using variables from their
environment.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let minmax x y =
   if x &lt; y then object method min = x method max = y end
   else object method min = y method max = x end;;
</FONT><FONT COLOR=maroon>val minmax : &#X2019;a -&gt; &#X2019;a -&gt; &lt; max : &#X2019;a; min : &#X2019;a &gt; = &lt;fun&gt;
</FONT></PRE><P>Immediate objects have two weaknesses compared to classes: their types
are not abbreviated, and you cannot inherit from them. But these two
weaknesses can be advantages in some situations, as we will see
in sections <A HREF="#ss:reference-to-self">3.3</A> and <A HREF="#ss:parameterized-classes">3.10</A>.</P><!--TOC section Reference to self-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">3.3</A>  Reference to self</H2><!--SEC END --><P>

<A NAME="ss:reference-to-self"></A></P><P>A method or an initializer can send messages to self (that is,
the current object). For that, self must be explicitly bound, here to
the variable <TT>s</TT> (<TT>s</TT> could be any identifier, even though we will
often choose the name <TT>self</TT>.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class printable_point x_init =
   object (s)
     val mutable x = x_init
     method get_x = x
     method move d = x &lt;- x + d
     method print = print_int s#get_x
   end;;
</FONT><FONT COLOR=maroon>class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new printable_point 7;;
</FONT>val p : printable_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#print;;
</FONT>7- : unit = ()
</FONT></PRE><P>
Dynamically, the variable <TT>s</TT> is bound at the invocation of a method. In
particular, when the class <TT>printable_point</TT> is inherited, the variable
<TT>s</TT> will be correctly bound to the object of the subclass. </P><P>A common problem with self is that, as its type may be extended in
subclasses, you cannot fix it in advance. Here is a simple example.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let ints = ref [];;
</FONT><FONT COLOR=maroon>val ints : &#X2019;_a list ref = {contents = []}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class my_int =
   object (self)
     method n = 1
     method register = ints := <U>self</U> :: !ints
   end;;
</FONT>Error: This expression has type &lt; n : int; register : &#X2019;a; .. &gt;
       but an expression was expected of type &#X2019;b
       Self type cannot escape its class
</FONT></PRE><P>
You can ignore the first two lines of the error message. What matters
is the last one: putting self into an external reference would make it
impossible to extend it afterwards.
We will see in section <A HREF="#ss:using-coercions">3.12</A> a workaround to this
problem.
Note however that, since immediate objects are not extensible, the
problem does not occur with them.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let my_int =
   object (self)
     method n = 1
     method register = ints := self :: !ints
   end;;
</FONT><FONT COLOR=maroon>val my_int : &lt; n : int; register : unit &gt; = &lt;obj&gt;
</FONT></PRE><!--TOC section Initializers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">3.4</A>  Initializers</H2><!--SEC END --><P>

<A NAME="ss:initializers"></A></P><P>Let-bindings within class definitions are evaluated before the object
is constructed. It is also possible to evaluate an expression
immediately after the object has been built. Such code is written as
an anonymous hidden method called an initializer. Therefore, it can
access self and the instance variables.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class printable_point x_init =
   let origin = (x_init / 10) * 10 in
   object (self)
     val mutable x = origin
     method get_x = x
     method move d = x &lt;- x + d
     method print = print_int self#get_x
     initializer print_string "new point at "; self#print; print_newline()
   end;;
</FONT><FONT COLOR=maroon>class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new printable_point 17;;
</FONT>new point at 10
val p : printable_point = &lt;obj&gt;
</FONT></PRE><P>
Initializers cannot be overridden. On the contrary, all initializers are
evaluated sequentially. 
Initializers are particularly useful to enforce invariants. 
Another example can be seen in section <A HREF="#ss:bank-accounts">5.1</A>.</P><!--TOC section Virtual methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">3.5</A>  Virtual methods</H2><!--SEC END --><P>

<A NAME="ss:virtual-methods"></A></P><P>It is possible to declare a method without actually defining it, using
the keyword <TT>virtual</TT>. This method will be provided later in
subclasses. A class containing virtual methods must be flagged
<TT>virtual</TT>, and cannot be instantiated (that is, no object of this class
can be created). It still defines type abbreviations (treating virtual methods
as other methods.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class virtual abstract_point x_init =
   object (self)
     method virtual get_x : int
     method get_offset = self#get_x - x_init
     method virtual move : int -&gt; unit
   end;;
</FONT><FONT COLOR=maroon>class virtual abstract_point :
  int -&gt;
  object
    method get_offset : int
    method virtual get_x : int
    method virtual move : int -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class point x_init =
   object
     inherit abstract_point x_init
     val mutable x = x_init
     method get_x = x
     method move d = x &lt;- x + d 
   end;;
</FONT>class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>Instance variables can also be declared as virtual, with the same effect
as with methods.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class virtual abstract_point2 =
   object
     val mutable virtual x : int
     method move d = x &lt;- x + d 
   end;;
</FONT><FONT COLOR=maroon>class virtual abstract_point2 :
  object val mutable virtual x : int method move : int -&gt; unit end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class point2 x_init =
   object
     inherit abstract_point2
     val mutable x = x_init
     method get_offset = x - x_init
   end;;
</FONT>class point2 :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method move : int -&gt; unit
  end
</FONT></PRE><!--TOC section Private methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.6</A>  Private methods</H2><!--SEC END --><P>

<A NAME="ss:private-methods"></A></P><P>Private methods are methods that do not appear in object interfaces.
They can only be invoked from other methods of the same object.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class restricted_point x_init =
   object (self)
     val mutable x = x_init
     method get_x = x
     method private move d = x &lt;- x + d
     method bump = self#move 1
   end;;
</FONT><FONT COLOR=maroon>class restricted_point :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method private move : int -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new restricted_point 0;;
</FONT>val p : restricted_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue><U>p</U>#move 10;;
</FONT>Error: This expression has type restricted_point
       It has no method move
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#bump;;
</FONT>- : unit = ()
</FONT></PRE><P>
Note that this is not the same thing as private and protected methods
in Java or C++, which can be called from other objects of the same
class. This is a direct consequence of the independence between types
and classes in OCaml: two unrelated classes may produce
objects of the same type, and there is no way at the type level to
ensure that an object comes from a specific class. However a possible
encoding of friend methods is given in section <A HREF="#ss:friends">3.17</A>.</P><P>Private methods are inherited (they are by default visible in subclasses), 
unless they are hidden by signature matching, as described below.</P><P>Private methods can be made public in a subclass. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point_again x =
   object (self)
     inherit restricted_point x
     method virtual move : _
   end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
The annotation <TT>virtual</TT> here is only used to mention a method without
providing its definition. Since we didn&#X2019;t add the <TT>private</TT>
annotation, this makes the method public, keeping the original
definition.</P><P>An alternative definition is
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point_again x =
   object (self : &lt; move : _; ..&gt; )
     inherit restricted_point x
   end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>
The constraint on self&#X2019;s type is requiring a public <TT>move</TT> method, and
this is sufficient to override <TT>private</TT>.</P><P>One could think that a private method should remain private in a subclass. 
However, since the method is visible in a subclass, it is always possible
to pick its code and define a method of the same name that runs that
code, so yet another (heavier) solution would be:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class point_again x =
   object
     inherit restricted_point x as super
     method move = super#move 
   end;;
</FONT><FONT COLOR=maroon>class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end
</FONT></PRE><P>Of course, private methods can also be virtual. Then, the keywords must
appear in this order <TT>method private virtual</TT>. </P><!--TOC section Class interfaces-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.7</A>  Class interfaces</H2><!--SEC END --><P>

<A NAME="ss:class-interfaces"></A></P><P>Class interfaces are inferred from class definitions. They may also
be defined directly and used to restrict the type of a class. Like class
declarations, they also define a new type abbreviation.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type restricted_point_type = 
   object
     method get_x : int
     method bump : unit
 end;;
</FONT><FONT COLOR=maroon>class type restricted_point_type =
  object method bump : unit method get_x : int end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>fun (x : restricted_point_type) -&gt; x;;
</FONT>- : restricted_point_type -&gt; restricted_point_type = &lt;fun&gt;
</FONT></PRE><P>
In addition to program documentation, class interfaces can be used to
constrain the type of a class. Both concrete instance variables and concrete
private methods can be hidden by a class type constraint. Public
methods and virtual members, however, cannot. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class restricted_point&#X2019; x = (restricted_point x : restricted_point_type);;
</FONT><FONT COLOR=maroon>class restricted_point&#X2019; : int -&gt; restricted_point_type
</FONT></PRE><P>
Or, equivalently:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class restricted_point&#X2019; = (restricted_point : int -&gt; restricted_point_type);;
</FONT><FONT COLOR=maroon>class restricted_point&#X2019; : int -&gt; restricted_point_type
</FONT></PRE><P>
The interface of a class can also be specified in a module
signature, and used to restrict the inferred signature of a module. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type POINT = sig 
   class restricted_point&#X2019; : int -&gt;
     object    
       method get_x : int
       method bump : unit
     end 
 end;;
</FONT><FONT COLOR=maroon>module type POINT =
  sig
    class restricted_point&#X2019; :
      int -&gt; object method bump : unit method get_x : int end
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module Point : POINT = struct 
   class restricted_point&#X2019; = restricted_point
 end;;
</FONT>module Point : POINT
</FONT></PRE><!--TOC section Inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">3.8</A>  Inheritance</H2><!--SEC END --><P>

<A NAME="ss:inheritance"></A></P><P>We illustrate inheritance by defining a class of colored points that
inherits from the class of points. This class has all instance
variables and all methods of class <TT>point</TT>, plus a new instance
variable <TT>c</TT> and a new method <TT>color</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class colored_point x (c : string) =
   object 
     inherit point x
     val c = c
     method color = c
   end;;
</FONT><FONT COLOR=maroon>class colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p&#X2019; = new colored_point 5 "red";;
</FONT>val p&#X2019; : colored_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p&#X2019;#get_x, p&#X2019;#color;;
</FONT>- : int * string = (5, "red")
</FONT></PRE><P>
A point and a colored point have incompatible types, since a point has
no method <TT>color</TT>. However, the function <TT>get_x</TT> below is a generic
function applying method <TT>get_x</TT> to any object <TT>p</TT> that has this
method (and possibly some others, which are represented by an ellipsis
in the type). Thus, it applies to both points and colored points.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let get_succ_x p = p#get_x + 1;;
</FONT><FONT COLOR=maroon>val get_succ_x : &lt; get_x : int; .. &gt; -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>get_succ_x p + get_succ_x p&#X2019;;;
</FONT>- : int = 8
</FONT></PRE><P>
Methods need not be declared previously, as shown by the example:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let set_x p = p#set_x;;
</FONT><FONT COLOR=maroon>val set_x : &lt; set_x : &#X2019;a; .. &gt; -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let incr p = set_x p (get_succ_x p);;
</FONT>val incr : &lt; get_x : int; set_x : int -&gt; &#X2019;a; .. &gt; -&gt; &#X2019;a = &lt;fun&gt;
</FONT></PRE><!--TOC section Multiple inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">3.9</A>  Multiple inheritance</H2><!--SEC END --><P>

<A NAME="ss:multiple-inheritance"></A></P><P>Multiple inheritance is allowed. Only the last definition of a method
is kept: the redefinition in a subclass of a method that was visible in
the parent class overrides the definition in the parent class.
Previous definitions of a method can be reused by binding the related
ancestor. Below, <TT>super</TT> is bound to the ancestor <TT>printable_point</TT>.
The name <TT>super</TT> is a pseudo value identifier that can only be used to
invoke a super-class method, as in <TT>super#print</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class printable_colored_point y c = 
   object (self)
     val c = c
     method color = c
     inherit printable_point y as super
     method print =
       print_string "(";
       super#print;
       print_string ", ";
       print_string (self#color);
       print_string ")"
   end;;
</FONT><FONT COLOR=maroon>class printable_colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p&#X2019; = new printable_colored_point 17 "red";;
</FONT>new point at (10, red)
val p&#X2019; : printable_colored_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p&#X2019;#print;;
</FONT>(10, red)- : unit = ()
</FONT></PRE><P>
A private method that has been hidden in the parent class is no longer
visible, and is thus not overridden. Since initializers are treated as
private methods, all initializers along the class hierarchy are evaluated,
in the order they are introduced.</P><!--TOC section Parameterized classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3.10</A>  Parameterized classes</H2><!--SEC END --><P>

<A NAME="ss:parameterized-classes"></A></P><P>Reference cells can be implemented as objects.
The naive definition fails to typecheck:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class <U>ref x_init =
   object 
     val mutable x = x_init
     method get = x
     method set y = x &lt;- y
   end</U>;;
</FONT><FONT COLOR=maroon>Error: Some type variables are unbound in this type:
         class ref :
           &#X2019;a -&gt;
           object
             val mutable x : &#X2019;a
             method get : &#X2019;a
             method set : &#X2019;a -&gt; unit
           end
       The method get has type &#X2019;a where &#X2019;a is unbound
</FONT></PRE><P>
The reason is that at least one of the methods has a polymorphic type
(here, the type of the value stored in the reference cell), thus 
either the class should be parametric, or the method type should be
constrained to a monomorphic type. A monomorphic instance of the class could
be defined by:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class ref (x_init:int) =
   object 
     val mutable x = x_init
     method get = x
     method set y = x &lt;- y
   end;;
</FONT><FONT COLOR=maroon>class ref :
  int -&gt;
  object val mutable x : int method get : int method set : int -&gt; unit end
</FONT></PRE><P>
Note that since immediate objects do not define a class type, they have
no such restriction.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let new_ref x_init =
   object 
     val mutable x = x_init
     method get = x
     method set y = x &lt;- y
   end;;
</FONT><FONT COLOR=maroon>val new_ref : &#X2019;a -&gt; &lt; get : &#X2019;a; set : &#X2019;a -&gt; unit &gt; = &lt;fun&gt;
</FONT></PRE><P>
On the other hand, a class for polymorphic references must explicitly
list the type parameters in its declaration. Class type parameters are
always listed between <TT>[</TT> and <TT>]</TT>. The type parameters must also be
bound somewhere in the class body by a type constraint.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] ref x_init = 
   object 
     val mutable x = (x_init : &#X2019;a)
     method get = x
     method set y = x &lt;- y
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] ref :
  &#X2019;a -&gt; object val mutable x : &#X2019;a method get : &#X2019;a method set : &#X2019;a -&gt; unit end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let r = new ref 1 in r#set 2; (r#get);;
</FONT>- : int = 2
</FONT></PRE><P>
The type parameter in the declaration may actually be constrained in the
body of the class definition. In the class type, the actual value of
the type parameter is displayed in the <TT>constraint</TT> clause. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] ref_succ (x_init:&#X2019;a) = 
   object
     val mutable x = x_init + 1
     method get = x
     method set y = x &lt;- y
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] ref_succ :
  &#X2019;a -&gt;
  object
    constraint &#X2019;a = int
    val mutable x : int
    method get : int
    method set : int -&gt; unit
  end
</FONT></PRE><P>
Let us consider a more complex example: define a circle, whose center
may be any kind of point. We put an additional type
constraint in method <TT>move</TT>, since no free variables must remain 
unaccounted for by the class type parameters.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] circle (c : &#X2019;a) =
   object 
     val mutable center = c
     method center = center
     method set_center c = center &lt;- c
     method move = (center#move : int -&gt; unit)
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] circle :
  &#X2019;a -&gt;
  object
    constraint &#X2019;a = &lt; move : int -&gt; unit; .. &gt;
    val mutable center : &#X2019;a
    method center : &#X2019;a
    method move : int -&gt; unit
    method set_center : &#X2019;a -&gt; unit
  end
</FONT></PRE><P>
An alternate definition of <TT>circle</TT>, using a <TT>constraint</TT> clause in
the class definition, is shown below. The type <TT>#point</TT> used below in
the <TT>constraint</TT> clause is an abbreviation produced by the definition
of class <TT>point</TT>. This abbreviation unifies with the type of any
object belonging to a subclass of class <TT>point</TT>. It actually expands to
<TT>&lt; get_x : int; move : int -&gt; unit; .. &gt;</TT>. This leads to the following
alternate definition of <TT>circle</TT>, which has slightly stronger
constraints on its argument, as we now expect <TT>center</TT> to have a
method <TT>get_x</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] circle (c : &#X2019;a) =
   object 
     constraint &#X2019;a = #point
     val mutable center = c
     method center = center
     method set_center c = center &lt;- c
     method move = center#move
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] circle :
  &#X2019;a -&gt;
  object
    constraint &#X2019;a = #point
    val mutable center : &#X2019;a
    method center : &#X2019;a
    method move : int -&gt; unit
    method set_center : &#X2019;a -&gt; unit
  end
</FONT></PRE><P>
The class <TT>colored_circle</TT> is a specialized version of class
<TT>circle</TT> that requires the type of the center to unify with
<TT>#colored_point</TT>, and adds a method <TT>color</TT>. Note that when specializing a
parameterized class, the instance of type parameter must always be
explicitly given. It is again written between <TT>[</TT> and <TT>]</TT>. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] colored_circle c =
   object
     constraint &#X2019;a = #colored_point
     inherit [&#X2019;a] circle c
     method color = center#color
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] colored_circle :
  &#X2019;a -&gt;
  object
    constraint &#X2019;a = #colored_point
    val mutable center : &#X2019;a
    method center : &#X2019;a
    method color : string
    method move : int -&gt; unit
    method set_center : &#X2019;a -&gt; unit
  end
</FONT></PRE><!--TOC section Polymorphic methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.11</A>  Polymorphic methods</H2><!--SEC END --><P>

<A NAME="ss:polymorphic-methods"></A></P><P>While parameterized classes may be polymorphic in their contents, they
are not enough to allow polymorphism of method use.</P><P>A classical example is defining an iterator.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>List.fold_left;;
</FONT><FONT COLOR=maroon>- : (&#X2019;a -&gt; &#X2019;b -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;b list -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] intlist (l : int list) =
   object
     method empty = (l = [])
     method fold f (accu : &#X2019;a) = List.fold_left f accu l
   end;;
</FONT>class [&#X2019;a] intlist :
  int list -&gt;
  object method empty : bool method fold : (&#X2019;a -&gt; int -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a end
</FONT></PRE><P>
At first look, we seem to have a polymorphic iterator, however this
does not work in practice.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let l = new intlist [1; 2; 3];;
</FONT><FONT COLOR=maroon>val l : &#X2019;_a intlist = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>l#fold (fun x y -&gt; x+y) 0;;
</FONT>- : int = 6
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>l;;
</FONT>- : int intlist = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>l#fold (fun s x -&gt; <U>s</U> ^ string_of_int x ^ " ") "";;
</FONT>Error: This expression has type int but an expression was expected of type
         string
</FONT></PRE><P>
Our iterator works, as shows its first use for summation. However,
since objects themselves are not polymorphic (only their constructors
are), using the <TT>fold</TT> method fixes its type for this individual object.
Our next attempt to use it as a string iterator fails.</P><P>The problem here is that quantification was wrongly located: this is
not the class we want to be polymorphic, but the <TT>fold</TT> method.
This can be achieved by giving an explicitly polymorphic type in the
method definition.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class intlist (l : int list) =
   object
     method empty = (l = [])
     method fold : &#X2019;a. (&#X2019;a -&gt; int -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a =
       fun f accu -&gt; List.fold_left f accu l
   end;;
</FONT><FONT COLOR=maroon>class intlist :
  int list -&gt;
  object method empty : bool method fold : (&#X2019;a -&gt; int -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let l = new intlist [1; 2; 3];;
</FONT>val l : intlist = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>l#fold (fun x y -&gt; x+y) 0;;
</FONT>- : int = 6
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>l#fold (fun s x -&gt; s ^ string_of_int x ^ " ") "";;
</FONT>- : string = "1 2 3 "
</FONT></PRE><P>
As you can see in the class type shown by the compiler, while
polymorphic method types must be fully explicit in class definitions
(appearing immediately after the method name), quantified type
variables can be left implicit in class descriptions. Why require types
to be explicit? The problem is that <TT>(int -&gt; int -&gt; int) -&gt; int -&gt; int</TT> would also be a valid type for <TT>fold</TT>, and it happens to be
incompatible with the polymorphic type we gave (automatic
instantiation only works for toplevel types variables, not for inner
quantifiers, where it becomes an undecidable problem.) So the compiler
cannot choose between those two types, and must be helped.</P><P>However, the type can be completely omitted in the class definition if
it is already known, through inheritance or type constraints on self.
Here is an example of method overriding.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class intlist_rev l =
   object
     inherit intlist l
     method fold f accu = List.fold_left f accu (List.rev l)
   end;;
</FONT></PRE><P>
The following idiom separates description and definition.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type [&#X2019;a] iterator =
   object method fold : (&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b end;;
 
 class intlist l =
   object (self : int #iterator)
     method empty = (l = [])
     method fold f accu = List.fold_left f accu l
   end;;
</FONT></PRE><P>
Note here the <TT>(self : int #iterator)</TT> idiom, which ensures that this
object implements the interface <TT>iterator</TT>.</P><P>Polymorphic methods are called in exactly the same way as normal
methods, but you should be aware of some limitations of type
inference. Namely, a polymorphic method can only be called if its
type is known at the call site. Otherwise, the method will be assumed
to be monomorphic, and given an incompatible type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let sum lst = lst#fold (fun x y -&gt; x+y) 0;;
</FONT><FONT COLOR=maroon>val sum : &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; &#X2019;a; .. &gt; -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>sum <U>l</U>;;
</FONT>Error: This expression has type intlist
       but an expression was expected of type
         &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; &#X2019;a; .. &gt;
       Types for method fold are incompatible
</FONT></PRE><P>
The workaround is easy: you should put a type constraint on the
parameter.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let sum (lst : _ #iterator) = lst#fold (fun x y -&gt; x+y) 0;;
</FONT><FONT COLOR=maroon>val sum : int #iterator -&gt; int = &lt;fun&gt;
</FONT></PRE><P>
Of course the constraint may also be an explicit method type.
Only occurences of quantified variables are required.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let sum lst =
   (lst : &lt; fold : &#X2019;a. (&#X2019;a -&gt; _ -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a; .. &gt;)#fold (+) 0;;
</FONT><FONT COLOR=maroon>val sum : &lt; fold : &#X2019;a. (&#X2019;a -&gt; int -&gt; &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a; .. &gt; -&gt; int = &lt;fun&gt;
</FONT></PRE><P>Another use of polymorphic methods is to allow some form of implicit
subtyping in method arguments. We have already seen in section
<A HREF="#ss:inheritance">3.8</A> how some functions may be polymorphic in the
class of their argument. This can be extended to methods.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type point0 = object method get_x : int end;;
</FONT><FONT COLOR=maroon>class type point0 = object method get_x : int end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class distance_point x =
   object
     inherit point x
     method distance : &#X2019;a. (#point0 as &#X2019;a) -&gt; int =
       fun other -&gt; abs (other#get_x - x)
   end;;
</FONT>class distance_point :
  int -&gt;
  object
    val mutable x : int
    method distance : #point0 -&gt; int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new distance_point 3 in
 (p#distance (new point 8), p#distance (new colored_point 1 "blue"));;
</FONT>- : int * int = (5, 2)
</FONT></PRE><P>
Note here the special syntax <TT>(#point0 as &#X2019;a)</TT> we have to use to
quantify the extensible part of <TT>#point0</TT>. As for the variable binder,
it can be omitted in class specifications. If you want polymorphism
inside object field it must be quantified independently.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class multi_poly =
   object
     method m1 : &#X2019;a. (&lt; n1 : &#X2019;b. &#X2019;b -&gt; &#X2019;b; .. &gt; as &#X2019;a) -&gt; _ =
       fun o -&gt; o#n1 true, o#n1 "hello"
     method m2 : &#X2019;a &#X2019;b. (&lt; n2 : &#X2019;b -&gt; bool; .. &gt; as &#X2019;a) -&gt; &#X2019;b -&gt; _ =
       fun o x -&gt; o#n2 x
   end;;
</FONT><FONT COLOR=maroon>class multi_poly :
  object
    method m1 : &lt; n1 : &#X2019;a. &#X2019;a -&gt; &#X2019;a; .. &gt; -&gt; bool * string
    method m2 : &lt; n2 : &#X2019;b -&gt; bool; .. &gt; -&gt; &#X2019;b -&gt; bool
  end
</FONT></PRE><P>
In method <TT>m1</TT>, <TT>o</TT> must be an object with at least a method <TT>n1</TT>,
itself polymorphic. In method <TT>m2</TT>, the argument of <TT>n2</TT> and <TT>x</TT> must
have the same type, which is quantified at the same level as <TT>&#X2019;a</TT>.</P><!--TOC section Using coercions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">3.12</A>  Using coercions</H2><!--SEC END --><P>

<A NAME="ss:using-coercions"></A></P><P>Subtyping is never implicit. There are, however, two ways to perform
subtyping. The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.</P><P>We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its <TT>color</TT> method:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let colored_point_to_point cp = (cp : colored_point :&gt; point);;
</FONT><FONT COLOR=maroon>val colored_point_to_point : colored_point -&gt; point = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new point 3 and q = new colored_point 4 "blue";;
</FONT>val p : point = &lt;obj&gt;
val q : colored_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let l = [p; (colored_point_to_point q)];;
</FONT>val l : point list = [&lt;obj&gt;; &lt;obj&gt;]
</FONT></PRE><P>
An object of type <TT>t</TT> can be seen as an object of type <TT>t&#X2019;</TT> 
only if <TT>t</TT> is a subtype of <TT>t&#X2019;</TT>. For instance, a point cannot be
seen as a colored point. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue><U>(p : point :&gt; colored_point)</U>;;
</FONT><FONT COLOR=maroon>Error: Type point = &lt; get_offset : int; get_x : int; move : int -&gt; unit &gt;
       is not a subtype of
         colored_point =
           &lt; color : string; get_offset : int; get_x : int;
             move : int -&gt; unit &gt; 
</FONT></PRE><P>
Indeed, narrowing coercions without runtime checks would be unsafe.
Runtime type checks might raise exceptions, and they would require
the presence of type information at runtime, which is not the case in
the OCaml system.
For these reasons, there is no such operation available in the language. </P><P>Be aware that subtyping and inheritance are not related. Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types. For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
</P><P>The domain of a coercion can often be omitted. For instance, one can
define:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let to_point cp = (cp :&gt; point);;
</FONT><FONT COLOR=maroon>val to_point : #point -&gt; point = &lt;fun&gt;
</FONT></PRE><P>
In this case, the function <TT>colored_point_to_point</TT> is an instance of the 
function <TT>to_point</TT>. This is not always true, however. The fully
explicit coercion is more precise and is sometimes unavoidable. 
Consider, for example, the following class:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class c0 = object method m = {&lt; &gt;} method n = 0 end;;
</FONT><FONT COLOR=maroon>class c0 : object (&#X2019;a) method m : &#X2019;a method n : int end
</FONT></PRE><P>
The object type <TT>c0</TT> is an abbreviation for <TT>&lt;m : &#X2019;a; n : int&gt; as &#X2019;a</TT>. 
Consider now the type declaration:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type c1 =  object method m : c1 end;;
</FONT><FONT COLOR=maroon>class type c1 = object method m : c1 end
</FONT></PRE><P>
The object type <TT>c1</TT> is an abbreviation for the type <TT>&lt;m : &#X2019;a&gt; as &#X2019;a</TT>. 
The coercion from an object of type <TT>c0</TT> to an object of type <TT>c1</TT> is
correct: 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>fun (x:c0) -&gt; (x : c0 :&gt; c1);;
</FONT><FONT COLOR=maroon>- : c0 -&gt; c1 = &lt;fun&gt;
</FONT></PRE><P>
However, the domain of the coercion cannot always be omitted.
In that case, the solution is to use the explicit form. 
Sometimes, a change in the class-type definition can also solve the problem
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type c2 =  object (&#X2019;a) method m : &#X2019;a end;;
</FONT><FONT COLOR=maroon>class type c2 = object (&#X2019;a) method m : &#X2019;a end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>fun (x:c0) -&gt; (x :&gt; c2);;
</FONT>- : c0 -&gt; c2 = &lt;fun&gt;
</FONT></PRE><P>
While class types <TT>c1</TT> and <TT>c2</TT> are different, both object types
<TT>c1</TT> and <TT>c2</TT> expand to the same object type (same method names and types).
Yet, when the domain of a coercion is left implicit and its co-domain
is an abbreviation of a known class type, then the class type, rather
than the object type, is used to derive the coercion function. This
allows to leave the domain implicit in most cases when coercing form a
subclass to its superclass.
The type of a coercion can always be seen as below: 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let to_c1 x = (x :&gt; c1);;
</FONT><FONT COLOR=maroon>val to_c1 : &lt; m : #c1; .. &gt; -&gt; c1 = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let to_c2 x = (x :&gt; c2);;
</FONT>val to_c2 : #c2 -&gt; c2 = &lt;fun&gt;
</FONT></PRE><P>
Note the difference between the two coercions: in the second case, the type
<TT>#c2 = &lt; m : &#X2019;a; .. &gt; as &#X2019;a</TT> is polymorphically recursive (according
to the explicit recursion in the class type of <TT>c2</TT>); hence the
success of applying this coercion to an object of class <TT>c0</TT>.
On the other hand, in the first case, <TT>c1</TT> was only expanded and
unrolled twice to obtain <TT>&lt; m : &lt; m : c1; .. &gt;; .. &gt;</TT> (remember <TT>#c1 = &lt; m : c1; .. &gt;</TT>), without introducing recursion.
You may also note that the type of <TT>to_c2</TT> is <TT>#c2 -&gt; c2</TT> while
the type of <TT>to_c1</TT> is more general than <TT>#c1 -&gt; c1</TT>. This is not always true,
since there are class types for which some instances of <TT>#c</TT> are not subtypes
of <TT>c</TT>, as explained in section <A HREF="#ss:binary-methods">3.16</A>. Yet, for
parameterless classes the coercion <TT>(_ :&gt; c)</TT> is always more general than
<TT>(_ : #c :&gt; c)</TT>.
</P><P>A common problem may occur when one tries to define a coercion to a
class <TT>c</TT> while defining class <TT>c</TT>. The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known. Then, a coercion <TT>(_ :&gt; c)</TT> or <TT>(_ : #c :&gt; c)</TT> is taken to be 
the identity function, as in
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>function x -&gt; (x :&gt; &#X2019;a);;
</FONT><FONT COLOR=maroon>- : &#X2019;a -&gt; &#X2019;a = &lt;fun&gt;
</FONT></PRE><P>
As a consequence, if the coercion is applied to <TT>self</TT>, as in the
following example, the type of <TT>self</TT> is unified with the closed type
<TT>c</TT> (a closed object type is an object type without ellipsis). This
would constrain the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class c = object method m = 1 end
 and d = object (self)
   inherit c
   method n = 2
   method as_c = (<U>self</U> :&gt; c)
 end;;
</FONT><FONT COLOR=maroon>Error: This expression cannot be coerced to type c = &lt; m : int &gt;; it has type
         &lt; as_c : c; m : int; n : int; .. &gt;
       but is here used with type c
       Self type cannot be unified with a closed object type
</FONT></PRE><P>
However, the most common instance of this problem, coercing self to
its current class, is detected as a special case by the type checker,
and properly typed.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class c = object (self) method m = (self :&gt; c) end;;
</FONT><FONT COLOR=maroon>class c : object method m : c end
</FONT></PRE><P>
This allows the following idiom, keeping a list of all objects
belonging to a class or its subclasses:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let all_c = ref [];;
</FONT><FONT COLOR=maroon>val all_c : &#X2019;_a list ref = {contents = []}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class c (m : int) =
   object (self)
     method m = m
     initializer all_c := (self :&gt; c) :: !all_c
   end;;
</FONT>class c : int -&gt; object method m : int end
</FONT></PRE><P>
This idiom can in turn be used to retrieve an object whose type has
been weakened:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec lookup_obj obj = function [] -&gt; raise Not_found
   | obj&#X2019; :: l -&gt;
      if (obj :&gt; &lt; &gt;) = (obj&#X2019; :&gt; &lt; &gt;) then obj&#X2019; else lookup_obj obj l ;;
</FONT><FONT COLOR=maroon>val lookup_obj : &lt; .. &gt; -&gt; (&lt; .. &gt; as &#X2019;a) list -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let lookup_c obj = lookup_obj obj !all_c;;
</FONT>val lookup_c : &lt; .. &gt; -&gt; &lt; m : int &gt; = &lt;fun&gt;
</FONT></PRE><P>
The type <TT>&lt; m : int &gt;</TT> we see here is just the expansion of <TT>c</TT>, due
to the use of a reference; we have succeeded in getting back an object
of type <TT>c</TT>.</P><P><BR>
The previous coercion problem can often be avoided by first
defining the abbreviation, using a class type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type c&#X2019; = object method m : int end;;
</FONT><FONT COLOR=maroon>class type c&#X2019; = object method m : int end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class c : c&#X2019; = object method m = 1 end
 and d = object (self)
   inherit c
   method n = 2
   method as_c = (self :&gt; c&#X2019;)
 end;;
</FONT>class c : c&#X2019;
and d : object method as_c : c&#X2019; method m : int method n : int end
</FONT></PRE><P>
It is also possible to use a virtual class. Inheriting from this class
simultaneously allows to enforce all methods of <TT>c</TT> to have the same
type as the methods of <TT>c&#X2019;</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class virtual c&#X2019; = object method virtual m : int end;;
</FONT><FONT COLOR=maroon>class virtual c&#X2019; : object method virtual m : int end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class c = object (self) inherit c&#X2019; method m = 1 end;;
</FONT>class c : object method m : int end
</FONT></PRE><P>
One could think of defining the type abbreviation directly:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type c&#X2019; = &lt;m : int&gt;;;
</FONT></PRE><P>
However, the abbreviation <TT>#c&#X2019;</TT> cannot be defined directly in a similar way.
It can only be defined by a class or a class-type definition. 
This is because <TT>#</TT> sharp abbreviations carry an implicit anonymous
variable <TT>..</TT> that cannot be explicitly named.
The closer you get to it is:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a c&#X2019;_class = &#X2019;a constraint &#X2019;a = &lt; m : int; .. &gt;;;
</FONT></PRE><P>
with an extra type variable capturing the open object type.</P><!--TOC section Functional objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">3.13</A>  Functional objects</H2><!--SEC END --><P>

<A NAME="ss:functional-objects"></A></P><P>It is possible to write a version of class <TT>point</TT> without assignments
on the instance variables. The construct <TT>{&lt; ... &gt;}</TT> returns a copy of
&#X201C;self&#X201D; (that is, the current object), possibly changing the value of
some instance variables.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class functional_point y =
   object 
     val x = y
     method get_x = x
     method move d = {&lt; x = x + d &gt;}
   end;;
</FONT><FONT COLOR=maroon>class functional_point :
  int -&gt;
  object (&#X2019;a) val x : int method get_x : int method move : int -&gt; &#X2019;a end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new functional_point 7;;
</FONT>val p : functional_point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT>- : int = 7
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>(p#move 3)#get_x;;
</FONT>- : int = 10
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p#get_x;;
</FONT>- : int = 7
</FONT></PRE><P>
Note that the type abbreviation <TT>functional_point</TT> is recursive, which can
be seen in the class type of <TT>functional_point</TT>: the type of self is <TT>&#X2019;a</TT>
and <TT>&#X2019;a</TT> appears inside the type of the method <TT>move</TT>.</P><P>The above definition of <TT>functional_point</TT> is not equivalent
to the following: 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class bad_functional_point y =
   object 
     val x = y
     method get_x = x
     method move d = new bad_functional_point (x+d)
   end;;
</FONT><FONT COLOR=maroon>class bad_functional_point :
  int -&gt;
  object
    val x : int
    method get_x : int
    method move : int -&gt; bad_functional_point
  end
</FONT></PRE><P>
While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of the latter, the method
<TT>move</TT> will
keep returning an object of the parent class. On the contrary, in a
subclass of the former, the method <TT>move</TT> will return an object of the
subclass.</P><P>Functional update is often used in conjunction with binary methods
as illustrated in section <A HREF="#module:string">5.2.1</A>.</P><!--TOC section Cloning objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">3.14</A>  Cloning objects</H2><!--SEC END --><P>

<A NAME="ss:cloning-objects"></A></P><P>Objects can also be cloned, whether they are functional or imperative.
The library function <TT>Oo.copy</TT> makes a shallow copy of an object. That is, 
it returns an object that is equal to the previous one. The 
instance variables have been copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely. 
A deeper assignment (for example if the instance variable if a reference cell) 
will of course affect both the original and the copy. </P><P>The type of <TT>Oo.copy</TT> is the following:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>Oo.copy;;
</FONT><FONT COLOR=maroon>- : (&lt; .. &gt; as &#X2019;a) -&gt; &#X2019;a = &lt;fun&gt;
</FONT></PRE><P>
The keyword <TT>as</TT> in that type binds the type variable <TT>&#X2019;a</TT> to
the object type <TT>&lt; .. &gt;</TT>. Therefore, <TT>Oo.copy</TT> takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of <TT>Oo.copy</TT> is different from type <TT>&lt; .. &gt; -&gt; &lt; .. &gt;</TT> as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new point 5;;
</FONT><FONT COLOR=maroon>val p : point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let q = Oo.copy p;;
</FONT>val q : point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>q#move 7; (p#get_x, q#get_x);;
</FONT>- : int * int = (5, 12)
</FONT></PRE><P>
In fact, <TT>Oo.copy p</TT> will behave as <TT>p#copy</TT> assuming that a public
method <TT>copy</TT> with body <TT>{&lt; &gt;}</TT> has been defined in the class of <TT>p</TT>.</P><P>Objects can be compared using the generic comparison functions <TT>=</TT> and <TT>&lt;&gt;</TT>.
Two objects are equal if and only if they are physically equal. In
particular, an object and its copy are not equal.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let q = Oo.copy p;;
</FONT><FONT COLOR=maroon>val q : point = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>p = q, p = p;;
</FONT>- : bool * bool = (false, true)
</FONT></PRE><P>
Other generic comparissons such as (<TT>&lt;</TT>, <TT>&lt;=</TT>,...) can also be used on objects. The
relation <TT>&lt;</TT> defines an unspecified but strict ordering on objets. The
ordering relationship between two objects is fixed once for all after the
two objects have been created and it is not affected by mutation of fields.</P><P>Cloning and override have a non empty intersection.
They are interchangeable when used within an object and without 
overriding any field:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class copy =
   object
     method copy = {&lt; &gt;}
   end;;
</FONT><FONT COLOR=maroon>class copy : object (&#X2019;a) method copy : &#X2019;a end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class copy =
   object (self)
     method copy = Oo.copy self
   end;;
</FONT>class copy : object (&#X2019;a) method copy : &#X2019;a end
</FONT></PRE><P>
Only the override can be used to actually override fields, and 
only the <TT>Oo.copy</TT> primitive can be used externally. </P><P>Cloning can also be used to provide facilities for saving and
restoring the state of objects.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class backup = 
   object (self : &#X2019;mytype)
     val mutable copy = None
     method save = copy &lt;- Some {&lt; copy = None &gt;}
     method restore = match copy with Some x -&gt; x | None -&gt; self
   end;;
</FONT><FONT COLOR=maroon>class backup :
  object (&#X2019;a)
    val mutable copy : &#X2019;a option
    method restore : &#X2019;a
    method save : unit
  end
</FONT></PRE><P>
The above definition will only backup one level. 
The backup facility can be added to any class using multiple inheritance.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] backup_ref x = object inherit [&#X2019;a] ref x inherit backup end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] backup_ref :
  &#X2019;a -&gt;
  object (&#X2019;b)
    val mutable copy : &#X2019;b option
    val mutable x : &#X2019;a
    method get : &#X2019;a
    method restore : &#X2019;b
    method save : unit
    method set : &#X2019;a -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;
</FONT>val get : (&lt; get : &#X2019;b; restore : &#X2019;a; .. &gt; as &#X2019;a) -&gt; int -&gt; &#X2019;b = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new backup_ref 0  in
 p # save; p # set 1; p # save; p # set 2; 
 [get p 0; get p 1; get p 2; get p 3; get p 4];;
</FONT>- : int list = [2; 1; 1; 1; 1]
</FONT></PRE><P>
A variant of backup could retain all copies. (We then add a method clear to
manually erase all copies.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class backup = 
   object (self : &#X2019;mytype)
     val mutable copy = None
     method save = copy &lt;- Some {&lt; &gt;}
     method restore = match copy with Some x -&gt; x | None -&gt; self
     method clear = copy &lt;- None
   end;;
</FONT><FONT COLOR=maroon>class backup :
  object (&#X2019;a)
    val mutable copy : &#X2019;a option
    method clear : unit
    method restore : &#X2019;a
    method save : unit
  end
</FONT></PRE><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] backup_ref x = object inherit [&#X2019;a] ref x inherit backup end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] backup_ref :
  &#X2019;a -&gt;
  object (&#X2019;b)
    val mutable copy : &#X2019;b option
    val mutable x : &#X2019;a
    method clear : unit
    method get : &#X2019;a
    method restore : &#X2019;b
    method save : unit
    method set : &#X2019;a -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let p = new backup_ref 0  in
 p # save; p # set 1; p # save; p # set 2; 
 [get p 0; get p 1; get p 2; get p 3; get p 4];;
</FONT>- : int list = [2; 1; 0; 0; 0]
</FONT></PRE><!--TOC section Recursive classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">3.15</A>  Recursive classes</H2><!--SEC END --><P>

<A NAME="ss:recursive-classes"></A></P><P>Recursive classes can be used to define objects whose types are
mutually recursive.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class window =
   object 
     val mutable top_widget = (None : widget option)
     method top_widget = top_widget
   end
 and widget (w : window) =
   object
     val window = w
     method window = window
   end;;
</FONT><FONT COLOR=maroon>class window :
  object
    val mutable top_widget : widget option
    method top_widget : widget option
  end
and widget : window -&gt; object val window : window method window : window end
</FONT></PRE><P>
Although their types are mutually recursive, the classes <TT>widget</TT> and 
<TT>window</TT> are themselves independent. </P><!--TOC section Binary methods-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">3.16</A>  Binary methods</H2><!--SEC END --><P>

<A NAME="ss:binary-methods"></A></P><P>A binary method is a method which takes an argument of the same type
as self. The class <TT>comparable</TT> below is a template for classes with a
binary method <TT>leq</TT> of type <TT>&#X2019;a -&gt; bool</TT> where the type variable <TT>&#X2019;a</TT>
is bound to the type of self. Therefore, <TT>#comparable</TT> expands to <TT>&lt; leq : &#X2019;a -&gt; bool; .. &gt; as &#X2019;a</TT>. We see here that the binder <TT>as</TT> also
allows to write recursive types.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class virtual comparable = 
   object (_ : &#X2019;a)
     method virtual leq : &#X2019;a -&gt; bool
   end;;
</FONT><FONT COLOR=maroon>class virtual comparable : object (&#X2019;a) method virtual leq : &#X2019;a -&gt; bool end
</FONT></PRE><P>
We then define a subclass <TT>money</TT> of <TT>comparable</TT>. The class money 
simply wraps floats as comparable objects. We will extend it below with
more operations. There is a type constraint on the class parameter <TT>x</TT>
as the primitive <TT>&lt;=</TT> is a polymorphic comparison function in
OCaml. The <TT>inherit</TT> clause ensures that the type of objects
of this class is an instance of <TT>#comparable</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class money (x : float) =
   object
     inherit comparable
     val repr = x
     method value = repr
     method leq p = repr &lt;= p#value
   end;;
</FONT><FONT COLOR=maroon>class money :
  float -&gt;
  object (&#X2019;a)
    val repr : float
    method leq : &#X2019;a -&gt; bool
    method value : float
  end
</FONT></PRE><P>
Note that the type <TT>money1</TT> is not a subtype of type
<TT>comparable</TT>, as the self type appears in contravariant position
in the type of method <TT>leq</TT>.
Indeed, an object <TT>m</TT> of class <TT>money</TT> has a method <TT>leq</TT>
that expects an argument of type <TT>money</TT> since it accesses
its <TT>value</TT> method. Considering <TT>m</TT> of type <TT>comparable</TT> would allow to
call method <TT>leq</TT> on <TT>m</TT> with an argument that does not have a method
<TT>value</TT>, which would be an error.</P><P>Similarly, the type <TT>money2</TT> below is not a subtype of type <TT>money</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class money2 x =
   object   
     inherit money x
     method times k = {&lt; repr = k *. repr &gt;}
   end;;
</FONT><FONT COLOR=maroon>class money2 :
  float -&gt;
  object (&#X2019;a)
    val repr : float
    method leq : &#X2019;a -&gt; bool
    method times : float -&gt; &#X2019;a
    method value : float
  end
</FONT></PRE><P>
It is however possible to define functions that manipulate objects of
type either <TT>money</TT> or <TT>money2</TT>: the function <TT>min</TT>
will return the minimum of any two objects whose type unifies with
<TT>#comparable</TT>. The type of <TT>min</TT> is not the same as <TT>#comparable -&gt; #comparable -&gt; #comparable</TT>, as the abbreviation <TT>#comparable</TT> hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let min (x : #comparable) y =
   if x#leq y then x else y;;
</FONT><FONT COLOR=maroon>val min : (#comparable as &#X2019;a) -&gt; &#X2019;a -&gt; &#X2019;a = &lt;fun&gt;
</FONT></PRE><P>
This function can be applied to objects of type <TT>money</TT>
or <TT>money2</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>(min (new money  1.3) (new money 3.1))#value;;
</FONT><FONT COLOR=maroon>- : float = 1.3
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>(min (new money2 5.0) (new money2 3.14))#value;;
</FONT>- : float = 3.14
</FONT></PRE><P>More examples of binary methods can be found in sections
<A HREF="#module:string">5.2.1</A> and <A HREF="#module:set">5.2.3</A>.</P><P>Notice the use of functional update for method <TT>times</TT>. 
Writing <TT>new money2 (k *. repr)</TT> instead of <TT>{&lt; repr = k *. repr &gt;}</TT>
would not behave well with inheritance: in a subclass <TT>money3</TT> of <TT>money2</TT>
the <TT>times</TT> method would return an object of class <TT>money2</TT> but not of class
<TT>money3</TT> as would be expected. </P><P>The class <TT>money</TT> could naturally carry another binary method. Here is a
direct definition:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class money x =
   object (self : &#X2019;a)
     val repr = x
     method value = repr
     method print = print_float repr
     method times k = {&lt; repr = k *. x &gt;}
     method leq (p : &#X2019;a) = repr &lt;= p#value
     method plus (p : &#X2019;a) = {&lt; repr = x +. p#value &gt;}
   end;;
</FONT><FONT COLOR=maroon>class money :
  float -&gt;
  object (&#X2019;a)
    val repr : float
    method leq : &#X2019;a -&gt; bool
    method plus : &#X2019;a -&gt; &#X2019;a
    method print : unit
    method times : float -&gt; &#X2019;a
    method value : float
  end
</FONT></PRE><!--TOC section Friends-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">3.17</A>  Friends</H2><!--SEC END --><P>

<A NAME="ss:friends"></A></P><P>The above class <TT>money</TT> reveals a problem that often occurs with binary
methods. In order to interact with other objects of the same class, the
representation of <TT>money</TT> objects must be revealed, using a method such as
<TT>value</TT>. If we remove all binary methods (here <TT>plus</TT> and <TT>leq</TT>),
the representation can easily be hidden inside objects by removing the method
<TT>value</TT> as well. However, this is not possible as long as some binary
requires access to the representation on object of the same class but
different from self.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class safe_money x =
   object (self : &#X2019;a)
     val repr = x
     method print = print_float repr
     method times k = {&lt; repr = k *. x &gt;}
   end;;
</FONT><FONT COLOR=maroon>class safe_money :
  float -&gt;
  object (&#X2019;a)
    val repr : float
    method print : unit
    method times : float -&gt; &#X2019;a
  end
</FONT></PRE><P>
Here, the representation of the object is known only to a particular object.
To make it available to other objects of the same class, we are forced to
make it available to the whole world. However we can easily restrict the
visibility of the representation using the module system.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type MONEY = 
   sig 
     type t
     class c : float -&gt; 
       object (&#X2019;a)
         val repr : t
         method value : t
         method print : unit
         method times : float -&gt; &#X2019;a
         method leq : &#X2019;a -&gt; bool
         method plus : &#X2019;a -&gt; &#X2019;a 
       end
   end;;
 
 module Euro : MONEY = 
   struct
     type t = float
     class c x =
       object (self : &#X2019;a)
         val repr = x
         method value = repr
         method print = print_float repr
         method times k = {&lt; repr = k *. x &gt;}
         method leq (p : &#X2019;a) = repr &lt;= p#value
         method plus (p : &#X2019;a) = {&lt; repr = x +. p#value &gt;}
       end
   end;;
</FONT></PRE><P>
Another example of friend functions may be found in section
<A HREF="#module:set">5.2.3</A>. These examples occur when a group of objects (here
objects of the same class) and functions should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside of the module.</P><!--TOC chapter Labels and variants-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc36">Chapter 4</A>  Labels and variants</H1><!--SEC END --><P> <A NAME="c:labl-examples"></A>
</P><P><I>(Chapter written by Jacques Garrigue)</I></P><P><BR>
<BR>
</P><P>This chapter gives an overview of the new features in
OCaml 3: labels, and polymorphic variants.</P><!--TOC section Labels-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">4.1</A>  Labels</H2><!--SEC END --><P>If you have a look at modules ending in <TT>Labels</TT> in the standard
library, you will see that function types have annotations you did not
have in the functions you defined yourself.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.map;;
</FONT><FONT COLOR=maroon>- : f:(&#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;a list -&gt; &#X2019;b list = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>StringLabels.sub;;
</FONT>- : string -&gt; pos:int -&gt; len:int -&gt; string = &lt;fun&gt;
</FONT></PRE><P>Such annotations of the form <TT>name:</TT> are called <EM>labels</EM>. They are
meant to document the code, allow more checking, and give more
flexibility to function application.
You can give such names to arguments in your programs, by prefixing them
with a tilde <TT>~</TT>.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f ~x ~y = x - y;;
</FONT><FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let x = 3 and y = 2 in f ~x ~y;;
</FONT>- : int = 1
</FONT></PRE><P>When you want to use distinct names for the variable and the label
appearing in the type, you can use a naming label of the form
<TT>~name:</TT>. This also applies when the argument is not a variable.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f ~x:x1 ~y:y1 = x1 - y1;;
</FONT><FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>f ~x:3 ~y:2;;
</FONT>- : int = 1
</FONT></PRE><P>Labels obey the same rules as other identifiers in Caml, that is you
cannot use a reserved keyword (like <TT>in</TT> or <TT>to</TT>) as label.</P><P>Formal parameters and arguments are matched according to their
respective labels<SUP><A NAME="text1" HREF="#note1">1</A></SUP>, the absence of label
being interpreted as the empty label.
This allows commuting arguments in applications. One can also
partially apply a function on any argument, creating a new function of
the remaining parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f ~x ~y = x - y;;
</FONT><FONT COLOR=maroon>val f : x:int -&gt; y:int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>f ~y:2 ~x:3;;
</FONT>- : int = 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.fold_left;;
</FONT>- : f:(&#X2019;a -&gt; &#X2019;b -&gt; &#X2019;a) -&gt; init:&#X2019;a -&gt; &#X2019;b list -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.fold_left [1;2;3] ~init:0 ~f:(+);;
</FONT>- : int = 6
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.fold_left ~init:0;;
</FONT>- : f:(int -&gt; &#X2019;a -&gt; int) -&gt; &#X2019;a list -&gt; int = &lt;fun&gt;
</FONT></PRE><P>If in a function several arguments bear the same label (or no label),
they will not commute among themselves, and order matters. But they
can still commute with other arguments.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let hline ~x:x1 ~x:x2 ~y = (x1, x2, y);;
</FONT><FONT COLOR=maroon>val hline : x:&#X2019;a -&gt; x:&#X2019;b -&gt; y:&#X2019;c -&gt; &#X2019;a * &#X2019;b * &#X2019;c = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>hline ~x:3 ~y:2 ~x:5;;
</FONT>- : int * int * int = (3, 5, 2)
</FONT></PRE><P>As an exception to the above parameter matching rules, if an
application is total, labels may be omitted. In practice, most
applications are total, so that labels can be omitted in applications.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>f 3 2;;
</FONT><FONT COLOR=maroon>- : int = 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.map succ [1;2;3];;
</FONT>- : int list = [2; 3; 4]
</FONT></PRE><P>
But beware that functions like <TT>ListLabels.fold_left</TT> whose result
type is a type variable will never be considered as totally applied.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>ListLabels.fold_left <U>(+)</U> 0 [1;2;3];;
</FONT><FONT COLOR=maroon>Error: This expression has type int -&gt; int -&gt; int
       but an expression was expected of type &#X2019;a list
</FONT></PRE><P>When a function is passed as an argument to an higher-order function,
labels must match in both types. Neither adding nor removing labels
are allowed.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let h g = g ~x:3 ~y:2;;
</FONT><FONT COLOR=maroon>val h : (x:int -&gt; y:int -&gt; &#X2019;a) -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>h f;;
</FONT>- : int = 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>h <U>(+)</U>;;
</FONT>Error: This expression has type int -&gt; int -&gt; int
       but an expression was expected of type x:int -&gt; y:int -&gt; &#X2019;a
</FONT></PRE><P>
Note that when you don&#X2019;t need an argument, you can still use a wildcard
pattern, but you must prefix it with the label.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>h (fun ~x:_ ~y -&gt; y+1);;
</FONT><FONT COLOR=maroon>- : int = 3
</FONT></PRE><!--TOC subsection Optional arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">4.1.1</A>  Optional arguments</H3><!--SEC END --><P>An interesting feature of labeled arguments is that they can be made
optional. For optional parameters, the question mark <TT>?</TT> replaces the
tilde <TT>~</TT> of non-optional ones, and the label is also prefixed by <TT>?</TT>
in the function type.
Default values may be given for such optional parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let bump ?(step = 1) x = x + step;;
</FONT><FONT COLOR=maroon>val bump : ?step:int -&gt; int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>bump 2;;
</FONT>- : int = 3
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>bump ~step:3 2;;
</FONT>- : int = 5
</FONT></PRE><P>A function taking some optional arguments must also take at least one
non-labeled argument. This is because the criterion for deciding
whether an optional has been omitted is the application on a
non-labeled argument appearing after this optional argument in the
function type.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let test ?(x = 0) ?(y = 0) () ?(z = 0) () = (x, y, z);;
</FONT><FONT COLOR=maroon>val test : ?x:int -&gt; ?y:int -&gt; unit -&gt; ?z:int -&gt; unit -&gt; int * int * int =
  &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>test ();;
</FONT>- : ?z:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>test ~x:2 () ~z:3 ();;
</FONT>- : int * int * int = (2, 0, 3)
</FONT></PRE><P>Optional parameters may also commute with non-optional or unlabelled
ones, as long as they are applied simultaneously. By nature, optional
arguments do not commute with unlabeled arguments applied
independently.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>test ~y:2 ~x:3 () ();;
</FONT><FONT COLOR=maroon>- : int * int * int = (3, 2, 0)
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>test () () ~z:1 ~y:2 ~x:3;;
</FONT>- : int * int * int = (3, 2, 1)
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue><U>(test () ())</U> ~z:1;;
</FONT>Error: This expression is not a function; it cannot be applied
</FONT></PRE><P>
Here <TT>(test () ())</TT> is already <TT>(0,0,0)</TT> and cannot be further
applied.</P><P>Optional arguments are actually implemented as option types. If
you do not give a default value, you have access to their internal
representation, <TT>type &#X2019;a option = None | Some of &#X2019;a</TT>. You can then
provide different behaviors when an argument is present or not.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let bump ?step x =
   match step with
   | None -&gt; x * 2
   | Some y -&gt; x + y
 ;;
</FONT><FONT COLOR=maroon>val bump : ?step:int -&gt; int -&gt; int = &lt;fun&gt;
</FONT></PRE><P>It may also be useful to relay an optional argument from a function
call to another. This can be done by prefixing the applied argument
with <TT>?</TT>. This question mark disables the wrapping of optional
argument in an option type.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let test2 ?x ?y () = test ?x ?y () ();;
</FONT><FONT COLOR=maroon>val test2 : ?x:int -&gt; ?y:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>test2 ?x:None;;
</FONT>- : ?y:int -&gt; unit -&gt; int * int * int = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Labels and type inference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">4.1.2</A>  Labels and type inference</H3><!--SEC END --><P>
<A NAME="ss:label-inference"></A></P><P>While they provide an increased comfort for writing function
applications, labels and optional arguments have the pitfall that they
cannot be inferred as completely as the rest of the language.</P><P>You can see it in the following two examples.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let h&#X2019; g = g ~y:2 ~x:3;;
</FONT><FONT COLOR=maroon>val h&#X2019; : (y:int -&gt; x:int -&gt; &#X2019;a) -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>h&#X2019; <U>f</U>;;
</FONT>Error: This expression has type x:int -&gt; y:int -&gt; int
       but an expression was expected of type y:int -&gt; x:int -&gt; &#X2019;a
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let bump_it bump x =
   bump ~step:2 x;;
</FONT>val bump_it : (step:int -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;a -&gt; &#X2019;b = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>bump_it <U>bump</U> 1;;
</FONT>Error: This expression has type ?step:int -&gt; int -&gt; int
       but an expression was expected of type step:int -&gt; &#X2019;a -&gt; &#X2019;b
</FONT></PRE><P>
The first case is simple: <TT>g</TT> is passed <TT>~y</TT> and then <TT>~x</TT>, but <TT>f</TT>
expects <TT>~x</TT> and then <TT>~y</TT>. This is correctly handled if we know the
type of <TT>g</TT> to be <TT>x:int -&gt; y:int -&gt; int</TT> in advance, but otherwise
this causes the above type clash. The simplest workaround is to apply
formal parameters in a standard order.</P><P>The second example is more subtle: while we intended the argument
<TT>bump</TT> to be of type <TT>?step:int -&gt; int -&gt; int</TT>, it is inferred as
<TT>step:int -&gt; int -&gt; &#X2019;a</TT>.
These two types being incompatible (internally normal and optional
arguments are different), a type error occurs when applying <TT>bump_it</TT>
to the real <TT>bump</TT>.</P><P>We will not try here to explain in detail how type inference works.
One must just understand that there is not enough information in the
above program to deduce the correct type of <TT>g</TT> or <TT>bump</TT>. That is,
there is no way to know whether an argument is optional or not, or
which is the correct order, by looking only at how a function is
applied. The strategy used by the compiler is to assume that there are
no optional arguments, and that applications are done in the right
order.</P><P>The right way to solve this problem for optional parameters is to add
a type annotation to the argument <TT>bump</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let bump_it (bump : ?step:int -&gt; int -&gt; int) x =
   bump ~step:2 x;;
</FONT><FONT COLOR=maroon>val bump_it : (?step:int -&gt; int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>bump_it bump 1;;
</FONT>- : int = 3
</FONT></PRE><P>
In practive, such problems appear mostly when using objects whose
methods have optional arguments, so that writing the type of object
arguments is often a good idea.</P><P>Normally the compiler generates a type error if you attempt to pass to
a function a parameter whose type is different from the expected one.
However, in the specific case where the expected type is a non-labeled
function type, and the argument is a function expecting optional
parameters, the compiler will attempt to transform the argument to
have it match the expected type, by passing <TT>None</TT> for all optional
parameters.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let twice f (x : int) = f(f x);;
</FONT><FONT COLOR=maroon>val twice : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>twice bump 2;;
</FONT>- : int = 8
</FONT></PRE><P>This transformation is coherent with the intended semantics,
including side-effects. That is, if the application of optional
parameters shall produce side-effects, these are delayed until the
received function is really applied to an argument.</P><!--TOC subsection Suggestions for labeling-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.1.3</A>  Suggestions for labeling</H3><!--SEC END --><P>Like for names, choosing labels for functions is not an easy task. A
good labeling is a labeling which</P><UL CLASS="itemize"><LI CLASS="li-itemize">
makes programs more readable,
</LI><LI CLASS="li-itemize">is easy to remember,
</LI><LI CLASS="li-itemize">when possible, allows useful partial applications.
</LI></UL><P>We explain here the rules we applied when labeling OCaml
libraries.</P><P>To speak in an &#X201C;object-oriented&#X201D; way, one can consider that each
function has a main argument, its <EM>object</EM>, and other arguments
related with its action, the <EM>parameters</EM>. To permit the
combination of functions through functionals in commuting label mode, the
object will not be labeled. Its role is clear by the function
itself. The parameters are labeled with names reminding either of
their nature or role. Best labels combine in their meaning nature and
role. When this is not possible the role is to prefer, since the nature will
often be given by the type itself. Obscure abbreviations should be
avoided.
</P><PRE><FONT COLOR=maroon>ListLabels.map : f:(&#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;a list -&gt; &#X2019;b list
UnixLabels.write : file_descr -&gt; buf:string -&gt; pos:int -&gt; len:int -&gt; unit
</FONT></PRE><P>When there are several objects of same nature and role, they are all
left unlabeled.
</P><PRE><FONT COLOR=maroon>ListLabels.iter2 : f:(&#X2019;a -&gt; &#X2019;b -&gt; &#X2019;c) -&gt; &#X2019;a list -&gt; &#X2019;b list -&gt; unit
</FONT></PRE><P>When there is no preferable object, all arguments are labeled.
</P><PRE><FONT COLOR=maroon>StringLabels.blit :
  src:string -&gt; src_pos:int -&gt; dst:string -&gt; dst_pos:int -&gt; len:int -&gt; unit
</FONT></PRE><P>However, when there is only one argument, it is often left unlabeled.
</P><PRE><FONT COLOR=maroon>StringLabels.create : int -&gt; string
</FONT></PRE><P>
This principle also applies to functions of several arguments whose
return type is a type variable, as long as the role of each argument
is not ambiguous. Labeling such functions may lead to awkward error
messages when one attempts to omit labels in an application, as we
have seen with <TT>ListLabels.fold_left</TT>.</P><P>Here are some of the label names you will find throughout the
libraries.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Label</B></TD><TD ALIGN=center NOWRAP><B>Meaning</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>f:</TT></TD><TD ALIGN=left NOWRAP>a function to be applied</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>pos:</TT></TD><TD ALIGN=left NOWRAP>a position in a string or array</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>len:</TT></TD><TD ALIGN=left NOWRAP>a length</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>buf:</TT></TD><TD ALIGN=left NOWRAP>a string used as buffer</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>src:</TT></TD><TD ALIGN=left NOWRAP>the source of an operation</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>dst:</TT></TD><TD ALIGN=left NOWRAP>the destination of an operation</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>init:</TT></TD><TD ALIGN=left NOWRAP>the initial value for an iterator</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>cmp:</TT></TD><TD ALIGN=left NOWRAP>a comparison function, <I>e.g.</I> <TT>Pervasives.compare</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>mode:</TT></TD><TD ALIGN=left NOWRAP>an operation mode or a flag list</TD></TR>
</TABLE></DIV><P>All these are only suggestions, but one shall keep in mind that the
choice of labels is essential for readability. Bizarre choices will
make the program harder to maintain.</P><P>In the ideal, the right function name with right labels shall be
enough to understand the function&#X2019;s meaning. Since one can get this
information with OCamlBrowser or the <TT>ocaml</TT> toplevel, the documentation
is only used when a more detailed specification is needed.</P><!--TOC section Polymorphic variants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">4.2</A>  Polymorphic variants</H2><!--SEC END --><P>Variants as presented in section <A HREF="#s:tut-recvariants">1.4</A> are a
powerful tool to build data structures and algorithms. However they
sometimes lack flexibility when used in modular programming. This is
due to the fact every constructor reserves a name to be used with a
unique type. One cannot use the same name in another type, or consider
a value of some type to belong to some other type with more
constructors.</P><P>With polymorphic variants, this original assumption is removed. That
is, a variant tag does not belong to any type in particular, the type
system will just check that it is an admissible value according to its
use. You need not define a type before using a variant tag. A variant
type will be inferred independently for each of its uses.</P><!--TOC subsection Basic use-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Basic use</H3><!--SEC END --><P>In programs, polymorphic variants work like usual ones. You just have
to prefix their names with a backquote character <TT>&#X2018;</TT>.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>[&#X2018;On; &#X2018;Off];;
</FONT><FONT COLOR=maroon>- : [&gt; &#X2018;Off | &#X2018;On ] list = [&#X2018;On; &#X2018;Off]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>&#X2018;Number 1;;
</FONT>- : [&gt; &#X2018;Number of int ] = &#X2018;Number 1
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let f = function &#X2018;On -&gt; 1 | &#X2018;Off -&gt; 0 | &#X2018;Number n -&gt; n;;
</FONT>val f : [&lt; &#X2018;Number of int | &#X2018;Off | &#X2018;On ] -&gt; int = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>List.map f [&#X2018;On; &#X2018;Off];;
</FONT>- : int list = [1; 0]
</FONT></PRE><P>
<TT>[&gt;&#X2018;Off|&#X2018;On] list</TT> means that to match this list, you should at
least be able to match <TT>&#X2018;Off</TT> and <TT>&#X2018;On</TT>, without argument.
<TT>[&lt;&#X2018;On|&#X2018;Off|&#X2018;Number of int]</TT> means that <TT>f</TT> may be applied to <TT>&#X2018;Off</TT>,
<TT>&#X2018;On</TT> (both without argument), or <TT>&#X2018;Number</TT> <I>n</I> where 
<I>n</I> is an integer.
The <TT>&gt;</TT> and <TT>&lt;</TT> inside the variant type shows that they may still be
refined, either by defining more tags or allowing less. As such they
contain an implicit type variable. Both variant types appearing only
once in the type, the implicit type variables they constrain are not
shown.</P><P>The above variant types were polymorphic, allowing further refinement.
When writing type annotations, one will most often describe fixed
variant types, that is types that can be no longer refined. This is
also the case for type abbreviations. Such types do not contain <TT>&lt;</TT> or
<TT>&gt;</TT>, but just an enumeration of the tags and their associated types,
just like in a normal datatype definition. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a vlist = [&#X2018;Nil | &#X2018;Cons of &#X2019;a * &#X2019;a vlist];;
</FONT><FONT COLOR=maroon>type &#X2019;a vlist = [ &#X2018;Cons of &#X2019;a * &#X2019;a vlist | &#X2018;Nil ]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let rec map f : &#X2019;a vlist -&gt; &#X2019;b vlist = function
   | &#X2018;Nil -&gt; &#X2018;Nil
   | &#X2018;Cons(a, l) -&gt; &#X2018;Cons(f a, map f l)
 ;;
</FONT>val map : (&#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;a vlist -&gt; &#X2019;b vlist = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Advanced use-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Advanced use</H3><!--SEC END --><P>Type-checking polymorphic variants is a subtle thing, and some
expressions may result in more complex type information.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f = function &#X2018;A -&gt; &#X2018;C | &#X2018;B -&gt; &#X2018;D | x -&gt; x;;
</FONT><FONT COLOR=maroon>val f : ([&gt; &#X2018;A | &#X2018;B | &#X2018;C | &#X2018;D ] as &#X2019;a) -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>f &#X2018;E;;
</FONT>- : [&gt; &#X2018;A | &#X2018;B | &#X2018;C | &#X2018;D | &#X2018;E ] = &#X2018;E
</FONT></PRE><P>
Here we are seeing two phenomena. First, since this matching is open
(the last case catches any tag), we obtain the type <TT>[&gt; &#X2018;A | &#X2018;B]</TT>
rather than <TT>[&lt; &#X2018;A | &#X2018;B]</TT> in a closed matching. Then, since <TT>x</TT> is
returned as is, input and return types are identical. The notation <TT>as &#X2019;a</TT> denotes such type sharing. If we apply <TT>f</TT> to yet another tag
<TT>&#X2018;E</TT>, it gets added to the list.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f1 = function &#X2018;A x -&gt; x = 1 | &#X2018;B -&gt; true | &#X2018;C -&gt; false
 let f2 = function &#X2018;A x -&gt; x = "a" | &#X2018;B -&gt; true ;;
</FONT><FONT COLOR=maroon>val f1 : [&lt; &#X2018;A of int | &#X2018;B | &#X2018;C ] -&gt; bool = &lt;fun&gt;
val f2 : [&lt; &#X2018;A of string | &#X2018;B ] -&gt; bool = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let f x = f1 x &amp;&amp; f2 x;;
</FONT>val f : [&lt; &#X2018;A of string &amp; int | &#X2018;B ] -&gt; bool = &lt;fun&gt;
</FONT></PRE><P>
Here <TT>f1</TT> and <TT>f2</TT> both accept the variant tags <TT>&#X2018;A</TT> and <TT>&#X2018;B</TT>, but the
argument of <TT>&#X2018;A</TT> is <TT>int</TT> for <TT>f1</TT> and <TT>string</TT> for <TT>f2</TT>. In <TT>f</TT>&#X2019;s
type <TT>&#X2018;C</TT>, only accepted by <TT>f1</TT>, disappears, but both argument types
appear for <TT>&#X2018;A</TT> as <TT>int &amp; string</TT>. This means that if we
pass the variant tag <TT>&#X2018;A</TT> to <TT>f</TT>, its argument should be <EM>both</EM>
<TT>int</TT> and <TT>string</TT>. Since there is no such value, <TT>f</TT> cannot be
applied to <TT>&#X2018;A</TT>, and <TT>&#X2018;B</TT> is the only accepted input.</P><P>Even if a value has a fixed variant type, one can still give it a
larger type through coercions. Coercions are normally written with
both the source type and the destination type, but in simple cases the
source type may be omitted.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a wlist = [&#X2018;Nil | &#X2018;Cons of &#X2019;a * &#X2019;a wlist | &#X2018;Snoc of &#X2019;a wlist * &#X2019;a];;
</FONT><FONT COLOR=maroon>type &#X2019;a wlist = [ &#X2018;Cons of &#X2019;a * &#X2019;a wlist | &#X2018;Nil | &#X2018;Snoc of &#X2019;a wlist * &#X2019;a ]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let wlist_of_vlist  l = (l : &#X2019;a vlist :&gt; &#X2019;a wlist);;
</FONT>val wlist_of_vlist : &#X2019;a vlist -&gt; &#X2019;a wlist = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let open_vlist l = (l : &#X2019;a vlist :&gt; [&gt; &#X2019;a vlist]);;
</FONT>val open_vlist : &#X2019;a vlist -&gt; [&gt; &#X2019;a vlist ] = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>fun x -&gt; (x :&gt; [&#X2018;A|&#X2018;B|&#X2018;C]);;
</FONT>- : [&lt; &#X2018;A | &#X2018;B | &#X2018;C ] -&gt; [ &#X2018;A | &#X2018;B | &#X2018;C ] = &lt;fun&gt;
</FONT></PRE><P>You may also selectively coerce values through pattern matching.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let split_cases = function
   | &#X2018;Nil | &#X2018;Cons _ as x -&gt; &#X2018;A x
   | &#X2018;Snoc _ as x -&gt; &#X2018;B x
 ;;
</FONT><FONT COLOR=maroon>val split_cases :
  [&lt; &#X2018;Cons of &#X2019;a | &#X2018;Nil | &#X2018;Snoc of &#X2019;b ] -&gt;
  [&gt; &#X2018;A of [&gt; &#X2018;Cons of &#X2019;a | &#X2018;Nil ] | &#X2018;B of [&gt; &#X2018;Snoc of &#X2019;b ] ] = &lt;fun&gt;
</FONT></PRE><P>
When an or-pattern composed of variant tags is wrapped inside an
alias-pattern, the alias is given a type containing only the tags
enumerated in the or-pattern. This allows for many useful idioms, like
incremental definition of functions.</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let num x = &#X2018;Num x
 let eval1 eval (&#X2018;Num x) = x
 let rec eval x = eval1 eval x ;;
</FONT><FONT COLOR=maroon>val num : &#X2019;a -&gt; [&gt; &#X2018;Num of &#X2019;a ] = &lt;fun&gt;
val eval1 : &#X2019;a -&gt; [&lt; &#X2018;Num of &#X2019;b ] -&gt; &#X2019;b = &lt;fun&gt;
val eval : [&lt; &#X2018;Num of &#X2019;a ] -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let plus x y = &#X2018;Plus(x,y)
 let eval2 eval = function
   | &#X2018;Plus(x,y) -&gt; eval x + eval y
   | &#X2018;Num _ as x -&gt; eval1 eval x
 let rec eval x = eval2 eval x ;;
</FONT>val plus : &#X2019;a -&gt; &#X2019;b -&gt; [&gt; &#X2018;Plus of &#X2019;a * &#X2019;b ] = &lt;fun&gt;
val eval2 : (&#X2019;a -&gt; int) -&gt; [&lt; &#X2018;Num of int | &#X2018;Plus of &#X2019;a * &#X2019;a ] -&gt; int = &lt;fun&gt;
val eval : ([&lt; &#X2018;Num of int | &#X2018;Plus of &#X2019;a * &#X2019;a ] as &#X2019;a) -&gt; int = &lt;fun&gt;
</FONT></PRE><P>To make this even more comfortable, you may use type definitions as
abbreviations for or-patterns. That is, if you have defined <TT>type myvariant = [&#X2018;Tag1 int | &#X2018;Tag2 bool]</TT>, then the pattern <TT>#myvariant</TT> is
equivalent to writing <TT>(&#X2018;Tag1(_ : int) | &#X2018;Tag2(_ : bool))</TT>.</P><P>Such abbreviations may be used alone,
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f = function
   | #myvariant -&gt; "myvariant"
   | &#X2018;Tag3 -&gt; "Tag3";;
</FONT><FONT COLOR=maroon>val f : [&lt; &#X2018;Tag1 of int | &#X2018;Tag2 of bool | &#X2018;Tag3 ] -&gt; string = &lt;fun&gt;
</FONT></PRE><P>
or combined with with aliases.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let g1 = function &#X2018;Tag1 _ -&gt; "Tag1" | &#X2018;Tag2 _ -&gt; "Tag2";;
</FONT><FONT COLOR=maroon>val g1 : [&lt; &#X2018;Tag1 of &#X2019;a | &#X2018;Tag2 of &#X2019;b ] -&gt; string = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let g = function
   | #myvariant as x -&gt; g1 x
   | &#X2018;Tag3 -&gt; "Tag3";;
</FONT>val g : [&lt; &#X2018;Tag1 of int | &#X2018;Tag2 of bool | &#X2018;Tag3 ] -&gt; string = &lt;fun&gt;
</FONT></PRE><!--TOC subsection Weaknesses of polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.2.1</A>  Weaknesses of polymorphic variants</H3><!--SEC END --><P>After seeing the power of polymorphic variants, one may wonder why
they were added to core language variants, rather than replacing them.</P><P>The answer is twofold. One first aspect is that while being pretty
efficient, the lack of static type information allows for less
optimizations, and makes polymorphic variants slightly heavier than
core language ones. However noticeable differences would only
appear on huge data structures.</P><P>More important is the fact that polymorphic variants, while being
type-safe, result in a weaker type discipline. That is, core language
variants do actually much more than ensuring type-safety, they also
check that you use only declared constructors, that all constructors
present in a data-structure are compatible, and they enforce typing
constraints to their parameters.</P><P>For this reason, you must be more careful about making types explicit
when you use polymorphic variants. When you write a library, this is
easy since you can describe exact types in interfaces, but for simple
programs you are probably better off with core language variants.</P><P>Beware also that some idioms make trivial errors very hard to find.
For instance, the following code is probably wrong but the compiler
has no way to see it.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type abc = [&#X2018;A | &#X2018;B | &#X2018;C] ;;
</FONT><FONT COLOR=maroon>type abc = [ &#X2018;A | &#X2018;B | &#X2018;C ]
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let f = function
   | &#X2018;As -&gt; "A"
   | #abc -&gt; "other" ;;
</FONT>val f : [&lt; &#X2018;A | &#X2018;As | &#X2018;B | &#X2018;C ] -&gt; string = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let f : abc -&gt; string = f ;;
</FONT>val f : abc -&gt; string = &lt;fun&gt;
</FONT></PRE><P>
You can avoid such risks by annotating the definition itself.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let f : abc -&gt; string = function
   | <U>&#X2018;As</U> -&gt; "A"
   | #abc -&gt; "other" ;;
</FONT><FONT COLOR=maroon>Warning 11: this match case is unused.
val f : abc -&gt; string = &lt;fun&gt;
</FONT></PRE><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">This correspond to the commuting label mode
of Objective Caml 3.00 through 3.02, with some additional flexibility
on total applications. The so-called classic mode (<TT>-nolabels</TT>
options) is now deprecated for normal use.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Advanced examples with classes and modules-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc43">Chapter 5</A>  Advanced examples with classes and modules</H1><!--SEC END --><P><I>(Chapter written by Didier Rémy)</I></P><P><BR>
<BR>
</P><P>In this chapter, we show some larger examples using objects, classes
and modules. We review many of the object features simultaneously on
the example of a bank account. We show how modules taken from the
standard library can be expressed as classes. Lastly, we describe a
programming pattern know of as <EM>virtual types</EM> through the example
of window managers.</P><!--TOC section Extended example: bank accounts-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">5.1</A>  Extended example: bank accounts</H2><!--SEC END --><P>

<A NAME="ss:bank-accounts"></A></P><P>In this section, we illustrate most aspects of Object and inheritance
by refining, debugging, and specializing the following 
initial naive definition of a simple bank account. (We reuse the
module <TT>Euro</TT> defined at the end of chapter <A HREF="#c:objectexamples">3</A>.)
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let euro = new Euro.c;;
</FONT><FONT COLOR=maroon>val euro : float -&gt; Euro.c = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let zero = euro 0.;;
</FONT>val zero : Euro.c = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let neg x = x#times (-1.);;
</FONT>val neg : &lt; times : float -&gt; &#X2019;a; .. &gt; -&gt; &#X2019;a = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class account =
   object 
     val mutable balance = zero
     method balance = balance
     method deposit x = balance &lt;- balance # plus x
     method withdraw x =
       if x#leq balance then (balance &lt;- balance # plus (neg x); x) else zero
   end;;
</FONT>class account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let c = new account in c # deposit (euro 100.); c # withdraw (euro 50.);;
</FONT>- : Euro.c = &lt;obj&gt;
</FONT></PRE><P>
We now refine this definition with a method to compute interest.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class account_with_interests =
   object (self)
     inherit account
     method private interest = self # deposit (self # balance # times 0.03)
   end;;
</FONT><FONT COLOR=maroon>class account_with_interests :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method private interest : unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
We make the method <TT>interest</TT> private, since clearly it should not be
called freely from the outside. Here, it is only made accessible to subclasses
that will manage monthly or yearly updates of the account. </P><P>We should soon fix a bug in the current definition: the deposit method can
be used for withdrawing money by depositing negative amounts. We can
fix this directly:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class safe_account =
   object
     inherit account
     method deposit x = if zero#leq x then balance &lt;- balance#plus x
   end;;
</FONT><FONT COLOR=maroon>class safe_account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
However, the bug might be fixed more safely by the following definition:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class safe_account =
   object
     inherit account as unsafe
     method deposit x =
       if zero#leq x then unsafe # deposit x
       else raise (Invalid_argument "deposit")
   end;;
</FONT><FONT COLOR=maroon>class safe_account :
  object
    val mutable balance : Euro.c
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
In particular, this does not require the knowledge of the implementation of 
the method <TT>deposit</TT>.</P><P>To keep trace of operations, we extend the class with a mutable field
<TT>history</TT> and a private method <TT>trace</TT> to add an operation in the
log. Then each method to be traced is redefined.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type &#X2019;a operation = Deposit of &#X2019;a | Retrieval of &#X2019;a;;
</FONT><FONT COLOR=maroon>type &#X2019;a operation = Deposit of &#X2019;a | Retrieval of &#X2019;a
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class account_with_history =
   object (self) 
     inherit safe_account as super  
     val mutable history = []
     method private trace x = history &lt;- x :: history
     method deposit x = self#trace (Deposit x);  super#deposit x
     method withdraw x = self#trace (Retrieval x); super#withdraw x
     method history = List.rev history
   end;;
</FONT>class account_with_history :
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
One may wish to open an account and simultaneously deposit some initial
amount. Although the initial implementation did not address this
requirement, it can be achieved by using an initializer.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class account_with_deposit x =
   object 
     inherit account_with_history 
     initializer balance &lt;- x 
   end;;
</FONT><FONT COLOR=maroon>class account_with_deposit :
  Euro.c -&gt;
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
A better alternative is:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class account_with_deposit x =
   object (self)
     inherit account_with_history 
     initializer self#deposit x
   end;;
</FONT><FONT COLOR=maroon>class account_with_deposit :
  Euro.c -&gt;
  object
    val mutable balance : Euro.c
    val mutable history : Euro.c operation list
    method balance : Euro.c
    method deposit : Euro.c -&gt; unit
    method history : Euro.c operation list
    method private trace : Euro.c operation -&gt; unit
    method withdraw : Euro.c -&gt; Euro.c
  end
</FONT></PRE><P>
Indeed, the latter is safer since the call to <TT>deposit</TT> will automatically
benefit from safety checks and from the trace.
Let&#X2019;s test it:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let ccp = new account_with_deposit (euro 100.) in 
 let <U>balance</U> = ccp#withdraw (euro 50.) in
 ccp#history;;
</FONT><FONT COLOR=maroon>Warning 26: unused variable balance.
- : Euro.c operation list = [Deposit &lt;obj&gt;; Retrieval &lt;obj&gt;]
</FONT></PRE><P>
Closing an account can be done with the following polymorphic function:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let close c = c#withdraw (c#balance);;
</FONT><FONT COLOR=maroon>val close : &lt; balance : &#X2019;a; withdraw : &#X2019;a -&gt; &#X2019;b; .. &gt; -&gt; &#X2019;b = &lt;fun&gt;
</FONT></PRE><P>
Of course, this applies to all sorts of accounts. </P><P>Finally, we gather several versions of the account into a module <TT>Account</TT>
abstracted over some currency.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let today () = (01,01,2000) (* an approximation *)
 module Account (M:MONEY) =
   struct
     type m = M.c
     let m = new M.c
     let zero = m 0. 
         
     class bank =
       object (self) 
         val mutable balance = zero
         method balance = balance
         val mutable history = []
         method private trace x = history &lt;- x::history
         method deposit x =
           self#trace (Deposit x);
           if zero#leq x then balance &lt;- balance # plus x
           else raise (Invalid_argument "deposit")
         method withdraw x =
           if x#leq balance then
             (balance &lt;- balance # plus (neg x); self#trace (Retrieval x); x)
           else zero
         method history = List.rev history
       end
         
     class type client_view = 
       object
         method deposit : m -&gt; unit
         method history : m operation list
         method withdraw : m -&gt; m
         method balance : m
       end
           
     class virtual check_client x = 
       let y = if (m 100.)#leq x then x
       else raise (Failure "Insufficient initial deposit") in
       object (self) initializer <U>self#deposit</U> y end
         
     module Client (B : sig class bank : client_view end) =
       struct
         class account x : client_view =
           object
             inherit B.bank
             inherit check_client x
           end
             
         let discount x =
           let c = new account x in
           if today() &lt; (1998,10,30) then c # deposit (m 100.); c
       end
   end;;
</FONT></PRE><P>
This shows the use of modules to group several class definitions that can in
fact be thought of as a single unit. This unit would be provided by a bank
for both internal and external uses. 
This is implemented as a functor that abstracts over the currency so that
the same code can be used to provide accounts in different currencies.</P><P>The class <TT>bank</TT> is the <EM>real</EM> implementation of the bank account (it
could have been inlined). This is the one that will be used for further
extensions, refinements, etc. Conversely, the client will only be given the client view.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module Euro_account = Account(Euro);;
 
 module Client = Euro_account.Client (Euro_account);;
 
 new Client.account (new Euro.c 100.);;
</FONT></PRE><P>
Hence, the clients do not have direct access to the <TT>balance</TT>, nor the
<TT>history</TT> of their own accounts. Their only way to change their balance is
to deposit or withdraw money. It is important to give the clients
a class and not just the ability to create accounts (such as the
promotional <TT>discount</TT> account), so that they can
personalize their account.
For instance, a client may refine the <TT>deposit</TT> and <TT>withdraw</TT> methods
so as to do his own financial bookkeeping, automatically. On the
other hand, the function <TT>discount</TT> is given as such, with no
possibility for further personalization.</P><P>It is important that to provide the client&#X2019;s view as a functor
<TT>Client</TT> so that client accounts can still be build after a possible
specialization of the <TT>bank</TT>. 
The functor <TT>Client</TT> may remain unchanged and be passed
the new definition to initialize a client&#X2019;s view of the extended account.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module Investment_account (M : MONEY) = 
   struct
     type m = M.c
     module A = Account(M)
         
     class bank =
       object
         inherit A.bank as super
         method deposit x =
           if (new M.c 1000.)#leq x then
             print_string "Would you like to invest?";
           super#deposit x
       end
         
     module Client = A.Client
   end;;
</FONT></PRE><P>
The functor <TT>Client</TT> may also be redefined when some new features of the
account can be given to the client. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module Internet_account (M : MONEY) = 
   struct
     type m = M.c
     module A = Account(M)

     class bank =
       object
         inherit A.bank 
         method mail s = print_string s
       end
         
     class type client_view = 
       object
         method deposit : m -&gt; unit
         method history : m operation list
         method withdraw : m -&gt; m
         method balance : m
         method mail : string -&gt; unit
       end
           
     module Client (B : sig class bank : client_view end) =
       struct
         class account x : client_view =
           object
             inherit B.bank
             inherit A.check_client x
           end
       end
   end;;
</FONT></PRE><!--TOC section Simple modules as classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">5.2</A>  Simple modules as classes</H2><!--SEC END --><P>

<A NAME="ss:modules-as-classes"></A></P><P>One may wonder whether it is possible to treat primitive types such as
integers and strings as objects. Although this is usually uninteresting
for integers or strings, there may be some situations where
this is desirable. The class <TT>money</TT> above is such an example. 
We show here how to do it for strings. </P><!--TOC subsection Strings-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">5.2.1</A>  Strings</H3><!--SEC END --><P>
<A NAME="module:string"></A></P><P>A naive definition of strings as objects could be:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class ostring s =
   object
      method get n = String.get s n
      method set n c = String.set s n c
      method print = print_string s
      method copy = new ostring (String.copy s)
   end;;
</FONT><FONT COLOR=maroon>class ostring :
  string -&gt;
  object
    method copy : ostring
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
  end
</FONT></PRE><P>
However, the method <TT>copy</TT> returns an object of the class <TT>ostring</TT>,
and not an objet of the current class. Hence, if the class is further
extended, the method <TT>copy</TT> will only return an object of the parent
class.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class sub_string s =
   object
      inherit ostring s
      method sub start len = new sub_string (String.sub s  start len)
   end;;
</FONT><FONT COLOR=maroon>class sub_string :
  string -&gt;
  object
    method copy : ostring
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; sub_string
  end
</FONT></PRE><P>
As seen in section <A HREF="#ss:binary-methods">3.16</A>, the solution is to use
functional update instead. We need to create an instance variable
containing the representation <TT>s</TT> of the string.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class better_string s =
   object
      val repr = s
      method get n = String.get repr n
      method set n c = String.set repr n c
      method print = print_string repr
      method copy = {&lt; repr = String.copy repr &gt;}
      method sub start len = {&lt; repr = String.sub s  start len &gt;}
   end;;
</FONT><FONT COLOR=maroon>class better_string :
  string -&gt;
  object (&#X2019;a)
    val repr : string
    method copy : &#X2019;a
    method get : int -&gt; char
    method print : unit
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; &#X2019;a
  end
</FONT></PRE><P>
As shown in the inferred type, the methods <TT>copy</TT> and <TT>sub</TT> now return
objects of the same type as the one of the class.</P><P>Another difficulty is the implementation of the method <TT>concat</TT>. 
In order to concatenate a string with another string of the same class, 
one must be able to access the instance variable externally. Thus, a method
<TT>repr</TT> returning s must be defined. Here is the correct definition of
strings: 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class ostring s =
   object (self : &#X2019;mytype)
      val repr = s
      method repr = repr
      method get n = String.get repr n
      method set n c = String.set repr n c
      method print = print_string repr
      method copy = {&lt; repr = String.copy repr &gt;}
      method sub start len = {&lt; repr = String.sub s start len &gt;}
      method concat (t : &#X2019;mytype) = {&lt; repr = repr ^ t#repr &gt;}
   end;;
</FONT><FONT COLOR=maroon>class ostring :
  string -&gt;
  object (&#X2019;a)
    val repr : string
    method concat : &#X2019;a -&gt; &#X2019;a
    method copy : &#X2019;a
    method get : int -&gt; char
    method print : unit
    method repr : string
    method set : int -&gt; char -&gt; unit
    method sub : int -&gt; int -&gt; &#X2019;a
  end
</FONT></PRE><P>
Another constructor of the class string can be defined to return an
uninitialized string of a given length:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class cstring n = ostring (String.create n);;
</FONT><FONT COLOR=maroon>class cstring : int -&gt; ostring
</FONT></PRE><P>
Here, exposing the representation of strings is probably harmless. We do
could also hide the representation of strings as we hid the currency in the
class <TT>money</TT> of section <A HREF="#ss:friends">3.17</A>.</P><!--TOC subsubsection Stacks-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Stacks</H4><!--SEC END --><P>
<A NAME="module:stack"></A></P><P>There is sometimes an alternative between using modules or classes for
parametric data types. 
Indeed, there are situations when the two approaches are quite similar. 
For instance, a stack can be straightforwardly implemented as a class:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>exception Empty;;
</FONT><FONT COLOR=maroon>exception Empty
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] stack =
   object 
     val mutable l = ([] : &#X2019;a list)
     method push x = l &lt;- x::l
     method pop = match l with [] -&gt; raise Empty | a::l&#X2019; -&gt; l &lt;- l&#X2019;; a
     method clear = l &lt;- []
     method length = List.length l
   end;;
</FONT>class [&#X2019;a] stack :
  object
    val mutable l : &#X2019;a list
    method clear : unit
    method length : int
    method pop : &#X2019;a
    method push : &#X2019;a -&gt; unit
  end
</FONT></PRE><P>
However, writing a method for iterating over a stack is more
problematic. A method <TT>fold</TT> would have type
<TT>(&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b</TT>. Here <TT>&#X2019;a</TT> is the parameter of the stack.
The parameter <TT>&#X2019;b</TT> is not related to the class <TT>&#X2019;a stack</TT> but to the
argument that will be passed to the method <TT>fold</TT>.
A naive approach is to make <TT>&#X2019;b</TT> an extra parameter of class <TT>stack</TT>:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a, &#X2019;b] stack2 =
   object
     inherit [&#X2019;a] stack
     method fold f (x : &#X2019;b) = List.fold_left f x l
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a, &#X2019;b] stack2 :
  object
    val mutable l : &#X2019;a list
    method clear : unit
    method fold : (&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b
    method length : int
    method pop : &#X2019;a
    method push : &#X2019;a -&gt; unit
  end
</FONT></PRE><P>
However, the method <TT>fold</TT> of a given object can only be
applied to functions that all have the same type:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let s = new stack2;;
</FONT><FONT COLOR=maroon>val s : (&#X2019;_a, &#X2019;_b) stack2 = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>s#fold (+) 0;;
</FONT>- : int = 0
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>s;;
</FONT>- : (int, int) stack2 = &lt;obj&gt;
</FONT></PRE><P>
A better solution is to use polymorphic methods, which were
introduced in OCaml version 3.05. Polymorphic methods makes
it possible to treat the type variable <TT>&#X2019;b</TT> in the type of <TT>fold</TT> as
universally quantified, giving <TT>fold</TT> the polymorphic type
<TT>Forall &#X2019;b. (&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b</TT>.
An explicit type declaration on the method <TT>fold</TT> is required, since
the type checker cannot infer the polymorphic type by itself.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a] stack3 =
   object
     inherit [&#X2019;a] stack
     method fold : &#X2019;b. (&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b
                 = fun f x -&gt; List.fold_left f x l
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] stack3 :
  object
    val mutable l : &#X2019;a list
    method clear : unit
    method fold : (&#X2019;b -&gt; &#X2019;a -&gt; &#X2019;b) -&gt; &#X2019;b -&gt; &#X2019;b
    method length : int
    method pop : &#X2019;a
    method push : &#X2019;a -&gt; unit
  end
</FONT></PRE><!--TOC subsection Hashtbl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.2.2</A>  Hashtbl</H3><!--SEC END --><P>
<A NAME="module:hashtbl"></A></P><P>A simplified version of object-oriented hash tables should have the
following class type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class type [&#X2019;a, &#X2019;b] hash_table =
   object 
     method find : &#X2019;a -&gt; &#X2019;b
     method add : &#X2019;a -&gt; &#X2019;b -&gt; unit
   end;;
</FONT><FONT COLOR=maroon>class type [&#X2019;a, &#X2019;b] hash_table =
  object method add : &#X2019;a -&gt; &#X2019;b -&gt; unit method find : &#X2019;a -&gt; &#X2019;b end
</FONT></PRE><P>
A simple implementation, which is quite reasonable for small hastables is
to use an association list:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a, &#X2019;b] small_hashtbl : [&#X2019;a, &#X2019;b] hash_table =
   object
     val mutable table = []
     method find key = List.assoc key table
     method add key valeur = table &lt;- (key, valeur) :: table
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a, &#X2019;b] small_hashtbl : [&#X2019;a, &#X2019;b] hash_table
</FONT></PRE><P>
A better implementation, and one that scales up better, is to use a
true hash tables&#X2026; whose elements are small hash tables!
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;a, &#X2019;b] hashtbl size : [&#X2019;a, &#X2019;b] hash_table =
   object (self)
     val table = Array.init size (fun i -&gt; new small_hashtbl) 
     method private hash key =
       (Hashtbl.hash key) mod (Array.length table)
     method find key = table.(self#hash key) # find key
     method add key = table.(self#hash key) # add key
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a, &#X2019;b] hashtbl : int -&gt; [&#X2019;a, &#X2019;b] hash_table
</FONT></PRE><!--TOC subsection Sets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.2.3</A>  Sets</H3><!--SEC END --><P>
<A NAME="module:set"></A></P><P>Implementing sets leads to another difficulty. Indeed, the method
<TT>union</TT> needs to be able to access the internal representation of
another object of the same class. </P><P>This is another instance of friend functions as seen in section
<A HREF="#ss:friends">3.17</A>. Indeed, this is the same mechanism used in the module
<TT>Set</TT> in the absence of objects.</P><P>In the object-oriented version of sets, we only need to add an additional 
method <TT>tag</TT> to return the representation of a set. Since sets are
parametric in the type of elements, the method <TT>tag</TT> has a parametric type
<TT>&#X2019;a tag</TT>, concrete within 
the module definition but abstract in its signature.
From outside, it will then be guaranteed that two objects with a method <TT>tag</TT> 
of the same type will share the same representation.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type SET =
   sig
     type &#X2019;a tag
     class [&#X2019;a] c :
       object (&#X2019;b)
         method is_empty : bool
         method mem : &#X2019;a -&gt; bool
         method add : &#X2019;a -&gt; &#X2019;b
         method union : &#X2019;b -&gt; &#X2019;b
         method iter : (&#X2019;a -&gt; unit) -&gt; unit
         method tag : &#X2019;a tag
       end
   end;;
 
 module Set : SET =
   struct
     let rec merge l1 l2 =
       match l1 with
         [] -&gt; l2
       | h1 :: t1 -&gt;
           match l2 with
             [] -&gt; l1
           | h2 :: t2 -&gt;
               if h1 &lt; h2 then h1 :: merge t1 l2
               else if h1 &gt; h2 then h2 :: merge l1 t2
               else merge t1 l2
     type &#X2019;a tag = &#X2019;a list
     class [&#X2019;a] c =
       object (_ : &#X2019;b)
         val repr = ([] : &#X2019;a list)
         method is_empty = (repr = [])
         method mem x = List.exists ((=) x) repr
         method add x = {&lt; repr = merge [x] repr &gt;}
         method union (s : &#X2019;b) = {&lt; repr = merge repr s#tag &gt;}
         method iter (f : &#X2019;a -&gt; unit) = List.iter f repr
         method tag = repr
       end
   end;;
</FONT></PRE><!--TOC section The subject/observer pattern-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">5.3</A>  The subject/observer pattern</H2><!--SEC END --><P>

<A NAME="ss:subject-observer"></A></P><P>The following example, known as the subject/observer pattern, is often
presented in the literature as a difficult inheritance problem with
inter-connected classes.
The general pattern amounts to the definition a pair of two
classes that recursively interact with one another. </P><P>The class <TT>observer</TT> has a distinguished method <TT>notify</TT> that requires 
two arguments, a subject and an event to execute an action. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class virtual [&#X2019;subject, &#X2019;event] observer =
   object
     method virtual notify : &#X2019;subject -&gt;  &#X2019;event -&gt; unit
   end;;
</FONT><FONT COLOR=maroon>class virtual [&#X2019;a, &#X2019;b] observer :
  object method virtual notify : &#X2019;a -&gt; &#X2019;b -&gt; unit end
</FONT></PRE><P>
The class <TT>subject</TT> remembers a list of observers in an instance variable,
and has a distinguished method <TT>notify_observers</TT> to broadcast the message
<TT>notify</TT> to all observers with a particular event <TT>e</TT>. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;observer, &#X2019;event] subject =
   object (self)
     val mutable observers = ([]:&#X2019;observer list)
     method add_observer obs = observers &lt;- (obs :: observers)
     method notify_observers (e : &#X2019;event) = 
         List.iter (fun x -&gt; x#notify self e) observers
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a, &#X2019;b] subject :
  object (&#X2019;c)
    constraint &#X2019;a = &lt; notify : &#X2019;c -&gt; &#X2019;b -&gt; unit; .. &gt;
    val mutable observers : &#X2019;a list
    method add_observer : &#X2019;a -&gt; unit
    method notify_observers : &#X2019;b -&gt; unit
  end
</FONT></PRE><P>
The difficulty usually relies in defining instances of the pattern above
by inheritance. This can be done in a natural and obvious manner in
Ocaml, as shown on the following example manipulating windows.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>type event = Raise | Resize | Move;;
</FONT><FONT COLOR=maroon>type event = Raise | Resize | Move
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let string_of_event = function
     Raise -&gt; "Raise" | Resize -&gt; "Resize" | Move -&gt; "Move";;
</FONT>val string_of_event : event -&gt; string = &lt;fun&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>let count = ref 0;;
</FONT>val count : int ref = {contents = 0}
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;observer] window_subject =
   let id = count := succ !count; !count in
   object (self)
     inherit [&#X2019;observer, event] subject
     val mutable position = 0
     method identity = id
     method move x = position &lt;- position + x; self#notify_observers Move
     method draw = Printf.printf "{Position = %d}\n"  position;
   end;;
</FONT>class [&#X2019;a] window_subject :
  object (&#X2019;b)
    constraint &#X2019;a = &lt; notify : &#X2019;b -&gt; event -&gt; unit; .. &gt;
    val mutable observers : &#X2019;a list
    val mutable position : int
    method add_observer : &#X2019;a -&gt; unit
    method draw : unit
    method identity : int
    method move : int -&gt; unit
    method notify_observers : event -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;subject] window_observer =
   object
     inherit [&#X2019;subject, event] observer
     method notify s e = s#draw
   end;;
</FONT>class [&#X2019;a] window_observer :
  object
    constraint &#X2019;a = &lt; draw : unit; .. &gt;
    method notify : &#X2019;a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
Unsurprisingly the type of <TT>window</TT> is recursive. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let window = new window_subject;;
</FONT><FONT COLOR=maroon>val window : &lt; notify : &#X2019;a -&gt; event -&gt; unit; _.. &gt; window_subject as &#X2019;a =
  &lt;obj&gt;
</FONT></PRE><P>
However, the two classes of <TT>window_subject</TT> and <TT>window_observer</TT> are not
mutually recursive. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let window_observer = new window_observer;;
</FONT><FONT COLOR=maroon>val window_observer : &lt; draw : unit; _.. &gt; window_observer = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>window#add_observer window_observer;;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>window#move 1;;
</FONT>{Position = 1}
- : unit = ()
</FONT></PRE><P>Classes <TT>window_observer</TT> and <TT>window_subject</TT> can still be extended by
inheritance. For instance, one may enrich the <TT>subject</TT> with new
behaviors and refined the behavior of the observer. 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;observer] richer_window_subject =
   object (self)
     inherit [&#X2019;observer] window_subject
     val mutable size = 1
     method resize x = size &lt;- size + x; self#notify_observers Resize
     val mutable top = false
     method raise = top &lt;- true; self#notify_observers Raise
     method draw = Printf.printf "{Position = %d; Size = %d}\n"  position size;
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] richer_window_subject :
  object (&#X2019;b)
    constraint &#X2019;a = &lt; notify : &#X2019;b -&gt; event -&gt; unit; .. &gt;
    val mutable observers : &#X2019;a list
    val mutable position : int
    val mutable size : int
    val mutable top : bool
    method add_observer : &#X2019;a -&gt; unit
    method draw : unit
    method identity : int
    method move : int -&gt; unit
    method notify_observers : event -&gt; unit
    method raise : unit
    method resize : int -&gt; unit
  end
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;subject] richer_window_observer =
   object 
     inherit [&#X2019;subject] window_observer as super
     method notify s e = if e &lt;&gt; Raise then s#raise; super#notify s e
   end;;
</FONT>class [&#X2019;a] richer_window_observer :
  object
    constraint &#X2019;a = &lt; draw : unit; raise : unit; .. &gt;
    method notify : &#X2019;a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
We can also create a different kind of observer: 
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>class [&#X2019;subject] trace_observer = 
   object 
     inherit [&#X2019;subject, event] observer
     method notify s e =
       Printf.printf
         "&lt;Window %d &lt;== %s&gt;\n" s#identity (string_of_event e)
   end;;
</FONT><FONT COLOR=maroon>class [&#X2019;a] trace_observer :
  object
    constraint &#X2019;a = &lt; identity : int; .. &gt;
    method notify : &#X2019;a -&gt; event -&gt; unit
  end
</FONT></PRE><P>
and attached several observers to the same object:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let window = new richer_window_subject;;
</FONT><FONT COLOR=maroon>val window :
  &lt; notify : &#X2019;a -&gt; event -&gt; unit; _.. &gt; richer_window_subject as &#X2019;a = &lt;obj&gt;
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>window#add_observer (new richer_window_observer);;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>window#add_observer (new trace_observer);;
</FONT>- : unit = ()
 
<FONT COLOR=black>#</FONT><FONT COLOR=blue>window#move 1; window#resize 2;;
</FONT>&lt;Window 1 &lt;== Move&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 1}
{Position = 1; Size = 1}
&lt;Window 1 &lt;== Resize&gt;
&lt;Window 1 &lt;== Raise&gt;
{Position = 1; Size = 3}
{Position = 1; Size = 3}
- : unit = ()
</FONT></PRE><!--TOC part The OCaml language-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc50">Part II</A><BR>
The OCaml language</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:refman"></A>
</P><!--TOC chapter The OCaml language-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc51">Chapter 6</A>  The OCaml language</H1><!--SEC END --><P> <A NAME="c:refman"></A>

</P><!--NAME language.html-->
<!--TOC subsection Foreword-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Foreword</H3><!--SEC END --><P>This document is intended as a reference manual for the OCaml
language. It lists the language constructs, and gives their precise
syntax and informal semantics. It is by no means a tutorial
introduction to the language: there is not a single example. A good
working knowledge of Caml is assumed.</P><P>No attempt has been made at mathematical rigor: words are employed
with their intuitive meaning, without further definition. As a
consequence, the typing rules have been left out, by lack of the
mathematical framework required to express them, while they are
definitely part of a full formal definition of the language. </P><!--TOC subsection Notations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Notations</H3><!--SEC END --><P>The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (<FONT COLOR=blue><TT>like</TT> <TT>this</TT></FONT>).
Non-terminal symbols are set in italic font (<FONT COLOR=maroon><I>like that</I></FONT>). 
Square brackets [&#X2026;] denote optional components. Curly brackets
{&#X2026;} denotes zero, one or several repetitions of the enclosed
components. Curly bracket with a trailing plus sign {&#X2026;}<SUP>+</SUP>
denote one or several repetitions of the enclosed components.
Parentheses (&#X2026;) denote grouping.</P><!--CUT DEF section  --><!--TOC section Lexical conventions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">6.1</A>  Lexical conventions</H2><!--SEC END --><!--NAME lex.html-->
<!--TOC subsubsection Blanks-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Blanks</H4><!--SEC END --><P>The following characters are considered as blanks: space, newline,
horizontal tabulation, carriage return, line feed and form feed. Blanks are
ignored, but they separate adjacent identifiers, literals and
keywords that would otherwise be confused as one single identifier,
literal or keyword.</P><!--TOC subsubsection Comments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments</H4><!--SEC END --><P>Comments are introduced by the two characters <TT>(*</TT>, with no
intervening blanks, and terminated by the characters <TT>*)</TT>, with
no intervening blanks. Comments are treated as blank characters.
Comments do not occur inside string or character literals. Nested
comments are handled correctly.</P><!--TOC subsubsection Identifiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Identifiers</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="ident"><FONT COLOR=maroon>ident</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> (<I><A HREF="#letter"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT>) { <I><A HREF="#letter"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223; <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT>&#X2223; <FONT COLOR=blue><TT>'</TT></FONT> }  </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="letter"><FONT COLOR=maroon>letter</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>A</TT></FONT> &#X2026; <FONT COLOR=blue><TT>Z</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>a</TT></FONT> &#X2026; <FONT COLOR=blue><TT>z</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Identifiers are sequences of letters, digits, <TT>_</TT> (the underscore
character), and <TT>&#X2019;</TT> (the single quote), starting with a
letter or an underscore.
Letters contain at least the 52 lowercase and uppercase
letters from the ASCII set. The current implementation
also recognizes as letters all accented characters from the ISO
8859-1 (&#X201C;ISO Latin 1&#X201D;) set. All characters in an identifier are
meaningful. The current implementation accepts identifiers up to
16000000 characters in length.</P><!--TOC subsubsection Integer literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Integer literals</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>) { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> [<FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0x</TT></FONT>&#X2223; <FONT COLOR=blue><TT>0X</TT></FONT>) (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223; <FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)
{ <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223; <FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> [<FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0o</TT></FONT>&#X2223; <FONT COLOR=blue><TT>0O</TT></FONT>) (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>7</TT></FONT>) { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>7</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> [<FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0b</TT></FONT>&#X2223; <FONT COLOR=blue><TT>0B</TT></FONT>) (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>1</TT></FONT>) { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>1</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }</TD></TR>
</TABLE></TD></TR>
</TABLE><P>An integer literal is a sequence of one or more digits, optionally
preceded by a minus sign. By default, integer literals are in decimal
(radix 10). The following prefixes select a different radix:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Prefix</B></TD><TD ALIGN=center NOWRAP><B>Radix</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>0x</TT>, <TT>0X</TT></TD><TD ALIGN=left NOWRAP>hexadecimal (radix 16)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0o</TT>, <TT>0O</TT></TD><TD ALIGN=left NOWRAP>octal (radix 8)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>0b</TT>, <TT>0B</TT></TD><TD ALIGN=left NOWRAP>binary (radix 2)</TD></TR>
</TABLE></DIV><P>
(The initial <TT>0</TT> is the digit zero; the <TT>O</TT> for octal is the letter O.)
The interpretation of integer literals that fall outside the range of
representable integer values is undefined.</P><P>For convenience and readability, underscore characters (<TT>_</TT>) are accepted
(and ignored) within integer literals.</P><!--TOC subsubsection Floating-point literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Floating-point literals</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="float-literal"><FONT COLOR=maroon>float-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>) { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> } [<FONT COLOR=blue><TT>.</TT></FONT> { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }]
[(<FONT COLOR=blue><TT>e</TT></FONT>&#X2223; <FONT COLOR=blue><TT>E</TT></FONT>) [<FONT COLOR=blue><TT>+</TT></FONT>&#X2223; <FONT COLOR=blue><TT>-</TT></FONT>] (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>) { <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT> }]</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Floating-point decimals consist in an integer part, a decimal part and
an exponent part. The integer part is a sequence of one or more
digits, optionally preceded by a minus sign. The decimal part is a
decimal point followed by zero, one or more digits.
The exponent part is the character <TT>e</TT> or <TT>E</TT> followed by an
optional <TT>+</TT> or <TT>-</TT> sign, followed by one or more digits.
The decimal part or the exponent part can be omitted, but not both to
avoid ambiguity with integer literals.
The interpretation of floating-point literals that fall outside the
range of representable floating-point values is undefined.</P><P>For convenience and readability, underscore characters (<TT>_</TT>) are accepted
(and ignored) within floating-point literals.</P><!--TOC subsubsection Character literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Character literals</H4><!--SEC END --><P>
<A NAME="s:characterliteral"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="char-literal"><FONT COLOR=maroon>char-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>regular-char</I></FONT> <FONT COLOR=blue><TT>'</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#escape-sequence"><FONT COLOR=maroon>escape-sequence</FONT></A></I> <FONT COLOR=blue><TT>'</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="escape-sequence"><FONT COLOR=maroon>escape-sequence</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>\</TT></FONT> (<FONT COLOR=blue><TT>\</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>"</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>'</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>n</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>t</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>b</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>r</TT></FONT>)
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>\</TT></FONT> (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>) (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>) (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>)
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>\x</TT></FONT> (<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223; <FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)
(<FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>A</TT></FONT>&#X2026;<FONT COLOR=blue><TT>F</TT></FONT>&#X2223; <FONT COLOR=blue><TT>a</TT></FONT>&#X2026;<FONT COLOR=blue><TT>f</TT></FONT>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Character literals are delimited by <TT>&#X2019;</TT> (single quote) characters.
The two single quotes enclose either one character different from
<TT>&#X2019;</TT> and <TT>\</TT>, or one of the escape sequences below:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Sequence</B></TD><TD ALIGN=center NOWRAP><B>Character denoted</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>\\</TT></TD><TD ALIGN=left NOWRAP>backslash (<TT>\</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\"</TT></TD><TD ALIGN=left NOWRAP>double quote (<TT>"</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\&#X2019;</TT></TD><TD ALIGN=left NOWRAP>single quote (<TT>&#X2019;</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\n</TT></TD><TD ALIGN=left NOWRAP>linefeed (LF)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\r</TT></TD><TD ALIGN=left NOWRAP>carriage return (CR)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\t</TT></TD><TD ALIGN=left NOWRAP>horizontal tabulation (TAB)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\b</TT></TD><TD ALIGN=left NOWRAP>backspace (BS)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\</TT><I>space</I></TD><TD ALIGN=left NOWRAP>space (SPC)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\</TT><I>ddd</I></TD><TD ALIGN=left NOWRAP>the character with ASCII code <I>ddd</I> in decimal</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>\x</TT><I>hh</I></TD><TD ALIGN=left NOWRAP>the character with ASCII code <I>hh</I> in hexadecimal</TD></TR>
</TABLE></DIV><!--TOC subsubsection String literals-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->String literals</H4><!--SEC END --><P>
<A NAME="s:stringliteral"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="string-literal"><FONT COLOR=maroon>string-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>"</TT></FONT> { <I><A HREF="#string-character"><FONT COLOR=maroon>string-character</FONT></A></I> } <FONT COLOR=blue><TT>"</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="string-character"><FONT COLOR=maroon>string-character</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>regular-char-str</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#escape-sequence"><FONT COLOR=maroon>escape-sequence</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>String literals are delimited by <TT>"</TT> (double quote) characters.
The two double quotes enclose a sequence of either characters
different from <TT>"</TT> and <TT>\</TT>, or escape sequences from the
table given above for character literals.</P><P>To allow splitting long string literals across lines, the sequence
<TT>\</TT><I>newline</I> <I>blanks</I> (a <TT>\</TT> at end-of-line followed by any
number of blanks at the beginning of the next line) is ignored inside
string literals.</P><P>The current implementation places practically no restrictions on the
length of string literals.</P><!--TOC subsubsection Naming labels-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Naming labels</H4><!--SEC END --><P>To avoid ambiguities, naming labels in expressions cannot just be defined
syntactically as the sequence of the three tokens <TT>~</TT>, <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> and
<TT>:</TT>, and have to be defined at the lexical level.</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="label-name"><FONT COLOR=maroon>label-name</FONT></A></I> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> (<FONT COLOR=blue><TT>a</TT></FONT> &#X2026; <FONT COLOR=blue><TT>z</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT>) { <I><A HREF="#letter"><FONT COLOR=maroon>letter</FONT></A></I>&#X2223; <FONT COLOR=blue><TT>0</TT></FONT>&#X2026;<FONT COLOR=blue><TT>9</TT></FONT>&#X2223; <FONT COLOR=blue><TT>_</TT></FONT>&#X2223; <FONT COLOR=blue><TT>'</TT></FONT> } </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="label"><FONT COLOR=maroon>label</FONT></A></I> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="optlabel"><FONT COLOR=maroon>optlabel</FONT></A></I> </TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Naming labels come in two flavours: <I><A HREF="#label"><FONT COLOR=maroon>label</FONT></A></I> for normal arguments and
<I><A HREF="#optlabel"><FONT COLOR=maroon>optlabel</FONT></A></I> for optional ones. They are simply distinguished by their
first character, either <TT>~</TT> or <TT>?</TT>.</P><P>Despite <I><A HREF="#label"><FONT COLOR=maroon>label</FONT></A></I> and <I><A HREF="#optlabel"><FONT COLOR=maroon>optlabel</FONT></A></I> being lexical entities in expressions,
their expansions <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> and <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> will be
used in grammars, for the sake of readability. Note also that inside
type expressions, this expansion can be taken literally, <EM>i.e.</EM>
there are really 3 tokens, with optional spaces beween them.</P><!--TOC subsubsection Prefix and infix symbols-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Prefix and infix symbols</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="infix-symbol"><FONT COLOR=maroon>infix-symbol</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
(<FONT COLOR=blue><TT>=</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&lt;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&gt;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>@</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>^</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>|</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&amp;</TT></FONT> &#X2223; 
<FONT COLOR=blue><TT>+</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>-</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>*</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>/</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>$</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>%</TT></FONT>) { <I><A HREF="#operator-char"><FONT COLOR=maroon>operator-char</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
(<FONT COLOR=blue><TT>!</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>?</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>~</TT></FONT>) { <I><A HREF="#operator-char"><FONT COLOR=maroon>operator-char</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="operator-char"><FONT COLOR=maroon>operator-char</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>!</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>$</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>%</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&amp;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>*</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>+</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>-</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>.</TT></FONT> &#X2223; 
<FONT COLOR=blue><TT>/</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>:</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&lt;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>=</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&gt;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>?</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>@</TT></FONT> &#X2223; 
<FONT COLOR=blue><TT>^</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>|</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>~</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Sequences of &#X201C;operator characters&#X201D;, such as <TT>&lt;=&gt;</TT> or <TT>!!</TT>,
are read as a single token from the <I><A HREF="#infix-symbol"><FONT COLOR=maroon>infix-symbol</FONT></A></I> or <I><A HREF="#prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>
class. These symbols are parsed as prefix and infix operators inside
expressions, but otherwise behave much as identifiers.
</P><!--TOC subsubsection Keywords-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Keywords</H4><!--SEC END --><P>The identifiers below are reserved as keywords, and cannot be employed
otherwise:
</P><PRE CLASS="verbatim">      and         as          assert      asr         begin       class
      constraint  do          done        downto      else        end
      exception   external    false       for         fun         function
      functor     if          in          include     inherit     initializer
      land        lazy        let         lor         lsl         lsr
      lxor        match       method      mod         module      mutable
      new         object      of          open        or          private
      rec         sig         struct      then        to          true
      try         type        val         virtual     when        while
      with        
</PRE><P>The following character sequences are also keywords:
</P><PRE CLASS="verbatim">    !=    #     &amp;     &amp;&amp;    '     (     )     *     +     ,     -
    -.    -&gt;    .     ..    :     ::    :=    :&gt;    ;     ;;    &lt;
    &lt;-    =     &gt;     &gt;]    &gt;}    ?     ??    [     [&lt;    [&gt;    [|
    ]     _     `     {     {&lt;    |     |]    }     ~
</PRE><P>Note that the following identifiers are keywords of the Camlp4
extensions and should be avoided for compatibility reasons.
</P><PRE CLASS="verbatim">    parser    &lt;&lt;    &lt;:    &gt;&gt;    $     $$    $:
</PRE><!--TOC subsubsection Ambiguities-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Ambiguities</H4><!--SEC END --><P>Lexical ambiguities are resolved according to the &#X201C;longest match&#X201D;
rule: when a character sequence can be decomposed into two tokens in
several different ways, the decomposition retained is the one with the
longest first token.</P><!--TOC subsubsection Line number directives-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Line number directives</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="linenum-directive"><FONT COLOR=maroon>linenum-directive</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>#</TT></FONT> {<FONT COLOR=blue><TT>0</TT></FONT> &#X2026; <FONT COLOR=blue><TT>9</TT></FONT>}<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>#</TT></FONT> {<FONT COLOR=blue><TT>0</TT></FONT> &#X2026; <FONT COLOR=blue><TT>9</TT></FONT>}<SUP>+</SUP> <FONT COLOR=blue><TT>"</TT></FONT> { <I><A HREF="#string-character"><FONT COLOR=maroon>string-character</FONT></A></I> } <FONT COLOR=blue><TT>"</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Preprocessors that generate Caml source code can insert line number
directives in their output so that error messages produced by the
compiler contain line numbers and file names referring to the source
file before preprocessing, instead of after preprocessing.
A line number directive is composed of a <TT>#</TT> (sharp sign), followed by
a positive integer (the source line number), optionally followed by a
character string (the source file name).
Line number directives are treated as blank characters during lexical
analysis.</P><!--TOC section Values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">6.2</A>  Values</H2><!--SEC END --><P>This section describes the kinds of values that are manipulated by
OCaml programs.</P><!--TOC subsection Base values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">6.2.1</A>  Base values</H3><!--SEC END --><!--TOC subsubsection Integer numbers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Integer numbers</H4><!--SEC END --><P>Integer values are integer numbers from &#X2212;2<SUP>30</SUP> to 2<SUP>30</SUP>&#X2212;1, that
is &#X2212;1073741824 to 1073741823. The implementation may support a
wider range of integer values: on 64-bit platforms, the current
implementation supports integers ranging from &#X2212;2<SUP>62</SUP> to 2<SUP>62</SUP>&#X2212;1.</P><!--TOC subsubsection Floating-point numbers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Floating-point numbers</H4><!--SEC END --><P>Floating-point values are numbers in floating-point representation.
The current implementation uses double-precision floating-point
numbers conforming to the IEEE 754 standard, with 53 bits of mantissa
and an exponent ranging from &#X2212;1022 to 1023.</P><!--TOC subsubsection Characters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Characters</H4><!--SEC END --><P>Character values are represented as 8-bit integers between 0 and 255.
Character codes between 0 and 127 are interpreted following the ASCII
standard. The current implementation interprets character codes
between 128 and 255 following the ISO 8859-1 standard.</P><!--TOC subsubsection Character strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Character strings</H4><!--SEC END --><P> <A NAME="s:string-val"></A></P><P>String values are finite sequences of characters. The current
implementation supports strings containing up to 2<SUP>24</SUP> &#X2212; 5
characters (16777211 characters); on 64-bit platforms, the limit is
2<SUP>57</SUP> &#X2212; 9.</P><!--TOC subsection Tuples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">6.2.2</A>  Tuples</H3><!--SEC END --><P>Tuples of values are written (<I>v</I><SUB>1</SUB>, &#X2026;, <I>v<SUB>n</SUB></I>), standing for the
<I>n</I>-tuple of values <I>v</I><SUB>1</SUB> to <I>v<SUB>n</SUB></I>. The current implementation
supports tuple of up to 2<SUP>22</SUP> &#X2212; 1 elements (4194303 elements).</P><!--TOC subsection Records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">6.2.3</A>  Records</H3><!--SEC END --><P>Record values are labeled tuples of values. The record value written
{ <I>field</I><SUB>1</SUB> = <I>v</I><SUB>1</SUB>; &#X2026;; <I>field<SUB>n</SUB></I> = <I>v<SUB>n</SUB></I> } associates the value
<I>v<SUB>i</SUB></I> to the record field <I>field<SUB>i</SUB></I>, for <I>i</I> = 1 &#X2026; <I>n</I>. The current
implementation supports records with up to 2<SUP>22</SUP> &#X2212; 1 fields
(4194303 fields).</P><!--TOC subsection Arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">6.2.4</A>  Arrays</H3><!--SEC END --><P>Arrays are finite, variable-sized sequences of values of the same
type. The current implementation supports arrays containing up to
2<SUP>22</SUP> &#X2212; 1 elements (4194303 elements) unless the elements are
floating-point numbers (2097151 elements in this case); on 64-bit
platforms, the limit is 2<SUP>54</SUP> &#X2212; 1 for all arrays.</P><!--TOC subsection Variant values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">6.2.5</A>  Variant values</H3><!--SEC END --><P>Variant values are either a constant constructor, or a pair of a
non-constant constructor and a value. The former case is written
<I>constr</I>; the latter case is written <I>constr</I>(<I>v</I>), where <I>v</I> is said
to be the argument of the non-constant constructor <I>constr</I>.</P><P>The following constants are treated like built-in constant
constructors:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constant</B></TD><TD ALIGN=center NOWRAP><B>Constructor</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>false</TT></TD><TD ALIGN=left NOWRAP>the boolean false</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>true</TT></TD><TD ALIGN=left NOWRAP>the boolean true</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>()</TT></TD><TD ALIGN=left NOWRAP>the &#X201C;unit&#X201D; value</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>[]</TT></TD><TD ALIGN=left NOWRAP>the empty list</TD></TR>
</TABLE></DIV><P>The current implementation limits each variant type to have at most
246 non-constant constructors.</P><!--TOC subsection Polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">6.2.6</A>  Polymorphic variants</H3><!--SEC END --><P>Polymorphic variants are an alternate form of variant values, not
belonging explicitly to a predefined variant type, and following
specific typing rules. They can be either constant, written
<FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>, or non-constant, written <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>(<I>v</I>).</P><!--TOC subsection Functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">6.2.7</A>  Functions</H3><!--SEC END --><P>Functional values are mappings from values to values.</P><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">6.2.8</A>  Objects</H3><!--SEC END --><P>Objects are composed of a hidden internal state which is a
record of instance variables, and a set of methods for accessing and
modifying these variables. The structure of an object is described by
the toplevel class that created it.</P><!--TOC section Names-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">6.3</A>  Names</H2><!--SEC END --><P> <A NAME="s:names"></A>
</P><P>Identifiers are used to give names to several classes of language
objects and refer to these objects by name later:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
value names (syntactic class <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">value constructors and exception constructors (class <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">labels (<I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">variant tags (<I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">type constructors (<I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">record fields (<I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">class names (<I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">method names (<I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">instance variable names (<I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">module names (<I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>),
</LI><LI CLASS="li-itemize">module type names (<I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I>).
</LI></UL><P>
These eleven name spaces are distinguished both by the context and by the
capitalization of the identifier: whether the first letter of the
identifier is in lowercase (written <FONT COLOR=maroon><I>lowercase-ident</I></FONT> below) or in
uppercase (written <FONT COLOR=maroon><I>capitalized-ident</I></FONT>). Underscore is considered a
lowercase letter for this purpose.</P><P><A NAME="@manual.kwd0"></A>
<A NAME="@manual.kwd1"></A></P><!--TOC subsubsection Naming objects-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Naming objects</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="value-name"><FONT COLOR=maroon>value-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#operator-name"><FONT COLOR=maroon>operator-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="operator-name"><FONT COLOR=maroon>operator-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I> &#X2223;  <I><A HREF="#infix-op"><FONT COLOR=maroon>infix-op</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="infix-op"><FONT COLOR=maroon>infix-op</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#infix-symbol"><FONT COLOR=maroon>infix-symbol</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>*</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>=</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>or</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>&amp;</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>:=</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>mod</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>land</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>lor</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>lxor</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>lsl</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>lsr</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>asr</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>capitalized-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>capitalized-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field-name"><FONT COLOR=maroon>field-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-name"><FONT COLOR=maroon>module-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>capitalized-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-name"><FONT COLOR=maroon>class-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="method-name"><FONT COLOR=maroon>method-name</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
As shown above, prefix and infix symbols as well as some keywords can
be used as value names, provided they are written between parentheses.
The capitalization rules are summarized in the table below.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Name space</B></TD><TD ALIGN=center NOWRAP><B>Case of first letter</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Values</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Constructors</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Labels</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Variant tags</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Exceptions</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Type constructors</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Record fields</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Classes</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Instance variables</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Methods</TD><TD ALIGN=left NOWRAP>lowercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Modules</TD><TD ALIGN=left NOWRAP>uppercase</TD></TR>
<TR><TD ALIGN=left NOWRAP>Module types</TD><TD ALIGN=left NOWRAP>any</TD></TR>
</TABLE></DIV><P><I>Note on variant tags:</I> the current implementation accepts
lowercase variant tags in addition to uppercase variant tags, but we
suggest you avoid lowercase variant tags for portability and
compatibility with future OCaml versions.</P><!--TOC subsubsection Referring to named objects-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Referring to named objects</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="value-path"><FONT COLOR=maroon>value-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr"><FONT COLOR=maroon>constr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field"><FONT COLOR=maroon>field</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-path"><FONT COLOR=maroon>module-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>  <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-path"><FONT COLOR=maroon>class-path</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>A named object can be referred to either by its name (following the
usual static scoping rules for names) or by an access path <FONT COLOR=maroon><I>prefix</I></FONT> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT>,
where <FONT COLOR=maroon><I>prefix</I></FONT> designates a module and <FONT COLOR=maroon><I>name</I></FONT> is the name of an object
defined in that module. The first component of the path, <FONT COLOR=maroon><I>prefix</I></FONT>, is
either a simple module name or an access path <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> &#X2026;,
in case the defining module is itself nested inside other modules.
For referring to type constructors or module types, the <FONT COLOR=maroon><I>prefix</I></FONT> can
also contain simple functor applications (as in the syntactic class
<I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> above), in case the defining module is the
result of a functor application.</P><P>Label names, tag names, method names and instance variable names need
not be qualified: the former three are global labels, while the latter
are local to a class.</P><!--TOC section Type expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">6.4</A>  Type expressions</H2><!--SEC END --><!--NAME types.html-->
<P>
<A NAME="@manual.kwd2"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>_</TT></FONT> 
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> [[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>]  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>*</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> }<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> } <FONT COLOR=blue><TT>)</TT></FONT>  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT> <FONT COLOR=blue><TT>'</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#polymorphic-variant-type"><FONT COLOR=maroon>polymorphic-variant-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>&lt;</TT></FONT> [<FONT COLOR=blue><TT>..</TT></FONT>] <FONT COLOR=blue><TT>&gt;</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>&lt;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I> }  [<FONT COLOR=blue><TT>;</TT></FONT> <FONT COLOR=blue><TT>..</TT></FONT>] <FONT COLOR=blue><TT>&gt;</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> } ) <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> { <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> }<SUP>+</SUP> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="method-type"><FONT COLOR=maroon>method-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed type constructions. The constructions with
higher precedences come first.
<A NAME="@manual.kwd3"></A>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Type constructor application</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>*</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>-&gt;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>as</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><P>Type expressions denote types in definitions of data types as well as
in type constraints over patterns and expressions.</P><!--TOC subsubsection Type variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type variables</H4><!--SEC END --><P>The type expression <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> stands for the type variable named
<I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>. The type expression <FONT COLOR=blue><TT>_</TT></FONT> stands for an anonymous type variable.
In data type definitions, type variables are names for the
data type parameters. In type constraints, they represent unspecified
types that can be instantiated by any type to satisfy the type
constraint. In general the scope of a named type variable is the
whole enclosing definition; and they can only be generalized when leaving
this scope. Anonymous variables have no such restriction.
In the following cases, the scope of named type variables is
restricted to the type expression where they appear: 1) for universal
(explicitly polymorphic) type variables; 2) for type variables that
only appear in public method specifications (as those variables will
be made universal, as described in section <A HREF="#sec-methspec">6.9.1</A>);
3) for variables used as aliases, when the type they are aliased to
would be invalid in the scope of the enclosing definition (<I>i.e.</I>
when it contains free universal type variables, or locally
defined types.)</P><!--TOC subsubsection Parenthesized types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized types</H4><!--SEC END --><P>The type expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> denotes the same type as
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><!--TOC subsubsection Function types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function types</H4><!--SEC END --><P>The type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the type of
functions mapping arguments of type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to results of type
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><P><I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the same function type, but
the argument is labeled <I><A HREF="#label"><FONT COLOR=maroon>label</FONT></A></I>.</P><P><FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> denotes the type of functions
mapping an optional labeled argument of type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to results of
type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. That is, the physical type of the function will be
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>option</TT> <TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><!--TOC subsubsection Tuple types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Tuple types</H4><!--SEC END --><P>The type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>*</TT></FONT> &#X2026; <FONT COLOR=blue><TT>*</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>
denotes the type of tuples whose elements belong to types <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,
&#X2026;  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> respectively.</P><!--TOC subsubsection Constructed types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constructed types</H4><!--SEC END --><P>Type constructors with no parameter, as in <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>, are type
expressions.</P><P>The type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>, where <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> is a type
constructor with one parameter, denotes the application of the unary type
constructor <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> to the type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><P>The type expression (<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,&#X2026;, <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>)  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>, where
<I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> is a type constructor with <I>n</I> parameters, denotes the
application of the <I>n</I>-ary type constructor <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> to the types
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> through <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Aliased and recursive types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Aliased and recursive types</H4><!--SEC END --><P><A NAME="@manual.kwd4"></A></P><P>The type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>as</TT> <TT>'</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> denotes the same type as
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>, and also binds the type variable <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> to type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> both
in <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> and in other types. In general the scope of an alias is
the same as for a named type variable, and covers the whole enclosing
definition. If the type variable
<I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> actually occurs in <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>, a recursive type is created. Recursive
types for which there exists a recursive path that does not contain
an object or polymorphic variant type constructor are rejected, except
when the <TT>-rectypes</TT> mode is selected.</P><P>If <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> denotes an explicit polymorphic variable, and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
denotes either an object or polymorphic variant type, the row variable
of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> is captured by <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>, and quantified upon.</P><!--TOC subsubsection Polymorphic variant types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant types</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="polymorphic-variant-type"><FONT COLOR=maroon>polymorphic-variant-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>[</TT></FONT> [ <FONT COLOR=blue><TT>|</TT></FONT> ] <I><A HREF="#tag-spec"><FONT COLOR=maroon>tag-spec</FONT></A></I>  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#tag-spec"><FONT COLOR=maroon>tag-spec</FONT></A></I> } <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[&gt;</TT></FONT> [ <I><A HREF="#tag-spec"><FONT COLOR=maroon>tag-spec</FONT></A></I> ]  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#tag-spec"><FONT COLOR=maroon>tag-spec</FONT></A></I> } <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[&lt;</TT></FONT> [ <FONT COLOR=blue><TT>|</TT></FONT> ] <I><A HREF="#tag-spec-full"><FONT COLOR=maroon>tag-spec-full</FONT></A></I>  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#tag-spec-full"><FONT COLOR=maroon>tag-spec-full</FONT></A></I> }  [ <FONT COLOR=blue><TT>&gt;</TT></FONT> { <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I> }<SUP>+</SUP> ] <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-spec"><FONT COLOR=maroon>tag-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>  [ <FONT COLOR=blue><TT>of</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> ]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="tag-spec-full"><FONT COLOR=maroon>tag-spec-full</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>  [ <FONT COLOR=blue><TT>of</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> ]  { <FONT COLOR=blue><TT>&amp;</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Polymorphic variant types describe the values a polymorphic variant
may take.</P><P>The first case is an exact variant type: all possible tags are
known, with their associated types, and they can all be present.
Its structure is fully known.</P><P>The second case is an open variant type, describing a polymorphic
variant value: it gives the list of all tags the value could take,
with their associated types. This type is still compatible with a
variant type containing more tags. A special case is the unknown
type, which does not define any tag, and is compatible with any
variant type.</P><P>The third case is a closed variant type. It gives information about
all the possible tags and their associated types, and which tags are
known to potentially appear in values. The above exact variant type is
just an abbreviation for a closed variant type where all possible tags
are also potentially present.</P><P>In all three cases, tags may be either specified directly in the
<I>&#X2018;tag-name </I>[&#X2026;] form, or indirectly through a type
expression. In this last case, the type expression must expand to an
exact variant type, whose tag specifications are inserted in its
place.</P><P>Full specification of variant tags are only used for non-exact closed
types. They can be understood as a conjunctive type for the argument:
it is intended to have all the types enumerated in the
specification.</P><P>Such conjunctive constraints may be unsatisfiable. In such a case the
corresponding tag may not be used in a value of this type. This
does not mean that the whole type is not valid: one can still use
other available tags.</P><!--TOC subsubsection Object types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object types</H4><!--SEC END --><P>An object type
<FONT COLOR=blue><TT>&lt;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I> } <FONT COLOR=blue><TT>&gt;</TT></FONT>
is a record of method types.</P><P>Each method may have an explicit polymorphic type: { <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> }<SUP>+</SUP>
<FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>. Explicit polymorphic variables have a local scope, and
an explicit polymorphic type can only be unified to an
equivalent one, with polymorphic variables at the same positions.</P><P>The type <FONT COLOR=blue><TT>&lt;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I> } <FONT COLOR=blue><TT>;</TT> <TT>..</TT> <TT>&gt;</TT></FONT> is the
type of an object with methods and their associated types are described by
<I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#method-type"><FONT COLOR=maroon>method-type</FONT></A><SUB>n</SUB></I>, and possibly some other
methods represented by the ellipsis. This ellipsis actually is
a special kind of type variable (also called <EM>row variable</EM> in the
literature) that stands for any number of extra method types.</P><!--TOC subsubsection #-types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->#-types</H4><!--SEC END --><P>
<A NAME="s:sharp-types"></A></P><P>The type <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> is a special kind of abbreviation. This
abbreviation unifies with the type of any object belonging to a subclass
of class <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>.
It is handled in a special way as it usually hides a type variable (an
ellipsis, representing the methods that may be added in a subclass).
In particular, it vanishes when the ellipsis gets instantiated.
Each type expression <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> defines a new type variable, so
type <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT> <TT>#</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> is usually not the same as
type (<FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> <FONT COLOR=blue><TT>as</TT> <TT>'</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>) <FONT COLOR=blue><TT>-&gt;</TT> <TT>'</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>.
</P><P>Use of #-types to abbreviate polymorphic variant types is deprecated.
If <TT>t</TT> is an exact variant type then <TT>#t</TT> translates to <TT>[&lt; t]</TT>,
and <FONT COLOR=blue><TT>#t[&gt;</TT> <TT>`tag</TT></FONT><SUB>1</SUB> &#X2026;<FONT COLOR=blue><TT>`tag</TT></FONT><I><SUB>k</SUB></I><FONT COLOR=blue><TT>]</TT></FONT> translates to 
<FONT COLOR=blue><TT>[&lt;</TT> <TT>t</TT> <TT>&gt;</TT> <TT>`tag</TT></FONT><SUB>1</SUB> &#X2026;<FONT COLOR=blue><TT>`tag</TT></FONT><I><SUB>k</SUB></I><FONT COLOR=blue><TT>]</TT></FONT></P><!--TOC subsubsection Variant and record types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variant and record types</H4><!--SEC END --><P>There are no type expressions describing (defined) variant types nor
record types, since those are always named, i.e. defined before use
and referred to by name. Type definitions are described in
section <A HREF="#s:type-defs">6.8.1</A>.

</P><!--TOC section Constants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">6.5</A>  Constants</H2><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="constant"><FONT COLOR=maroon>constant</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#float-literal"><FONT COLOR=maroon>float-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#char-literal"><FONT COLOR=maroon>char-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#string-literal"><FONT COLOR=maroon>string-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>false</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>true</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>()</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The syntactic class of constants comprises literals from the four
base types (integers, floating-point numbers, characters, character
strings), and constant constructors from both normal and polymorphic
variants, as well as the special constants <TT>false</TT>, <TT>true</TT>, <TT>[]</TT>,
and <TT>()</TT>, which behave like constant constructors.

</P><!--TOC section Patterns-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc65">6.6</A>  Patterns</H2><!--SEC END --><P>

<A NAME="@manual.kwd5"></A>
</P><!--NAME patterns.html-->
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="pattern"><FONT COLOR=maroon>pattern</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>_</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constant"><FONT COLOR=maroon>constant</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>|</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>#</TT></FONT><I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> } <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[|</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> } <FONT COLOR=blue><TT>|]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed pattern constructions. The constructions with
higher precedences come first.
<A NAME="@manual.kwd6"></A>
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Constructor application</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>::</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>,</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>|</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>as</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><P>Patterns are templates that allow selecting data structures of a
given shape, and binding identifiers to components of the data
structure. This selection operation is called pattern matching; its
outcome is either &#X201C;this value does not match this pattern&#X201D;, or
&#X201C;this value matches this pattern, resulting in the following bindings
of names to values&#X201D;.</P><!--TOC subsubsection Variable patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variable patterns</H4><!--SEC END --><P>A pattern that consists in a value name matches any value,
binding the name to the value. The pattern <FONT COLOR=blue><TT>_</TT></FONT> also matches
any value, but does not bind any name.</P><P>Patterns are <EM>linear</EM>: a variable cannot appear several times in
a given pattern. In particular, there is no way to test for equality
between two parts of a data structure using only a pattern (but
<FONT COLOR=blue><TT>when</TT></FONT> guards can be used for this purpose).</P><!--TOC subsubsection Constant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constant patterns</H4><!--SEC END --><P>A pattern consisting in a constant matches the values that
are equal to this constant.</P><!--TOC subsubsection Alias patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Alias patterns</H4><!--SEC END --><P>
<A NAME="@manual.kwd7"></A></P><P>The pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> matches the same values as
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>. If the matching against <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> is successful,
the name <FONT COLOR=maroon><I>name</I></FONT> is bound to the matched value, in addition to the
bindings performed by the matching against <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.</P><!--TOC subsubsection Parenthesized patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT> matches the same values as
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>. A type constraint can appear in a
parenthesized pattern, as in <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>. This
constraint forces the type of <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to be compatible with
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><!--TOC subsubsection &#X201C;Or&#X201D; patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->&#X201C;Or&#X201D; patterns</H4><!--SEC END --><P>The pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> represents the logical &#X201C;or&#X201D; of
the two patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> and <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>. A value matches
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> either if it matches <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> or if it
matches <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>. The two sub-patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> and <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>
must bind exactly the same identifiers to values having the same types.
Matching is performed from left to right.
More precisely,
in case some value <I>v</I> matches <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>, the bindings 
performed are those of <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> when <I>v</I> matches <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.
Otherwise, value <I>v</I> matches <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> whose bindings are performed.</P><!--TOC subsubsection Variant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variant patterns</H4><!--SEC END --><P>The pattern <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> matches all variants whose
constructor is equal to <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>, and whose argument matches
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.</P><P>The pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB> matches non-empty lists whose
heads match <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>, and whose tails match <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>2</SUB>.</P><P>The pattern <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> matches lists
of length <I>n</I> whose elements match <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026;<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>,
respectively. This pattern behaves like
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#X2026; <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>::</TT> <TT>[]</TT></FONT>.</P><!--TOC subsubsection Polymorphic variant patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>`tag-name</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> matches all polymorphic variants
whose tag is equal to <I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>, and whose argument matches
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>.</P><!--TOC subsubsection Variant abbreviation patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variant abbreviation patterns</H4><!--SEC END --><P>If the type [<FONT COLOR=blue><TT>('a,'b,...)</TT></FONT>] <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> = <FONT COLOR=blue><TT>[`tag</TT></FONT><SUB>1</SUB>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>
&#X2026; <FONT COLOR=blue><TT>|</TT> <TT>`tag</TT></FONT><I><SUB>n</SUB></I>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I><FONT COLOR=blue><TT>]</TT></FONT> is defined, then the pattern #<I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
is a shorthand for the or-pattern <FONT COLOR=blue><TT>(`tag</TT></FONT><SUB>1</SUB><FONT COLOR=blue><TT>(_</TT> <TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>)</TT> <TT>|</TT></FONT>
&#X2026; <FONT COLOR=blue><TT>|</TT> <TT>`tag</TT></FONT><I><SUB>n</SUB></I><FONT COLOR=blue><TT>(_</TT> <TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I><FONT COLOR=blue><TT>))</TT></FONT>. It matches all values of type
#<I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>.</P><!--TOC subsubsection Tuple patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Tuple patterns</H4><!--SEC END --><P>The pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> matches <I>n</I>-tuples
whose components match the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> through <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. That
is, the pattern matches the tuple values (<I>v</I><SUB>1</SUB>, &#X2026;, <I>v<SUB>n</SUB></I>) such that
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> matches <I>v<SUB>i</SUB></I> for <I>i</I> = 1,&#X2026; , <I>n</I>.</P><!--TOC subsubsection Record patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Record patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>
 <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> matches records that define at least the fields
<I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> through <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>, and such that the value associated to
<I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>i</SUB></I> matches the pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>, for <I>i</I> = 1,&#X2026; , <I>n</I>.
The record value can define more fields than <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026;<I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>; the values associated to these extra fields are not taken
into account for matching.</P><!--TOC subsubsection Array patterns-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Array patterns</H4><!--SEC END --><P>The pattern <FONT COLOR=blue><TT>[|</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT>
matches arrays of length <I>n</I> such that the <I>i</I>-th array element
matches the pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>, for <I>i</I> = 1,&#X2026; , <I>n</I>.</P><!--TOC section Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">6.7</A>  Expressions<A NAME="s:value-expr"></A></H2><!--SEC END --><!--NAME expr.html-->
<P>
<A NAME="@manual.kwd8"></A>
<A NAME="@manual.kwd9"></A>
<A NAME="@manual.kwd10"></A>
<A NAME="@manual.kwd11"></A>
<A NAME="@manual.kwd12"></A>
<A NAME="@manual.kwd13"></A>
<A NAME="@manual.kwd14"></A>
<A NAME="@manual.kwd15"></A>
<A NAME="@manual.kwd16"></A>
<A NAME="@manual.kwd17"></A>
<A NAME="@manual.kwd18"></A>
<A NAME="@manual.kwd19"></A>
<A NAME="@manual.kwd20"></A>
<A NAME="@manual.kwd21"></A>
<A NAME="@manual.kwd22"></A>
<A NAME="@manual.kwd23"></A>
<A NAME="@manual.kwd24"></A>
<A NAME="@manual.kwd25"></A>
<A NAME="@manual.kwd26"></A>
<A NAME="@manual.kwd27"></A>
<A NAME="@manual.kwd28"></A>
<A NAME="@manual.kwd29"></A>
<A NAME="@manual.kwd30"></A>
<A NAME="@manual.kwd31"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="expr"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#value-path"><FONT COLOR=maroon>value-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constant"><FONT COLOR=maroon>constant</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>begin</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>[|</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>|]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I> }<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  <I><A HREF="#infix-op"><FONT COLOR=maroon>infix-op</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.(</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.(</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.[</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.[</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>if</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>then</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  [ <FONT COLOR=blue><TT>else</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> ]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>while</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>do</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>done</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>for</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  ( <FONT COLOR=blue><TT>to</TT></FONT> &#X2223;  <FONT COLOR=blue><TT>downto</TT></FONT> ) <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>do</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>done</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>match</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#pattern-matching"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>function</TT></FONT> <I><A HREF="#pattern-matching"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>fun</TT></FONT> <I><A HREF="#multiple-matching"><FONT COLOR=maroon>multiple-matching</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>try</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#pattern-matching"><FONT COLOR=maroon>pattern-matching</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I>   { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I> } <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>new</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>object</TT></FONT> <I><A HREF="#class-body"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>:&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{&lt;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>&gt;}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>assert</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="argument"><FONT COLOR=maroon>argument</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="pattern-matching"><FONT COLOR=maroon>pattern-matching</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[ <FONT COLOR=blue><TT>|</TT></FONT> ] <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>when</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>when</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="multiple-matching"><FONT COLOR=maroon>multiple-matching</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{ <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I> }<SUP>+</SUP>  [<FONT COLOR=blue><TT>when</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>  { <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I> }  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="parameter"><FONT COLOR=maroon>parameter</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>~</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>]  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>?</TT></FONT> <I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT> <FONT COLOR=blue><TT>(</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>]  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The table below shows the relative precedences and associativity of
operators and non-closed constructions. The constructions with higher
precedence come first. For infix and prefix symbols, we write
&#X201C;<TT>*</TT>&#X2026;&#X201D; to mean &#X201C;any symbol starting with <TT>*</TT>&#X201D;.
<A NAME="@manual.kwd32"></A><A NAME="@manual.kwd33"></A><A NAME="@manual.kwd34"></A><A NAME="@manual.kwd35"></A><A NAME="@manual.kwd36"></A><A NAME="@manual.kwd37"></A><A NAME="@manual.kwd38"></A></P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Construction or operator</B></TD><TD ALIGN=center NOWRAP><B>Associativity</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
prefix-symbol</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>.   .(    .[</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP>function application, constructor application, <TT>assert</TT>, <TT>lazy</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>-   -.</TT> (prefix)</TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>**</TT>&#X2026;<TT>   lsl   lsr   asr</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>*</TT>&#X2026;<TT>   /</TT>&#X2026;<TT>   %</TT>&#X2026;<TT>   mod   land   lor   lxor</TT></TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>+</TT>&#X2026;<TT>   -</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>::</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@</TT>&#X2026;<TT>   ^</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>=</TT>&#X2026;<TT>   &lt;</TT>&#X2026;<TT>   &gt;</TT>&#X2026;<TT>   |</TT>&#X2026;<TT>   &amp;</TT>&#X2026;<TT>   $</TT>&#X2026;</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&amp;   &amp;&amp;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>or  ||</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>,</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&lt;-   :=</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>if</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>;</TT></TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>let  match  fun  function  try</TT></TD><TD ALIGN=left NOWRAP>&#X2013;</TD></TR>
</TABLE></DIV><!--TOC subsection Basic expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">6.7.1</A>  Basic expressions</H3><!--SEC END --><!--TOC subsubsection Constants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constants</H4><!--SEC END --><P>Expressions consisting in a constant evaluate to this constant.</P><!--TOC subsubsection Value paths-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value paths</H4><!--SEC END --><P> <A NAME="expr:var"></A></P><P>Expressions consisting in an access path evaluate to the value bound to
this path in the current evaluation environment. The path can
be either a value name or an access path to a value component of a module.</P><!--TOC subsubsection Parenthesized expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Parenthesized expressions</H4><!--SEC END --><P>
<A NAME="@manual.kwd39"></A>
<A NAME="@manual.kwd40"></A></P><P>The expressions <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> and <FONT COLOR=blue><TT>begin</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> have the same
value as <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. The two constructs are semantically equivalent, but it
is good style to use <FONT COLOR=blue><TT>begin</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> inside control structures:
</P><PRE>
        if &#X2026; then begin &#X2026; ; &#X2026; end else begin &#X2026; ; &#X2026; end
</PRE><P>
and <FONT COLOR=blue><TT>(</TT></FONT> &#X2026; <FONT COLOR=blue><TT>)</TT></FONT> for the other grouping situations.</P><P>Parenthesized expressions can contain a type constraint, as in <FONT COLOR=blue><TT>(</TT></FONT>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>. This constraint forces the type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> to be
compatible with <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.</P><P>Parenthesized expressions can also contain coercions
<FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>:&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT> (see
subsection <A HREF="#s:coercions">6.7.6</A> below).</P><!--TOC subsubsection Function application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function application</H4><!--SEC END --><P>Function application is denoted by juxtaposition of (possibly labeled)
expressions. The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>
evaluates the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> and those appearing in <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>
to <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>. The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> must evaluate to a
functional value <I>f</I>, which is then applied to the values of 
<I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I>.</P><P>The order in which the expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>,  <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I><SUB>1</SUB>, &#X2026;,
 <I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A><SUB>n</SUB></I> are evaluated is not specified.</P><P>Arguments and parameters are matched according to their respective
labels. Argument order is irrelevant, except among arguments with the
same label, or no label.</P><P>If a parameter is specified as optional (label prefixed by <TT>?</TT>) in the
type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the corresponding argument will be automatically
wrapped with the constructor <TT>Some</TT>, except if the argument itself is
also prefixed by <TT>?</TT>, in which case it is passed as is.
If a non-labeled argument is passed, and its corresponding parameter
is preceded by one or several optional parameters, then these
parameters are <EM>defaulted</EM>, <EM>i.e.</EM> the value <TT>None</TT> will be
passed for them.
All other missing parameters (without corresponding argument), both
optional and non-optional, will be kept, and the result of the
function will still be a function of these missing parameters to the
body of <I>f</I>.</P><P>As a special case, if the function has a known arity, all the
arguments are unlabeled, and their number matches the number of
non-optional parameters, then labels are ignored and non-optional
parameters are matched in their definition order. Optional arguments
are defaulted.</P><P>In all cases but exact match of order and labels, without optional
parameters, the function type should be known at the application
point. This can be ensured by adding a type constraint. Principality
of the derivation can be checked in the <TT>-principal</TT> mode.</P><!--TOC subsubsection Function definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function definition</H4><!--SEC END --><P>Two syntactic forms are provided to define functions. The first form
is introduced by the keyword <TT>function</TT>:
<A NAME="@manual.kwd41"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>function</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026; </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
This expression evaluates to a functional value with one argument.
When this function is applied to a value <I>v</I>, this value is
matched against each pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>.
If one of these matchings succeeds, that is, if the value <I>v</I>
matches the pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> for some <I>i</I>,
then the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> associated to the selected pattern
is evaluated, and its value becomes the value of the function
application. The evaluation of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an
environment enriched by the bindings performed during the matching.</P><P>If several patterns match the argument <I>v</I>, the one that occurs
first in the function definition is selected. If none of the patterns
matches the argument, the exception <TT>Match_failure</TT> is raised.
<A NAME="@manual0"></A></P><P><BR>
</P><P>The other form of function definition is introduced by the keyword <TT>fun</TT>:
<A NAME="@manual.kwd42"></A>
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
This expression is equivalent to:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT>  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>The parameter patterns <TT>~var</TT> and <FONT COLOR=blue><TT>~(var</TT></FONT> [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>])</TT></FONT>
are shorthands for respectively <TT>~var:var</TT> and
<FONT COLOR=blue><TT>~var:(var</TT></FONT> [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>]<FONT COLOR=blue><TT>)</TT></FONT>, and similarly for their optional
counterparts.</P><P>Functions of the form <FONT COLOR=blue><TT>fun</TT> <TT>?lab:(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>
 <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> are equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT> <TT>?lab:</TT></FONT><I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT>
<TT>let</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>=</TT>
<TT>match</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>with</TT> <TT>Some</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>|</TT> <TT>None</TT> <TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB>
<FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
where <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
is a fresh variable. When <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> will be evaluated is left
unspecified.</P><P>After these two transformations, expressions are of the form
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> [<I><A HREF="#label"><FONT COLOR=maroon>label</FONT></A></I><SUB>1</SUB>]  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT>  [<I><A HREF="#label"><FONT COLOR=maroon>label</FONT></A><SUB>n</SUB></I>]  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
If we ignore labels, which will only be meaningful at function
application, this is equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>function</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>function</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
That is, the <TT>fun</TT> expression above evaluates to a curried function
with <I>n</I> arguments: after applying this function <I>n</I> times to the
values <I>v</I><SUB>1</SUB> &#X2026; <I>v<SUB>m</SUB></I>, the values will be matched
in parallel against the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>.
If the matching succeeds, the function returns the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> in
an environment enriched by the bindings performed during the matchings.
If the matching fails, the exception <TT>Match_failure</TT> is raised.</P><!--TOC subsubsection Guards in pattern-matchings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Guards in pattern-matchings</H4><!--SEC END --><P><A NAME="@manual.kwd43"></A>
Cases of a pattern matching (in the <TT>function</TT>, <TT>fun</TT>, <TT>match</TT> and
<TT>try</TT> constructs) can include guard expressions, which are
arbitrary boolean expressions that must evaluate to <TT>true</TT> for the
match case to be selected. Guards occur just before the <TT>-&gt;</TT> token and
are introduced by the <TT>when</TT> keyword:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>function</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB>   [<FONT COLOR=blue><TT>when</TT></FONT>   <FONT COLOR=maroon><I>cond</I></FONT><SUB>1</SUB>]</TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026; </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I>    [<FONT COLOR=blue><TT>when</TT></FONT>   <I><FONT COLOR=maroon>cond</FONT><SUB>n</SUB></I>]</TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Matching proceeds as described before, except that if the value
matches some pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> which has a guard <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I>, then the
expression <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> is evaluated (in an environment enriched by the
bindings performed during matching). If <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> evaluates to <TT>true</TT>,
then <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated and its value returned as the result of the
matching, as usual. But if <I><FONT COLOR=maroon>cond</FONT><SUB>i</SUB></I> evaluates to <TT>false</TT>, the matching
is resumed against the patterns following <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I>.</P><!--TOC subsubsection Local definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Local definitions</H4><!--SEC END --><P> <A NAME="s:localdef"></A></P><P><A NAME="@manual.kwd44"></A></P><P>The <TT>let</TT> and <TT>let rec</TT> constructs bind value names locally.
The construct
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
evaluates <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> in some unspecified order, then matches
their values against the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the
matchings succeed, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is evaluated in the environment enriched by
the bindings performed during matching, and the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is
returned as the value of the whole <TT>let</TT> expression. If one of the
matchings fails, the exception <TT>Match_failure</TT> is raised.
<A NAME="@manual1"></A></P><P>An alternate syntax is provided to bind variables to functional
values: instead of writing
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT>  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
in a <TT>let</TT> expression, one may instead write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P><BR>
Recursive definitions of names are introduced by <TT>let rec</TT>:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT>  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>
<FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
The only difference with the <TT>let</TT> construct described above is
that the bindings of names to values performed by the
pattern-matching are considered already performed when the expressions
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are evaluated. That is, the expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>
to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> can reference identifiers that are bound by one of the
patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>, and expect them to have the
same value as in <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the body of the <TT>let rec</TT> construct.</P><P>The recursive definition is guaranteed to behave as described above if
the expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are function definitions
(<FONT COLOR=blue><TT>fun</TT></FONT> &#X2026; or <FONT COLOR=blue><TT>function</TT></FONT> &#X2026;), and the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB>
&#X2026;  <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I> are just value names, as in:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT>  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT> <TT>fun</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
This defines <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> as mutually recursive functions
local to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. </P><P>The behavior of other forms of <TT>let rec</TT> definitions is
implementation-dependent. The current implementation also supports
a certain class of recursive definitions of non-functional values,
as explained in section <A HREF="#s:letrecvalues">7.3</A>.</P><!--TOC subsection Control structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">6.7.2</A>  Control structures</H3><!--SEC END --><!--TOC subsubsection Sequence-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Sequence</H4><!--SEC END --><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> first, then
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, and returns the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.</P><!--TOC subsubsection Conditional-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Conditional</H4><!--SEC END --><P>
<A NAME="@manual.kwd45"></A></P><P>The expression <FONT COLOR=blue><TT>if</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>else</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> evaluates to
the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> if <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to the boolean <FONT COLOR=blue><TT>true</TT></FONT>,
and to the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> if <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to the boolean
<FONT COLOR=blue><TT>false</TT></FONT>.</P><P>The <FONT COLOR=blue><TT>else</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> part can be omitted, in which case it defaults to
<FONT COLOR=blue><TT>else</TT> <TT>()</TT></FONT>.</P><!--TOC subsubsection Case expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Case expression</H4><!--SEC END --><P><A NAME="@manual.kwd46"></A></P><P>The expression
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>match</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>with</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026; </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
matches the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> against the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the matching against <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> succeeds, the
associated expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated, and its value becomes the
value of the whole <FONT COLOR=blue><TT>match</TT></FONT> expression. The evaluation of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an environment enriched by the bindings
performed during matching. If several patterns match the value of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the one that occurs first in the <FONT COLOR=blue><TT>match</TT></FONT> expression is
selected. If none of the patterns match the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the
exception <FONT COLOR=blue><TT>Match_failure</TT></FONT> is raised.
<A NAME="@manual2"></A></P><!--TOC subsubsection Boolean operators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Boolean operators</H4><!--SEC END --><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT> if both
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluate to <FONT COLOR=blue><TT>true</TT></FONT>; otherwise, it evaluates to
<FONT COLOR=blue><TT>false</TT></FONT>. The first component, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, is evaluated first. The
second component, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, is not evaluated if the first component
evaluates to <FONT COLOR=blue><TT>false</TT></FONT>. Hence, the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> behaves 
exactly as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>if</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>else</TT> <TT>false</TT></FONT>.
</DIV><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>||</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT> if one of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT>; otherwise, it evaluates to
<FONT COLOR=blue><TT>false</TT></FONT>. The first component, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, is evaluated first. The
second component, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>, is not evaluated if the first component
evaluates to <FONT COLOR=blue><TT>true</TT></FONT>. Hence, the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>||</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> behaves 
exactly as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>if</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>then</TT> <TT>true</TT> <TT>else</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.
</DIV><P><A NAME="@manual.kwd47"></A>
The boolean operator <FONT COLOR=blue><TT>&amp;</TT></FONT> is synonymous for <FONT COLOR=blue><TT>&amp;&amp;</TT></FONT>. The boolean operator
<FONT COLOR=blue><TT>or</TT></FONT> is synonymous for <FONT COLOR=blue><TT>||</TT></FONT>.</P><!--TOC subsubsection Loops-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Loops</H4><!--SEC END --><P><A NAME="@manual.kwd48"></A>
The expression <FONT COLOR=blue><TT>while</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>do</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>done</TT></FONT> repeatedly
evaluates <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> while <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> evaluates to <FONT COLOR=blue><TT>true</TT></FONT>. The loop
condition <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> is evaluated and tested at the beginning of each
iteration. The whole <FONT COLOR=blue><TT>while</TT></FONT> &#X2026; <FONT COLOR=blue><TT>done</TT></FONT> expression evaluates to
the unit value <FONT COLOR=blue><TT>()</TT></FONT>.</P><P><A NAME="@manual.kwd49"></A>
The expression <FONT COLOR=blue><TT>for</TT> <FONT COLOR=maroon><I>name</I></FONT> <TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>to</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>do</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> <FONT COLOR=blue><TT>done</TT></FONT>
first evaluates the expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> (the boundaries)
into integer values <I>n</I> and <I>p</I>. Then, the loop body <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> is
repeatedly evaluated in an environment where <FONT COLOR=maroon><I>name</I></FONT> is successively
bound to the values
<I>n</I>, <I>n</I>+1, &#X2026;, <I>p</I>&#X2212;1, <I>p</I>.
The loop body is never evaluated if <I>n</I> &gt; <I>p</I>.</P><P>The expression <FONT COLOR=blue><TT>for</TT> <FONT COLOR=maroon><I>name</I></FONT> <TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>downto</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>do</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> <FONT COLOR=blue><TT>done</TT></FONT>
evaluates similarly, except that <FONT COLOR=maroon><I>name</I></FONT> is successively bound to the values
<I>n</I>, <I>n</I>&#X2212;1, &#X2026;, <I>p</I>+1, <I>p</I>.
The loop body is never evaluated if <I>n</I> &lt; <I>p</I>.</P><P>In both cases, the whole <FONT COLOR=blue><TT>for</TT></FONT> expression evaluates to the unit
value <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Exception handling-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception handling</H4><!--SEC END --><P>
<A NAME="@manual.kwd50"></A></P><P>The expression
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>try </TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>with</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>pattern</I></FONT><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I>expr</I></FONT><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP>&#X2026; </TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=blue><TT>|</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>pattern</FONT><SUB>n</SUB></I></TD><TD ALIGN=left NOWRAP><FONT COLOR=blue><TT>-&gt;</TT></FONT></TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>expr</FONT><SUB>n</SUB></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
evaluates the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> and returns its value if the
evaluation of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> does not raise any exception. If the evaluation
of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> raises an exception, the exception value is matched against
the patterns <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I><SUB>1</SUB> to <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>n</SUB></I>. If the matching against
<I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A><SUB>i</SUB></I> succeeds, the associated expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> is evaluated,
and its value becomes the value of the whole <FONT COLOR=blue><TT>try</TT></FONT> expression. The
evaluation of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> takes place in an environment enriched by the
bindings performed during matching. If several patterns match the value of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the one that occurs first in the <FONT COLOR=blue><TT>try</TT></FONT> expression is
selected. If none of the patterns matches the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, the
exception value is raised again, thereby transparently &#X201C;passing
through&#X201D; the <FONT COLOR=blue><TT>try</TT></FONT> construct.</P><!--TOC subsection Operations on data structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">6.7.3</A>  Operations on data structures</H3><!--SEC END --><!--TOC subsubsection Products-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Products</H4><!--SEC END --><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> evaluates to the
<I>n</I>-tuple of the values of expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>. The
evaluation order for the subexpressions is not specified.</P><!--TOC subsubsection Variants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variants</H4><!--SEC END --><P>The expression <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to the variant value whose
constructor is <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>, and whose argument is the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>For lists, some syntactic sugar is provided. The expression
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> stands for the constructor <FONT COLOR=blue><TT>(</TT> <TT>::</TT> <TT>)</TT></FONT> 
applied to the argument <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT>, and therefore
evaluates to the list whose head is the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> and whose tail
is the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>. The expression <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>
 <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT> is equivalent to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>::</TT></FONT> &#X2026; <FONT COLOR=blue><TT>::</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>::</TT>
<TT>[]</TT></FONT>, and therefore evaluates to the list whose elements are the
values of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Polymorphic variants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variants</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to the polymorphic variant
value whose tag is <I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I>, and whose argument is the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.</P><!--TOC subsubsection Records-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Records</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>
 <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> evaluates to the record value
{ <I>field</I><SUB>1</SUB> = <I>v</I><SUB>1</SUB>; &#X2026;; <I>field<SUB>n</SUB></I> = <I>v<SUB>n</SUB></I> }
where <I>v<SUB>i</SUB></I> is the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I> for <I>i</I> = 1,&#X2026; , <I>n</I>.
The fields <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> to <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> must all belong to the same record
types; all fields belonging to this record type must appear exactly
once in the record expression, though they can appear in any
order. The order in which <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> are evaluated is not
specified.</P><P>The expression
<FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT>
builds a fresh record with fields <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I> equal to
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>, and all other fields having the same value as
in the record <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. In other terms, it returns a shallow copy of
the record <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, except for the fields <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>n</SUB></I>,
which are initialized to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> evaluates <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to a record
value, and returns the value associated to <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> in this record
value.</P><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to a record
value, which is then modified in-place by replacing the value
associated to <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> in this record by the value of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>. This operation is permitted only if <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> has been
declared <FONT COLOR=blue><TT>mutable</TT></FONT> in the definition of the record type. The whole
expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> evaluates to the unit value
<FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>[|</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT> evaluates to
a <I>n</I>-element array, whose elements are initialized with the values of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> to <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> respectively. The order in which these
expressions are evaluated is unspecified.</P><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.(</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT> returns the value of element
number <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> in the array denoted by <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>. The first element
has number 0; the last element has number <I>n</I>&#X2212;1, where <I>n</I> is the
size of the array. The exception <TT>Invalid_argument</TT> is raised if the
access is out of bounds.</P><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.(</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT> <TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> modifies in-place
the array denoted by <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, replacing element number <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> by
the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB>. The exception <TT>Invalid_argument</TT> is raised if
the access is out of bounds. The value of the whole expression is <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Strings</H4><!--SEC END --><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.[</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>]</TT></FONT> returns the value of character
number <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> in the string denoted by <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>. The first character
has number 0; the last character has number <I>n</I>&#X2212;1, where <I>n</I> is the
length of the string. The exception <TT>Invalid_argument</TT> is raised if the
access is out of bounds.</P><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>.[</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>]</TT> <TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB> modifies in-place
the string denoted by <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>, replacing character number <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> by
the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>3</SUB>. The exception <TT>Invalid_argument</TT> is raised if
the access is out of bounds. The value of the whole expression is <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsection Operators-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">6.7.4</A>  Operators</H3><!--SEC END --><P>Symbols from the class <FONT COLOR=blue><TT>infix-symbols</TT></FONT>, as well as the keywords
<TT>*</TT>, <TT>=</TT>, <TT>or</TT> and <TT>&amp;</TT>, can appear in infix position (between two
expressions). Symbols from the class <FONT COLOR=blue><TT>prefix-symbols</TT></FONT>
can appear in prefix position (in front of an expression).</P><P>Infix and prefix symbols do not have a fixed meaning: they are simply
interpreted as applications of functions bound to the names
corresponding to the symbols. The expression <I><A HREF="#prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is
interpreted as the application <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#prefix-symbol"><FONT COLOR=maroon>prefix-symbol</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. Similarly, the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>  <I><A HREF="#infix-symbol"><FONT COLOR=maroon>infix-symbol</FONT></A></I>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB> is
interpreted as the application <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#infix-symbol"><FONT COLOR=maroon>infix-symbol</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>.</P><P>The table below lists the symbols defined in the initial environment
and their initial meaning. (See the description of the core
library module <TT>Pervasives</TT> in chapter <A HREF="#c:corelib">19</A> for more
details). Their meaning may be changed at any time using
<FONT COLOR=blue><TT>let</TT> <TT>(</TT></FONT> <I><A HREF="#infix-op"><FONT COLOR=maroon>infix-op</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB>  <FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT></FONT> &#X2026;</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Operator</B></TD><TD ALIGN=center NOWRAP><B>Initial meaning</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>+</TT></TD><TD VALIGN=top ALIGN=left>Integer addition.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-</TT> (infix)</TD><TD VALIGN=top ALIGN=left>Integer subtraction.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-</TT> (prefix)</TD><TD VALIGN=top ALIGN=left>Integer negation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>*</TT></TD><TD VALIGN=top ALIGN=left>Integer multiplication.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>/</TT></TD><TD VALIGN=top ALIGN=left>Integer division.
Raise <TT>Division_by_zero</TT> if second argument is zero.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>mod</TT></TD><TD VALIGN=top ALIGN=left>Integer modulus. Raise
<TT>Division_by_zero</TT> if second argument is zero.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>land</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;and&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lor</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;or&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lxor</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical &#X201C;exclusive or&#X201D; on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lsl</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical shift left on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>lsr</TT></TD><TD VALIGN=top ALIGN=left>Bitwise logical shift right on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>asr</TT></TD><TD VALIGN=top ALIGN=left>Bitwise arithmetic shift right on integers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>+.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point addition.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-.</TT> (infix)</TD><TD VALIGN=top ALIGN=left>Floating-point subtraction.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>-.</TT> (prefix)</TD><TD VALIGN=top ALIGN=left>Floating-point negation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>*.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point multiplication.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>/.</TT></TD><TD VALIGN=top ALIGN=left>Floating-point division.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>**</TT></TD><TD VALIGN=top ALIGN=left>Floating-point exponentiation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>@</TT> </TD><TD VALIGN=top ALIGN=left>List concatenation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>^</TT> </TD><TD VALIGN=top ALIGN=left>String concatenation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>!</TT> </TD><TD VALIGN=top ALIGN=left>Dereferencing (return the current
contents of a reference).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>:=</TT></TD><TD VALIGN=top ALIGN=left>Reference assignment (update the
reference given as first argument with the value of the second
argument).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>=</TT> </TD><TD VALIGN=top ALIGN=left>Structural equality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;&gt;</TT> </TD><TD VALIGN=top ALIGN=left>Structural inequality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>==</TT> </TD><TD VALIGN=top ALIGN=left>Physical equality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>!=</TT> </TD><TD VALIGN=top ALIGN=left>Physical inequality test.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;less than&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&lt;=</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;less than or equal&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&gt;</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;greater than&#X201D;.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>&gt;=</TT> </TD><TD VALIGN=top ALIGN=left>Test &#X201C;greater than or equal&#X201D;.</TD></TR>
</TABLE></DIV><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">6.7.5</A>  Objects</H3><!--SEC END --><P> <A NAME="s:objects"></A></P><!--TOC subsubsection Object creation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object creation</H4><!--SEC END --><P><A NAME="@manual.kwd51"></A></P><P>When <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to a class body, <FONT COLOR=blue><TT>new</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to an object containing the instance variables and
methods of this class.</P><P>When <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to a class function, <FONT COLOR=blue><TT>new</TT></FONT> <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to a function expecting the same number of arguments and
returning a new object of this class.</P><!--TOC subsubsection Immediate object creation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Immediate object creation</H4><!--SEC END --><P><A NAME="@manual.kwd52"></A></P><P>Creating directly an object through the <FONT COLOR=blue><TT>object</TT></FONT> <I><A HREF="#class-body"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
construct is operationally equivalent to defining locally a <FONT COLOR=blue><TT>class</TT></FONT>
<I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>object</TT></FONT>  <I><A HREF="#class-body"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> &#X2014;see sections
<A HREF="#ss:class-body">6.9.2</A> and following for the syntax of <I><A HREF="#class-body"><FONT COLOR=maroon>class-body</FONT></A></I>&#X2014;
and immediately creating a single object from it by <FONT COLOR=blue><TT>new</TT></FONT> <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I>.</P><P>The typing of immediate objects is slightly different from explicitely
defining a class in two respects. First, the inferred object type may
contain free type variables. Second, since the class body of an
immediate object will never be extended, its self type can be unified
with a closed object type.</P><!--TOC subsubsection Message sending-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Message sending</H4><!--SEC END --><P>The expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> invokes the method
<I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> of the object denoted by <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>If <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> is a polymorphic method, its type should be known at
the invocation site. This is true for instance if <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is the name
of a fresh object (<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> = <FONT COLOR=blue><TT>new</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> &#X2026; ) or if
there is a type constraint. Principality of the derivation can be
checked in the <TT>-principal</TT> mode.</P><!--TOC subsubsection Accessing and modifying instance variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Accessing and modifying instance variables</H4><!--SEC END --><P>The instance variables of a class are visible only in the body of the
methods defined in the same class or a class that inherits from the
class defining the instance variables. The expression <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
evaluates to the value of the given instance variable. The expression
<I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> assigns the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> to the instance
variable <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>, which must be mutable. The whole expression
<I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to <FONT COLOR=blue><TT>()</TT></FONT>.</P><!--TOC subsubsection Object duplication-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object duplication</H4><!--SEC END --><P>An object can be duplicated using the library function <TT>Oo.copy</TT>
(see 
<A HREF="libref/Oo.html">Module <TT>Oo</TT></A>). Inside a method, the expression
 <FONT COLOR=blue><TT>{&lt;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } <FONT COLOR=blue><TT>&gt;}</TT></FONT>
returns a copy of self with the given instance variables replaced by
the values of the associated expressions; other instance variables
have the same value in the returned object as in self.</P><!--TOC subsection Coercions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">6.7.6</A>  Coercions</H3><!--SEC END --><P> <A NAME="s:coercions"></A></P><P>Expressions whose type contains object or polymorphic variant types
can be explicitly coerced (weakened) to a supertype.
The expression <FONT COLOR=blue><TT>(</TT></FONT><I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT> coerces the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
to type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.
The expression <FONT COLOR=blue><TT>(</TT></FONT><I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB><FONT COLOR=blue><TT>)</TT></FONT> coerces the
expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> from type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.</P><P>The former operator will sometimes fail to coerce an expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
from a type <I>t</I><SUB>1</SUB> to a type <I>t</I><SUB>2</SUB> even if type <I>t</I><SUB>1</SUB> is a subtype of type
<I>t</I><SUB>2</SUB>: in the current implementation it only expands two levels of
type abbreviations containing objects and/or polymorphic variants,
keeping only recursion when it is explicit in the class type (for objects).
As an exception to the above algorithm, if both the inferred type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> are ground (<EM>i.e.</EM> do not contain type variables), the
former operator behaves as the latter one, taking the inferred type of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> as <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>. In case of failure with the former operator,
the latter one should be used.</P><P>It is only possible to coerce an expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> from type
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> to type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>, if the type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is an instance of
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> (like for a type annotation), and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a subtype
of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. The type of the coerced expression is an
instance of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. If the types contain variables,
they may be instanciated by the subtyping algorithm, but this is only
done after determining whether <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a potential subtype of
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. This means that typing may fail during this latter
unification step, even if some instance of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> is a subtype of
some instance of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>.
In the following paragraphs we describe the subtyping relation used. </P><!--TOC subsubsection Object types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Object types</H4><!--SEC END --><P>A fixed object type admits as subtype any object type including all
its methods. The types of the methods shall be subtypes of those in
the supertype. Namely,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT> &lt; </TT> <I>met</I><SUB>1</SUB> <TT>  : </TT> <I>typ</I><SUB>1</SUB> <TT>  ; </TT> ... <TT>  ; </TT> <I>met<SUB>n</SUB></I> <TT>  : </TT> <I>typ<SUB>n</SUB></I> <TT> &gt; </TT> </TD></TR>
</TABLE><P>
is a supertype of
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT> &lt; </TT> <I>met</I><SUB>1</SUB> <TT>  : </TT> <I>typ</I>&#X2032;<SUB>1</SUB> <TT>  ; </TT> ... <TT>  ; </TT> <I>met<SUB>n</SUB></I> <TT>  : </TT> <I>typ</I>&#X2032;<I><SUB>n</SUB></I> <TT>  ; </TT>
<I>met</I><SUB><I>n</I>+1</SUB> <TT>  : </TT> <I>typ</I>&#X2032;<SUB><I>n</I>+1</SUB> <TT>  ; </TT> ... <TT>  ; </TT> <I>met</I><SUB><I>n</I>+<I>m</I></SUB> <TT>  : </TT> <I>typ</I>&#X2032;<SUB><I>n</I>+<I>m</I></SUB>
 [<TT> ; ..</TT>] <TT>  &gt;</TT> </TD></TR>
</TABLE><P>
which may contain an ellipsis <TT>..</TT>, if every <I>typ<SUB>i</SUB></I> is a supertype of
<I>typ</I>&#X2032;<I><SUB>i</SUB></I>.</P><P>A monomorphic method type can be a supertype of a polymorphic method
type. Namely, if <FONT COLOR=maroon><I>typ</I></FONT> is an instance of <I>typ</I>&#X2032;, then <TT> &#X2032;</TT><I>a</I><SUB>1</SUB>
...<TT> &#X2032;</TT><I>a<SUB>n</SUB></I><TT> .</TT><I>typ</I>&#X2032; is a subtype of <FONT COLOR=maroon><I>typ</I></FONT>.</P><P>Inside a class definition, newly defined types are not available for
subtyping, as the type abbreviations are not yet completely
defined. There is an exception for coercing <FONT COLOR=maroon><I>self</I></FONT> to the (exact)
type of its class: this is allowed if the type of <FONT COLOR=maroon><I>self</I></FONT> does not
appear in a contravariant position in the class type, <EM>i.e.</EM> if
there are no binary methods.</P><!--TOC subsubsection Polymorphic variant types-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Polymorphic variant types</H4><!--SEC END --><P>A polymorphic variant type <FONT COLOR=maroon><I>typ</I></FONT> is subtype of another polymorphic
variant type <I>typ</I>&#X2032; if the upper bound of <FONT COLOR=maroon><I>typ</I></FONT> (<EM>i.e.</EM> the
maximum set of constructors that may appear in an instance of <FONT COLOR=maroon><I>typ</I></FONT>)
is included in the lower bound of <I>typ</I>&#X2032;, and the types of arguments
for the constructors of <FONT COLOR=maroon><I>typ</I></FONT> are subtypes of those in
<I>typ</I>&#X2032;. Namely,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT> [</TT>[<TT> &lt;</TT>] <TT>  &#X2032;</TT><I>C</I><SUB>1</SUB> <TT>  <I>of</I> </TT> <I>typ</I><SUB>1</SUB> <TT>  | </TT> ... <TT>  | &#X2032;</TT><I>C<SUB>n</SUB></I> <TT>  <I>of</I> </TT> <I>typ<SUB>n</SUB></I> <TT>  ]</TT> </TD></TR>
</TABLE><P>
which may be a shrinkable type, is a subtype of
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TT> [</TT>[<TT> &gt;</TT>] <TT>  &#X2032;</TT><I>C</I><SUB>1</SUB> <TT>  <I>of</I> </TT> <I>typ</I>&#X2032;<SUB>1</SUB> <TT>  | </TT> ... <TT>  | &#X2032;</TT><I>C<SUB>n</SUB></I> <TT>  <I>of</I> </TT> <I>typ</I>&#X2032;<I><SUB>n</SUB></I>
<TT> | &#X2032;</TT><I>C</I><SUB><I>n</I>+1</SUB> <TT>  <I>of</I> </TT> <I>typ</I>&#X2032;<SUB><I>n</I>+1</SUB> <TT>  | </TT> ... <TT>  | &#X2032;</TT><I>C</I><SUB><I>n</I>+<I>m</I></SUB> <TT>  <I>of</I> </TT>
<I>typ</I>&#X2032;<SUB><I>n</I>+<I>m</I></SUB> <TT>  ]</TT> </TD></TR>
</TABLE><P>
which may be an extensible type, if every <I>typ<SUB>i</SUB></I> is a subtype of <I>typ</I>&#X2032;<I><SUB>i</SUB></I>.</P><!--TOC subsubsection Variance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variance</H4><!--SEC END --><P>Other types do not introduce new subtyping, but they may propagate the
subtyping of their arguments. For instance, <I>typ</I><SUB>1</SUB> <TT>  * </TT> <I>typ</I><SUB>2</SUB> is a
subtype of <I>typ</I>&#X2032;<SUB>1</SUB> <TT>  * </TT> <I>typ</I>&#X2032;<SUB>2</SUB> when <I>typ</I><SUB>1</SUB> and <I>typ</I><SUB>2</SUB> are
respectively subtypes of <I>typ</I>&#X2032;<SUB>1</SUB> and <I>typ</I>&#X2032;<SUB>2</SUB>.
For function types, the relation is more subtle:
<I>typ</I><SUB>1</SUB> <TT>-&gt;</TT> <I>typ</I><SUB>2</SUB> is a subtype of <I>typ</I>&#X2032;<SUB>1</SUB> <TT>-&gt;</TT> <I>typ</I>&#X2032;<SUB>2</SUB>
if <I>typ</I><SUB>1</SUB> is a supertype of <I>typ</I>&#X2032;<SUB>1</SUB> and <I>typ</I><SUB>2</SUB> is a
subtype of <I>typ</I>&#X2032;<SUB>2</SUB>. For this reason, function types are covariant in
their second argument (like tuples), but contravariant in their first
argument. Mutable types, like <TT>array</TT> or <TT>ref</TT> are neither covariant
nor contravariant, they are nonvariant, that is they do not propagate
subtyping.</P><P>For user defined types, the variance is automatically inferred: a
parameter is covariant if it has only covariant occurences,
contravariant if it has only contravariant occurences,
variance-free if it has no occurences, and nonvariant otherwise.
A variance-free parameter may change freely through subtyping, it does
not have to be a subtype or a supertype.
For abstract and private types, the variance must be given explicitly,
otherwise the default is nonvariant. This is also the case for
constrained arguments in type definitions.</P><!--TOC section Type and exception definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc73">6.8</A>  Type and exception definitions</H2><!--SEC END --><!--TOC subsection Type definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.8.1</A>  Type definitions</H3><!--SEC END --><P>
<A NAME="s:type-defs"></A></P><P>Type definitions bind type constructors to data types: either
variant types, record types, type abbreviations, or abstract data
types. They also bind the value constructors and record fields
associated with the definition.</P><P><A NAME="@manual.kwd53"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-definition"><FONT COLOR=maroon>type-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="typedef"><FONT COLOR=maroon>typedef</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<I><A HREF="#type-params"><FONT COLOR=maroon>type-params</FONT></A></I>]  <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I>  [<I><A HREF="#type-information"><FONT COLOR=maroon>type-information</FONT></A></I>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-information"><FONT COLOR=maroon>type-information</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<I><A HREF="#type-equation"><FONT COLOR=maroon>type-equation</FONT></A></I>]  [<I><A HREF="#type-representation"><FONT COLOR=maroon>type-representation</FONT></A></I>]  { <I><A HREF="#type-constraint"><FONT COLOR=maroon>type-constraint</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-equation"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-representation"><FONT COLOR=maroon>type-representation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I>  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-params"><FONT COLOR=maroon>type-params</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#type-param"><FONT COLOR=maroon>type-param</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#type-param"><FONT COLOR=maroon>type-param</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#type-param"><FONT COLOR=maroon>type-param</FONT></A></I> } <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-param"><FONT COLOR=maroon>type-param</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>+</TT></FONT> <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>-</TT></FONT> <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>of</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>*</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>mutable</TT></FONT> <I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-constraint"><FONT COLOR=maroon>type-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>constraint</TT></FONT> <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<A NAME="@manual.kwd54"></A>
<A NAME="@manual.kwd55"></A></P><P>Type definitions are introduced by the <TT>type</TT> keyword, and
consist in one or several simple definitions, possibly mutually
recursive, separated by the <TT>and</TT> keyword. Each simple definition
defines one type constructor.</P><P>A simple definition consists in a lowercase identifier, possibly
preceded by one or several type parameters, and followed by an
optional type equation, then an optional type representation, and then
a constraint clause. The identifier is the name of the type
constructor being defined.</P><P>The optional type parameters are either one type variable <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>,
for type constructors with one parameter, or a list of type variables
(<FONT COLOR=blue><TT>'</TT></FONT><I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I><SUB>1</SUB>,&#X2026;,<FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A><SUB>n</SUB></I>), for type constructors with several
parameters. Each type parameter may be prefixed by a variance
constraint <FONT COLOR=blue><TT>+</TT></FONT> (resp. <FONT COLOR=blue><TT>-</TT></FONT>) indicating that the parameter is
covariant (resp. contravariant). These type parameters can appear in
the type expressions of the right-hand side of the definition,
restricted eventually by a variance constraint ; <EM>i.e.</EM> a
covariant parameter may only appear on the right side of a functional
arrow (more precisely, follow the left branch of an even number of
arrows), and a contravariant parameter only the left side (left branch of
an odd number of arrows). If the type has either a representation or
an equation, and the parameter is free (<EM>i.e.</EM> not bound via a
type constraint to a constructed type), its variance constraint is
checked but subtyping <EM>etc.</EM> will use the inferred variance of the
parameter, which may be better; otherwise (<EM>i.e.</EM> for abstract
types or non-free parameters), the variance must be given explicitly,
and the parameter is invariant if no variance was given.</P><P>The optional type equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> makes the defined type
equivalent to the type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> on the right of the <FONT COLOR=blue><TT>=</TT></FONT>
sign: one can be substituted for the other during typing.
If no type equation is given, a new type is generated: the defined type
is incompatible with any other type.</P><P>The optional type representation describes the data structure
representing the defined type, by giving the list of associated
constructors (if it is a variant type) or associated fields (if it is
a record type). If no type representation is given, nothing is
assumed on the structure of the type besides what is stated in the
optional type equation.</P><P>The type representation <FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I>  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I> }
describes a variant type. The constructor declarations
<I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A><SUB>n</SUB></I> describe the constructors
associated to this variant type. The constructor
declaration <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>of</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> declares the name
<I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> as a non-constant constructor, whose
arguments have types <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> &#X2026;<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.
The constructor declaration <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>
declares the name <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> as a constant
constructor. Constructor names must be capitalized.</P><P>The type representation <FONT COLOR=blue><TT>=</TT> <TT>{</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT>
describes a record type. The field declarations <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I><SUB>1</SUB>, &#X2026;,
 <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A><SUB>n</SUB></I> describe the fields associated to this record type.
The field declaration <I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> declares
<I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I> as a field whose argument has type <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>.
The field declaration <FONT COLOR=blue><TT>mutable</TT></FONT> <I><A HREF="#field-name"><FONT COLOR=maroon>field-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
<A NAME="@manual.kwd56"></A>
behaves similarly; in addition, it allows physical modification over
the argument to this field.
Immutable fields are covariant, but mutable fields are neither
covariant nor contravariant.
Both mutable and immutable field may have an explicitly polymorphic
type. The polymorphism of the contents is statically checked whenever
a record value is created or modified. Extracted values may have their
types instanciated.</P><P>The two components of a type definition, the optional equation and the
optional representation, can be combined independently, giving
rise to four typical situations:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Abstract type: no equation, no representation.</B></DT><DD CLASS="dd-description">  <BR>
When appearing in a module signature, this definition specifies
nothing on the type constructor, besides its number of parameters: 
its representation is hidden and it is assumed incompatible with any
other type.</DD><DT CLASS="dt-description"><B>Type abbreviation: an equation, no representation.</B></DT><DD CLASS="dd-description">  <BR>
This defines the type constructor as an abbreviation for the type
expression on the right of the <FONT COLOR=blue><TT>=</TT></FONT> sign. </DD><DT CLASS="dt-description"><B>New variant type or record type: no equation, a representation.</B></DT><DD CLASS="dd-description">  <BR>
This generates a new type constructor and defines associated
constructors or fields, through which values of that type can be
directly built or inspected.</DD><DT CLASS="dt-description"><B>Re-exported variant type or record type: an equation,
a representation.</B></DT><DD CLASS="dd-description">  <BR>
In this case, the type constructor is defined as an abbreviation for
the type expression given in the equation, but in addition the
constructors or fields given in the representation remain attached to
the defined type constructor. The type expression in the equation part
must agree with the representation: it must be of the same kind
(record or variant) and have exactly the same constructors or fields,
in the same order, with the same arguments. 
</DD></DL><P>The type variables appearing as type parameters can optionally be
prefixed by <TT>+</TT> or <TT>-</TT> to indicate that the type constructor is
covariant or contravariant with respect to this parameter. This
variance information is used to decide subtyping relations when
checking the validity of <FONT COLOR=blue><TT>:&gt;</TT></FONT> coercions (see section <A HREF="#s:coercions">6.7.6</A>).</P><P>For instance, <TT>type +&#X2019;a t</TT> declares <TT>t</TT> as an abstract type that is
covariant in its parameter; this means that if the type &#X3C4; is a
subtype of the type &#X3C3;, then &#X3C4; <I><TT>  t</TT></I> is a subtype of &#X3C3;
<I><TT>  t</TT></I>. Similarly, <TT>type -&#X2019;a t</TT> declares that the abstract type <TT>t</TT> is
contravariant in its parameter: if &#X3C4; is subtype of &#X3C3;, then
&#X3C3; <I><TT>  t</TT></I> is subtype of &#X3C4; <I><TT>  t</TT></I>. If no <TT>+</TT> or <TT>-</TT> variance
annotation is given, the type constructor is assumed invariant in the
corresponding parameter. For instance, the abstract type declaration
<TT>type &#X2019;a t</TT> means that &#X3C4; <I><TT>  t</TT></I> is neither a subtype nor a
supertype of &#X3C3; <I><TT>  t</TT></I> if &#X3C4; is subtype of &#X3C3;.</P><P>The variance indicated by the <TT>+</TT> and <TT>-</TT> annotations on parameters
are required only for abstract types. For abbreviations, variant
types or record types, the variance properties of the type constructor
are inferred from its definition, and the variance annotations are
only checked for conformance with the definition.</P><P><A NAME="@manual.kwd57"></A>
The construct  <FONT COLOR=blue><TT>constraint</TT> <TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  allows to specify
type parameters. Any actual type argument corresponding to the type
parameter <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> has to be an instance of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> (more precisely,
<I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> are unified). Type variables of <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> can
appear in the type equation and the type declaration.</P><!--TOC subsection Exception definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">6.8.2</A>  Exception definitions</H3><!--SEC END --><P> <A NAME="s:excdef"></A>
<A NAME="@manual.kwd58"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="exception-definition"><FONT COLOR=maroon>exception-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>  [<FONT COLOR=blue><TT>of</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>*</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> }]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Exception definitions add new constructors to the built-in variant
type <CODE>exn</CODE> of exception values. The constructors are declared as
for a definition of a variant type.</P><P>The form <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I>  [<FONT COLOR=blue><TT>of</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  { <FONT COLOR=blue><TT>*</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> }]
generates a new exception, distinct from all other exceptions in the system.
The form <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>
gives an alternate name to an existing exception.

</P><!--TOC section Classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">6.9</A>  Classes</H2><!--SEC END --><P>Classes are defined using a small language, similar to the module
language.</P><!--TOC subsection Class types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">6.9.1</A>  Class types</H3><!--SEC END --><P>Class types are the class-level equivalent of type expressions: they
specify the general shape and type properties of classes.</P><P><A NAME="@manual.kwd59"></A>
<A NAME="@manual.kwd60"></A>
<A NAME="@manual.kwd61"></A>
<A NAME="@manual.kwd62"></A>
<A NAME="@manual.kwd63"></A>
<A NAME="@manual.kwd64"></A>
<A NAME="@manual.kwd65"></A>
<A NAME="@manual.kwd66"></A>
<A NAME="@manual.kwd67"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-type"><FONT COLOR=maroon>class-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#class-body-type"><FONT COLOR=maroon>class-body-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  [[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>]  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-body-type"><FONT COLOR=maroon>class-body-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>object</TT></FONT> [<FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>]  {<I><A HREF="#class-field-spec"><FONT COLOR=maroon>class-field-spec</FONT></A></I>} <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  {<FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>} <FONT COLOR=blue><TT>]</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-field-spec"><FONT COLOR=maroon>class-field-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>inherit</TT></FONT> <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] [<FONT COLOR=blue><TT>virtual</TT></FONT>] <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT> <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Simple class expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple class expressions</H4><!--SEC END --><P>The expression <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> is equivalent to the class type bound to
the name <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>. Similarly, the expression
<FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026;  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> is equivalent to
the parametric class type bound to the name <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>, in which
type parameters have been instanciated to respectively <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>,
&#X2026;<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Class function type-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class function type</H4><!--SEC END --><P>The class type expression <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> is the type of
class functions (functions from values to classes) that take as
argument a value of type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> and return as result a class of
type <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>.</P><!--TOC subsubsection Class body type-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class body type</H4><!--SEC END --><P>The class type expression
<FONT COLOR=blue><TT>object</TT></FONT> [<FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>]  {<I><A HREF="#class-field-spec"><FONT COLOR=maroon>class-field-spec</FONT></A></I>} <FONT COLOR=blue><TT>end</TT></FONT>
is the type of a class body. It specifies its instance variables and
methods. In this type, <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> is matched against the self type, therefore
providing a binding for the self type.</P><P>A class body will match a class body type if it provides definitions
for all the components specified in the class type, and these
definitions meet the type requirements given in the class type.
Furthermore, all methods either virtual or public present in the class
body must also be present in the class type (on the other hand, some
instance variables and concrete private methods may be omitted). A
virtual method will match a concrete method, which makes it possible
to forget its implementation. An immutable instance variable will match a
mutable instance variable.</P><!--TOC subsubsection Inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Inheritance</H4><!--SEC END --><P><A NAME="@manual.kwd68"></A></P><P>The inheritance construct <FONT COLOR=blue><TT>inherit</TT></FONT> <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> allows to include
methods and instance variables from other classes types.
The instance variable and method types from this class type are added
into the current class type.</P><!--TOC subsubsection Instance variable specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Instance variable specification</H4><!--SEC END --><P><A NAME="@manual.kwd69"></A>
<A NAME="@manual.kwd70"></A>
<A NAME="@manual.kwd71"></A></P><P>A specification of an instance variable is written
<FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] [<FONT COLOR=blue><TT>virtual</TT></FONT>] <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>, where
<I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>
is the name of the instance variable and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> its expected type.
The flag <FONT COLOR=blue><TT>mutable</TT></FONT> indicates whether this instance variable can be
physically modified.
The flag <FONT COLOR=blue><TT>virtual</TT></FONT> indicates that this instance variable is not
initialized. It can be initialized later through inheritance.</P><P>An instance variable specification will hide any previous
specification of an instance variable of the same name.</P><!--TOC subsubsection Method specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Method specification</H4><!--SEC END --><P>
<A NAME="sec-methspec"></A></P><P><A NAME="@manual.kwd72"></A>
<A NAME="@manual.kwd73"></A></P><P>The specification of a method is written
<FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>, where
<I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> is the name of the method and <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> its
expected type, possibly polymorphic. The flag <FONT COLOR=blue><TT>private</TT></FONT> indicates
that the method cannot be accessed from outside the object.</P><P>The polymorphism may be left implicit in public method specifications:
any type variable which is not bound to a class parameter and does not
appear elsewhere inside the class specification will be assumed to be
universal, and made polymorphic in the resulting method type.
Writing an explicit polymorphic type will disable this behaviour.</P><P>Several specifications for the same method must have compatible types.
Any non-private specification of a method forces it to be public.</P><!--TOC subsubsection Virtual method specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual method specification</H4><!--SEC END --><P><A NAME="@manual.kwd74"></A>
<A NAME="@manual.kwd75"></A>
<A NAME="@manual.kwd76"></A></P><P>Virtual method specification is written <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>]
<FONT COLOR=blue><TT>virtual</TT></FONT> <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>, where <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> is the
name of the method and <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> its expected type.</P><!--TOC subsubsection Constraints on type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constraints on type parameters</H4><!--SEC END --><P><A NAME="@manual.kwd77"></A></P><P>The construct <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.</P><!--TOC subsection Class expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">6.9.2</A>  Class expressions</H3><!--SEC END --><P>Class expressions are the class-level equivalent of value expressions:
they evaluate to classes, thus providing implementations for the
specifications expressed in class types.</P><P><A NAME="@manual.kwd78"></A>
<A NAME="@manual.kwd79"></A>
<A NAME="@manual.kwd80"></A>
<A NAME="@manual.kwd81"></A>
<A NAME="@manual.kwd82"></A>
<A NAME="@manual.kwd83"></A>
<A NAME="@manual.kwd84"></A>
<A NAME="@manual.kwd85"></A>
<A NAME="@manual.kwd86"></A>
<A NAME="@manual.kwd87"></A>
<A NAME="@manual.kwd88"></A>
<A NAME="@manual.kwd89"></A>
<A NAME="@manual.kwd90"></A>
<A NAME="@manual.kwd91"></A>
<A NAME="@manual.kwd92"></A>
<A NAME="@manual.kwd93"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>  {<FONT COLOR=blue><TT>,</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>} <FONT COLOR=blue><TT>]</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>  {<I><A HREF="#argument"><FONT COLOR=maroon>argument</FONT></A></I>}<SUP>+</SUP>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>fun</TT></FONT> {<I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I>}<SUP>+</SUP> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I>  {<FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I>} <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>object</TT></FONT> [<FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT>]  { <I><A HREF="#class-field"><FONT COLOR=maroon>class-field</FONT></A></I> } <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-field"><FONT COLOR=maroon>class-field</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>inherit</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>  [<FONT COLOR=blue><TT>as</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>  {<I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I>}  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT> <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>initializer</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Simple class expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple class expressions</H4><!--SEC END --><P>The expression <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I> evaluates to the class bound to the name
<I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>. Similarly, the expression
<FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>,</TT></FONT> &#X2026;  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>]</TT></FONT>  <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>
evaluates to the parametric class bound to the name <I><A HREF="#class-path"><FONT COLOR=maroon>class-path</FONT></A></I>,
in which type parameters have been instanciated to respectively
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB>, &#X2026;<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A><SUB>n</SUB></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> evaluates to the same module as
<I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> checks that
<I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> match the type of <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> (that is, that the
implementation <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> meets the type specification
<I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>). The whole expression evaluates to the same class as
<I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>, except that all components not specified in
<I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I> are hidden and can no longer be accessed.</P><!--TOC subsubsection Class application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class application</H4><!--SEC END --><P>Class application is denoted by juxtaposition of (possibly labeled)
expressions. It denotes the class whose constructor is the original
constructor applied to the given arguments. The arguments are
evaluated like for expression application, but the constructor itself will
only be evaluated when objects are created. In particular, side-effects
caused by the application of the constructor will only occur at object
creation time.</P><!--TOC subsubsection Class function-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class function</H4><!--SEC END --><P>The expression <FONT COLOR=blue><TT>fun</TT></FONT> [[<FONT COLOR=blue><TT>?</TT></FONT>]<I><A HREF="#label-name"><FONT COLOR=maroon>label-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>] <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> evaluates
to a function from values to classes.
When this function is applied to a value <I>v</I>, this value is
matched against the pattern <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> and the result is the result of
the evaluation of <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> in the extended environment.</P><P>Conversion from functions with default values to functions with
patterns only works identically for class functions as for normal
functions.</P><P>The expression
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>
</DIV><P>
is a short form for
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>fun</TT></FONT> <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>fun</TT></FONT>  <I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><!--TOC subsubsection Local definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Local definitions</H4><!--SEC END --><P>The <TT>let</TT> and <TT>let rec</TT> constructs bind value names locally,
as for the core language expressions.</P><P>If a local definition occurs at the very beginning of a class
definition, it will be evaluated when the class is created (just as if
the definition was outside of the class).
Otherwise, it will be evaluated when the object constructor is called.</P><!--TOC subsubsection Class body-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class<A NAME="ss:class-body"></A> body</H4><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-body"><FONT COLOR=maroon>class-body</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>  [<FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT>]  { <I><A HREF="#class-field"><FONT COLOR=maroon>class-field</FONT></A></I> }</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
The expression
<FONT COLOR=blue><TT>object</TT></FONT> <I><A HREF="#class-body"><FONT COLOR=maroon>class-body</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT> denotes
a class body. This is the prototype for an object : it lists the
instance variables and methods of an objet of this class.</P><P>A class body is a class value: it is not evaluated at once. Rather,
its components are evaluated each time an object is created.</P><P>In a class body, the pattern <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>)</TT></FONT> is
matched against self, therefore provinding a binding for self and self
type. Self can only be used in method and initializers.</P><P>Self type cannot be a closed object type, so that the class remains
extensible.</P><!--TOC subsubsection Inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Inheritance</H4><!--SEC END --><P><A NAME="@manual.kwd94"></A></P><P>The inheritance construct <FONT COLOR=blue><TT>inherit</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> allows to reuse
methods and instance variables from other classes. The class
expression <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> must evaluate to a class body. The instance
variables, methods and initializers from this class body are added
into the current class. The addition of a method will override any
previously defined methods of the same name.</P><P><A NAME="@manual.kwd95"></A>
An ancestor can be bound by prepending the construct <FONT COLOR=blue><TT>as</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>
to the inheritance construct above. <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> is not a true
variable and can only be used to select a method, i.e. in an expression
<I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>. This gives access to the
method <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> as it was defined in the parent class even if it is
redefined in the current class. 
The scope of an ancestor binding is limited to the current class. 
The ancestor method may be called from a subclass but only indirectly. </P><!--TOC subsubsection Instance variable definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Instance variable definition</H4><!--SEC END --><P><A NAME="@manual.kwd96"></A>
<A NAME="@manual.kwd97"></A></P><P>The definition <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> adds an
instance variable <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> whose initial value is the value of
expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.
The flag <FONT COLOR=blue><TT>mutable</TT></FONT> allows physical modification of this variable by
methods.</P><P>An instance variables can only be used in the following methods and
initializers of the class.</P><P>Since version 3.10, redefinitions of a visible instance variable with
the same name do not create a new variable, but are merged, using the
last value for initialization. They must have identical types and
mutability.
However, if an instance variable is hidden by
omitting it from an interface, it will be kept distinct from
other instance variables with the same name.</P><!--TOC subsubsection Virtual instance variable definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual instance variable definition</H4><!--SEC END --><P><A NAME="@manual.kwd98"></A>
<A NAME="@manual.kwd99"></A>
<A NAME="@manual.kwd100"></A></P><P>Variable specification is written <FONT COLOR=blue><TT>val</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT>
<I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>. It specifies whether the variable is
modifiable, and gives its type.</P><P>Virtual instance variables were added in version 3.10.</P><!--TOC subsubsection Method definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Method definition</H4><!--SEC END --><P><A NAME="@manual.kwd101"></A>
<A NAME="@manual.kwd102"></A></P><P>Method definition is written <FONT COLOR=blue><TT>method</TT></FONT> <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. The
definition of a method overrides any previous definition of this
method. The method will be public (that is, not private) if any of
the definition states so.</P><P>A private method, <FONT COLOR=blue><TT>method</TT> <TT>private</TT></FONT> <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, is a
method that can only be invoked on self (from other methods of the
same object, defined in this class or one of its subclasses). This
invocation is performed using the expression
<I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>, where <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> is directly bound to
self at the beginning of the class definition. Private methods do
not appear in object types. A method may have both public and private
definitions, but as soon as there is a public one, all subsequent
definitions will be made public.</P><P>Methods may have an explicitly polymorphic type, allowing them to be
used polymorphically in programs (even for the same object). The
explicit declaration may be done in one of three ways: (1) by giving an
explicit polymorphic type in the method definition, immediately after
the method name, <EM>i.e.</EM>
<FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  {<FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>}<SUP>+</SUP> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>
 <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>; (2) by a forward declaration of the explicit polymorphic type
through a virtual method definition; (3) by importing such a
declaration through inheritance and/or constraining the type of <EM>self</EM>.</P><P>Some special expressions are available in method bodies for
manipulating instance variables and duplicating self:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X2026;
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{&lt;</TT></FONT> [ <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } ] <FONT COLOR=blue><TT>&gt;}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expression <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>&lt;-</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> modifies in-place the current
object by replacing the value associated to <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> by the
value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. Of course, this instance variable must have been
declared mutable.</P><P>The expression
<FONT COLOR=blue><TT>{&lt;</TT></FONT> [ <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> } ] <FONT COLOR=blue><TT>&gt;}</TT></FONT>
evaluates to a copy of the current object in which the values of
instance variables <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I><SUB>1</SUB>, &#X2026;,  <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A><SUB>n</SUB></I> have
been replaced by the values of the corresponding expressions <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>,
&#X2026;,  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I>.</P><!--TOC subsubsection Virtual method definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual method definition</H4><!--SEC END --><P><A NAME="@manual.kwd103"></A>
<A NAME="@manual.kwd104"></A>
<A NAME="@manual.kwd105"></A></P><P>Method specification is written <FONT COLOR=blue><TT>method</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <FONT COLOR=blue><TT>virtual</TT></FONT>
<I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I>. It specifies whether the method is
public or private, and gives its type. If the method is intended to be
polymorphic, the type should be explicit.</P><!--TOC subsubsection Constraints on type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Constraints on type parameters</H4><!--SEC END --><P><A NAME="@manual.kwd106"></A></P><P>The construct <FONT COLOR=blue><TT>constraint</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB> forces the two
type expressions to be equals. This is typically used to specify type
parameters: they can be that way be bound to a specified type
expression.</P><!--TOC subsubsection Initializers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Initializers</H4><!--SEC END --><P><A NAME="@manual.kwd107"></A></P><P>A class initializer <FONT COLOR=blue><TT>initializer</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> specifies an expression that
will be evaluated when an object will be created from the class, once
all the instance variables have been initialized.</P><!--TOC subsection Class definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">6.9.3</A>  Class definitions</H3><!--SEC END --><P>
<A NAME="s:classdef"></A></P><P><A NAME="@manual.kwd108"></A>
<A NAME="@manual.kwd109"></A>
<A NAME="@manual.kwd110"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-definition"><FONT COLOR=maroon>class-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT> <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>] [<FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT>]  <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I>
 {<I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I>}  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>]  <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>  { <FONT COLOR=blue><TT>,</TT></FONT> <FONT COLOR=blue><TT>'</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A class definition <FONT COLOR=blue><TT>class</TT></FONT> <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I> } is
recursive. Each <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I> defines a <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> that can be
used in the whole expression except for inheritance. It can also be
used for inheritance, but only in the definitions that follow its own.</P><P>A class binding binds the class name <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> to the value of
expression <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>. It also binds the class type <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> to
the type of the class, and defines two type abbreviations :
<I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> and <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I>. The first one is the type of
objects of this class, while the second is more general as it unifies
with the type of any object belonging to a subclass (see
section <A HREF="#s:sharp-types">6.4</A>).</P><!--TOC subsubsection Virtual class-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Virtual class</H4><!--SEC END --><P><A NAME="@manual.kwd111"></A>
A class must be flagged virtual if one of its methods is virtual (that
is, appears in the class type, but is not actually defined).
Objects cannot be created from a virtual class.</P><!--TOC subsubsection Type parameters-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type parameters</H4><!--SEC END --><P>The class type parameters correspond to the ones of the class type and
of the two type abbreviations defined by the class binding. They must
be bound to actual types in the class definition using type
constraints. So that the abbreviations are well-formed, type
variables of the inferred type of the class must either be type
parameters or be bound in the constraint clause.</P><!--TOC subsection Class specification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">6.9.4</A>  Class specification</H3><!--SEC END --><P>
<A NAME="s:class-spec"></A></P><P><A NAME="@manual.kwd112"></A>
<A NAME="@manual.kwd113"></A>
<A NAME="@manual.kwd114"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-specification"><FONT COLOR=maroon>class-specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT> <I><A HREF="#class-spec"><FONT COLOR=maroon>class-spec</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#class-spec"><FONT COLOR=maroon>class-spec</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="class-spec"><FONT COLOR=maroon>class-spec</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>] [<FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT>]  <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>
 <I><A HREF="#class-type"><FONT COLOR=maroon>class-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>This is the counterpart in signatures of class definitions.
A class specification matches a class definition if they have the same
type parameters and their types match.</P><!--TOC subsection Class type definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">6.9.5</A>  Class type definitions</H3><!--SEC END --><P>
<A NAME="s:classtype"></A></P><P><A NAME="@manual.kwd115"></A>
<A NAME="@manual.kwd116"></A>
<A NAME="@manual.kwd117"></A>
<A NAME="@manual.kwd118"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="classtype-definition"><FONT COLOR=maroon>classtype-definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>class</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I>
 { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
[<FONT COLOR=blue><TT>virtual</TT></FONT>] [<FONT COLOR=blue><TT>[</TT></FONT> <I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I> <FONT COLOR=blue><TT>]</TT></FONT>]  <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#class-body-type"><FONT COLOR=maroon>class-body-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A class type definition <FONT COLOR=blue><TT>class</TT></FONT> <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#class-body-type"><FONT COLOR=maroon>class-body-type</FONT></A></I>
defines an abbreviation <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> for the class body type
<I><A HREF="#class-body-type"><FONT COLOR=maroon>class-body-type</FONT></A></I>. As for class definitions, two type abbreviations
<I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> and <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#class-name"><FONT COLOR=maroon>class-name</FONT></A></I> are also defined. The definition can
be parameterized by some type parameters. If any method in the class
type body is virtual, the definition must be flagged <FONT COLOR=blue><TT>virtual</TT></FONT>.</P><P>Two class type definitions match if they have the same type parameters
and the types they expand to match.

</P><!--TOC section Module types (module specifications)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc82">6.10</A>  Module types (module specifications)</H2><!--SEC END --><P>Module types are the module-level equivalent of type expressions: they
specify the general shape and type properties of modules.</P><P><A NAME="@manual.kwd119"></A>
<A NAME="@manual.kwd120"></A>
<A NAME="@manual.kwd121"></A>
<A NAME="@manual.kwd122"></A>
<A NAME="@manual.kwd123"></A>
<A NAME="@manual.kwd124"></A>
<A NAME="@manual.kwd125"></A>
<A NAME="@manual.kwd126"></A>
<A NAME="@manual.kwd127"></A>
<A NAME="@manual.kwd128"></A>
<A NAME="@manual.kwd129"></A>
<A NAME="@manual.kwd130"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-type"><FONT COLOR=maroon>module-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>sig</TT></FONT> { <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A></I>  [<FONT COLOR=blue><TT>;;</TT></FONT>] } <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>functor</TT></FONT> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#mod-constraint"><FONT COLOR=maroon>mod-constraint</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#mod-constraint"><FONT COLOR=maroon>mod-constraint</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="mod-constraint"><FONT COLOR=maroon>mod-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT> [<I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I>]  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="specification"><FONT COLOR=maroon>specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>external</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <FONT COLOR=maroon><I>external-declaration</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#type-definition"><FONT COLOR=maroon>type-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#class-specification"><FONT COLOR=maroon>class-specification</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#classtype-definition"><FONT COLOR=maroon>classtype-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>  { <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> }
<FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>include</TT></FONT> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Simple module types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">6.10.1</A>  Simple module types</H3><!--SEC END --><P>The expression <I><A HREF="#modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I> is equivalent to the module type bound
to the name <I><A HREF="#modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I>.
The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> denotes the same type as
<I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>.</P><!--TOC subsection Signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">6.10.2</A>  Signatures</H3><!--SEC END --><P><A NAME="@manual.kwd131"></A>
<A NAME="@manual.kwd132"></A></P><P>Signatures are type specifications for structures. Signatures
<FONT COLOR=blue><TT>sig</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> are collections of type specifications for value
names, type names, exceptions, module names and module type names. A
structure will match a signature if the structure provides definitions
(implementations) for all the names specified in the signature (and
possibly more), and these definitions meet the type requirements given
in the signature.</P><P>For compatibility with Caml Light, an optional <TT>;;</TT> is allowed after each
specification in a signature. The <TT>;;</TT> has no semantic meaning.</P><!--TOC subsubsection Value specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value specifications</H4><!--SEC END --><P><A NAME="@manual.kwd133"></A></P><P>A specification of a value component in a signature is written
<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>, where <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> is the name of the
value and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> its expected type.</P><P><A NAME="@manual.kwd134"></A></P><P>The form <FONT COLOR=blue><TT>external</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <FONT COLOR=maroon><I>external-declaration</I></FONT>
is similar, except that it requires in addition the name to be
implemented as the external function specified in <FONT COLOR=maroon><I>external-declaration</I></FONT>
(see chapter <A HREF="#c:intf-c">18</A>).</P><!--TOC subsubsection Type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd135"></A></P><P>A specification of one or several type components in a signature is
written <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of type names.</P><P>Each type definition in the signature specifies an optional type
equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> and an optional type representation 
<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I> &#X2026; or <FONT COLOR=blue><TT>=</TT> <TT>{</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I> &#X2026; <FONT COLOR=blue><TT>}</TT></FONT>.
The implementation of the type name in a matching structure must
be compatible with the type expression specified in the equation (if
given), and have the specified representation (if given). Conversely,
users of that signature will be able to rely on the type equation
or type representation, if given. More precisely, we have the
following four situations:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Abstract type: no equation, no representation.</B></DT><DD CLASS="dd-description">  <BR>
Names that are defined as abstract types in a signature can be
implemented in a matching structure by any kind of type definition
(provided it has the same number of type parameters). The exact
implementation of the type will be hidden to the users of the
structure. In particular, if the type is implemented as a variant type
or record type, the associated constructors and fields will not be
accessible to the users; if the type is implemented as an
abbreviation, the type equality between the type name and the
right-hand side of the abbreviation will be hidden from the users of the
structure. Users of the structure consider that type as incompatible
with any other type: a fresh type has been generated.</DD><DT CLASS="dt-description"><B>Type abbreviation: an equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>, no representation.</B></DT><DD CLASS="dd-description">  <BR>
The type name must be implemented by a type compatible with <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.
All users of the structure know that the type name is
compatible with <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.</DD><DT CLASS="dt-description"><B>New variant type or record type: no equation, a representation.</B></DT><DD CLASS="dd-description">  <BR>
The type name must be implemented by a variant type or record type
with exactly the constructors or fields specified. All users of the
structure have access to the constructors or fields, and can use them
to create or inspect values of that type. However, users of the
structure consider that type as incompatible with any other type: a
fresh type has been generated.</DD><DT CLASS="dt-description"><B>Re-exported variant type or record type: an equation,
a representation.</B></DT><DD CLASS="dd-description">  <BR>
This case combines the previous two: the representation of the type is
made visible to all users, and no fresh type is generated.
</DD></DL><!--TOC subsubsection Exception specification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception specification</H4><!--SEC END --><P><A NAME="@manual.kwd136"></A></P><P>The specification <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I> in a signature requires the
matching structure to provide an exception with the name and arguments
specified in the definition, and makes the exception available to all
users of the structure.</P><!--TOC subsubsection Class specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class specifications</H4><!--SEC END --><P><A NAME="@manual.kwd137"></A></P><P>A specification of one or several classes in a signature is written
<FONT COLOR=blue><TT>class</TT></FONT> <I><A HREF="#class-spec"><FONT COLOR=maroon>class-spec</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#class-spec"><FONT COLOR=maroon>class-spec</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of class names.</P><P>Class specifications are described more precisely in
section <A HREF="#s:class-spec">6.9.4</A>.</P><!--TOC subsubsection Class type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd138"></A>
<A NAME="@manual.kwd139"></A></P><P>A specification of one or several classe types in a signature is
written <FONT COLOR=blue><TT>class</TT> <TT>type</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I> { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I> } and
consists of a sequence of mutually recursive definitions of class type
names. Class type specifications are described more precisely in
section <A HREF="#s:classtype">6.9.5</A>.</P><!--TOC subsubsection Module specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module specifications</H4><!--SEC END --><P><A NAME="@manual.kwd140"></A></P><P>A specification of a module component in a signature is written
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>, where <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> is the
name of the module component and <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> its expected type.
Modules can be nested arbitrarily; in particular, functors can appear
as components of structures and functor types as components of
signatures.</P><P>For specifying a module component that is a functor, one may write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT>
&#X2026; <FONT COLOR=blue><TT>(</TT></FONT>  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>)</TT>
<TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
</DIV><P>
instead of
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT>
<TT>functor</TT> <TT>(</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
</DIV><!--TOC subsubsection Module type specifications-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module type specifications</H4><!--SEC END --><P><A NAME="@manual.kwd141"></A>
<A NAME="@manual.kwd142"></A></P><P>A module type component of a signature can be specified either as a
manifest module type or as an abstract module type.</P><P>An abstract module type specification
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> allows the name <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> to be
implemented by any module type in a matching signature, but hides the
implementation of the module type to all users of the signature.</P><P>A manifest module type specification
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
requires the name <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> to be implemented by the module type
<I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> in a matching signature, but makes the equality between
<I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> and <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> apparent to all users of the signature.</P><!--TOC subsubsection Opening a module path-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Opening a module path</H4><!--SEC END --><P><A NAME="@manual.kwd143"></A></P><P>The expression <FONT COLOR=blue><TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> in a signature does not specify
any components. It simply affects the parsing of the following items
of the signature, allowing components of the module denoted by
<I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> to be referred to by their simple names <FONT COLOR=maroon><I>name</I></FONT> instead of
path accesses <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT>. The scope of the <TT>open</TT>
stops at the end of the signature expression.</P><!--TOC subsubsection Including a signature-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Including a signature</H4><!--SEC END --><P><A NAME="@manual.kwd144"></A></P><P>The expression <FONT COLOR=blue><TT>include</TT></FONT> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> in a signature performs textual
inclusion of the components of the signature denoted by <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>.
It behaves as if the components of the included signature were copied
at the location of the <FONT COLOR=blue><TT>include</TT></FONT>. The <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> argument must
refer to a module type that is a signature, not a functor type.</P><!--TOC subsection Functor types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">6.10.3</A>  Functor types</H3><!--SEC END --><P><A NAME="@manual.kwd145"></A></P><P>The module type expression 
<FONT COLOR=blue><TT>functor</TT> <TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB> 
is the type of functors (functions from modules to modules) that take
as argument a module of type <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> and return as result a
module of type <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB>. The module type <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>2</SUB> can
use the name <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> to refer to type components of the actual
argument of the functor. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (&#X201C;higher-order&#X201D; functor).</P><!--TOC subsection The <TT>with</TT> operator-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">6.10.4</A>  The <TT>with</TT> operator</H3><!--SEC END --><P><A NAME="@manual.kwd146"></A></P><P>Assuming <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> denotes a signature, the expression
<I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#mod-constraint"><FONT COLOR=maroon>mod-constraint</FONT></A></I> { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#mod-constraint"><FONT COLOR=maroon>mod-constraint</FONT></A></I> } denotes
the same signature where type equations have been added to some of the
type specifications, as described by the constraints following the
<TT>with</TT> keyword. The constraint <FONT COLOR=blue><TT>type</TT></FONT> [<I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I>]  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
<FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> adds the type equation <FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> to the specification
of the type component named <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I> of the constrained signature.
The constraint <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I> adds
type equations to all type components of the sub-structure denoted by
<I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>, making them equivalent to the corresponding type
components of the structure denoted by <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I>.</P><P>For instance, if the module type name <TT>S</TT> is bound to the signature
</P><PRE CLASS="verbatim">        sig type t module M: (sig type u end) end
</PRE><P>then <TT>S with type t=int</TT> denotes the signature
</P><PRE CLASS="verbatim">        sig type t=int module M: (sig type u end) end
</PRE><P>and <TT>S with module M = N</TT> denotes the signature
</P><PRE CLASS="verbatim">        sig type t module M: (sig type u=N.u end) end
</PRE><P>A functor taking two arguments of type <TT>S</TT> that share their <TT>t</TT> component
is written
</P><PRE CLASS="verbatim">        functor (A: S) (B: S with type t = A.t) ...
</PRE><P>Constraints are added left to right. After each constraint has been
applied, the resulting signature must be a subtype of the signature
before the constraint was applied. Thus, the <FONT COLOR=blue><TT>with</TT></FONT> operator can
only add information on the type components of a signature, but never
remove information.

</P><!--TOC section Module expressions (module implementations)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc87">6.11</A>  Module<A NAME="s:module-expr"></A> expressions (module implementations)</H2><!--SEC END --><P>Module expressions are the module-level equivalent of value
expressions: they evaluate to modules, thus providing implementations
for the specifications expressed in module types.</P><P><A NAME="@manual.kwd147"></A>
<A NAME="@manual.kwd148"></A>
<A NAME="@manual.kwd149"></A>
<A NAME="@manual.kwd150"></A>
<A NAME="@manual.kwd151"></A>
<A NAME="@manual.kwd152"></A>
<A NAME="@manual.kwd153"></A>
<A NAME="@manual.kwd154"></A>
<A NAME="@manual.kwd155"></A>
<A NAME="@manual.kwd156"></A>
<A NAME="@manual.kwd157"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>struct</TT></FONT> { <I><A HREF="#definition"><FONT COLOR=maroon>definition</FONT></A></I>  [<FONT COLOR=blue><TT>;;</TT></FONT>] &#X2223;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>;;</TT></FONT> } <FONT COLOR=blue><TT>end</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>functor</TT></FONT> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="definition"><FONT COLOR=maroon>definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I>   { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>external</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <FONT COLOR=maroon><I>external-declaration</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#type-definition"><FONT COLOR=maroon>type-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#exception-definition"><FONT COLOR=maroon>exception-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#class-definition"><FONT COLOR=maroon>class-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#classtype-definition"><FONT COLOR=maroon>classtype-definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>  { <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> }
 [ <FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> ]  <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>include</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Simple module expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">6.11.1</A>  Simple module expressions</H3><!--SEC END --><P>The expression <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> evaluates to the module bound to the name
<I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> evaluates to the same module as
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>.</P><P>The expression <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT> checks that the
type of <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> is a subtype of <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>, that is, that all
components specified in <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> are implemented in
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>, and their implementation meets the requirements given
in <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>. In other terms, it checks that the implementation
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> meets the type specification <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>. The whole
expression evaluates to the same module as <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>, except that
all components not specified in <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> are hidden and can no
longer be accessed.</P><!--TOC subsection Structures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">6.11.2</A>  Structures</H3><!--SEC END --><P><A NAME="@manual.kwd158"></A>
<A NAME="@manual.kwd159"></A></P><P>Structures <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> are collections of definitions for
value names, type names, exceptions, module names and module type
names. The definitions are evaluated in the order in which they appear
in the structure. The scope of the bindings performed by the
definitions extend to the end of the structure. As a consequence, a
definition may refer to names bound by earlier definitions in the same
structure.</P><P>For compatibility with toplevel phrases (chapter <A HREF="#c:camllight">9</A>)
and with Caml Light, an optional <TT>;;</TT> is allowed after each
definition in a structure. The <TT>;;</TT> has no semantic meaning. Also for
compatibility, <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>;;</TT></FONT> is allowed as a component of a structure,
meaning <FONT COLOR=blue><TT>let</TT> <TT>_</TT> <TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>, i.e. evaluate <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> for its side-effects.
In this case, the <TT>;;</TT> of the previous component is not optional.</P><!--TOC subsubsection Value definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Value definitions</H4><!--SEC END --><P><A NAME="@manual.kwd160"></A></P><P>A value definition <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#let-binding"><FONT COLOR=maroon>let-binding</FONT></A></I> }
bind value names in the same way as a <FONT COLOR=blue><TT>let</TT></FONT> &#X2026; <FONT COLOR=blue><TT>in</TT></FONT> &#X2026; expression
(see section <A HREF="#s:localdef">6.7.1</A>). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values
in the right-hand sides.</P><P><A NAME="@manual.kwd161"></A></P><P>A value definition <FONT COLOR=blue><TT>external</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <FONT COLOR=maroon><I>external-declaration</I></FONT>
implements <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> as the external function specified in
<FONT COLOR=maroon><I>external-declaration</I></FONT> (see chapter <A HREF="#c:intf-c">18</A>).</P><!--TOC subsubsection Type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd162"></A></P><P>A definition of one or several type components is written
<FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#typedef"><FONT COLOR=maroon>typedef</FONT></A></I> } and consists of a sequence
of mutually recursive definitions of type names.</P><!--TOC subsubsection Exception definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exception definitions</H4><!--SEC END --><P><A NAME="@manual.kwd163"></A></P><P>Exceptions are defined with the syntax <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I>
or <FONT COLOR=blue><TT>exception</TT></FONT> <I><A HREF="#constr-name"><FONT COLOR=maroon>constr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>.</P><!--TOC subsubsection Class definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class definitions</H4><!--SEC END --><P><A NAME="@manual.kwd164"></A></P><P>A definition of one or several classes is written <FONT COLOR=blue><TT>class</TT></FONT>
<I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#class-binding"><FONT COLOR=maroon>class-binding</FONT></A></I> } and consists of a sequence of
mutually recursive definitions of class names. Class definitions are
described more precisely in section <A HREF="#s:classdef">6.9.3</A>.</P><!--TOC subsubsection Class type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Class type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd165"></A>
<A NAME="@manual.kwd166"></A></P><P>A definition of one or several classes is written
<FONT COLOR=blue><TT>class</TT> <TT>type</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#classtype-def"><FONT COLOR=maroon>classtype-def</FONT></A></I> } and consists of
a sequence of mutually recursive definitions of class type names.
Class type definitions are described more precisely in
section <A HREF="#s:classtype">6.9.5</A>.</P><!--TOC subsubsection Module definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module definitions</H4><!--SEC END --><P><A NAME="@manual.kwd167"></A></P><P>The basic form for defining a module component is
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>, which evaluates <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> and binds
the result to the name <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I>.</P><P>One can write
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><P>
instead of
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT> <TT>(</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>.
</DIV><P>
Another derived form is
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>(</TT></FONT>  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>)</TT> <TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><P>
which is equivalent to
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT>
<TT>functor</TT> <TT>(</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
</DIV><!--TOC subsubsection Module type definitions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Module type definitions</H4><!--SEC END --><P><A NAME="@manual.kwd168"></A>
<A NAME="@manual.kwd169"></A></P><P>A definition for a module type is written
<FONT COLOR=blue><TT>module</TT> <TT>type</TT></FONT> <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>.
It binds the name <I><A HREF="#modtype-name"><FONT COLOR=maroon>modtype-name</FONT></A></I> to the module type denoted by the
expression <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>.</P><!--TOC subsubsection Opening a module path-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Opening a module path</H4><!--SEC END --><P><A NAME="@manual.kwd170"></A></P><P>The expression <FONT COLOR=blue><TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> in a structure does not define any
components nor perform any bindings. It simply affects the parsing of
the following items of the structure, allowing components of the
module denoted by <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> to be referred to by their simple names
<FONT COLOR=maroon><I>name</I></FONT> instead of path accesses <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT>. The scope of
the <TT>open</TT> stops at the end of the structure expression.</P><!--TOC subsubsection Including the components of another structure-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Including the components of another structure</H4><!--SEC END --><P><A NAME="@manual.kwd171"></A></P><P>The expression <FONT COLOR=blue><TT>include </TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> in a structure re-exports in
the current structure all definitions of the structure denoted by
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>. For instance, if the identifier <TT>S</TT> is bound to the
module
</P><PRE CLASS="verbatim">        struct type t = int  let x = 2 end
</PRE><P>the module expression
</P><PRE CLASS="verbatim">        struct include S  let y = (x + 1 : t) end
</PRE><P>is equivalent to the module expression
</P><PRE CLASS="verbatim">        struct type t = int  let x = 2  let y = (x + 1 : t) end
</PRE><P>The difference between <FONT COLOR=blue><TT>open</TT></FONT> and <FONT COLOR=blue><TT>include</TT></FONT> is that <FONT COLOR=blue><TT>open</TT></FONT>
simply provides short names for the components of the opened
structure, without defining any components of the current structure,
while <FONT COLOR=blue><TT>include</TT></FONT> also adds definitions for the components of the
included structure.</P><!--TOC subsection Functors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">6.11.3</A>  Functors</H3><!--SEC END --><!--TOC subsubsection Functor definition-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Functor definition</H4><!--SEC END --><P><A NAME="@manual.kwd172"></A></P><P>The expression <FONT COLOR=blue><TT>functor</TT> <TT>(</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>
 <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> evaluates to a functor that takes as argument modules of
the type <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I><SUB>1</SUB>, binds <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> to these modules,
evaluates <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> in the extended environment, and returns the
resulting modules as results. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (&#X201C;higher-order&#X201D; functor).</P><!--TOC subsubsection Functor application-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Functor application</H4><!--SEC END --><P>The expression <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>(</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>)</TT></FONT> evaluates
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB> to a functor and <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> to a module, and
applies the former to the latter. The type of <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>2</SUB> must
match the type expected for the arguments of the functor <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I><SUB>1</SUB>.</P><!--TOC section Compilation units-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">6.12</A>  Compilation units</H2><!--SEC END --><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="unit-interface"><FONT COLOR=maroon>unit-interface</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> { <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A></I>  [<FONT COLOR=blue><TT>;;</TT></FONT>] }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="unit-implementation"><FONT COLOR=maroon>unit-implementation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> { <I><A HREF="#definition"><FONT COLOR=maroon>definition</FONT></A></I>  [<FONT COLOR=blue><TT>;;</TT></FONT>] }</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Compilation units bridge the module system and the separate
compilation system. A compilation unit is composed of two parts: an
interface and an implementation. The interface contains a sequence of
specifications, just as the inside of a <FONT COLOR=blue><TT>sig</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT>
signature expression. The implementation contains a sequence of
definitions, just as the inside of a <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT> module
expression. A compilation unit also has a name <FONT COLOR=maroon><I>unit-name</I></FONT>, derived
from the names of the files containing the interface and the
implementation (see chapter <A HREF="#c:camlc">8</A> for more details). A
compilation unit behaves roughly as the module definition
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>module</TT> <FONT COLOR=maroon><I>unit-name</I></FONT> <TT>:</TT> <TT>sig</TT></FONT>  <I><A HREF="#unit-interface"><FONT COLOR=maroon>unit-interface</FONT></A></I> <FONT COLOR=blue><TT>end</TT> <TT>=</TT>
<TT>struct</TT></FONT>  <I><A HREF="#unit-implementation"><FONT COLOR=maroon>unit-implementation</FONT></A></I> <FONT COLOR=blue><TT>end</TT></FONT>
</DIV><P>A compilation unit can refer to other compilation units by their
names, as if they were regular modules. For instance, if <TT>U</TT> is a
compilation unit that defines a type <TT>t</TT>, other compilation units can
refer to that type under the name <TT>U.t</TT>; they can also refer to <TT>U</TT> as
a whole structure. Except for names of other compilation units, a unit
interface or unit implementation must not have any other free variables.
In other terms, the type-checking and compilation of an interface or
implementation proceeds in the initial environment
</P><DIV CLASS="center">
<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT> <TT>sig</TT></FONT>  <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>end</TT></FONT> &#X2026;
 <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>:</TT> <TT>sig</TT></FONT>  <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>end</TT></FONT>
</DIV><P>
where <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> are the names of the other
compilation units available in the search path (see
chapter <A HREF="#c:camlc">8</A> for more details) and <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A></I><SUB>1</SUB> &#X2026;
 <I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A><SUB>n</SUB></I> are their respective interfaces.

</P><!--CUT END -->
<!--TOC chapter Language extensions-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc92">Chapter 7</A>  Language extensions</H1><!--SEC END --><P> <A NAME="c:extensions"></A>
</P><P>This chapter describes language extensions and convenience features
that are implemented in OCaml, but not described in the
OCaml reference manual.</P><!--TOC section Integer literals for types <TT>int32</TT>, <TT>int64</TT> and <TT>nativeint</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc93">7.1</A>  Integer literals for types <TT>int32</TT>, <TT>int64</TT> and <TT>nativeint</TT></H2><!--SEC END --><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="int32-literal"><FONT COLOR=maroon>int32-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <I><A HREF="#integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I> <FONT COLOR=blue><TT>l</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="int64-literal"><FONT COLOR=maroon>int64-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <I><A HREF="#integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I> <FONT COLOR=blue><TT>L</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="nativeint-literal"><FONT COLOR=maroon>nativeint-literal</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <I><A HREF="#integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I> <FONT COLOR=blue><TT>n</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
An integer literal can be followed by one of the letters <TT>l</TT>, <TT>L</TT> or <TT>n</TT>
to indicate that this integer has type <TT>int32</TT>, <TT>int64</TT> or <TT>nativeint</TT>
respectively, instead of the default type <TT>int</TT> for integer literals.
<A NAME="@manual3"></A>
<A NAME="@manual4"></A>
<A NAME="@manual5"></A>
The library modules <TT>Int32</TT>[<TT><A HREF="libref/Int32.html">Int32</A></TT>],
<TT>Int64</TT>[<TT><A HREF="libref/Int64.html">Int64</A></TT>] and <TT>Nativeint</TT>[<TT><A HREF="libref/Nativeint.html">Nativeint</A></TT>]
provide operations on these integer types.</P><!--TOC section Streams and stream parsers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc94">7.2</A>  Streams and stream parsers</H2><!--SEC END --><P>
<A NAME="s:streams"></A></P><P>(Removed in Objective Caml 3.03)</P><P>The syntax for streams and stream parsers is no longer part of the
OCaml language, but available through a Camlp4 syntax
extension. See the Camlp4 reference manual for more information.
Support for basic operations on streams is still available through the
<TT>Stream</TT>[<TT><A HREF="libref/Stream.html">Stream</A></TT>] module of the standard library.
OCaml programs
that use the stream parser syntax should be compiled with the
<TT>-pp camlp4o</TT> option to <TT>ocamlc</TT> and <TT>ocamlopt</TT>. For interactive use,
run <TT>ocaml</TT> and issue the <CODE>#load "camlp4o.cma";;</CODE> command.</P><!--TOC section Recursive definitions of values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">7.3</A>  Recursive definitions of values</H2><!--SEC END --><P> <A NAME="s:letrecvalues"></A></P><P>(Introduced in Objective Caml 1.00)</P><P>As mentioned in section <A HREF="#s:localdef">6.7.1</A>, the <FONT COLOR=blue><TT>let rec</TT></FONT> binding
construct, in addition to the definition of recursive functions,
also supports a certain class of recursive definitions of
non-functional values, such as
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT> <TT>1</TT> <TT>::</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB>
<FONT COLOR=blue><TT>and</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT> <TT>2</TT> <TT>::</TT></FONT>  <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB>
<FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
which binds <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> to the cyclic list <TT>1::2::1::2::</TT>&#X2026;, and
<FONT COLOR=maroon><I>name</I></FONT><SUB>2</SUB> to the cyclic list <TT>2::1::2::1::</TT>&#X2026;Informally, the class of accepted definitions consists of those
definitions where the defined names occur only inside function
bodies or as argument to a data constructor.</P><P>More precisely, consider the expression:
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>let</TT> <TT>rec</TT></FONT> <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026; <FONT COLOR=blue><TT>and</TT></FONT>  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
</DIV><P>
It will be accepted if each one of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>n</SUB></I> is
statically constructive with respect to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>,
is not immediately linked to any of <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>,
and is not an array constructor whose arguments have abstract type.</P><P>An expression <FONT COLOR=maroon><I>e</I></FONT> is said to be <EM>statically constructive
with respect to</EM> the variables <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I> if at least
one of the following conditions is true:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I>e</I></FONT> has no free occurrence of any of <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> is a variable
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>fun</TT></FONT> &#X2026; <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026;
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>function</TT></FONT> &#X2026; <FONT COLOR=blue><TT>-&gt;</TT></FONT> &#X2026;
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>lazy</TT> <TT>(</TT></FONT> &#X2026; <FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has one of the following forms, where each one of
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> &#X2026;  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> is statically constructive with respect to
<FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>, and <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> is statically constructive with
respect to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>,  <FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I>:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT>  <I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>let</TT> <TT>module</TT></FONT> &#X2026; <FONT COLOR=blue><TT>in</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB>
</LI><LI CLASS="li-itemize"><I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I><FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>`</TT></FONT><I><A HREF="#tag-name"><FONT COLOR=maroon>tag-name</FONT></A></I> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I><FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>[|</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>|]</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>m</SUB></I> =  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>
 <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A><SUB>m</SUB></I> =  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>}</TT></FONT> where <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> is not immediately
linked to <FONT COLOR=maroon><I>name</I></FONT><SUB>1</SUB> &#X2026;  <I><FONT COLOR=maroon>name</FONT><SUB>n</SUB></I>
</LI><LI CLASS="li-itemize"><FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>,</TT></FONT> &#X2026; <FONT COLOR=blue><TT>,</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>)</TT></FONT>
</LI><LI CLASS="li-itemize"><I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I>
</LI></UL>
</LI></UL><P>An expression <FONT COLOR=maroon><I>e</I></FONT> is said to be <EM>immediately linked to</EM> the variable
<FONT COLOR=maroon><I>name</I></FONT> in the following cases:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I>e</I></FONT> is <FONT COLOR=maroon><I>name</I></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB><FONT COLOR=blue><TT>;</TT></FONT> &#X2026; <FONT COLOR=blue><TT>;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> where <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I>
is immediately linked to <FONT COLOR=maroon><I>name</I></FONT>
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I>e</I></FONT> has the form <FONT COLOR=blue><TT>let</TT></FONT> [<FONT COLOR=blue><TT>rec</TT></FONT>] <FONT COLOR=maroon><I>xname</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>and</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>and</TT></FONT>  <I><FONT COLOR=maroon>xname</FONT><SUB>m</SUB></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>m</SUB></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> where <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>0</SUB> is immediately
linked to <FONT COLOR=maroon><I>name</I></FONT> or to one of the <I><FONT COLOR=maroon>xname</FONT><SUB>i</SUB></I> such that <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A><SUB>i</SUB></I>
is immediately linked to <FONT COLOR=maroon><I>name</I></FONT>.
</LI></UL><!--TOC section Range patterns-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc96">7.4</A>  Range patterns</H2><!--SEC END --><P>(Introduced in Objective Caml 1.00)</P><P>In patterns, OCaml recognizes the form
<FONT COLOR=blue><TT>'</TT> <FONT COLOR=maroon><I>c</I></FONT> <TT>'</TT> <TT>..</TT> <TT>'</TT> <FONT COLOR=maroon><I>d</I></FONT> <TT>'</TT></FONT>
(two character literals separated by <TT>..</TT>) as shorthand for the pattern
</P><DIV CLASS="center">
<FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT></FONT> <I>c</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>'</TT> <TT>|</TT></FONT> &#X2026;
<FONT COLOR=blue><TT>|</TT> <TT>'</TT></FONT> <I><FONT COLOR=maroon>c</FONT><SUB>n</SUB></I> <FONT COLOR=blue><TT>'</TT> <TT>|</TT> <TT>'</TT> <FONT COLOR=maroon><I>d</I></FONT> <TT>'</TT></FONT>
</DIV><P>
where <I>c</I><SUB>1</SUB>, <I>c</I><SUB>2</SUB>, &#X2026;, <I>c<SUB>n</SUB></I> are the characters
that occur between <I>c</I> and <I>d</I> in the ASCII character set. For
instance, the pattern <TT>&#X2019;0&#X2019;..&#X2019;9&#X2019;</TT> matches all characters that are digits.</P><!--TOC section Assertion checking-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc97">7.5</A>  Assertion checking</H2><!--SEC END --><P>
<A NAME="@manual.kwd173"></A></P><P>(Introduced in Objective Caml 1.06)</P><P>OCaml supports the <TT>assert</TT> construct to check debugging assertions.
The expression <FONT COLOR=blue><TT>assert</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> evaluates the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> and
returns <TT>()</TT> if <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> evaluates to <TT>true</TT>. Otherwise, the exception
<TT>Assert_failure</TT> is raised with the source file name and the
location of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> as arguments. Assertion
checking can be turned off with the <TT>-noassert</TT> compiler option.</P><P>As a special case, <TT>assert false</TT> is reduced to
<TT>raise (Assert_failure ...)</TT>, which is polymorphic (and
is not turned off by the <TT>-noassert</TT> option).
<A NAME="@manual6"></A></P><!--TOC section Lazy evaluation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc98">7.6</A>  Lazy evaluation</H2><!--SEC END --><P>
<A NAME="@manual.kwd174"></A></P><P>(Introduced in Objective Caml 1.06 for expressions;
in Objective Caml 3.11 for patterns)</P><P>The expression <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> returns a value <I>v</I> of type <TT>Lazy.t</TT> that
encapsulates the computation of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. The argument <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> is not
evaluated at this point in the program. Instead, its evaluation will
be performed the first time <TT>Lazy.force</TT> is applied to the value
<I>v</I>, returning the actual value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. Subsequent applications
of <TT>Lazy.force</TT> to <I>v</I> do not evaluate <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> again. Applications
of <TT>Lazy.force</TT> may be implicit through pattern matching.</P><P>The pattern <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> matches values <I>v</I> of type <TT>Lazy.t</TT>,
provided <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I> matches the result of forcing <I>v</I> with
<TT>Lazy.force</TT>. A successful match of a pattern containing <TT>lazy</TT>
sub-patterns forces the corresponding parts of the value being matched, even
those that imply no test such as <FONT COLOR=blue><TT>lazy</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> or <FONT COLOR=blue><TT>lazy</TT> <TT>_</TT></FONT>.
Matching a value with a <I><A HREF="#pattern-matching"><FONT COLOR=maroon>pattern-matching</FONT></A></I> where some patterns
contain <TT>lazy</TT> sub-patterns may imply forcing parts of the value,
even when the pattern selected in the end has no <TT>lazy</TT> sub-pattern.</P><P>For more information, see the description of module <TT>Lazy</TT> in the
standard library (see
<A HREF="libref/Lazy.html">Module <TT>Lazy</TT></A>).
<A NAME="@manual7"></A><A NAME="@manual8"></A></P><!--TOC section Local modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">7.7</A>  Local modules</H2><!--SEC END --><P>
<A NAME="@manual.kwd175"></A>
<A NAME="@manual.kwd176"></A></P><P>(Introduced in Objective Caml 2.00)</P><P>The expression
<FONT COLOR=blue><TT>let</TT> <TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
locally binds the module expression <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> to the identifier
<I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> during the evaluation of the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.
It then returns the value of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. For example:
</P><PRE CLASS="verbatim">        let remove_duplicates comparison_fun string_list =
          let module StringSet =
            Set.Make(struct type t = string
                            let compare = comparison_fun end) in
          StringSet.elements
            (List.fold_right StringSet.add string_list StringSet.empty)
</PRE><!--TOC section Recursive modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc100">7.8</A>  Recursive modules</H2><!--SEC END --><P> <A NAME="s-recursive-modules"></A>
<A NAME="@manual.kwd177"></A>
<A NAME="@manual.kwd178"></A></P><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#definition"><FONT COLOR=maroon>definition</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>rec</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> 
 { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A HREF="#specification"><FONT COLOR=maroon>specification</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>rec</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I>
 { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I><FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> }</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Recursive module definitions, introduced by the &#X2019;module rec&#X2019; &#X2026;&#X2019;and&#X2019; &#X2026; construction, generalize regular module definitions
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> and module specifications
<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> by allowing the defining
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> and the <I><A HREF="#module-type"><FONT COLOR=maroon>module-type</FONT></A></I> to refer recursively to the module
identifiers being defined. A typical example of a recursive module
definition is:
</P><PRE CLASS="verbatim">    module rec A : sig
                     type t = Leaf of string | Node of ASet.t
                     val compare: t -&gt; t -&gt; int
                   end
                 = struct
                     type t = Leaf of string | Node of ASet.t
                     let compare t1 t2 =
                       match (t1, t2) with
                         (Leaf s1, Leaf s2) -&gt; Pervasives.compare s1 s2
                       | (Leaf _, Node _) -&gt; 1
                       | (Node _, Leaf _) -&gt; -1
                       | (Node n1, Node n2) -&gt; ASet.compare n1 n2
                   end
        and ASet : Set.S with type elt = A.t
                 = Set.Make(A)
</PRE><P>It can be given the following specification:
</P><PRE CLASS="verbatim">    module rec A : sig
                     type t = Leaf of string | Node of ASet.t
                     val compare: t -&gt; t -&gt; int
                   end
        and ASet : Set.S with type elt = A.t
</PRE><P>This is an experimental extension of OCaml: the class of
recursive definitions accepted, as well as its dynamic semantics are
not final and subject to change in future releases.</P><P>Currently, the compiler requires that all dependency cycles between
the recursively-defined module identifiers go through at least one
&#X201C;safe&#X201D; module. A module is &#X201C;safe&#X201D; if all value definitions that
it contains have function types <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>-&gt;</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><SUB>2</SUB>. Evaluation of a
recursive module definition proceeds by building initial values for
the safe modules involved, binding all (functional) values to
<FONT COLOR=blue><TT>fun</TT> <TT>_</TT> <TT>-&gt;</TT> <TT>raise</TT> <TT>Undefined_recursive_module</TT></FONT>. The defining
module expressions are then evaluated, and the initial values
for the safe modules are replaced by the values thus computed. If a
function component of a safe module is applied during this computation
(which corresponds to an ill-founded recursive definition), the
<TT>Undefined_recursive_module</TT> exception is raised.</P><!--TOC section Private types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">7.9</A>  Private types</H2><!--SEC END --><P>
<A NAME="@manual.kwd179"></A></P><P>Private type declarations in module signatures, of the form 
<TT>type t = private ...</TT>, enable libraries to
reveal some, but not all aspects of the implementation of a type to
clients of the library. In this respect, they strike a middle ground
between abstract type declarations, where no information is revealed
on the type implementation, and data type definitions and type
abbreviations, where all aspects of the type implementation are
publicized. Private type declarations come in three flavors: for
variant and record types (section <A HREF="#s-private-types-variant">7.9.1</A>),
for type abbreviations (section <A HREF="#s-private-types-abbrev">7.9.2</A>),
and for row types (section <A HREF="#s-private-rows">7.9.3</A>).</P><!--TOC subsection Private variant and record types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">7.9.1</A>  Private variant and record types</H3><!--SEC END --><P>
<A NAME="s-private-types-variant"></A></P><P>(Introduced in Objective Caml 3.07)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#type-representation"><FONT COLOR=maroon>type-representation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=blue><TT>private</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I>  { <FONT COLOR=blue><TT>|</TT></FONT> <I><A HREF="#constr-decl"><FONT COLOR=maroon>constr-decl</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=blue><TT>private</TT></FONT> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I>  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field-decl"><FONT COLOR=maroon>field-decl</FONT></A></I> } <FONT COLOR=blue><TT>}</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Values of a variant or record type declared <TT>private</TT>
can be de-structured normally in pattern-matching or via
the <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I> notation for record accesses. However, values of
these types cannot be constructed directly by constructor application
or record construction. Moreover, assignment on a mutable field of a
private record type is not allowed.</P><P>The typical use of private types is in the export signature of a
module, to ensure that construction of values of the private type always
go through the functions provided by the module, while still allowing
pattern-matching outside the defining module. For example:
</P><PRE CLASS="verbatim">        module M : sig
                     type t = private A | B of int
                     val a : t
                     val b : int -&gt; t
                   end
                 = struct
                     type t = A | B of int
                     let a = A
                     let b n = assert (n &gt; 0); B n
                   end
</PRE><P>Here, the <TT>private</TT> declaration ensures that in any value of type
<TT>M.t</TT>, the argument to the <TT>B</TT> constructor is always a positive integer.</P><P>With respect to the variance of their parameters, private types are
handled like abstract types. That is, if a private type has
parameters, their variance is the one explicitly given by prefixing
the parameter by a &#X2018;<TT>+</TT>&#X2019; or a &#X2018;<TT>-</TT>&#X2019;, it is invariant otherwise.</P><!--TOC subsection Private type abbreviations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc103">7.9.2</A>  Private type abbreviations</H3><!--SEC END --><P> <A NAME="s-private-types-abbrev"></A></P><P>(Introduced in Objective Caml 3.11)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#type-equation"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=blue><TT>private</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Unlike a regular type abbreviation, a private type abbreviation
declares a type that is distinct from its implementation type <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>.
However, coercions from the type to <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> are permitted. 
Moreover, the compiler &#X201C;knows&#X201D; the implementation type and can take
advantage of this knowledge to perform type-directed optimizations.
For ambiguity reasons, <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> cannot be an object or polymorphic
variant type, but a similar behaviour can be obtained through private
row types.</P><P>The following example uses a private type abbreviation to define a
module of nonnegative integers:
</P><PRE CLASS="verbatim">        module N : sig
                     type t = private int
                     val of_int: int -&gt; t
                     val to_int: t -&gt; int
                   end
                 = struct
                     type t = int
                     let of_int n = assert (n &gt;= 0); n
                     let to_int n = n
                   end
</PRE><P>The type <TT>N.t</TT> is incompatible with <TT>int</TT>, ensuring that nonnegative
integers and regular integers are not confused. However, if <TT>x</TT> has
type <TT>N.t</TT>, the coercion <TT>(x :&gt; int)</TT> is legal and returns the
underlying integer, just like <TT>N.to_int x</TT>. Deep coercions are also
supported: if <TT>l</TT> has type <TT>N.t list</TT>, the coercion <TT>(l :&gt; int list)</TT>
returns the list of underlying integers, like <TT>List.map N.to_int l</TT>
but without copying the list <TT>l</TT>.</P><P>Note that the coercion <TT>(</TT><I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><TT> :&gt; </TT><I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><TT>)</TT> is actually an abbreviated form,
and will only work in presence of private abbreviations if both the
type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> and <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> contain no type variables. If this is not the
case, you must use the full form <TT>(</TT><I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><TT> : </TT>typ_e<TT> :&gt; </TT><I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I><TT>)</TT> where
typ_e is the expected type of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>. Concretely, this would be <TT>(x : N.t :&gt; int)</TT> and <TT>(l : N.t list :&gt; int list)</TT> for the above examples.</P><!--TOC subsection Private row types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">7.9.3</A>  Private row types</H3><!--SEC END --><P> <A NAME="s-private-rows"></A>
<A NAME="@manual.kwd180"></A></P><P>(Introduced in Objective Caml 3.09)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#type-equation"><FONT COLOR=maroon>type-equation</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>=</TT></FONT> <FONT COLOR=blue><TT>private</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Private row types are type abbreviations where part of the
structure of the type is left abstract. Concretely <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> in the
above should denote either an object type or a polymorphic variant
type, with some possibility of refinement left. If the private
declaration is used in an interface, the corresponding implementation
may either provide a ground instance, or a refined private type.
</P><PRE CLASS="verbatim">   module M : sig type c = private &lt; x : int; .. &gt; val o : c end =
     struct
       class c = object method x = 3 method y = 2 end
       let o = new c
     end
</PRE><P>This declaration does more than hiding the <TT>y</TT> method, it also makes
the type <TT>c</TT> incompatible with any other closed object type, meaning
that only <TT>o</TT> will be of type <TT>c</TT>. In that respect it behaves
similarly to private record types. But private row types are
more flexible with respect to incremental refinement. This feature can
be used in combination with functors.
</P><PRE CLASS="verbatim">   module F(X : sig type c = private &lt; x : int; .. &gt; end) =
     struct
       let get_x (o : X.c) = o#x
     end
   module G(X : sig type c = private &lt; x : int; y : int; .. &gt; end) =
     struct
       include F(X)
       let get_y (o : X.c) = o#y
     end
</PRE><P>Polymorphic variant types can be refined in two ways, either to allow
the addition of new constructors, or to allow the disparition of
declared constructors. The second case corresponds to private variant
types (one cannot create a value of the private type), while the first
case requires default cases in pattern-matching to handle addition.
</P><PRE CLASS="verbatim">   type t = [ `A of int | `B of bool ]
   type u = private [&lt; t &gt; `A ]
   type v = private [&gt; t ]
</PRE><P>With type <TT>u</TT>, it is possible to create values of the form <TT>(&#X2018;A n)</TT>,
but not <TT>(&#X2018;B b)</TT>. With type <TT>v</TT>, construction is not restricted but
pattern-matching must have a default case.</P><P>Like for abstract and private types, the variance of type parameters
is not inferred, and must be given explicitly.</P><!--TOC section Local opens-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc105">7.10</A>  Local opens</H2><!--SEC END --><P>
<A NAME="@manual.kwd181"></A>
<A NAME="@manual.kwd182"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>let</TT></FONT> <FONT COLOR=blue><TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>.(</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expressions
<FONT COLOR=blue><TT>let</TT> <TT>open</TT></FONT> <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
and
<I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I>. (<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>) are strictly equivalent. They
locally open the module referred to by the module path <I><A HREF="#module-path"><FONT COLOR=maroon>module-path</FONT></A></I> in
the scope of the expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>.</P><P>Restricting opening to the scope of a single expression instead of a
whole structure allows one to benefit from shorter syntax to refer to
components of the opened module, without polluting the global
scope. Also, this can make the code easier to read (the open statement is
closer to where it is used) and to refactor (because the code
fragment is more self-contained).</P><!--TOC section Record notations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc106">7.11</A>  Record notations</H2><!--SEC END --><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>pattern</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>]  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#pattern"><FONT COLOR=maroon>pattern</FONT></A></I>] }  [<FONT COLOR=blue><TT>;</TT></FONT> <FONT COLOR=blue><TT>_</TT></FONT> ] <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>]  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>{</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>]  { <FONT COLOR=blue><TT>;</TT></FONT> <I><A HREF="#field"><FONT COLOR=maroon>field</FONT></A></I>  [<FONT COLOR=blue><TT>=</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>] } <FONT COLOR=blue><TT>}</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>In a record pattern or a record construction expression, a single
identifier <FONT COLOR=maroon><I>id</I></FONT> stands for <FONT COLOR=maroon><I>id</I></FONT> =  <FONT COLOR=maroon><I>id</I></FONT>, and a qualified identifier
<FONT COLOR=maroon><I>path</I></FONT> <FONT COLOR=blue><TT>,</TT></FONT>  <FONT COLOR=maroon><I>id</I></FONT> stands for <FONT COLOR=maroon><I>path</I></FONT> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>id</I></FONT> =  <FONT COLOR=maroon><I>id</I></FONT>. For example, assuming
the record type
</P><PRE CLASS="verbatim">          type point = { x: float; y: float }
</PRE><P>has been declared, the following expressions are equivalent:
</P><PRE CLASS="verbatim">          let x = 1 and y = 2 in { x = x; y = y }
          let x = 1 and y = 2 in { x; y }
          let x = 1 and y = 2 in { x = x; y }
</PRE><P>Likewise, the following functions are equivalent:
</P><PRE CLASS="verbatim">          fun {x = x; y = y} -&gt; x + y
          fun {x; y} -&gt; x + y
</PRE><P>Optionally, a record pattern can be terminated by <TT>; _</TT> to convey the
fact that not all fields of the record type are listed in the record
pattern and that it is intentional. By default, the compiler ignores
the <TT>; _</TT> annotation. If the <TT>R</TT> warning is turned on, however,
the compiler will warn if a record pattern fails to list all fields of
the corresponding record type and is not terminated by <TT>; _</TT>.
Continuing the <TT>point</TT> example above,
</P><PRE CLASS="verbatim">          fun {x} -&gt; x + 1
</PRE><P>will warn if the <TT>R</TT> warning is on, while
</P><PRE CLASS="verbatim">          fun {x; _} -&gt; x + 1
</PRE><P>will not warn. This warning can help spot program points where record
patterns may need to be modified after new fields were added to a
record type.</P><!--TOC section Explicit polymorphic type annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc107">7.12</A>  Explicit polymorphic type annotations</H2><!--SEC END --><P>
<A NAME="@manual.kwd183"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>let-binding</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Polymorphic type annotations in <TT>let</TT>-definitions behave in a way
similar to polymorphic methods: they explicitly require the defined
value to be polymorphic, and allow one to use this polymorphism in
recursive occurences (when using <TT>let rec</TT>). Note however that this
is just an usual polymorphic type, unifiable with any instance of
itself.</P><P>There two possible applications of this feature. One is polymorphic
recursion:
</P><PRE CLASS="verbatim">        type 'a t = Leaf of 'a | Node of ('a * 'a) t
        let rec depth : 'a. 'a t -&gt; 'b = function
            Leaf _ -&gt; 1
          | Node x -&gt; 1 + depth x
</PRE><P>Note that <TT>&#X2019;b</TT> is not explicitly polymorphic here, and it will
actually be unified with <TT>int</TT>.</P><P>The other application is to ensure that some definition is sufficiently
polymorphic.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>let id : &#X2019;a. &#X2019;a -&gt; &#X2019;a = <U>fun x -&gt; x+1</U> ;;
</FONT><FONT COLOR=maroon>Error: This definition has type int -&gt; int which is less general than
         &#X2019;a. &#X2019;a -&gt; &#X2019;a
</FONT></PRE><!--TOC section Explicit naming of type variables-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc108">7.13</A>  Explicit naming of type variables</H2><!--SEC END --><P>
<A NAME="@manual.kwd184"></A>
<A NAME="@manual.kwd185"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>parameter</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The expression <FONT COLOR=blue><TT>fun</TT> <TT>(</TT> <TT>type</TT></FONT> <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> introduces a
type constructor named <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> which is considered abstract
in the scope of the sub-expression, but then replaced by a fresh type
variable. Note that contrary to what the syntax could suggest, the
expression <FONT COLOR=blue><TT>fun</TT> <TT>(</TT> <TT>type</TT></FONT> <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>-&gt;</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> itself does not
suspend the evaluation of <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> as a regular abstraction would. The
syntax has been chosen to fit nicely in the context of function
declarations, where it is generally used. It is possible to freely mix
regular function parameters with pseudo type parameters, as in:
</P><PRE CLASS="verbatim">        let f = fun (type t) (foo : t list) -&gt; ...
</PRE><P>and even use the alternative syntax for declaring functions:
</P><PRE CLASS="verbatim">        let f (type t) (foo : t list) = ...
</PRE><P>This construction is useful because the type constructor it introduces
can be used in places where a type variable is not allowed. For
instance, one can use it to define an exception in a local module
within a polymorphic function.
</P><PRE CLASS="verbatim">        let f (type t) () =
          let module M = struct exception E of t end in
          (fun x -&gt; M.E x), (function M.E x -&gt; Some x | _ -&gt; None)
</PRE><P>Here is another example:
</P><PRE CLASS="verbatim">        let sort_uniq (type s) (cmp : s -&gt; s -&gt; int) =
          let module S = Set.Make(struct type t = s let compare = cmp end) in
          fun l -&gt;
            S.elements (List.fold_right S.add l S.empty)
</PRE><P>This construction by itself does not make polymorphic the type
variable it introduces, but it can be combined with explicit
polymorphic annotations where needed. It is also extremely useful for
first-class modules.</P><!--TOC section First-class modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc109">7.14</A>  First-class modules</H2><!--SEC END --><P>
<A NAME="@manual.kwd186"></A>
<A NAME="@manual.kwd187"></A>
<A NAME="@manual.kwd188"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(module</TT></FONT> <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(val</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(module</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I><FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="package-type"><FONT COLOR=maroon>package-type</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#modtype-path"><FONT COLOR=maroon>modtype-path</FONT></A></I> <FONT COLOR=blue><TT>with</TT></FONT>  <I><A HREF="#package-type-constraint"><FONT COLOR=maroon>package-type-constraint</FONT></A></I>  { <FONT COLOR=blue><TT>and</TT></FONT> <I><A HREF="#package-type-constraint"><FONT COLOR=maroon>package-type-constraint</FONT></A></I> }
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="package-type-constraint"><FONT COLOR=maroon>package-type-constraint</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=blue><TT>type</TT></FONT> <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Modules are typically thought as static components. This extension
makes it possible to pack a module as a first-class value, which can
later be dynamically unpacked into a module.</P><P>The expression (<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>) converts the
module (structure or functor) denoted by module expression <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>
to a value of the core language that encapsulates this module. The
type of this core language value is (<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>).</P><P>Conversely, the module expression (<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>)
evaluates the core language expression <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> to a value, which must
have type <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>, and extracts the module that was
encapsulated in this value.</P><P>The <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I> syntactic class appearing in the (<FONT COLOR=blue><TT>module</TT></FONT>
<I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>) expressions, the (<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>
 <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>) module expressions and the (<FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>)
type expression represents a subset of module types. 
This subset consists of named module types with optional constraints
of a limited form: only non-parametrized types can be specified. For
type-checking purposes, package types are compared by path equality on
the module type name component, and normal type equality for
constraints.</P><P>The module expression (<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>) cannot be used in the
body of a functor, because this can cause unsoundness in conjunction
with applicative functors. It can be used anywhere in the context of a local
module binding <FONT COLOR=blue><TT>let</TT></FONT> <I>M</I> = (<FONT COLOR=blue><TT>val</TT></FONT> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#package-type"><FONT COLOR=maroon>package-type</FONT></A></I>) <FONT COLOR=blue><TT>in</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I><SUB>2</SUB>,
however.</P><!--TOC paragraph Basic example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Basic example</H5><!--SEC END --><P> A typical use of first-class modules is to
select at run-time among several implementations of a signatures. 
Each implementation is a structure that we can encapsulate as a
first-class module, then store in a data structure such as a hash
table:
</P><PRE CLASS="verbatim">        module type DEVICE = sig ... end
        let devices : (string, module DEVICE) Hashtbl.t = Hashtbl.create 17

        module SVG = struct ... end
        let _ = Hashtbl.add devices "SVG" (module SVG : DEVICE)

        module PDF = struct ... end
        let _ = Hashtbl.add devices "PDF" (module PDF: DEVICE)
</PRE><P>We can then select one implementation based on command-line
arguments, for instance:
</P><PRE CLASS="verbatim">        module Device =
          (val (try Hashtbl.find devices (parse_cmdline())
                with Not_found -&gt; eprintf "Unknown device %s\n"; exit 2)
           : DEVICE)
</PRE><P>Alternatively, the selection can be performed within a function:
</P><PRE CLASS="verbatim">        let draw_using_device device_name picture =
          let module Device =
            (val (Hashtbl.find_devices device_name) : DEVICE)
          in
            Device.draw picture
</PRE><!--TOC paragraph Advanced examples-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Advanced examples</H5><!--SEC END --><P>
With first-class modules, it is possible to parametrize some code over the
implementation of a module without using a functor.</P><PRE CLASS="verbatim">        let sort (type s) set l =
          let module Set = (val set : Set.S with type elt = s) in
          Set.elements (List.fold_right Set.add l Set.empty)
</PRE><P>The type inferred for this function is <TT>(module Set.S with type elt = &#X2019;a) -&gt; &#X2019;a list -&gt; &#X2019;a list</TT>. To use this function, one can wrap the <TT>Set.Make</TT> functor:</P><PRE CLASS="verbatim">        let make_set (type s) cmp =
          let module S = Set.Make(struct
            type t = s
            let compare = cmp
          end) in
          (module S : Set.S with type elt = s) 
</PRE><P>This function has type <TT>(&#X2019;a -&gt; &#X2019;a -&gt; int) -&gt; (module Set.S with type elt = &#X2019;a)</TT>.</P><P>Another advanced use of first-class module is to encode existential
types. In particular, they can be used to simulate generalized
algebraic data types (GADT). To demonstrate this, we first define a type
of witnesses for type equalities:</P><PRE CLASS="verbatim">        module TypEq : sig
          type ('a, 'b) t
          val apply: ('a, 'b) t -&gt; 'a -&gt; 'b
          val refl: ('a, 'a) t
          val sym: ('a, 'b) t -&gt; ('b, 'a) t
        end = struct
          type ('a, 'b) t = ('a -&gt; 'b) * ('b -&gt; 'a)
          let refl = (fun x -&gt; x), (fun x -&gt; x)
          let apply (f, _) x = f x
          let sym (f, g) = (g, f)
        end
</PRE><P>We can then define a paramatrized algebraic data type whose
constructors provide some information about the type parameter:</P><PRE CLASS="verbatim">        module rec Typ : sig
          module type PAIR = sig
            type t and t1 and t2
            val eq: (t, t1 * t2) TypEq.t
            val t1: t1 Typ.typ
            val t2: t2 Typ.typ
          end

          type 'a typ =
            | Int of ('a, int) TypEq.t
            | String of ('a, string) TypEq.t
            | Pair of (module PAIR with type t = 'a)
        end = Typ
</PRE><P>Values of type <TT>&#X2019;a typ</TT> are supposed to be runtime representations for
the type <TT>&#X2019;a</TT>. The constructors <TT>Int</TT> and <TT>String</TT> are easy: they
directly give a witness of type equality between the parameter <TT>&#X2019;a</TT>
and the ground types <TT>int</TT> (resp. <TT>string</TT>). The constructor <TT>Pair</TT> is
more complex. One wants to give a witness of type equality between
<TT>&#X2019;a</TT> and a type of the form <TT>t1 * t2</TT> together with the representations
for <TT>t1</TT> and <TT>t2</TT>. However, these two types are unknown. The code above
shows how to use first-class modules to simulate existentials.</P><P>Here is how to construct values of type <TT>&#X2019;a typ</TT>:</P><PRE CLASS="verbatim">        let int = Typ.Int TypEq.refl

        let str = Typ.String TypEq.refl

        let pair (type s1) (type s2) t1 t2 =
          let module P = struct
            type t = s1 * s2
            type t1 = s1
            type t2 = s2
            let eq = TypEq.refl
            let t1 = t1
            let t2 = t2
          end in
          let pair = (module P : Typ.PAIR with type t = s1 * s2) in
          Typ.Pair pair
</PRE><P>And finally, here is an example of a polymorphic function that takes the
runtime representation of some type <TT>&#X2019;a</TT> and a value of the same type,
then pretty-print the value as a string:</P><PRE CLASS="verbatim">        open Typ
        let rec to_string: 'a. 'a Typ.typ -&gt; 'a -&gt; string =
          fun (type s) t x -&gt;
            match t with
            | Int eq -&gt; string_of_int (TypEq.apply eq x)
            | String eq -&gt; Printf.sprintf "%S" (TypEq.apply eq x)
            | Pair p -&gt;
                let module P = (val p : PAIR with type t = s) in
                let (x1, x2) = TypEq.apply P.eq x in
                Printf.sprintf "(%s,%s)" (to_string P.t1 x1) (to_string P.t2 x2)
</PRE><P>Note that this function uses an explicit polymorphic annotation to obtain
polymorphic recursion.</P><!--TOC section Recovering the type of a module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">7.15</A>  Recovering the type of a module</H2><!--SEC END --><P><A NAME="@manual.kwd189"></A>
<A NAME="@manual.kwd190"></A>
<A NAME="@manual.kwd191"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>module-type</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> 
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <FONT COLOR=blue><TT>type</TT></FONT> <FONT COLOR=blue><TT>of</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The construction <FONT COLOR=blue><TT>module</TT> <TT>type</TT> <TT>of</TT></FONT> <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I> expands to the module type
(signature or functor type) inferred for the module expression <I><A HREF="#module-expr"><FONT COLOR=maroon>module-expr</FONT></A></I>.</P><P>A typical use, in conjunction with the signature-level <FONT COLOR=blue><TT>include</TT></FONT>
construct, is to extend the signature of an existing structure, as in
the following example.
</P><PRE CLASS="verbatim">        module type MYHASH = sig
          include module type of Hashtbl
          val replace: ('a, 'b) t -&gt; 'a -&gt; 'b -&gt; unit
        end
</PRE><P>The signature <TT>MYHASH</TT>, then, contains all the fields of the signature
of module <TT>Hashtbl</TT>, plus the new field <TT>replace</TT>. An implementation
of this signature can be obtained easily, using the <FONT COLOR=blue><TT>include</TT></FONT>
construct at the structure level this time:
</P><PRE CLASS="verbatim">        module MyHash : MYHASH = struct
          include Hashtbl
          let replace t k v = remove t k; add t k v
        end
</PRE><!--TOC section Substituting inside a signature-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc111">7.16</A>  Substituting inside a signature</H2><!--SEC END --><P>
<A NAME="@manual.kwd192"></A>
<A NAME="@manual.kwd193"></A>
<A NAME="@manual.kwd194"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>mod-constraint</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>type</TT></FONT> [<I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I>]  <I><A HREF="#typeconstr-name"><FONT COLOR=maroon>typeconstr-name</FONT></A></I> <FONT COLOR=blue><TT>:=</TT></FONT>  [<I><A HREF="#type-parameters"><FONT COLOR=maroon>type-parameters</FONT></A></I>]  <I><A HREF="#typeconstr"><FONT COLOR=maroon>typeconstr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>module</TT></FONT> <I><A HREF="#module-name"><FONT COLOR=maroon>module-name</FONT></A></I> <FONT COLOR=blue><TT>:=</TT></FONT>  <I><A HREF="#extended-module-path"><FONT COLOR=maroon>extended-module-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>&#X201C;Destructive&#X201D; substitution (<TT>with ... :=</TT>) behaves essentially like
normal signature constraints (<TT>with ... =</TT>), but it additionally removes
the redefined type or module from the signature. There are a number of
restrictions: one can only remove types and modules at the outermost
level (not inside submodules), and the definition must be either
another type constructor (with identical type parameters), or a module
path.</P><P>A natural application of destructive substitution is merging two
signatures sharing a type name.
</P><PRE CLASS="verbatim">        module type Printable = sig
          type t
          val print : Format.formatter -&gt; t -&gt; unit
        end
        module type Comparable = sig
          type t
          val compare : t -&gt; t -&gt; int
        end
        module type PrintableComparable = sig
          include Printable
          include Comparable with type t := t
        end
</PRE><P>One can also use this to completely remove a field:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type S = Comparable with type t := int;;
</FONT><FONT COLOR=maroon>module type S = sig val compare : int -&gt; int -&gt; int end
</FONT></PRE><P>
or to rename one:
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type S = sig
   type u
   include Comparable with type t := u
 end;;
</FONT><FONT COLOR=maroon>module type S = sig type u val compare : u -&gt; u -&gt; int end
</FONT></PRE><P>Note that you can also remove manifest types, by substituting with the
same type.
</P><PRE><FONT COLOR=black>#</FONT><FONT COLOR=blue>module type ComparableInt = Comparable with type t = int ;;
</FONT><FONT COLOR=maroon>module type ComparableInt = sig type t = int val compare : t -&gt; t -&gt; int end
<FONT COLOR=black>#</FONT><FONT COLOR=blue>module type CompareInt = ComparableInt with type t := int ;;
</FONT>module type CompareInt = sig val compare : int -&gt; int -&gt; int end
</FONT></PRE><!--TOC section Explicit overriding in class definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc112">7.17</A>  Explicit overriding in class definitions</H2><!--SEC END --><P>
<A NAME="@manual.kwd195"></A>
<A NAME="@manual.kwd196"></A>
<A NAME="@manual.kwd197"></A></P><P>(Introduced in OCaml 3.12)</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<FONT COLOR=maroon><I>class-field</I></FONT></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
...
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>inherit!</TT></FONT> <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I>  [<FONT COLOR=blue><TT>as</TT></FONT> <I><A HREF="#value-name"><FONT COLOR=maroon>value-name</FONT></A></I>]
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>val!</TT></FONT> [<FONT COLOR=blue><TT>mutable</TT></FONT>] <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I>  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method!</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I>  {<I><A HREF="#parameter"><FONT COLOR=maroon>parameter</FONT></A></I>}  [<FONT COLOR=blue><TT>:</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I>] <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP>  <FONT COLOR=blue><TT>method!</TT></FONT> [<FONT COLOR=blue><TT>private</TT></FONT>] <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> <FONT COLOR=blue><TT>:</TT></FONT>  <I><A HREF="#poly-typexpr"><FONT COLOR=maroon>poly-typexpr</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>The keywords <TT>inherit!</TT>, <TT>val!</TT> and <TT>method!</TT> have the same semantics
as <TT>inherit</TT>, <TT>val</TT> and <TT>method</TT>, but they additionally require the
definition they introduce to be an overriding. Namely, <TT>method!</TT>
requires <I><A HREF="#method-name"><FONT COLOR=maroon>method-name</FONT></A></I> to be already defined in this class, <TT>val!</TT>
requires <I><A HREF="#inst-var-name"><FONT COLOR=maroon>inst-var-name</FONT></A></I> to be already defined in this class, and
<TT>inherit!</TT> requires <I><A HREF="#class-expr"><FONT COLOR=maroon>class-expr</FONT></A></I> to override some definitions.
If no such overriding occurs, an error is signaled.</P><P>As a side-effect, these 3 keywords avoid the warnings
&#X201C;method override&#X201D; and &#X201C; instance variable override&#X201D;.
As of OCaml 3.12, the warning &#X201C;method override&#X201D; has to be
enabled manually for backwards compatibility reasons.
</P><!--TOC part The OCaml tools-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc113">Part III</A><BR>
The OCaml tools</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:commands"></A></P><!--TOC chapter Batch compilation (ocamlc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc114">Chapter 8</A>  Batch compilation (ocamlc)</H1><!--SEC END --><P> <A NAME="c:camlc"></A>
</P><P>This chapter describes the OCaml batch compiler <TT>ocamlc</TT>,
which compiles Caml source files to bytecode object files and links
these object files to produce standalone bytecode executable files.
These executable files are then run by the bytecode interpreter
<TT>ocamlrun</TT>.</P><!--TOC section Overview of the compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc115">8.1</A>  Overview of the compiler</H2><!--SEC END --><P>The <TT>ocamlc</TT> command has a command-line interface similar to the one of
most C compilers. It accepts several types of arguments and processes them
sequentially:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arguments ending in <TT>.mli</TT> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <I>x</I><TT>.mli</TT>, the <TT>ocamlc</TT> compiler produces a compiled interface
in the file <I>x</I><TT>.cmi</TT>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.ml</TT> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <I>x</I><TT>.ml</TT>, the <TT>ocamlc</TT>
compiler produces compiled object bytecode in the file <I>x</I><TT>.cmo</TT>. <P>If the interface file <I>x</I><TT>.mli</TT> exists, the implementation
<I>x</I><TT>.ml</TT> is checked against the corresponding compiled interface
<I>x</I><TT>.cmi</TT>, which is assumed to exist. If no interface
<I>x</I><TT>.mli</TT> is provided, the compilation of <I>x</I><TT>.ml</TT> produces a
compiled interface file <I>x</I><TT>.cmi</TT> in addition to the compiled
object code file <I>x</I><TT>.cmo</TT>. The file <I>x</I><TT>.cmi</TT> produced
corresponds to an interface that exports everything that is defined in
the implementation <I>x</I><TT>.ml</TT>.</P></LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmo</TT> are taken to be compiled object bytecode. These
files are linked together, along with the object files obtained
by compiling <TT>.ml</TT> arguments (if any), and the OCaml standard
library, to produce a standalone executable program. The order in
which <TT>.cmo</TT> and <TT>.ml</TT> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <I>x</I><TT>.cmo</TT> file must come
before all <TT>.cmo</TT> files that refer to the unit <I>x</I>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.cma</TT> are taken to be libraries of object bytecode.
A library of object bytecode packs in a single file a set of object
bytecode files (<TT>.cmo</TT> files). Libraries are built with <TT>ocamlc -a</TT>
(see the description of the <TT>-a</TT> option below). The object files
contained in the library are linked as regular <TT>.cmo</TT> files (see
above), in the order specified when the <TT>.cma</TT> file was built. The
only difference is that if an object file contained in a library is
not referenced anywhere in the program, then it is not linked in.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.c</TT> are passed to the C compiler, which generates
a <TT>.o</TT> object file (<TT>.obj</TT> under Windows). This object file is linked
with the program if the <TT>-custom</TT> flag is set (see the description of
<TT>-custom</TT> below).</LI><LI CLASS="li-itemize">Arguments ending in <TT>.o</TT> or <TT>.a</TT> (<TT>.obj</TT> or <TT>.lib</TT> under Windows)
are assumed to be C object files and libraries. They are passed to the
C linker when linking in <TT>-custom</TT> mode (see the description of
<TT>-custom</TT> below).</LI><LI CLASS="li-itemize">Arguments ending in <TT>.so</TT> (<TT>.dll</TT> under Windows)
are assumed to be C shared libraries (DLLs). During linking, they are
searched for external C functions referenced from the Caml code,
and their names are written in the generated bytecode executable.
The run-time system <TT>ocamlrun</TT> then loads them dynamically at program
start-up time.</LI></UL><P>The output of the linking phase is a file containing compiled bytecode
that can be executed by the OCaml bytecode interpreter:
the command named <TT>ocamlrun</TT>. If <TT>caml.out</TT> is the name of the file
produced by the linking phase, the command
</P><PRE>
        ocamlrun caml.out <I>arg</I><SUB>1</SUB> <I>arg</I><SUB>2</SUB> &#X2026; <I>arg<SUB>n</SUB></I>
</PRE><P>
executes the compiled code contained in <TT>caml.out</TT>, passing it as
arguments the character strings <I>arg</I><SUB>1</SUB> to <I>arg<SUB>n</SUB></I>.
(See chapter <A HREF="#c:runtime">10</A> for more details.)</P><P>On most systems, the file produced by the linking
phase can be run directly, as in:
</P><PRE>
        ./caml.out <I>arg</I><SUB>1</SUB> <I>arg</I><SUB>2</SUB> &#X2026; <I>arg<SUB>n</SUB></I>
</PRE><P>
The produced file has the executable bit set, and it manages to launch
the bytecode interpreter by itself.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc116">8.2</A>  Options</H2><!--SEC END --><P><A NAME="s:comp-options"></A></P><P>The following command-line options are recognized by <TT>ocamlc</TT>.
The options <TT>-pack</TT>, <TT>-a</TT>, <TT>-c</TT> and <TT>-output-obj</TT> are mutually exclusive.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-a</B></TT></DT><DD CLASS="dd-description">
Build a library (<TT>.cma</TT> file) with the object files (<TT>.cmo</TT> files)
given on the command line, instead of linking them into an executable
file. The name of the library must be set with the <TT>-o</TT> option.<P>If <TT>-custom</TT>, <TT>-cclib</TT> or <TT>-ccopt</TT> options are passed on the command
line, these options are stored in the resulting <TT>.cma</TT> library. Then,
linking with this library automatically adds back the <TT>-custom</TT>,
<TT>-cclib</TT> and <TT>-ccopt</TT> options as if they had been provided on the
command line, unless the <TT>-noautolink</TT> option is given.</P></DD><DT CLASS="dt-description"><TT><B>-annot</B></TT></DT><DD CLASS="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc). The information for file <I>src</I><TT>.ml</TT>
is put into file <I>src</I><TT>.annot</TT>. In case of a type error, dump
all the information inferred by the type-checker before the error.
The <I>src</I><TT>.annot</TT> file can be used with the emacs commands given in
<TT>emacs/caml-types.el</TT> to display types and other annotations
interactively.</DD><DT CLASS="dt-description"><TT><B>-c</B></TT></DT><DD CLASS="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.</DD><DT CLASS="dt-description"><B><TT>-cc</TT> <I>ccomp</I></B></DT><DD CLASS="dd-description">
Use <I>ccomp</I> as the C linker when linking in &#X201C;custom runtime&#X201D;
mode (see the <TT>-custom</TT> option)
and as the C compiler for compiling <TT>.c</TT> source files.</DD><DT CLASS="dt-description"><B><TT>-cclib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the C linker when linking in
&#X201C;custom runtime&#X201D; mode (see the <TT>-custom</TT> option). This causes the
given C library to be linked with the program.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker. When linking in
&#X201C;custom runtime&#X201D; mode, for instance,
<TT>-ccopt -L</TT><I>dir</I> causes the C linker to search for C libraries in
directory <I>dir</I>. (See the <TT>-custom</TT> option.) </DD><DT CLASS="dt-description"><TT><B>-config</B></TT></DT><DD CLASS="dd-description">
Print the version number of <TT>ocamlc</TT> and a detailed summary of its
configuration, then exit.</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description">
Link in &#X201C;custom runtime&#X201D; mode. In the default linking mode, the
linker produces bytecode that is intended to be executed with the
shared runtime system, <TT>ocamlrun</TT>. In the custom runtime mode, the
linker produces an output file that contains both the runtime system
and the bytecode for the program. The resulting file is larger, but it
can be executed directly, even if the <TT>ocamlrun</TT> command is not
installed. Moreover, the &#X201C;custom runtime&#X201D; mode enables static
linking of Caml code with user-defined C functions, as described in
chapter <A HREF="#c:intf-c">18</A>.
<BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
Never use the <TT>strip</TT> command on executables produced by <TT>ocamlc -custom</TT>,
this would remove the bytecode part of the executable.
</BLOCKQUOTE></DD><DT CLASS="dt-description"><B><TT>-dllib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Arrange for the C shared library <TT>dll</TT><I>libname</I><TT>.so</TT>
(<TT>dll</TT><I>libname</I><TT>.dll</TT> under Windows) to be loaded dynamically
by the run-time system <TT>ocamlrun</TT> at program start-up time.</DD><DT CLASS="dt-description"><B><TT>-dllpath</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Adds the directory <I>dir</I> to the run-time search path for shared
C libraries. At link-time, shared libraries are searched in the
standard search path (the one corresponding to the <TT>-I</TT> option).
The <TT>-dllpath</TT> option simply stores <I>dir</I> in the produced
executable file, where <TT>ocamlrun</TT> can find it and use it as
described in section <A HREF="#s-ocamlrun-dllpath">10.3</A>.</DD><DT CLASS="dt-description"><TT><B>-g</B></TT></DT><DD CLASS="dd-description">
Add debugging information while compiling and linking. This option is
required in order to be able to debug the program with <TT>ocamldebug</TT>
(see chapter <A HREF="#c:debugger">16</A>), and to produce stack backtraces when
the program terminates on an uncaught exception (see
section <A HREF="#ocamlrun-options">10.2</A>).</DD><DT CLASS="dt-description"><TT><B>-help-warnings</B></TT></DT><DD CLASS="dd-description">
Show description for all available warning numbers.</DD><DT CLASS="dt-description"><TT><B>-i</B></TT></DT><DD CLASS="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<TT>.ml</TT>
file). No compiled files (<TT>.cmo</TT> and <TT>.cmi</TT> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<TT>.mli</TT> file) for a file:
just redirect the standard output of the compiler to a <TT>.mli</TT> file,
and edit that file to remove all declarations of unexported names.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled interface files (<TT>.cmi</TT>), compiled object code files
(<TT>.cmo</TT>), libraries (<TT>.cma</TT>), and C libraries specified with
<TT>-cclib -lxxx</TT>. By default, the current directory is
searched first, then the standard library directory. Directories added
with <TT>-I</TT> are searched after the current directory, in the order in
which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P></DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf-suffix</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Recognize file names ending with <I>string</I> as interface files
(instead of the default <TT>.mli</TT>).</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-linkall</B></TT></DT><DD CLASS="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (option <TT>-a</TT>), setting the <TT>-linkall</TT> option forces all
subsequent links of programs involving that library to link all the
modules contained in the library.</DD><DT CLASS="dt-description"><TT><B>-make-runtime</B></TT></DT><DD CLASS="dd-description">
Build a custom runtime system (in the file specified by option <TT>-o</TT>)
incorporating the C object files and libraries given on the command
line. This custom runtime system can be used later to execute
bytecode executables produced with the
<TT>ocamlc -use-runtime</TT> <I>runtime-name</I> option.
See section <A HREF="#s:custom-runtime">18.1.6</A> for more information.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</DD><DT CLASS="dt-description"><TT><B>-noautolink</B></TT></DT><DD CLASS="dd-description">
When linking <TT>.cma</TT> libraries, ignore <TT>-custom</TT>, <TT>-cclib</TT> and <TT>-ccopt</TT>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <TT>-noautolink</TT> and pass the correct C
libraries and options on the command line.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by the compiler. The
default output name is <TT>a.out</TT> under Unix and <TT>camlprog.exe</TT> under
Windows. If the <TT>-a</TT> option is given, specify the name of the library
produced. If the <TT>-pack</TT> option is given, specify the name of the
packed object file produced. If the <TT>-output-obj</TT> option is given,
specify the name of the output file produced. If the <TT>-c</TT> option is
given, specify the name of the object file produced for the <EM>next</EM>
source file that appears on the command line.</DD><DT CLASS="dt-description"><TT><B>-output-obj</B></TT></DT><DD CLASS="dd-description">
Cause the linker to produce a C object file instead of a bytecode
executable file. This is useful to wrap Caml code as a C library,
callable from any C program. See chapter <A HREF="#c:intf-c">18</A>,
section <A HREF="#s:embedded-code">18.7.5</A>. The name of the output object file is
<TT>camlprog.o</TT> by default; it can be set with the <TT>-o</TT> option. This
option can also be used to produce a C source file (<TT>.c</TT> extension) or
a compiled shared/dynamic library (<TT>.so</TT> extension, <TT>.dll</TT> under Windows).</DD><DT CLASS="dt-description"><TT><B>-pack</B></TT></DT><DD CLASS="dd-description">
Build a bytecode object file (<TT>.cmo</TT> file) and its associated compiled
interface (<TT>.cmi</TT>) that combines the object
files given on the command line, making them appear as sub-modules of
the output <TT>.cmo</TT> file. The name of the output <TT>.cmo</TT> file must be
given with the <TT>-o</TT> option. For instance,
<PRE CLASS="verbatim">        ocamlc -pack -o p.cmo a.cmo b.cmo c.cmo
</PRE>generates compiled files <TT>p.cmo</TT> and <TT>p.cmi</TT> describing a compilation
unit having three sub-modules <TT>A</TT>, <TT>B</TT> and <TT>C</TT>, corresponding to the
contents of the object files <TT>a.cmo</TT>, <TT>b.cmo</TT> and <TT>c.cmo</TT>. These
contents can be referenced as <TT>P.A</TT>, <TT>P.B</TT> and <TT>P.C</TT> in the remainder
of the program.</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause the compiler to call the given <I>command</I> as a preprocessor
for each source file. The output of <I>command</I> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <TT>-principal</TT> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</DD><DT CLASS="dt-description"><B><TT>-runtime-variant</TT> <I>suffix</I></B></DT><DD CLASS="dd-description">
Add the <I>suffix</I> string to the name of the runtime library used by
the program. Currently, only one such suffix is supported: <TT>d</TT>, and
only if the OCaml compiler was configured with option
<TT>-with-debug-runtime</TT>. This suffix gives the debug version of the
runtime, which is useful for debugging pointer problems in low-level
code such as C stubs.</DD><DT CLASS="dt-description"><TT><B>-thread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
system <TT>threads</TT> library described in chapter <A HREF="#c:threads">24</A>.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
Turn bound checking off for array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
slightly faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.</DD><DT CLASS="dt-description"><B><TT>-use-runtime</TT> <I>runtime-name</I></B></DT><DD CLASS="dd-description">
Generate a bytecode executable file that can be executed on the custom
runtime system <I>runtime-name</I>, built earlier with
<TT>ocamlc -make-runtime</TT> <I>runtime-name</I>. 
See section <A HREF="#s:custom-runtime">18.1.6</A> for more information.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</DD><DT CLASS="dt-description"><TT><B>-verbose</B></TT></DT><DD CLASS="dd-description">
Print all external commands before they are executed, in particular
invocations of the C compiler and linker in <TT>-custom</TT> mode. Useful to
debug C library problems.</DD><DT CLASS="dt-description"><B><TT>-vnum</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description">
Print the version number of the compiler in short form (e.g. <TT>3.11.0</TT>),
then exit.</DD><DT CLASS="dt-description"><TT><B>-vmthread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
VM-level <TT>threads</TT> library described in chapter <A HREF="#c:threads">24</A>.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable, disable, or mark as errors the warnings specified by the argument
<I>warning-list</I>.
Each warning can be <EM>enabled</EM> or <EM>disabled</EM>, and each warning
can be <EM>marked</EM> or <EM>unmarked</EM>.
If a warning is disabled, it isn&#X2019;t displayed and doesn&#X2019;t affect
compilation in any way (even if it is marked). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and marked, the compiler will stop
with an error after displaying that warning if the source code
triggers it.<P>The <I>warning-list</I> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>+</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num</I></B></DT><DD CLASS="dd-description"> Disable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable and mark warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Disable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable and mark warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable and mark the set of warnings
corresponding to <I>letter</I>. The letter may be uppercase or
lowercase.
</DD><DT CLASS="dt-description"><I><B>uppercase-letter</B></I></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding
to <I>uppercase-letter</I>.
</DD><DT CLASS="dt-description"><I><B>lowercase-letter</B></I></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding
to <I>lowercase-letter</I>.
</DD></DL><P>Warning numbers which are out of the range of warnings that are currently
defined are ignored. The warning numbers are as follows.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>1</B></DT><DD CLASS="dd-description"> Suspicious-looking start-of-comment mark.
</DD><DT CLASS="dt-description"><B>2</B></DT><DD CLASS="dd-description"> Suspicious-looking end-of-comment mark.
</DD><DT CLASS="dt-description"><B>3</B></DT><DD CLASS="dd-description"> Deprecated syntax.
</DD><DT CLASS="dt-description"><B>4</B></DT><DD CLASS="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</DD><DT CLASS="dt-description"><B>5</B></DT><DD CLASS="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</DD><DT CLASS="dt-description"><B>6</B></DT><DD CLASS="dd-description"> Label omitted in function application.
</DD><DT CLASS="dt-description"><B>7</B></DT><DD CLASS="dd-description"> Some methods are overridden in the class where they are defined.
</DD><DT CLASS="dt-description"><B>8</B></DT><DD CLASS="dd-description"> Partial match: missing cases in pattern-matching.
</DD><DT CLASS="dt-description"><B>9</B></DT><DD CLASS="dd-description"> Missing fields in a record pattern.
</DD><DT CLASS="dt-description"><B>10</B></DT><DD CLASS="dd-description"> Expression on the left-hand side of a sequence that doesn&#X2019;t have type
"unit" (and that is not a function, see warning number 5).
</DD><DT CLASS="dt-description"><B>11</B></DT><DD CLASS="dd-description"> Redundant case in a pattern matching (unused match case).
</DD><DT CLASS="dt-description"><B>12</B></DT><DD CLASS="dd-description"> Redundant sub-pattern in a pattern-matching.
</DD><DT CLASS="dt-description"><B>13</B></DT><DD CLASS="dd-description"> Override of an instance variable.
</DD><DT CLASS="dt-description"><B>14</B></DT><DD CLASS="dd-description"> Illegal backslash escape in a string constant.
</DD><DT CLASS="dt-description"><B>15</B></DT><DD CLASS="dd-description"> Private method made public implicitly.
</DD><DT CLASS="dt-description"><B>16</B></DT><DD CLASS="dd-description"> Unerasable optional argument.
</DD><DT CLASS="dt-description"><B>17</B></DT><DD CLASS="dd-description"> Undeclared virtual method.
</DD><DT CLASS="dt-description"><B>18</B></DT><DD CLASS="dd-description"> Non-principal type.
</DD><DT CLASS="dt-description"><B>19</B></DT><DD CLASS="dd-description"> Type without principality.
</DD><DT CLASS="dt-description"><B>20</B></DT><DD CLASS="dd-description"> Unused function argument.
</DD><DT CLASS="dt-description"><B>21</B></DT><DD CLASS="dd-description"> Non-returning statement.
</DD><DT CLASS="dt-description"><B>22</B></DT><DD CLASS="dd-description"> Camlp4 warning.
</DD><DT CLASS="dt-description"><B>23</B></DT><DD CLASS="dd-description"> Useless record "with" clause.
</DD><DT CLASS="dt-description"><B>24</B></DT><DD CLASS="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</DD><DT CLASS="dt-description"><B>25</B></DT><DD CLASS="dd-description"> Pattern-matching with all clauses guarded. Exhaustiveness cannot be
checked
</DD><DT CLASS="dt-description"><B>26</B></DT><DD CLASS="dd-description"> Suspicious unused variable: unused variable that is bound with "let"
or "as", and doesn&#X2019;t start with an underscore ("_") character.
</DD><DT CLASS="dt-description"><B>27</B></DT><DD CLASS="dd-description"> Innocuous unused variable: unused variable that is not bound with
"let" nor "as", and doesn&#X2019;t start with an underscore ("_")
character.
</DD><DT CLASS="dt-description"><B>28</B></DT><DD CLASS="dd-description"> Wildcard pattern given as argument to a constant constructor.
</DD><DT CLASS="dt-description"><B>29</B></DT><DD CLASS="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</DD><DT CLASS="dt-description"><B>30</B></DT><DD CLASS="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.

</DD></DL><P>The letters stand for the following sets of warnings. Any letter not
mentioned here corresponds to the empty set.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>A</B></DT><DD CLASS="dd-description"> all warnings
</DD><DT CLASS="dt-description"><B>C</B></DT><DD CLASS="dd-description"> 1, 2
</DD><DT CLASS="dt-description"><B>D</B></DT><DD CLASS="dd-description"> 3
</DD><DT CLASS="dt-description"><B>E</B></DT><DD CLASS="dd-description"> 4
</DD><DT CLASS="dt-description"><B>F</B></DT><DD CLASS="dd-description"> 5
</DD><DT CLASS="dt-description"><B>L</B></DT><DD CLASS="dd-description"> 6
</DD><DT CLASS="dt-description"><B>M</B></DT><DD CLASS="dd-description"> 7
</DD><DT CLASS="dt-description"><B>P</B></DT><DD CLASS="dd-description"> 8
</DD><DT CLASS="dt-description"><B>R</B></DT><DD CLASS="dd-description"> 9
</DD><DT CLASS="dt-description"><B>S</B></DT><DD CLASS="dd-description"> 10
</DD><DT CLASS="dt-description"><B>U</B></DT><DD CLASS="dd-description"> 11, 12
</DD><DT CLASS="dt-description"><B>V</B></DT><DD CLASS="dd-description"> 13
</DD><DT CLASS="dt-description"><B>X</B></DT><DD CLASS="dd-description"> 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
</DD><DT CLASS="dt-description"><B>Y</B></DT><DD CLASS="dd-description"> 26
</DD><DT CLASS="dt-description"><B>Z</B></DT><DD CLASS="dd-description"> 27
</DD></DL><P>The default setting is <TT>-w +a-4-6-7-9-27..29</TT>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</P></DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Mark as errors the warnings specified in the argument <I>warning-list</I>.
The compiler will stop with an error when one of these warnings is
emitted. The <I>warning-list</I> has the same meaning as for
the <TT>-w</TT> option: a <TT>+</TT> sign (or an uppercase letter) turns the
corresponding warnings into errors, a <TT>-</TT>
sign (or a lowercase letter) turns them back into warnings, and a
<TT>@</TT> sign both enables and marks the corresponding warnings.<P>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <TT>-warn-error</TT>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</P><P>The default setting is <TT>-warn-error -a</TT>
(none of the warnings is treated as an error).</P></DD><DT CLASS="dt-description"><TT><B>-where</B></TT></DT><DD CLASS="dd-description">
Print the location of the standard library, then exit.</DD><DT CLASS="dt-description"><B><TT>-</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as a file name, even if it starts with a dash (-)
character.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Modules and the file system-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc117">8.3</A>  Modules and the file system</H2><!--SEC END --><P>This short section is intended to clarify the relationship between the
names of the modules corresponding to compilation units and the names
of the files that contain their compiled interface and compiled
implementation.</P><P>The compiler always derives the module name by taking the capitalized
base name of the source file (<TT>.ml</TT> or <TT>.mli</TT> file). That is, it
strips the leading directory name, if any, as well as the <TT>.ml</TT> or
<TT>.mli</TT> suffix; then, it set the first letter to uppercase, in order to
comply with the requirement that module names must be capitalized.
For instance, compiling the file <TT>mylib/misc.ml</TT> provides an
implementation for the module named <TT>Misc</TT>. Other compilation units
may refer to components defined in <TT>mylib/misc.ml</TT> under the names
<TT>Misc.</TT><I>name</I>; they can also do <TT>open Misc</TT>, then use unqualified
names <I>name</I>.</P><P>The <TT>.cmi</TT> and <TT>.cmo</TT> files produced by the compiler have the same
base name as the source file. Hence, the compiled files always have
their base name equal (modulo capitalization of the first letter) to
the name of the module they describe (for <TT>.cmi</TT> files) or implement
(for <TT>.cmo</TT> files).</P><P>When the compiler encounters a reference to a free module identifier
<TT>Mod</TT>, it looks in the search path for a file named <TT>Mod.cmi</TT> or <TT>mod.cmi</TT>
and loads the compiled interface
contained in that file. As a consequence, renaming <TT>.cmi</TT> files is not
advised: the name of a <TT>.cmi</TT> file must always correspond to the name
of the compilation unit it implements. It is admissible to move them
to another directory, if their base name is preserved, and the correct
<TT>-I</TT> options are given to the compiler. The compiler will flag an
error if it loads a <TT>.cmi</TT> file that has been renamed.</P><P>Compiled bytecode files (<TT>.cmo</TT> files), on the other hand, can be
freely renamed once created. That&#X2019;s because the linker never attempts
to find by itself the <TT>.cmo</TT> file that implements a module with a
given name: it relies instead on the user providing the list of <TT>.cmo</TT>
files by hand.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc118">8.4</A>  Common errors</H2><!--SEC END --><P> <A NAME="s:comp-errors"></A></P><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B>Cannot find file <I>filename</I></B></DT><DD CLASS="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path. The <I>filename</I> is either a
compiled interface file (<TT>.cmi</TT> file), or a compiled bytecode file
(<TT>.cmo</TT> file). If <I>filename</I> has the format <I>mod</I><TT>.cmi</TT>, this
means you are trying to compile a file that references identifiers
from module <I>mod</I>, but you have not yet compiled an interface for
module <I>mod</I>. Fix: compile <I>mod</I><TT>.mli</TT> or <I>mod</I><TT>.ml</TT>
first, to create the compiled interface <I>mod</I><TT>.cmi</TT>. <P>If <I>filename</I> has the format <I>mod</I><TT>.cmo</TT>, this
means you are trying to link a bytecode object file that does not
exist yet. Fix: compile <I>mod</I><TT>.ml</TT> first.</P><P>If your program spans several directories, this error can also appear
because you haven&#X2019;t specified the directories to look into. Fix: add
the correct <TT>-I</TT> options to the command line.</P></DD><DT CLASS="dt-description"><B>Corrupted compiled interface <I>filename</I></B></DT><DD CLASS="dd-description">
The compiler produces this error when it tries to read a compiled
interface file (<TT>.cmi</TT> file) that has the wrong structure. This means
something went wrong when this <TT>.cmi</TT> file was written: the disk was
full, the compiler was interrupted in the middle of the file creation,
and so on. This error can also appear if a <TT>.cmi</TT> file is modified after
its creation by the compiler. Fix: remove the corrupted <TT>.cmi</TT> file,
and rebuild it.</DD><DT CLASS="dt-description"><B>This expression has type <I>t</I><SUB>1</SUB>, but is used with type <I>t</I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
This is by far the most common type error in programs. Type <I>t</I><SUB>1</SUB> is
the type inferred for the expression (the part of the program that is
displayed in the error message), by looking at the expression itself.
Type <I>t</I><SUB>2</SUB> is the type expected by the context of the expression; it
is deduced by looking at how the value of this expression is used in
the rest of the program. If the two types <I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB> are not
compatible, then the error above is produced.<P>In some cases, it is hard to understand why the two types <I>t</I><SUB>1</SUB> and
<I>t</I><SUB>2</SUB> are incompatible. For instance, the compiler can report that
&#X201C;expression of type <TT>foo</TT> cannot be used with type <TT>foo</TT>&#X201D;, and it
really seems that the two types <TT>foo</TT> are compatible. This is not
always true. Two type constructors can have the same name, but
actually represent different types. This can happen if a type
constructor is redefined. Example:
</P><PRE CLASS="verbatim">        type foo = A | B
        let f = function A -&gt; 0 | B -&gt; 1
        type foo = C | D
        f C
</PRE><P>This result in the error message &#X201C;expression <TT>C</TT> of type <TT>foo</TT> cannot
be used with type <TT>foo</TT>&#X201D;. </P></DD><DT CLASS="dt-description"><B>The type of this expression, <I>t</I>, contains type variables
that cannot be generalized</B></DT><DD CLASS="dd-description">
Type variables (<TT>&#X2019;a</TT>, <TT>&#X2019;b</TT>, &#X2026;) in a type <I>t</I> can be in either
of two states: generalized (which means that the type <I>t</I> is valid
for all possible instantiations of the variables) and not generalized
(which means that the type <I>t</I> is valid only for one instantiation
of the variables). In a <TT>let</TT> binding <TT>let </TT><I>name</I><TT> = </TT><I>expr</I>,
the type-checker normally generalizes as many type variables as
possible in the type of <I>expr</I>. However, this leads to unsoundness
(a well-typed program can crash) in conjunction with polymorphic
mutable data structures. To avoid this, generalization is performed at
<TT>let</TT> bindings only if the bound expression <I>expr</I> belongs to the
class of &#X201C;syntactic values&#X201D;, which includes constants, identifiers,
functions, tuples of syntactic values, etc. In all other cases (for
instance, <I>expr</I> is a function application), a polymorphic mutable
could have been created and generalization is therefore turned off for
all variables occuring in contravariant or non-variant branches of the
type. For instance, if the type of a non-value is <TT>&#X2019;a list</TT> the
variable is generalizable (<TT>list</TT> is a covariant type constructor),
but not in <TT>&#X2019;a list -&gt; &#X2019;a list</TT> (the left branch of <TT>-&gt;</TT> is
contravariant) or <TT>&#X2019;a ref</TT> (<TT>ref</TT> is non-variant).<P>Non-generalized type variables in a type cause no difficulties inside
a given structure or compilation unit (the contents of a <TT>.ml</TT> file,
or an interactive session), but they cannot be allowed inside
signatures nor in compiled interfaces (<TT>.cmi</TT> file), because they
could be used inconsistently later. Therefore, the compiler
flags an error when a structure or compilation unit defines a value
<I>name</I> whose type contains non-generalized type variables. There
are two ways to fix this error:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Add a type constraint or a <TT>.mli</TT> file to give a monomorphic
type (without type variables) to <I>name</I>. For instance, instead of
writing
<PRE CLASS="verbatim">    let sort_int_list = Sort.list (&lt;)
    (* inferred type 'a list -&gt; 'a list, with 'a not generalized *)
</PRE>write
<PRE CLASS="verbatim">    let sort_int_list = (Sort.list (&lt;) : int list -&gt; int list);;
</PRE></LI><LI CLASS="li-itemize">If you really need <I>name</I> to have a polymorphic type, turn
its defining expression into a function by adding an extra parameter.
For instance, instead of writing
<PRE CLASS="verbatim">    let map_length = List.map Array.length
    (* inferred type 'a array list -&gt; int list, with 'a not generalized *)
</PRE>write
<PRE CLASS="verbatim">    let map_length lv = List.map Array.length lv
</PRE></LI></UL></DD><DT CLASS="dt-description"><B>Reference to undefined global <I>mod</I></B></DT><DD CLASS="dd-description">
This error appears when trying to link an incomplete or incorrectly
ordered set of files. Either you have forgotten to provide an
implementation for the compilation unit named <I>mod</I> on the command line
(typically, the file named <I>mod</I><TT>.cmo</TT>, or a library containing
that file). Fix: add the missing <TT>.ml</TT> or <TT>.cmo</TT> file to the command
line. Or, you have provided an implementation for the module named
<I>mod</I>, but it comes too late on the command line: the
implementation of <I>mod</I> must come before all bytecode object files
that reference <I>mod</I>. Fix: change the order of <TT>.ml</TT> and <TT>.cmo</TT>
files on the command line.<P>Of course, you will always encounter this error if you have mutually
recursive functions across modules. That is, function <TT>Mod1.f</TT> calls
function <TT>Mod2.g</TT>, and function <TT>Mod2.g</TT> calls function <TT>Mod1.f</TT>.
In this case, no matter what permutations you perform on the command
line, the program will be rejected at link-time. Fixes:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Put <TT>f</TT> and <TT>g</TT> in the same module.
</LI><LI CLASS="li-itemize">Parameterize one function by the other.
That is, instead of having
<PRE CLASS="verbatim">mod1.ml:    let f x = ... Mod2.g ...
mod2.ml:    let g y = ... Mod1.f ...
</PRE>define
<PRE CLASS="verbatim">mod1.ml:    let f g x = ... g ...
mod2.ml:    let rec g y = ... Mod1.f g ...
</PRE>and link <TT>mod1.cmo</TT> before <TT>mod2.cmo</TT>.
</LI><LI CLASS="li-itemize">Use a reference to hold one of the two functions, as in :
<PRE CLASS="verbatim">mod1.ml:    let forward_g =
                ref((fun x -&gt; failwith "forward_g") : &lt;type&gt;)
            let f x = ... !forward_g ...
mod2.ml:    let g y = ... Mod1.f ...
            let _ = Mod1.forward_g := g
</PRE></LI></UL></DD><DT CLASS="dt-description"><B>The external function <I>f</I> is not available</B></DT><DD CLASS="dd-description">
This error appears when trying to link code that calls external
functions written in C. As explained in
chapter <A HREF="#c:intf-c">18</A>, such code must be linked with C libraries that
implement the required <I>f</I> C function. If the C libraries in
question are not shared libraries (DLLs), the code must be linked in
&#X201C;custom runtime&#X201D; mode. Fix: add the required C libraries to the
command line, and possibly the <TT>-custom</TT> option.</DD></DL><!--TOC chapter The toplevel system (ocaml)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc119">Chapter 9</A>  The toplevel system (ocaml)</H1><!--SEC END --><P> <A NAME="c:camllight"></A>
</P><P>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system
through a read-eval-print loop. In this mode, the system repeatedly
reads Caml phrases from the input, then typechecks, compile and
evaluate them, then prints the inferred type and result value, if
any. The system prints a <TT>#</TT> (sharp) prompt before reading each
phrase.</P><P>Input to the toplevel can span several lines. It is terminated by <TT>;;</TT> (a
double-semicolon). The toplevel input consists in one or several
toplevel phrases, with the following syntax:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="toplevel-input"><FONT COLOR=maroon>toplevel-input</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
{ <I><A HREF="#toplevel-phrase"><FONT COLOR=maroon>toplevel-phrase</FONT></A></I> } <FONT COLOR=blue><TT>;;</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="toplevel-phrase"><FONT COLOR=maroon>toplevel-phrase</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<I><A HREF="#definition"><FONT COLOR=maroon>definition</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#expr"><FONT COLOR=maroon>expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>#</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>  <I><A HREF="#directive-argument"><FONT COLOR=maroon>directive-argument</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><A NAME="directive-argument"><FONT COLOR=maroon>directive-argument</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X454;
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#string-literal"><FONT COLOR=maroon>string-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#integer-literal"><FONT COLOR=maroon>integer-literal</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#value-path"><FONT COLOR=maroon>value-path</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>A phrase can consist of a definition, similar to those found in
implementations of compilation units or in <FONT COLOR=blue><TT>struct</TT></FONT> &#X2026; <FONT COLOR=blue><TT>end</TT></FONT>
module expressions. The definition can bind value names, type names,
an exception, a module name, or a module type name. The toplevel
system performs the bindings, then prints the types and values (if
any) for the names thus defined.</P><P>A phrase may also consist in a <TT>open</TT> directive (see
section <A HREF="#s:module-expr">6.11</A>), or a value expression
(section <A HREF="#s:value-expr">6.7</A>). Expressions are simply evaluated,
without performing any bindings, and the value of the expression is
printed.</P><P>Finally, a phrase can also consist in a toplevel directive,
starting with <TT>#</TT> (the sharp sign). These directives control the
behavior of the toplevel; they are listed below in
section <A HREF="#s:toplevel-directives">9.2</A>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
The toplevel system is started by the command <TT>ocaml</TT>, as follows:
<PRE>
        ocaml <I>options objects</I>                # interactive mode
        ocaml <I>options objects scriptfile</I>        # script mode
</PRE>
<I>options</I> are described below.
<I>objects</I> are filenames ending in <TT>.cmo</TT> or <TT>.cma</TT>; they are
loaded into the interpreter immediately after <I>options</I> are set.
<I>scriptfile</I> is any file name not ending in <TT>.cmo</TT> or <TT>.cma</TT>.<P>If no <I>scriptfile</I> is given on the command line, the toplevel system
enters interactive mode: phrases are read on standard input, results
are printed on standard output, errors on standard error. End-of-file
on standard input terminates <TT>ocaml</TT> (see also the <TT>#quit</TT> directive
in section <A HREF="#s:toplevel-directives">9.2</A>).</P><P>On start-up (before the first phrase is read), if the file
<TT>.ocamlinit</TT> exists in the current directory,
its contents are read as a sequence of OCaml phrases
and executed as per the <TT>#use</TT> directive
described in section <A HREF="#s:toplevel-directives">9.2</A>.
The evaluation outcode for each phrase are not displayed.
If the current directory does not contain an <TT>.ocamlinit</TT> file, but
the user&#X2019;s home directory (environment variable <TT>HOME</TT>) does, the
latter is read and executed as described below.</P><P>The toplevel system does not perform line editing, but it can
easily be used in conjunction with an external line editor such as
<TT>ledit</TT>, <TT>ocaml2</TT> or <TT>rlwrap</TT>


(see the
<A HREF="http://caml.inria.fr/humps/index_framed_caml.html">Caml Hump</A>).

Another option is to use <TT>ocaml</TT> under Gnu Emacs, which gives the
full editing power of Emacs (command <TT>run-caml</TT> from library <TT>inf-caml</TT>).</P><P>At any point, the parsing, compilation or evaluation of the current
phrase can be interrupted by pressing <TT>ctrl-C</TT> (or, more precisely,
by sending the <TT>INTR</TT> signal to the <TT>ocaml</TT> process). The toplevel
then immediately returns to the <TT>#</TT> prompt.</P><P>If <I>scriptfile</I> is given on the command-line to <TT>ocaml</TT>, the toplevel
system enters script mode: the contents of the file are read as a
sequence of OCaml phrases and executed, as per the <TT>#use</TT>
directive (section <A HREF="#s:toplevel-directives">9.2</A>). The outcome of the
evaluation is not printed. On reaching the end of file, the <TT>ocaml</TT>
command exits immediately. No commands are read from standard input.
<TT>Sys.argv</TT> is transformed, ignoring all OCaml parameters, and
starting with the script file name in <TT>Sys.argv.(0)</TT>.</P><P>In script mode, the first line of the script is ignored if it starts
with <TT>#!</TT>. Thus, it should be possible to make the script
itself executable and put as first line <TT>#!/usr/local/bin/ocaml</TT>,
thus calling the toplevel system automatically when the script is
run. However, <TT>ocaml</TT> itself is a <TT>#!</TT> script on most installations
of OCaml, and Unix kernels usually do not handle nested <TT>#!</TT>
scripts. A better solution is to put the following as the first line
of the script:
</P><PRE CLASS="verbatim">        #!/usr/local/bin/ocamlrun /usr/local/bin/ocaml
</PRE></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
In addition to the text-only command <TT>ocaml.exe</TT>, which works exactly
as under Unix (see above), a graphical user interface for the
toplevel is available under the name <TT>ocamlwin.exe</TT>. It should be
launched from the Windows file manager or program manager.
This interface provides a text window in which commands can be entered
and edited, and the toplevel responses are printed.
</BLOCKQUOTE><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc120">9.1</A>  Options</H2><!--SEC END --><P> <A NAME="s:toplevel-options"></A></P><P>The following command-line options are recognized by the <TT>ocaml</TT> command.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files. By default, the current directory is
searched first, then the standard library directory. Directories added
with <TT>-I</TT> are searched after the current directory, in the order in
which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P><P>Directories can also be added to the list once
the toplevel is running with the <TT>#directory</TT> directive
(section <A HREF="#s:toplevel-directives">9.2</A>).</P></DD><DT CLASS="dt-description"><B><TT>-init</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Load the given file instead of the default initialization file.
The default file is <TT>.ocamlinit</TT> in the current directory if it
exists, otherwise <TT>.ocamlinit</TT> in the user&#X2019;s home directory.</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><TT><B>-noprompt</B></TT></DT><DD CLASS="dd-description">
Do not display any prompt when waiting for input.</DD><DT CLASS="dt-description"><TT><B>-nostdlib</B></TT></DT><DD CLASS="dd-description">
Do not include the standard library directory in the list of
directories searched for source and compiled files.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. When using labelled arguments
and/or polymorphic methods, this flag is required to ensure future
versions of the compiler will be able to infer types correctly, even
if internal algorithms change.
All programs accepted in <TT>-principal</TT> mode are also accepted in the
default mode with equivalent types, but different binary signatures,
and this may slow down type checking; yet it is a good idea to
use it once before publishing source code.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
See the corresponding option for <TT>ocamlc</TT>, chapter <A HREF="#c:camlc">8</A>.
Turn bound checking off on array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
slightly faster, but unsafe: anything can happen if the program
accesses an array or string outside of its bounds.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument <I>warning-list</I>.
See section <A HREF="#s:comp-options">8.2</A> for the syntax of the argument.</DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Treat as errors the warnings enabled by the argument <I>warning-list</I>.
See section <A HREF="#s:comp-options">8.2</A> for the syntax of the argument.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
The following environment variables are also consulted:
<DL CLASS="description"><DT CLASS="dt-description">
<B><TT>LC_CTYPE</TT></B></DT><DD CLASS="dd-description"> If set to <TT>iso_8859_1</TT>, accented characters (from the
ISO Latin-1 character set) in string and character literals are
printed as is; otherwise, they are printed as decimal escape sequences
(<TT>\</TT><I>ddd</I>).</DD><DT CLASS="dt-description"><TT><B>TERM</B></TT></DT><DD CLASS="dd-description"> When printing error messages, the toplevel system
attempts to underline visually the location of the error. It
consults the <TT>TERM</TT> variable to determines the type of output terminal
and look up its capabilities in the terminal database.</DD><DT CLASS="dt-description"><TT><B>HOME</B></TT></DT><DD CLASS="dd-description"> Directory where the <TT>.ocamlinit</TT> file is searched.
</DD></DL>
</BLOCKQUOTE><!--TOC section Toplevel directives-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc121">9.2</A>  Toplevel directives</H2><!--SEC END --><P>
<A NAME="s:toplevel-directives"></A></P><P>The following directives control the toplevel behavior, load files in
memory, and trace program execution.</P><P><B>Note:</B> all directives start with a <TT>#</TT> (sharp) symbol. This <TT>#</TT>
must be typed before the directive, and must not be confused with the
<TT>#</TT> prompt displayed by the interactive loop. For instance,
typing <TT>#quit;;</TT> will exit the toplevel loop, but typing <TT>quit;;</TT>
will result in an &#X201C;unbound value <TT>quit</TT>&#X201D; error.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>#quit;;</B></TT></DT><DD CLASS="dd-description">
Exit the toplevel loop and terminate the <TT>ocaml</TT> command.</DD><DT CLASS="dt-description"><B><TT>#labels </TT><I>bool</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Ignore labels in function types if argument is <TT>false</TT>, or switch back
to default behaviour (commuting style) if argument is <TT>true</TT>.</DD><DT CLASS="dt-description"><B><TT>#warnings "</TT><I>warning-list</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument.</DD><DT CLASS="dt-description"><B><TT>#directory "</TT><I>dir-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files.</DD><DT CLASS="dt-description"><B><TT>#cd "</TT><I>dir-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Change the current working directory.</DD><DT CLASS="dt-description"><B><TT>#load "</TT><I>file-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Load in memory a bytecode object file (<TT>.cmo</TT> file) produced by
the batch compiler <TT>ocamlc</TT>.</DD><DT CLASS="dt-description"><B><TT>#use "</TT><I>file-name</I><TT>";;</TT></B></DT><DD CLASS="dd-description">
Read, compile and execute source phrases from the given file.
This is textual inclusion: phrases are processed just as if
they were typed on standard input. The reading of the file stops at
the first error encountered.</DD><DT CLASS="dt-description"><B><TT>#install_printer </TT><I>printer-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
This directive registers the function named <I>printer-name</I> (a
value path) as a printer for values whose types match the argument
type of the function. That is, the toplevel loop will call
<I>printer-name</I> when it has such a value to print.<P>The printing function <I>printer-name</I> should have type
<FONT COLOR=blue><TT>Format.formatter</TT> <TT>-&gt;</TT> <FONT COLOR=maroon><I>t</I></FONT> <TT>-&gt;</TT> <TT>unit</TT></FONT>, where <FONT COLOR=maroon><I>t</I></FONT> is the
type for the values to be printed, and should output its textual
representation for the value of type <FONT COLOR=maroon><I>t</I></FONT> on the given formatter,
using the functions provided by the <TT>Format</TT> library. For backward
compatibility, <I>printer-name</I> can also have type
<FONT COLOR=maroon><I>t</I></FONT> <FONT COLOR=blue><TT>-&gt;</TT> <TT>unit</TT></FONT> and should then output on the standard
formatter, but this usage is deprecated.</P></DD><DT CLASS="dt-description"><B><TT>#remove_printer </TT><I>printer-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Remove the named function from the table of toplevel printers.</DD><DT CLASS="dt-description"><B><TT>#trace </TT><I>function-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
After executing this directive, all calls to the function named
<I>function-name</I> will be &#X201C;traced&#X201D;. That is, the argument and the
result are displayed for each call, as well as the exceptions escaping
out of the function, raised either by the function itself or by
another function it calls. If the function is curried, each argument
is printed as it is passed to the function.</DD><DT CLASS="dt-description"><B><TT>#untrace </TT><I>function-name</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Stop tracing the given function.</DD><DT CLASS="dt-description"><B><TT>#untrace_all;;</TT></B></DT><DD CLASS="dd-description">
Stop tracing all functions traced so far.</DD><DT CLASS="dt-description"><B><TT>#print_depth </TT><I>n</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Limit the printing of values to a maximal depth of <I>n</I>.
The parts of values whose depth exceeds <I>n</I> are printed as <TT>...</TT>
(ellipsis).</DD><DT CLASS="dt-description"><B><TT>#print_length </TT><I>n</I><TT>;;</TT></B></DT><DD CLASS="dd-description">
Limit the number of value nodes printed to at most <I>n</I>.
Remaining parts of values are printed as <TT>...</TT> (ellipsis).</DD></DL><!--TOC section The toplevel and the module system-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc122">9.3</A>  The toplevel and the module system</H2><!--SEC END --><P> <A NAME="s:toplevel-modules"></A></P><P>Toplevel phrases can refer to identifiers defined in compilation units
with the same mechanisms as for separately compiled units: either by
using qualified names (<TT>Modulename.localname</TT>), or by using
the <TT>open</TT> construct and unqualified names (see section <A HREF="#s:names">6.3</A>).</P><P>However, before referencing another compilation unit, an
implementation of that unit must be present in memory.
At start-up, the toplevel system contains implementations for all the
modules in the the standard library. Implementations for user modules
can be entered with the <TT>#load</TT> directive described above. Referencing
a unit for which no implementation has been provided
results in the error &#X201C;Reference to undefined global &#X2018;&#X2026;&#X2019; &#X201D;.</P><P>Note that entering <TT>open </TT><I>Mod</I> merely accesses the compiled
interface (<TT>.cmi</TT> file) for <I>Mod</I>, but does not load the
implementation of <I>Mod</I>, and does not cause any error if no
implementation of <I>Mod</I> has been loaded. The error 
&#X201C;reference to undefined global <I>Mod</I>&#X201D; will occur only when
executing a value or module definition that refers to <I>Mod</I>.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc123">9.4</A>  Common errors</H2><!--SEC END --><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B>Cannot find file <I>filename</I></B></DT><DD CLASS="dd-description">
The named file could not be found in the current directory, nor in the
directories of the search path. <P>If <I>filename</I> has the format <I>mod</I><TT>.cmi</TT>, this
means you have referenced the compilation unit <I>mod</I>, but its
compiled interface could not be found. Fix: compile <I>mod</I><TT>.mli</TT> or
<I>mod</I><TT>.ml</TT> first, to create the compiled interface <I>mod</I><TT>.cmi</TT>.</P><P>If <I>filename</I> has the format <I>mod</I><TT>.cmo</TT>, this
means you are trying to load with <TT>#load</TT> a bytecode object file that
does not exist yet. Fix: compile <I>mod</I><TT>.ml</TT> first.</P><P>If your program spans several directories, this error can also appear
because you haven&#X2019;t specified the directories to look into. Fix: use
the <TT>#directory</TT> directive to add the correct directories to the
search path.</P></DD><DT CLASS="dt-description"><B>This expression has type <I>t</I><SUB>1</SUB>, but is used with type <I>t</I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
See section <A HREF="#s:comp-errors">8.4</A>.</DD><DT CLASS="dt-description"><B>Reference to undefined global <I>mod</I></B></DT><DD CLASS="dd-description">
You have neglected to load in memory an implementation for a module
with <TT>#load</TT>. See section <A HREF="#s:toplevel-modules">9.3</A> above.</DD></DL><!--TOC section Building custom toplevel systems: <TT>ocamlmktop</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc124">9.5</A>  Building custom toplevel systems: <TT>ocamlmktop</TT></H2><!--SEC END --><P>The <TT>ocamlmktop</TT> command builds OCaml toplevels that
contain user code preloaded at start-up. </P><P>The <TT>ocamlmktop</TT> command takes as argument a set of <TT>.cmo</TT> and <TT>.cma</TT>
files, and links them with the object files that implement the OCaml toplevel.
The typical use is:
</P><PRE CLASS="verbatim">        ocamlmktop -o mytoplevel foo.cmo bar.cmo gee.cmo
</PRE><P>This creates the bytecode file <TT>mytoplevel</TT>, containing the OCaml toplevel
system, plus the code from the three <TT>.cmo</TT>
files. This toplevel is directly executable and is started by:
</P><PRE CLASS="verbatim">        ./mytoplevel
</PRE><P>This enters a regular toplevel loop, except that the code from
<TT>foo.cmo</TT>, <TT>bar.cmo</TT> and <TT>gee.cmo</TT> is already loaded in memory, just as
if you had typed:
</P><PRE CLASS="verbatim">        #load "foo.cmo";;
        #load "bar.cmo";;
        #load "gee.cmo";;
</PRE><P>on entrance to the toplevel. The modules <TT>Foo</TT>, <TT>Bar</TT> and <TT>Gee</TT> are
not opened, though; you still have to do
</P><PRE CLASS="verbatim">        open Foo;;
</PRE><P>yourself, if this is what you wish.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc125">9.6</A>  Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamlmktop</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-cclib</TT> <I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the C linker when linking in
&#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter <A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker, when linking in
&#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter <A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description">
Link in &#X201C;custom runtime&#X201D; mode. See the corresponding option for
<TT>ocamlc</TT>, in chapter <A HREF="#c:camlc">8</A>.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled object code files (<TT>.cmo</TT> and <TT>.cma</TT>).</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the toplevel file produced by the linker.
The default is <TT>a.out</TT>.</DD></DL><!--TOC chapter The runtime system (ocamlrun)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc126">Chapter 10</A>  The runtime system (ocamlrun)</H1><!--SEC END --><P> <A NAME="c:runtime"></A>
</P><P>The <TT>ocamlrun</TT> command executes bytecode files produced by the
linking phase of the <TT>ocamlc</TT> command.</P><!--TOC section Overview-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc127">10.1</A>  Overview</H2><!--SEC END --><P>The <TT>ocamlrun</TT> command comprises three main parts: the bytecode
interpreter, that actually executes bytecode files; the memory
allocator and garbage collector; and a set of C functions that
implement primitive operations such as input/output.</P><P>The usage for <TT>ocamlrun</TT> is:
</P><PRE>
        ocamlrun <I>options bytecode-executable arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
The first non-option argument is taken to be the name of the file
containing the executable bytecode. (That file is searched in the
executable path as well as in the current directory.) The remaining
arguments are passed to the Caml program, in the string array
<TT>Sys.argv</TT>. Element 0 of this array is the name of the
bytecode executable file; elements 1 to <I>n</I> are the remaining
arguments <I>arg</I><SUB>1</SUB> to <I>arg<SUB>n</SUB></I>.</P><P>As mentioned in chapter <A HREF="#c:camlc">8</A>, the bytecode executable files
produced by the <TT>ocamlc</TT> command are self-executable, and manage to
launch the <TT>ocamlrun</TT> command on themselves automatically. That is,
assuming <TT>caml.out</TT> is a bytecode executable file,
</P><PRE>
        caml.out <I>arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
works exactly as
</P><PRE>
        ocamlrun caml.out <I>arg</I><SUB>1</SUB> ... <I>arg<SUB>n</SUB></I>
</PRE><P>
Notice that it is not possible to pass options to <TT>ocamlrun</TT> when
invoking <TT>caml.out</TT> directly.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
Under several versions of Windows, bytecode executable files are
self-executable only if their name ends in <TT>.exe</TT>. It is recommended
to always give <TT>.exe</TT> names to bytecode executables, e.g. compile
with <TT>ocamlc -o myprog.exe ...</TT> rather than <TT>ocamlc -o myprog ...</TT>.
</BLOCKQUOTE><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">10.2</A>  Options</H2><!--SEC END --><P> <A NAME="ocamlrun-options"></A></P><P>The following command-line options are recognized by <TT>ocamlrun</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-b</B></TT></DT><DD CLASS="dd-description">
When the program aborts due to an uncaught exception, print a detailed
&#X201C;back trace&#X201D; of the execution, showing where the exception was
raised and which function calls were outstanding at this point. The
back trace is printed only if the bytecode executable contains
debugging information, i.e. was compiled and linked with the <TT>-g</TT>
option to <TT>ocamlc</TT> set. This is equivalent to setting the <TT>b</TT> flag
in the <TT>OCAMLRUNPARAM</TT> environment variable (see below).
</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Search the directory <I>dir</I> for dynamically-loaded libraries,
in addition to the standard search path (see
section <A HREF="#s-ocamlrun-dllpath">10.3</A>).
</DD><DT CLASS="dt-description"><TT><B>-p</B></TT></DT><DD CLASS="dd-description">
Print the names of the primitives known to this version of
<TT>ocamlrun</TT> and exit.
</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description"> 
Direct the memory manager to print some progress messages on
standard error. This is equivalent to setting <TT>v=63</TT> in the
<TT>OCAMLRUNPARAM</TT> environment variable (see below).
</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description"> 
Print version string and exit.
</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description"> 
Print short version number and exit.</DD></DL><P>The following environment variables are also consulted:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>CAML_LD_LIBRARY_PATH</TT></B></DT><DD CLASS="dd-description"> Additional directories to search for
dynamically-loaded libraries (see section <A HREF="#s-ocamlrun-dllpath">10.3</A>).</DD><DT CLASS="dt-description"><TT><B>OCAMLLIB</B></TT></DT><DD CLASS="dd-description"> The directory containing the OCaml standard
library. (If <TT>OCAMLLIB</TT> is not set, <TT>CAMLLIB</TT> will be used instead.)
Used to locate the <TT>ld.conf</TT> configuration file for
dynamic loading (see section <A HREF="#s-ocamlrun-dllpath">10.3</A>). If not set,
default to the library directory specified when compiling OCaml.</DD><DT CLASS="dt-description"><TT><B>OCAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> Set the runtime system options 
and garbage collection parameters.
(If <TT>OCAMLRUNPARAM</TT> is not set, <TT>CAMLRUNPARAM</TT> will be used instead.)
This variable must be a sequence of parameter specifications.
A parameter specification is an option letter followed by an <TT>=</TT>
sign, a decimal number (or an hexadecimal number prefixed by <TT>0x</TT>),
and an optional multiplier. There are
nine options, six of which correspond to the fields of the
<TT>control</TT> record documented in 
<A HREF="libref/Gc.html">Module <TT>Gc</TT></A>.
<DL CLASS="description"><DT CLASS="dt-description">
<B>b</B></DT><DD CLASS="dd-description"> (backtrace) Trigger the printing of a stack backtrace 
when an uncaught exception aborts the program.
This option takes no argument.
</DD><DT CLASS="dt-description"><B>p</B></DT><DD CLASS="dd-description"> (parser trace) Turn on debugging support for
<TT>ocamlyacc</TT>-generated parsers. When this option is on,
the pushdown automaton that executes the parsers prints a
trace of its actions. This option takes no argument.
</DD><DT CLASS="dt-description"><B>s</B></DT><DD CLASS="dd-description"> (<TT>minor_heap_size</TT>) Size of the minor heap. (in words)
</DD><DT CLASS="dt-description"><B>i</B></DT><DD CLASS="dd-description"> (<TT>major_heap_increment</TT>) Default size increment for the
major heap. (in words)
</DD><DT CLASS="dt-description"><B>o</B></DT><DD CLASS="dd-description"> (<TT>space_overhead</TT>) The major GC speed setting.
</DD><DT CLASS="dt-description"><B>O</B></DT><DD CLASS="dd-description"> (<TT>max_overhead</TT>) The heap compaction trigger setting.
</DD><DT CLASS="dt-description"><B>v</B></DT><DD CLASS="dd-description"> (<TT>verbose</TT>) What GC messages to print to stderr. This
is a sum of values selected from the following:
<DL CLASS="description"><DT CLASS="dt-description">
<B>1 (= 0x001)</B></DT><DD CLASS="dd-description"> Start of major GC cycle.
</DD><DT CLASS="dt-description"><B>2 (= 0x002)</B></DT><DD CLASS="dd-description"> Minor collection and major GC slice.
</DD><DT CLASS="dt-description"><B>4 (= 0x004)</B></DT><DD CLASS="dd-description"> Growing and shrinking of the heap.
</DD><DT CLASS="dt-description"><B>8 (= 0x008)</B></DT><DD CLASS="dd-description"> Resizing of stacks and memory manager tables.
</DD><DT CLASS="dt-description"><B>16 (= 0x010)</B></DT><DD CLASS="dd-description"> Heap compaction.
</DD><DT CLASS="dt-description"><B>32 (= 0x020)</B></DT><DD CLASS="dd-description"> Change of GC parameters.
</DD><DT CLASS="dt-description"><B>64 (= 0x040)</B></DT><DD CLASS="dd-description"> Computation of major GC slice size.
</DD><DT CLASS="dt-description"><B>128 (= 0x080)</B></DT><DD CLASS="dd-description"> Calling of finalisation functions
</DD><DT CLASS="dt-description"><B>256 (= 0x100)</B></DT><DD CLASS="dd-description"> Startup messages (loading the bytecode
executable file, resolving shared libraries).
</DD></DL>
</DD><DT CLASS="dt-description"><B>l</B></DT><DD CLASS="dd-description"> (<TT>stack_limit</TT>) The limit (in words) of the stack size.
</DD><DT CLASS="dt-description"><B>h</B></DT><DD CLASS="dd-description"> The initial size of the major heap (in words).
</DD></DL>
The multiplier is <TT>k</TT>, <TT>M</TT>, or <TT>G</TT>, for multiplication by 2<SUP>10</SUP>,
2<SUP>20</SUP>, and 2<SUP>30</SUP> respectively.
For example, on a 32-bit machine, under <TT>bash</TT> the command
<PRE>
        export OCAMLRUNPARAM=&#X2019;b,s=256k,v=0x015&#X2019;
</PRE>
tells a subsequent <TT>ocamlrun</TT> to print backtraces for uncaught exceptions,
set its initial minor heap size to 1 megabyte and
print a message at the start of each major GC cycle, when the heap
size changes, and when compaction is triggered.</DD><DT CLASS="dt-description"><TT><B>CAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> If <TT>OCAMLRUNPARAM</TT> is not found in the
environment, then <TT>CAMLRUNPARAM</TT> will be used instead. If
<TT>CAMLRUNPARAM</TT> is not found, then the default values will be used.</DD><DT CLASS="dt-description"><TT><B>PATH</B></TT></DT><DD CLASS="dd-description"> List of directories searched to find the bytecode
executable file.
</DD></DL><!--TOC section Dynamic loading of shared libraries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">10.3</A>  Dynamic loading of shared libraries</H2><!--SEC END --><P> <A NAME="s-ocamlrun-dllpath"></A></P><P>On platforms that support dynamic loading, <TT>ocamlrun</TT> can link
dynamically with C shared libraries (DLLs) providing additional C primitives
beyond those provided by the standard runtime system. The names for
these libraries are provided at link time as described in
section <A HREF="#dynlink-c-code">18.1.4</A>), and recorded in the bytecode executable
file; <TT>ocamlrun</TT>, then, locates these libraries and resolves references
to their primitives when the bytecode executable program starts.</P><P>The <TT>ocamlrun</TT> command searches shared libraries in the following
directories, in the order indicated:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Directories specified on the <TT>ocamlrun</TT> command line with the
<TT>-I</TT> option.
</LI><LI CLASS="li-enumerate">Directories specified in the <TT>CAML_LD_LIBRARY_PATH</TT> environment
variable.
</LI><LI CLASS="li-enumerate">Directories specified at link-time via the <TT>-dllpath</TT> option to
<TT>ocamlc</TT>. (These directories are recorded in the bytecode executable
file.)
</LI><LI CLASS="li-enumerate">Directories specified in the file <TT>ld.conf</TT>. This file resides
in the OCaml standard library directory, and lists directory
names (one per line) to be searched. Typically, it contains only one
line naming the <TT>stublibs</TT> subdirectory of the OCaml standard
library directory. Users can add there the names of other directories
containing frequently-used shared libraries; however, for consistency
of installation, we recommend that shared libraries are installed
directly in the system <TT>stublibs</TT> directory, rather than adding lines
to the <TT>ld.conf</TT> file.
</LI><LI CLASS="li-enumerate">Default directories searched by the system dynamic loader.
Under Unix, these generally include <TT>/lib</TT> and <TT>/usr/lib</TT>, plus the
directories listed in the file <TT>/etc/ld.so.conf</TT> and the environment
variable <TT>LD_LIBRARY_PATH</TT>. Under Windows, these include the Windows
system directories, plus the directories listed in the <TT>PATH</TT>
environment variable.
</LI></OL><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">10.4</A>  Common errors</H2><!--SEC END --><P>This section describes and explains the most frequently encountered
error messages.</P><DL CLASS="description"><DT CLASS="dt-description"><B><I>filename</I><TT>: no such file or directory</TT></B></DT><DD CLASS="dd-description">
If <I>filename</I> is the name of a self-executable bytecode file, this
means that either that file does not exist, or that it failed to run
the <TT>ocamlrun</TT> bytecode interpreter on itself. The second possibility
indicates that OCaml has not been properly installed on your
system.</DD><DT CLASS="dt-description"><TT><B>Cannot exec ocamlrun</B></TT></DT><DD CLASS="dd-description">
(When launching a self-executable bytecode file.) The <TT>ocamlrun</TT>
could not be found in the executable path. Check that OCaml
has been properly installed on your system.</DD><DT CLASS="dt-description"><TT><B>Cannot find the bytecode file</B></TT></DT><DD CLASS="dd-description">
The file that <TT>ocamlrun</TT> is trying to execute (e.g. the file given as
first non-option argument to <TT>ocamlrun</TT>) either does not exist, or is
not a valid executable bytecode file.</DD><DT CLASS="dt-description"><TT><B>Truncated bytecode file</B></TT></DT><DD CLASS="dd-description">
The file that <TT>ocamlrun</TT> is trying to execute is not a valid executable
bytecode file. Probably it has been truncated or mangled since
created. Erase and rebuild it.</DD><DT CLASS="dt-description"><TT><B>Uncaught exception</B></TT></DT><DD CLASS="dd-description">
The program being executed contains a &#X201C;stray&#X201D; exception. That is,
it raises an exception at some point, and this exception is never
caught. This causes immediate termination of the program. The name of
the exception is printed, along with its string and integer arguments
(arguments of more complex types are not correctly printed).
To locate the context of the uncaught exception, compile the program
with the <TT>-g</TT> option and either run it again under the <TT>ocamldebug</TT>
debugger (see chapter <A HREF="#c:debugger">16</A>), or run it with <TT>ocamlrun -b</TT>
or with the <TT>OCAMLRUNPARAM</TT> environment variable set to <TT>b=1</TT>.</DD><DT CLASS="dt-description"><TT><B>Out of memory</B></TT></DT><DD CLASS="dd-description">
The program being executed requires more memory than available. Either
the program builds excessively large data structures; or the program
contains too many nested function calls, and the stack overflows. In
some cases, your program is perfectly correct, it just requires more
memory than your machine provides. In other cases, the &#X201C;out of
memory&#X201D; message reveals an error in your program: non-terminating
recursive function, allocation of an excessively large array or
string, attempts to build an infinite list or other data structure,
&#X2026;<P>To help you diagnose this error, run your program with the <TT>-v</TT> option
to <TT>ocamlrun</TT>, or with the <TT>OCAMLRUNPARAM</TT> environment variable set to
<TT>v=63</TT>. If it displays lots of &#X201C;<TT>Growing stack</TT>&#X2026;&#X201D;
messages, this is probably a looping recursive function. If it
displays lots of &#X201C;<TT>Growing heap</TT>&#X2026;&#X201D; messages, with the heap size
growing slowly, this is probably an attempt to construct a data
structure with too many (infinitely many?) cells. If it displays few 
&#X201C;<TT>Growing heap</TT>&#X2026;&#X201D; messages, but with a huge increment in the
heap size, this is probably an attempt to build an excessively large
array or string.</P></DD></DL><!--TOC chapter Native-code compilation (ocamlopt)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc131">Chapter 11</A>  Native-code compilation (ocamlopt)</H1><!--SEC END --><P> <A NAME="c:nativecomp"></A>
</P><P>This chapter describes the OCaml high-performance
native-code compiler <TT>ocamlopt</TT>, which compiles Caml source files to
native code object files and link these object files to produce
standalone executables. </P><P>The native-code compiler is only available on certain platforms.
It produces code that runs faster than the bytecode produced by
<TT>ocamlc</TT>, at the cost of increased compilation time and executable code
size. Compatibility with the bytecode compiler is extremely high: the
same source code should run identically when compiled with <TT>ocamlc</TT> and
<TT>ocamlopt</TT>.</P><P>It is not possible to mix native-code object files produced by <TT>ocamlopt</TT>
with bytecode object files produced by <TT>ocamlc</TT>: a program must be
compiled entirely with <TT>ocamlopt</TT> or entirely with <TT>ocamlc</TT>. Native-code
object files produced by <TT>ocamlopt</TT> cannot be loaded in the toplevel
system <TT>ocaml</TT>.</P><!--TOC section Overview of the compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc132">11.1</A>  Overview of the compiler</H2><!--SEC END --><P>The <TT>ocamlopt</TT> command has a command-line interface very close to that
of <TT>ocamlc</TT>. It accepts the same types of arguments, and processes them
sequentially:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arguments ending in <TT>.mli</TT> are taken to be source files for
compilation unit interfaces. Interfaces specify the names exported by
compilation units: they declare value names with their types, define
public data types, declare abstract data types, and so on. From the
file <I>x</I><TT>.mli</TT>, the <TT>ocamlopt</TT> compiler produces a compiled interface
in the file <I>x</I><TT>.cmi</TT>. The interface produced is identical to that
produced by the bytecode compiler <TT>ocamlc</TT>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.ml</TT> are taken to be source files for compilation
unit implementations. Implementations provide definitions for the
names exported by the unit, and also contain expressions to be
evaluated for their side-effects. From the file <I>x</I><TT>.ml</TT>, the <TT>ocamlopt</TT>
compiler produces two files: <I>x</I><TT>.o</TT>, containing native object code,
and <I>x</I><TT>.cmx</TT>, containing extra information for linking and
optimization of the clients of the unit. The compiled implementation
should always be referred to under the name <I>x</I><TT>.cmx</TT> (when given
a <TT>.o</TT> or <TT>.obj</TT> file, <TT>ocamlopt</TT> assumes that it contains code compiled from C,
not from Caml).<P>The implementation is checked against the interface file <I>x</I><TT>.mli</TT>
(if it exists) as described in the manual for <TT>ocamlc</TT>
(chapter <A HREF="#c:camlc">8</A>).</P></LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmx</TT> are taken to be compiled object code. These
files are linked together, along with the object files obtained
by compiling <TT>.ml</TT> arguments (if any), and the Caml standard
library, to produce a native-code executable program. The order in
which <TT>.cmx</TT> and <TT>.ml</TT> arguments are presented on the command line is
relevant: compilation units are initialized in that order at
run-time, and it is a link-time error to use a component of a unit
before having initialized it. Hence, a given <I>x</I><TT>.cmx</TT> file must come
before all <TT>.cmx</TT> files that refer to the unit <I>x</I>.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.cmxa</TT> are taken to be libraries of object code.
Such a library packs in two files (<I>lib</I><TT>.cmxa</TT> and <I>lib</I><TT>.a</TT>/<TT>.lib</TT>)
a set of object files (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files). Libraries are build with
<TT>ocamlopt -a</TT> (see the description of the <TT>-a</TT> option below). The object
files contained in the library are linked as regular <TT>.cmx</TT> files (see
above), in the order specified when the library was built. The only
difference is that if an object file contained in a library is not
referenced anywhere in the program, then it is not linked in.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.c</TT> are passed to the C compiler, which generates
a <TT>.o</TT>/<TT>.obj</TT> object file. This object file is linked with the program.</LI><LI CLASS="li-itemize">Arguments ending in <TT>.o</TT>, <TT>.a</TT> or <TT>.so</TT> (<TT>.obj</TT>, <TT>.lib</TT> and <TT>.dll</TT>
under Windows) are assumed to be C object files and
libraries. They are linked with the program.</LI></UL><P>The output of the linking phase is a regular Unix or Windows
executable file. It does not need <TT>ocamlrun</TT> to run.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc133">11.2</A>  Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamlopt</TT>.
The options <TT>-pack</TT>, <TT>-a</TT>, <TT>-shared</TT>, <TT>-c</TT> and <TT>-output-obj</TT> are mutually exclusive.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-a</B></TT></DT><DD CLASS="dd-description">
Build a library (<TT>.cmxa</TT> and <TT>.a</TT>/<TT>.lib</TT> files) with the object files
(<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) given on the command line, instead of
linking them into an executable file. The name of the library must be
set with the <TT>-o</TT> option.<P>If <TT>-cclib</TT> or <TT>-ccopt</TT> options are passed on the command
line, these options are stored in the resulting <TT>.cmxa</TT> library. Then,
linking with this library automatically adds back the
<TT>-cclib</TT> and <TT>-ccopt</TT> options as if they had been provided on the
command line, unless the <TT>-noautolink</TT> option is given.</P></DD><DT CLASS="dt-description"><TT><B>-annot</B></TT></DT><DD CLASS="dd-description">
Dump detailed information about the compilation (types, bindings,
tail-calls, etc). The information for file <I>src</I><TT>.ml</TT>
is put into file <I>src</I><TT>.annot</TT>. In case of a type error, dump
all the information inferred by the type-checker before the error.
The <I>src</I><TT>.annot</TT> file can be used with the emacs commands given in
<TT>emacs/caml-types.el</TT> to display types and other annotations
interactively.</DD><DT CLASS="dt-description"><TT><B>-c</B></TT></DT><DD CLASS="dd-description">
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.</DD><DT CLASS="dt-description"><B><TT>-cc</TT> <I>ccomp</I></B></DT><DD CLASS="dd-description">
Use <I>ccomp</I> as the C linker called to build the final executable
and as the C compiler for compiling <TT>.c</TT> source files.</DD><DT CLASS="dt-description"><B><TT>-cclib</TT> <TT>-l</TT><I>libname</I></B></DT><DD CLASS="dd-description">
Pass the <TT>-l</TT><I>libname</I> option to the linker. This causes the given
C library to be linked with the program.</DD><DT CLASS="dt-description"><B><TT>-ccopt</TT> <I>option</I></B></DT><DD CLASS="dd-description">
Pass the given option to the C compiler and linker. For instance,
<TT>-ccopt -L</TT><I>dir</I> causes the C linker to search for C libraries in
directory <I>dir</I>.</DD><DT CLASS="dt-description"><TT><B>-compact</B></TT></DT><DD CLASS="dd-description">
Optimize the produced code for space rather than for time. This
results in slightly smaller but slightly slower programs. The default is to
optimize for speed.</DD><DT CLASS="dt-description"><TT><B>-config</B></TT></DT><DD CLASS="dd-description">
Print the version number of <TT>ocamlopt</TT> and a detailed summary of its
configuration, then exit.</DD><DT CLASS="dt-description"><B><TT>-for-pack</TT> <I>module-path</I></B></DT><DD CLASS="dd-description">
Generate an object file (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) that can later be included
as a sub-module (with the given access path) of a compilation unit
constructed with <TT>-pack</TT>. For instance, <TT>ocamlopt -for-pack P -c A.ml</TT>
will generate <TT>a.cmx</TT> and <TT>a.o</TT> files that can later be used with
<TT>ocamlopt -pack -o P.cmx a.cmx</TT>.</DD><DT CLASS="dt-description"><TT><B>-g</B></TT></DT><DD CLASS="dd-description">
Add debugging information while compiling and linking. This option is
required in order to produce stack backtraces when
the program terminates on an uncaught exception (see
section <A HREF="#ocamlrun-options">10.2</A>).</DD><DT CLASS="dt-description"><TT><B>-i</B></TT></DT><DD CLASS="dd-description">
Cause the compiler to print all defined names (with their inferred
types or their definitions) when compiling an implementation (<TT>.ml</TT>
file). No compiled files (<TT>.cmo</TT> and <TT>.cmi</TT> files) are produced.
This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of interfaces, it
can help in writing an explicit interface (<TT>.mli</TT> file) for a file:
just redirect the standard output of the compiler to a <TT>.mli</TT> file,
and edit that file to remove all declarations of unexported names.</DD><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
compiled interface files (<TT>.cmi</TT>), compiled object code files
(<TT>.cmx</TT>), and libraries (<TT>.cmxa</TT>). By default, the current directory
is searched first, then the standard library directory. Directories
added with <TT>-I</TT> are searched after the current directory, in the order
in which they were given on the command line, but before the standard
library directory.<P>If the given directory starts with <TT>+</TT>, it is taken relative to the
standard library directory. For instance, <TT>-I +labltk</TT> adds the
subdirectory <TT>labltk</TT> of the standard library to the search path.</P></DD><DT CLASS="dt-description"><B><TT>-inline</TT> <I>n</I></B></DT><DD CLASS="dd-description">
Set aggressiveness of inlining to <I>n</I>, where <I>n</I> is a positive
integer. Specifying <TT>-inline 0</TT> prevents all functions from being
inlined, except those whose body is smaller than the call site. Thus,
inlining causes no expansion in code size. The default aggressiveness,
<TT>-inline 1</TT>, allows slightly larger functions to be inlined, resulting
in a slight expansion in code size. Higher values for the <TT>-inline</TT>
option cause larger and larger functions to become candidate for
inlining, but can result in a serious increase in code size.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Compile the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf-suffix</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Recognize file names ending with <I>string</I> as interface files
(instead of the default <TT>.mli</TT>).</DD><DT CLASS="dt-description"><TT><B>-labels</B></TT></DT><DD CLASS="dd-description">
Labels are not ignored in types, labels may be used in applications,
and labelled parameters can be given in any order. This is the default.</DD><DT CLASS="dt-description"><TT><B>-linkall</B></TT></DT><DD CLASS="dd-description">
Force all modules contained in libraries to be linked in. If this
flag is not given, unreferenced modules are not linked in. When
building a library (<TT>-a</TT> flag), setting the <TT>-linkall</TT> flag forces all
subsequent links of programs involving that library to link all the
modules contained in the library.</DD><DT CLASS="dt-description"><TT><B>-noassert</B></TT></DT><DD CLASS="dd-description">
Do not compile assertion checks. Note that the special form
<TT>assert false</TT> is always compiled because it is typed specially.
This flag has no effect when linking already-compiled files.</DD><DT CLASS="dt-description"><TT><B>-noautolink</B></TT></DT><DD CLASS="dd-description">
When linking <TT>.cmxa</TT> libraries, ignore <TT>-cclib</TT> and <TT>-ccopt</TT>
options potentially contained in the libraries (if these options were
given when building the libraries). This can be useful if a library
contains incorrect specifications of C libraries or C options; in this
case, during linking, set <TT>-noautolink</TT> and pass the correct C
libraries and options on the command line.</DD><DT CLASS="dt-description"><TT><B>-nodynlink</B></TT></DT><DD CLASS="dd-description">
Allow the compiler to use some optimizations that are valid only for code
that is never dynlinked.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>exec-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by the linker. The
default output name is <TT>a.out</TT> under Unix and <TT>camlprog.exe</TT> under
Windows. If the <TT>-a</TT> option is given, specify the name of the library
produced. If the <TT>-pack</TT> option is given, specify the name of the
packed object file produced. If the <TT>-output-obj</TT> option is given,
specify the name of the output file produced. If the <TT>-shared</TT> option
is given, specify the name of plugin file produced.</DD><DT CLASS="dt-description"><TT><B>-output-obj</B></TT></DT><DD CLASS="dd-description">
Cause the linker to produce a C object file instead of an executable
file. This is useful to wrap Caml code as a C library,
callable from any C program. See chapter <A HREF="#c:intf-c">18</A>,
section <A HREF="#s:embedded-code">18.7.5</A>. The name of the output object file is
<TT>camlprog.o</TT> by default; it can be set with the <TT>-o</TT> option.
This option can also be used to produce a compiled shared/dynamic
library (<TT>.so</TT> extension, <TT>.dll</TT> under Windows).</DD><DT CLASS="dt-description"><TT><B>-p</B></TT></DT><DD CLASS="dd-description">
Generate extra code to write profile information when the program is
executed. The profile information can then be examined with the
analysis program <TT>gprof</TT>. (See chapter <A HREF="#c:profiler">17</A> for more
information on profiling.) The <TT>-p</TT> option must be given both at
compile-time and at link-time. Linking object files not compiled with
<TT>-p</TT> is possible, but results in less precise profiling.<BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>   See the Unix manual page for <TT>gprof(1)</TT> for more
information about the profiles.<P>Full support for <TT>gprof</TT> is only available for certain platforms
(currently: Intel x86/Linux and Alpha/Digital Unix).
On other platforms, the <TT>-p</TT> option will result in a less precise
profile (no call graph information, only a time profile).
</P></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
The <TT>-p</TT> option does not work under Windows.
</BLOCKQUOTE></DD><DT CLASS="dt-description"><TT><B>-pack</B></TT></DT><DD CLASS="dd-description">
Build an object file (<TT>.cmx</TT> and <TT>.o</TT>/<TT>.obj</TT> files) and its associated compiled
interface (<TT>.cmi</TT>) that combines the <TT>.cmx</TT> object
files given on the command line, making them appear as sub-modules of
the output <TT>.cmx</TT> file. The name of the output <TT>.cmx</TT> file must be
given with the <TT>-o</TT> option. For instance,
<PRE CLASS="verbatim">        ocamlopt -pack -o P.cmx A.cmx B.cmx C.cmx
</PRE>generates compiled files <TT>P.cmx</TT>, <TT>P.o</TT> and <TT>P.cmi</TT> describing a
compilation unit having three sub-modules <TT>A</TT>, <TT>B</TT> and <TT>C</TT>,
corresponding to the contents of the object files <TT>A.cmx</TT>, <TT>B.cmx</TT> and
<TT>C.cmx</TT>. These contents can be referenced as <TT>P.A</TT>, <TT>P.B</TT> and <TT>P.C</TT>
in the remainder of the program.<P>The <TT>.cmx</TT> object files being combined must have been compiled with
the appropriate <TT>-for-pack</TT> option. In the example above,
<TT>A.cmx</TT>, <TT>B.cmx</TT> and <TT>C.cmx</TT> must have been compiled with
<TT>ocamlopt -for-pack P</TT>.</P><P>Multiple levels of packing can be achieved by combining <TT>-pack</TT> with
<TT>-for-pack</TT>. Consider the following example:
</P><PRE CLASS="verbatim">        ocamlopt -for-pack P.Q -c A.ml
        ocamlopt -pack -o Q.cmx -for-pack P A.cmx
        ocamlopt -for-pack P -c B.ml
        ocamlopt -pack -o P.cmx Q.cmx B.cmx
</PRE><P>The resulting <TT>P.cmx</TT> object file has sub-modules <TT>P.Q</TT>, <TT>P.Q.A</TT>
and <TT>P.B</TT>.</P></DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause the compiler to call the given <I>command</I> as a preprocessor
for each source file. The output of <I>command</I> is redirected to
an intermediate file, which is compiled. If there are no compilation
errors, the intermediate file is deleted afterwards.</DD><DT CLASS="dt-description"><TT><B>-principal</B></TT></DT><DD CLASS="dd-description">
Check information path during type-checking, to make sure that all
types are derived in a principal way. All programs accepted in
<TT>-principal</TT> mode are also accepted in default mode with equivalent
types, but different binary signatures.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported. Note that once you have created an interface using this
flag, you must use it again for all dependencies.</DD><DT CLASS="dt-description"><TT><B>-S</B></TT></DT><DD CLASS="dd-description">
Keep the assembly code produced during the compilation. The assembly
code for the source file <I>x</I><TT>.ml</TT> is saved in the file <I>x</I><TT>.s</TT>.</DD><DT CLASS="dt-description"><TT><B>-shared</B></TT></DT><DD CLASS="dd-description">
Build a plugin (usually <TT>.cmxs</TT>) that can be dynamically loaded with
the <TT>Dynlink</TT> module. The name of the plugin must be
set with the <TT>-o</TT> option. A plugin can include a number of Caml
modules and libraries, and extra native objects (<TT>.o</TT>, <TT>.obj</TT>, <TT>.a</TT>,
<TT>.lib</TT> files). Building native plugins is only supported for some
operating system. Under some systems (currently,
only Linux AMD 64), all the Caml code linked in a plugin must have
been compiled without the <TT>-nodynlink</TT> flag. Some constraints might also
apply to the way the extra native objects have been compiled (under
Linux AMD 64, they must contain only position-independent code).</DD><DT CLASS="dt-description"><TT><B>-thread</B></TT></DT><DD CLASS="dd-description">
Compile or link multithreaded programs, in combination with the
system <TT>threads</TT> library described in chapter <A HREF="#c:threads">24</A>.</DD><DT CLASS="dt-description"><TT><B>-unsafe</B></TT></DT><DD CLASS="dd-description">
Turn bound checking off for array and string accesses (the <TT>v.(i)</TT> and
<TT>s.[i]</TT> constructs). Programs compiled with <TT>-unsafe</TT> are therefore
faster, but unsafe: anything can happen if the program accesses an
array or string outside of its bounds. Additionally, turn off the
check for zero divisor in integer division and modulus operations.
With <TT>-unsafe</TT>, an integer division (or modulus) by zero can halt the
program or continue with an unspecified result instead of raising a
<TT>Division_by_zero</TT> exception.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Print the version number of the compiler and the location of the
standard library directory, then exit.</DD><DT CLASS="dt-description"><TT><B>-verbose</B></TT></DT><DD CLASS="dd-description">
Print all external commands before they are executed, in particular
invocations of the assembler, C compiler, and linker.</DD><DT CLASS="dt-description"><B><TT>-vnum</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description">
Print the version number of the compiler in short form (e.g. <TT>3.11.0</TT>),
then exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable, disable, or mark as errors the warnings specified by the argument
<I>warning-list</I>.
Each warning can be <EM>enabled</EM> or <EM>disabled</EM>, and each warning
can be <EM>marked</EM> or <EM>unmarked</EM>.
If a warning is disabled, it isn&#X2019;t displayed and doesn&#X2019;t affect
compilation in any way (even if it is marked). If a warning is
enabled, it is displayed normally by the compiler whenever the source
code triggers it. If it is enabled and marked, the compiler will stop
with an error after displaying that warning if the source code
triggers it.<P>The <I>warning-list</I> argument is a sequence of warning specifiers,
with no separators between them. A warning specifier is one of the
following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>+</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num</I></B></DT><DD CLASS="dd-description"> Disable warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num</I></B></DT><DD CLASS="dd-description"> Enable and mark warning number <I>num</I>.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Disable warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>num1</I>..<I>num2</I></B></DT><DD CLASS="dd-description"> Enable and mark warnings in the given range.
</DD><DT CLASS="dt-description"><B><TT>+</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>-</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding to
<I>letter</I>. The letter may be uppercase or lowercase.
</DD><DT CLASS="dt-description"><B><TT>@</TT><I>letter</I></B></DT><DD CLASS="dd-description"> Enable and mark the set of warnings
corresponding to <I>letter</I>. The letter may be uppercase or
lowercase.
</DD><DT CLASS="dt-description"><I><B>uppercase-letter</B></I></DT><DD CLASS="dd-description"> Enable the set of warnings corresponding
to <I>uppercase-letter</I>.
</DD><DT CLASS="dt-description"><I><B>lowercase-letter</B></I></DT><DD CLASS="dd-description"> Disable the set of warnings corresponding
to <I>lowercase-letter</I>.
</DD></DL><P>Warning numbers which are out of the range of warnings that are currently
defined are ignored. The warning numbers are as follows.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>1</B></DT><DD CLASS="dd-description"> Suspicious-looking start-of-comment mark.
</DD><DT CLASS="dt-description"><B>2</B></DT><DD CLASS="dd-description"> Suspicious-looking end-of-comment mark.
</DD><DT CLASS="dt-description"><B>3</B></DT><DD CLASS="dd-description"> Deprecated syntax.
</DD><DT CLASS="dt-description"><B>4</B></DT><DD CLASS="dd-description"> Fragile pattern matching: matching that will remain complete even
if additional constructors are added to one of the variant types
matched.
</DD><DT CLASS="dt-description"><B>5</B></DT><DD CLASS="dd-description"> Partially applied function: expression whose result has function
type and is ignored.
</DD><DT CLASS="dt-description"><B>6</B></DT><DD CLASS="dd-description"> Label omitted in function application.
</DD><DT CLASS="dt-description"><B>7</B></DT><DD CLASS="dd-description"> Some methods are overridden in the class where they are defined.
</DD><DT CLASS="dt-description"><B>8</B></DT><DD CLASS="dd-description"> Partial match: missing cases in pattern-matching.
</DD><DT CLASS="dt-description"><B>9</B></DT><DD CLASS="dd-description"> Missing fields in a record pattern.
</DD><DT CLASS="dt-description"><B>10</B></DT><DD CLASS="dd-description"> Expression on the left-hand side of a sequence that doesn&#X2019;t have type
"unit" (and that is not a function, see warning number 5).
</DD><DT CLASS="dt-description"><B>11</B></DT><DD CLASS="dd-description"> Redundant case in a pattern matching (unused match case).
</DD><DT CLASS="dt-description"><B>12</B></DT><DD CLASS="dd-description"> Redundant sub-pattern in a pattern-matching.
</DD><DT CLASS="dt-description"><B>13</B></DT><DD CLASS="dd-description"> Override of an instance variable.
</DD><DT CLASS="dt-description"><B>14</B></DT><DD CLASS="dd-description"> Illegal backslash escape in a string constant.
</DD><DT CLASS="dt-description"><B>15</B></DT><DD CLASS="dd-description"> Private method made public implicitly.
</DD><DT CLASS="dt-description"><B>16</B></DT><DD CLASS="dd-description"> Unerasable optional argument.
</DD><DT CLASS="dt-description"><B>17</B></DT><DD CLASS="dd-description"> Undeclared virtual method.
</DD><DT CLASS="dt-description"><B>18</B></DT><DD CLASS="dd-description"> Non-principal type.
</DD><DT CLASS="dt-description"><B>19</B></DT><DD CLASS="dd-description"> Type without principality.
</DD><DT CLASS="dt-description"><B>20</B></DT><DD CLASS="dd-description"> Unused function argument.
</DD><DT CLASS="dt-description"><B>21</B></DT><DD CLASS="dd-description"> Non-returning statement.
</DD><DT CLASS="dt-description"><B>22</B></DT><DD CLASS="dd-description"> Camlp4 warning.
</DD><DT CLASS="dt-description"><B>23</B></DT><DD CLASS="dd-description"> Useless record "with" clause.
</DD><DT CLASS="dt-description"><B>24</B></DT><DD CLASS="dd-description"> Bad module name: the source file name is not a valid OCaml module name.
</DD><DT CLASS="dt-description"><B>25</B></DT><DD CLASS="dd-description"> Pattern-matching with all clauses guarded. Exhaustiveness cannot be
checked
</DD><DT CLASS="dt-description"><B>26</B></DT><DD CLASS="dd-description"> Suspicious unused variable: unused variable that is bound with "let"
or "as", and doesn&#X2019;t start with an underscore ("_") character.
</DD><DT CLASS="dt-description"><B>27</B></DT><DD CLASS="dd-description"> Innocuous unused variable: unused variable that is not bound with
"let" nor "as", and doesn&#X2019;t start with an underscore ("_")
character.
</DD><DT CLASS="dt-description"><B>28</B></DT><DD CLASS="dd-description"> Wildcard pattern given as argument to a constant constructor.
</DD><DT CLASS="dt-description"><B>29</B></DT><DD CLASS="dd-description"> Unescaped end-of-line in a string constant (non-portable code).
</DD><DT CLASS="dt-description"><B>30</B></DT><DD CLASS="dd-description"> Two labels or constructors of the same name are defined in two
mutually recursive types.

</DD></DL><P>The letters stand for the following sets of warnings. Any letter not
mentioned here corresponds to the empty set.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>A</B></DT><DD CLASS="dd-description"> all warnings
</DD><DT CLASS="dt-description"><B>C</B></DT><DD CLASS="dd-description"> 1, 2
</DD><DT CLASS="dt-description"><B>D</B></DT><DD CLASS="dd-description"> 3
</DD><DT CLASS="dt-description"><B>E</B></DT><DD CLASS="dd-description"> 4
</DD><DT CLASS="dt-description"><B>F</B></DT><DD CLASS="dd-description"> 5
</DD><DT CLASS="dt-description"><B>L</B></DT><DD CLASS="dd-description"> 6
</DD><DT CLASS="dt-description"><B>M</B></DT><DD CLASS="dd-description"> 7
</DD><DT CLASS="dt-description"><B>P</B></DT><DD CLASS="dd-description"> 8
</DD><DT CLASS="dt-description"><B>R</B></DT><DD CLASS="dd-description"> 9
</DD><DT CLASS="dt-description"><B>S</B></DT><DD CLASS="dd-description"> 10
</DD><DT CLASS="dt-description"><B>U</B></DT><DD CLASS="dd-description"> 11, 12
</DD><DT CLASS="dt-description"><B>V</B></DT><DD CLASS="dd-description"> 13
</DD><DT CLASS="dt-description"><B>X</B></DT><DD CLASS="dd-description"> 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
</DD><DT CLASS="dt-description"><B>Y</B></DT><DD CLASS="dd-description"> 26
</DD><DT CLASS="dt-description"><B>Z</B></DT><DD CLASS="dd-description"> 27
</DD></DL><P>The default setting is <TT>-w +a-4-6-7-9-27..29</TT>.
Note that warnings 5 and 10 are not always triggered, depending on
the internals of the type checker.</P></DD><DT CLASS="dt-description"><B><TT>-warn-error</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Mark as errors the warnings specified in the argument <I>warning-list</I>.
The compiler will stop with an error when one of these warnings is
emitted. The <I>warning-list</I> has the same meaning as for
the <TT>-w</TT> option: a <TT>+</TT> sign (or an uppercase letter) turns the
corresponding warnings into errors, a <TT>-</TT>
sign (or a lowercase letter) turns them back into warnings, and a
<TT>@</TT> sign both enables and marks the corresponding warnings.<P>Note: it is not recommended to use warning sets (i.e. letters) as
arguments to <TT>-warn-error</TT>
in production code, because this can break your build when future versions
of OCaml add some new warnings.</P><P>The default setting is <TT>-warn-error -a</TT>
(none of the warnings is treated as an error).</P></DD><DT CLASS="dt-description"><TT><B>-where</B></TT></DT><DD CLASS="dd-description">
Print the location of the standard library, then exit.</DD><DT CLASS="dt-description"><B><TT>-</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as a file name, even if it starts with a dash (-)
character.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC paragraph Options for the IA32 architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the IA32 architecture</H5><!--SEC END --><P>
The IA32 code generator (Intel Pentium, AMD Athlon) supports the
following additional option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-ffast-math</B></TT></DT><DD CLASS="dd-description"> Use the IA32 instructions to compute
trigonometric and exponential functions, instead of calling the
corresponding library routines. The functions affected are:
<TT>atan</TT>, <TT>atan2</TT>, <TT>cos</TT>, <TT>log</TT>, <TT>log10</TT>, <TT>sin</TT>, <TT>sqrt</TT> and <TT>tan</TT>.
The resulting code runs faster, but the range of supported arguments
and the precision of the result can be reduced. In particular,
trigonometric operations <TT>cos</TT>, <TT>sin</TT>, <TT>tan</TT> have their range reduced to
[&#X2212;2<SUP>64</SUP>, 2<SUP>64</SUP>].
</DD></DL><!--TOC paragraph Options for the AMD64 architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the AMD64 architecture</H5><!--SEC END --><P>
The AMD64 code generator (64-bit versions of Intel Pentium and AMD
Athlon) supports the following additional options:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-fPIC</B></TT></DT><DD CLASS="dd-description"> Generate position-independent machine code. This is
the default.
</DD><DT CLASS="dt-description"><TT><B>-fno-PIC</B></TT></DT><DD CLASS="dd-description"> Generate position-dependent machine code.
</DD></DL><!--TOC paragraph Options for the Sparc architecture-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Options for the Sparc architecture</H5><!--SEC END --><P>
The Sparc code generator supports the following additional options:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-march=v8</B></TT></DT><DD CLASS="dd-description"> Generate SPARC version 8 code.
</DD><DT CLASS="dt-description"><TT><B>-march=v9</B></TT></DT><DD CLASS="dd-description"> Generate SPARC version 9 code.
</DD></DL><P>
The default is to generate code for SPARC version 7, which runs on all
SPARC processors.</P><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc134">11.3</A>  Common errors</H2><!--SEC END --><P>The error messages are almost identical to those of <TT>ocamlc</TT>.
See section <A HREF="#s:comp-errors">8.4</A>.</P><!--TOC section Running executables produced by ocamlopt-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc135">11.4</A>  Running executables produced by ocamlopt</H2><!--SEC END --><P>Executables generated by <TT>ocamlopt</TT> are native, stand-alone executable
files that can be invoked directly. They do
not depend on the <TT>ocamlrun</TT> bytecode runtime system nor on
dynamically-loaded C/Caml stub libraries.</P><P>During execution of an <TT>ocamlopt</TT>-generated executable,
the following environment variables are also consulted:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>OCAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> Same usage as in <TT>ocamlrun</TT>
(see section <A HREF="#ocamlrun-options">10.2</A>), except that option <TT>l</TT>
is ignored (the operating system&#X2019;s stack size limit
is used instead).
</DD><DT CLASS="dt-description"><TT><B>CAMLRUNPARAM</B></TT></DT><DD CLASS="dd-description"> If <TT>OCAMLRUNPARAM</TT> is not found in the
environment, then <TT>CAMLRUNPARAM</TT> will be used instead. If
<TT>CAMLRUNPARAM</TT> is not found, then the default values will be used.
</DD></DL><!--TOC section Compatibility with the bytecode compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc136">11.5</A>  Compatibility with the bytecode compiler</H2><!--SEC END --><P>
<A NAME="s:compat-native-bytecode"></A></P><P>This section lists the known incompatibilities between the bytecode
compiler and the native-code compiler. Except on those points, the two
compilers should generate code that behave identically.</P><UL CLASS="itemize"><LI CLASS="li-itemize">Signals are detected only when the program performs an
allocation in the heap. That is, if a signal is delivered while in a
piece of code that does not allocate, its handler will not be called
until the next heap allocation.</LI><LI CLASS="li-itemize">Stack overflow, typically caused by excessively deep recursion, 
is handled in one of the following ways, depending on the
platform used:
<UL CLASS="itemize"><LI CLASS="li-itemize">
By raising a <TT>Stack_overflow</TT> exception, like the bytecode
compiler does. (IA32/Linux, AMD64/Linux, PowerPC/MacOSX, MS Windows
32-bit ports).
</LI><LI CLASS="li-itemize">By aborting the program on a &#X201C;segmentation fault&#X201D; signal.
(All other Unix systems.)
</LI><LI CLASS="li-itemize">By terminating the program silently.
(MS Windows 64 bits).
</LI></UL></LI><LI CLASS="li-itemize">On IA32 processors only (Intel Pentium, AMD Athlon, etc, in
32-bit mode), some intermediate results in floating-point computations
are kept in extended precision rather than being rounded to double
precision like the bytecode compiler always does. Floating-point
results can therefore differ between bytecode and native code; in
general, the results obtained with native code are &#X201C;more exact&#X201D;
(less affected by rounding errors and loss of precision).</LI><LI CLASS="li-itemize">On the Alpha processor only, floating-point operations involving
infinite or denormalized numbers can abort the program on a
&#X201C;floating-point exception&#X201D; signal.</LI></UL><!--TOC chapter Lexer and parser generators (ocamllex, ocamlyacc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc137">Chapter 12</A>  Lexer and parser generators (ocamllex, ocamlyacc)</H1><!--SEC END --><P>
<A NAME="c:ocamlyacc"></A>
</P><P>This chapter describes two program generators: <TT>ocamllex</TT>, that
produces a lexical analyzer from a set of regular expressions with
associated semantic actions, and <TT>ocamlyacc</TT>, that produces a parser
from a grammar with associated semantic actions.</P><P>These program generators are very close to the well-known <TT>lex</TT> and
<TT>yacc</TT> commands that can be found in most C programming environments.
This chapter assumes a working knowledge of <TT>lex</TT> and <TT>yacc</TT>: while
it describes the input syntax for <TT>ocamllex</TT> and <TT>ocamlyacc</TT> and the
main differences with <TT>lex</TT> and <TT>yacc</TT>, it does not explain the basics
of writing a lexer or parser description in <TT>lex</TT> and <TT>yacc</TT>. Readers
unfamiliar with <TT>lex</TT> and <TT>yacc</TT> are referred to &#X201C;Compilers:
principles, techniques, and tools&#X201D; by Aho, Sethi and Ullman
(Addison-Wesley, 1986), or &#X201C;Lex &amp; Yacc&#X201D;, by Levine, Mason and
Brown (O&#X2019;Reilly, 1992).</P><!--TOC section Overview of <TT>ocamllex</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc138">12.1</A>  Overview of <TT>ocamllex</TT></H2><!--SEC END --><P>The <TT>ocamllex</TT> command produces a lexical analyzer from a set of regular
expressions with attached semantic actions, in the style of
<TT>lex</TT>. Assuming the input file is <I>lexer</I><TT>.mll</TT>, executing
</P><PRE>
        ocamllex <I>lexer</I>.mll
</PRE><P>
produces Caml code for a lexical analyzer in file <I>lexer</I><TT>.ml</TT>.
This file defines one lexing function per entry point in the lexer
definition. These functions have the same names as the entry
points. Lexing functions take as argument a lexer buffer, and return
the semantic attribute of the corresponding entry point.</P><P>Lexer buffers are an abstract data type implemented in the standard
library module <TT>Lexing</TT>. The functions <TT>Lexing.from_channel</TT>,
<TT>Lexing.from_string</TT> and <TT>Lexing.from_function</TT> create
lexer buffers that read from an input channel, a character string, or
any reading function, respectively. (See the description of module
<TT>Lexing</TT> in chapter <A HREF="#c:stdlib">20</A>.)</P><P>When used in conjunction with a parser generated by <TT>ocamlyacc</TT>, the
semantic actions compute a value belonging to the type <TT>token</TT> defined
by the generated parsing module. (See the description of <TT>ocamlyacc</TT>
below.)</P><!--TOC subsection Options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc139">12.1.1</A>  Options</H3><!--SEC END --><P>
The following command-line options are recognized by <TT>ocamllex</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><TT><B>-ml</B></TT></DT><DD CLASS="dd-description">
Output code that does not use OCaml&#X2019;s built-in automata
interpreter. Instead, the automaton is encoded by Caml functions.
This option mainly is useful for debugging <TT>ocamllex</TT>, using it for
production lexers is not recommended.</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>output-file</I></B></DT><DD CLASS="dd-description">
Specify the name of the output file produced by <TT>ocamllex</TT>.
The default is the input file name with its extension replaced by <TT>.ml</TT>.</DD><DT CLASS="dt-description"><TT><B>-q</B></TT></DT><DD CLASS="dd-description">
Quiet mode. <TT>ocamllex</TT> normally outputs informational messages
to standard output. They are suppressed if option <TT>-q</TT> is used.</DD><DT CLASS="dt-description"><B><TT>-v</TT> or <TT>-version</TT></B></DT><DD CLASS="dd-description"> 
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description"> 
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Syntax of lexer definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc140">12.2</A>  Syntax of lexer definitions</H2><!--SEC END --><P>The format of lexer definitions is as follows:

</P><PRE>
{ <I>header</I> }
let <I>ident</I> = <I>regexp</I> &#X2026;
rule <I>entrypoint</I> [<I>arg<SUB>1</SUB></I>&#X2026; <I>arg<SUB>n</SUB></I>] =
  parse <I>regexp</I> { <I>action</I> }
      | &#X2026;
      | <I>regexp</I> { <I>action</I> }
and <I>entrypoint</I> [<I>arg<SUB>1</SUB></I>&#X2026; <I>arg<SUB>n</SUB></I>] =
  parse &#X2026;
and &#X2026;
{ <I>trailer</I> }
</PRE><P>
Comments are delimited by <TT>(*</TT> and <TT>*)</TT>, as in Caml.
The <TT>parse</TT> keyword, can be replaced by the <TT>shortest</TT> keyword, with
the semantic consequences explained below.</P><!--TOC subsection Header and trailer-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc141">12.2.1</A>  Header and trailer</H3><!--SEC END --><P>
The <I>header</I> and <I>trailer</I> sections are arbitrary Caml
text enclosed in curly braces. Either or both can be omitted. If
present, the header text is copied as is at the beginning of the
output file and the trailer text at the end. Typically, the
header section contains the <CODE>open</CODE> directives required
by the actions, and possibly some auxiliary functions used in the
actions.</P><!--TOC subsection Naming regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">12.2.2</A>  Naming regular expressions</H3><!--SEC END --><P>Between the header and the entry points, one can give names to
frequently-occurring regular expressions. This is written
<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I>.
In regular expressions that follow this declaration, the identifier
<I>ident</I> can be used as shorthand for <I>regexp</I>.</P><!--TOC subsection Entry points-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc143">12.2.3</A>  Entry points</H3><!--SEC END --><P>The names of the entry points must be valid identifiers for Caml
values (starting with a lowercase letter).
Similarily, the arguments <TT><I>arg<SUB>1</SUB></I>&#X2026;
<I>arg<SUB>n</SUB></I></TT> must be valid identifiers for Caml.
Each entry point becomes a
Caml function that takes <I>n</I>+1 arguments,
the extra implicit last argument being of type <TT>Lexing.lexbuf</TT>.
Characters are read from the <TT>Lexing.lexbuf</TT> argument and matched
against the regular expressions provided in the rule, until a prefix
of the input matches one of the rule. The corresponding action is
then evaluated and returned as the result of the function.</P><P>If several regular expressions match a prefix of the input, the
&#X201C;longest match&#X201D; rule applies: the regular expression that matches
the longest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is selected.</P><P>However, if lexer rules are introduced with the <TT>shortest</TT> keyword in
place of the <TT>parse</TT> keyword, then the &#X201C;shortest match&#X201D; rule applies:
the shortest prefix of the input is selected. In case of tie, the
regular expression that occurs earlier in the rule is still selected.
This feature is not intended for use in ordinary lexical analyzers, it
may facilitate the use of <TT>ocamllex</TT> as a simple text processing tool.</P><!--TOC subsection Regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">12.2.4</A>  Regular expressions</H3><!--SEC END --><P>The regular expressions are in the style of <TT>lex</TT>, with a more
Caml-like syntax.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="regexp"><FONT COLOR=maroon>regexp</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
&#X2026;</TD></TR>
</TABLE></TD></TR>
</TABLE><DL CLASS="description"><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>regular-char</I></FONT> &#X2223;  <I><A HREF="#escape-sequence"><FONT COLOR=maroon>escape-sequence</FONT></A></I> <FONT COLOR=blue><TT>'</TT></FONT></B></DT><DD CLASS="dd-description">
A character constant, with the same syntax as OCaml character
constants. Match the denoted character.</DD><DT CLASS="dt-description"><TT><B>_</B></TT></DT><DD CLASS="dd-description">
(Underscore.) Match any character.</DD><DT CLASS="dt-description"><FONT COLOR=blue><TT><B>eof</B></TT></FONT></DT><DD CLASS="dd-description">
Match the end of the lexer input.<BR>
<B>Note:</B> On some systems, with interactive input, an end-of-file
may be followed by more characters. However, <TT>ocamllex</TT> will not
correctly handle regular expressions that contain <TT>eof</TT> followed by
something else.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>"</TT></FONT> { <I><A HREF="#string-character"><FONT COLOR=maroon>string-character</FONT></A></I> } <FONT COLOR=blue><TT>"</TT></FONT></B></DT><DD CLASS="dd-description">
A string constant, with the same syntax as OCaml string
constants. Match the corresponding sequence of characters.</DD><DT CLASS="dt-description"><FONT COLOR=blue><B><TT>[</TT> <FONT COLOR=maroon><I>character-set</I></FONT> <TT>]</TT></B></FONT></DT><DD CLASS="dd-description">
Match any single character belonging to the given
character set. Valid character sets are: single
character constants <FONT COLOR=blue><TT>'</TT> <FONT COLOR=maroon><I>c</I></FONT> <TT>'</TT></FONT>; ranges of characters
<FONT COLOR=blue><TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>1</SUB> <FONT COLOR=blue><TT>'</TT> <TT>-</TT> <TT>'</TT></FONT> <FONT COLOR=maroon><I>c</I></FONT><SUB>2</SUB> <FONT COLOR=blue><TT>'</TT></FONT> (all characters between <I>c</I><SUB>1</SUB> and <I>c</I><SUB>2</SUB>,
inclusive); and the union of two or more character sets, denoted by
concatenation.</DD><DT CLASS="dt-description"><FONT COLOR=blue><B><TT>[</TT> <TT>^</TT> <FONT COLOR=maroon><I>character-set</I></FONT> <TT>]</TT></B></FONT></DT><DD CLASS="dd-description">
Match any single character not belonging to the given character set.</DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>#</TT></FONT>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(Difference of character sets).
Regular expressions <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> and <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB> must be character sets
defined with <FONT COLOR=blue><TT>[</TT></FONT>&#X2026; <FONT COLOR=blue><TT>]</TT></FONT> (or a a single character expression or
underscore <TT>_</TT>).
Match the difference of the two specified character sets.</DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>*</TT></FONT></B></DT><DD CLASS="dd-description">
(Repetition.) Match the concatenation of zero or more
strings that match <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I>. </DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>+</TT></FONT></B></DT><DD CLASS="dd-description">
(Strict repetition.) Match the concatenation of one or more
strings that match <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>?</TT></FONT></B></DT><DD CLASS="dd-description">
(Option.) Match either the empty string, or a string matching <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT></FONT>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(Alternative.) Match any string that matches either <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> or <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB></B></DT><DD CLASS="dd-description">
(Concatenation.) Match the concatenation of two strings, the first
matching <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB>, the second matching <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB>.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT></B></DT><DD CLASS="dd-description">
Match the same strings as <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I>.</DD><DT CLASS="dt-description"><I><B><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></B></I></DT><DD CLASS="dd-description">
Reference the regular expression bound to <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> by an earlier
<FONT COLOR=blue><TT>let</TT></FONT> <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>=</TT></FONT>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> definition.</DD><DT CLASS="dt-description"><B><I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I></B></DT><DD CLASS="dd-description">
Bind the substring matched by <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> to identifier <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>.
</DD></DL><P>Concerning the precedences of operators, <TT>#</TT> has the highest precedence,
followed by <TT>*</TT>, <TT>+</TT> and <TT>?</TT>,
then concatenation, then <TT>|</TT> (alternation), then <TT>as</TT>.</P><!--TOC subsection Actions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">12.2.5</A>  Actions</H3><!--SEC END --><P>The actions are arbitrary Caml expressions. They are evaluated in
a context where the identifiers defined by using the <TT>as</TT> construct
are bound to subparts of the matched string.
Additionally, <TT>lexbuf</TT> is bound to the current lexer
buffer. Some typical uses for <TT>lexbuf</TT>, in conjunction with the
operations on lexer buffers provided by the <TT>Lexing</TT> standard library
module, are listed below.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>Lexing.lexeme lexbuf</B></TT></DT><DD CLASS="dd-description">
Return the matched string.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_char lexbuf </TT><I>n</I></B></DT><DD CLASS="dd-description">
Return the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT>
character in the matched string. The first character corresponds to <I>n</I> = 0.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_start lexbuf</TT></B></DT><DD CLASS="dd-description">
Return the absolute position in the input text of the beginning of the
matched string (i.e. the offset of the first character of the matched
string). The first character read from the input text has offset 0.</DD><DT CLASS="dt-description"><B><TT>Lexing.lexeme_end lexbuf</TT></B></DT><DD CLASS="dd-description">
Return the absolute position in the input text of the end of the
matched string (i.e. the offset of the first character after the
matched string). The first character read from the input text has
offset 0.</DD><DT CLASS="dt-description"><B><I>entrypoint</I> [<I>exp<SUB>1</SUB></I>&#X2026; <I>exp<SUB>n</SUB></I>] <TT>lexbuf</TT></B></DT><DD CLASS="dd-description">
(Where <I>entrypoint</I> is the name of another entry point in the same
lexer definition.) Recursively call the lexer on the given entry point.
Notice that <TT>lexbuf</TT> is the last argument.
Useful for lexing nested comments, for example.</DD></DL><!--TOC subsection Variables in regular expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">12.2.6</A>  Variables in regular expressions</H3><!--SEC END --><P>
The <TT>as</TT> construct is similar to &#X201C;<EM>groups</EM>&#X201D; as provided by
numerous regular expression packages.
The type of these variables can be <TT>string</TT>, <TT>char</TT>, <TT>string option</TT>
or <TT>char option</TT>.</P><P>We first consider the case of linear patterns, that is the case when
all <TT>as</TT> bound variables are distinct.
In <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I>, the type of <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> normally is <TT>string</TT> (or
<TT>string option</TT>) except
when <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> is a character constant, an underscore, a string
constant of length one, a character set specification, or an
alternation of those. Then, the type of <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> is <TT>char</TT> (or <TT>char option</TT>).
Option types are introduced when overall rule matching does not
imply matching of the bound sub-pattern. This is in particular the
case of <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>)</TT> <TT>?</TT></FONT> and of
<I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>1</SUB> <FONT COLOR=blue><TT>|</TT> <TT>(</TT></FONT>  <I><A HREF="#regexp"><FONT COLOR=maroon>regexp</FONT></A></I><SUB>2</SUB> <FONT COLOR=blue><TT>as</TT></FONT>  <I><A HREF="#ident"><FONT COLOR=maroon>ident</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT>.</P><P>There is no linearity restriction over <TT>as</TT> bound variables.
When a variable is bound more than once, the previous rules are to be
extended as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A variable is a <TT>char</TT> variable when all its occurrences bind
<TT>char</TT> occurrences in the previous sense.
</LI><LI CLASS="li-itemize">A variable is an <TT>option</TT> variable when the overall expression
can be matched without binding this variable.
</LI></UL><P>
For instance, in
<CODE>('a' as x) | ( 'a' (_ as x) )</CODE> the variable <CODE>x</CODE> is of type
<TT>char</TT>, whereas in 
<CODE>("ab" as x) | ( 'a' (_ as x) ? )</CODE> the variable <CODE>x</CODE> is of type
<TT>string option</TT>.</P><P>In some cases, a sucessful match may not yield a unique set of bindings.
For instance the matching of <CODE>aba</CODE> by the regular expression
<CODE>(('a'|"ab") as x) (("ba"|'a') as y)</CODE> may result in binding
either
<CODE>x</CODE> to <CODE>"ab"</CODE> and <CODE>y</CODE> to <CODE>"a"</CODE>, or
<CODE>x</CODE> to <CODE>"a"</CODE> and <CODE>y</CODE> to <CODE>"ba"</CODE>.
The automata produced <TT>ocamllex</TT> on such ambiguous regular
expressions will select one of the possible resulting sets of
bindings.
The selected set of bindings is purposely left unspecified.</P><!--TOC subsection Reserved identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">12.2.7</A>  Reserved identifiers</H3><!--SEC END --><P>All identifiers starting with <TT>__ocaml_lex</TT> are reserved for use by
<TT>ocamllex</TT>; do not use any such identifier in your programs.</P><!--TOC section Overview of <TT>ocamlyacc</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc148">12.3</A>  Overview of <TT>ocamlyacc</TT></H2><!--SEC END --><P>The <TT>ocamlyacc</TT> command produces a parser from a context-free grammar
specification with attached semantic actions, in the style of <TT>yacc</TT>.
Assuming the input file is <I>grammar</I><TT>.mly</TT>, executing
</P><PRE>
        ocamlyacc <I>options grammar</I>.mly
</PRE><P>
produces Caml code for a parser in the file <I>grammar</I><TT>.ml</TT>,
and its interface in file <I>grammar</I><TT>.mli</TT>.</P><P>The generated module defines one parsing function per entry point in
the grammar. These functions have the same names as the entry points.
Parsing functions take as arguments a lexical analyzer (a function
from lexer buffers to tokens) and a lexer buffer, and return the
semantic attribute of the corresponding entry point. Lexical analyzer
functions are usually generated from a lexer specification by the
<TT>ocamllex</TT> program. Lexer buffers are an abstract data type
implemented in the standard library module <TT>Lexing</TT>. Tokens are values from
the concrete type <TT>token</TT>, defined in the interface file
<I>grammar</I><TT>.mli</TT> produced by <TT>ocamlyacc</TT>.</P><!--TOC section Syntax of grammar definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc149">12.4</A>  Syntax of grammar definitions</H2><!--SEC END --><P>Grammar definitions have the following format:
</P><PRE>
%{
  <I>header</I>
%}
  <I>declarations</I>
%%
  <I>rules</I>
%%
  <I>trailer</I>
</PRE><P>Comments are enclosed between <CODE>/*</CODE> and <CODE>*/</CODE> (as in C) in the
&#X201C;declarations&#X201D; and &#X201C;rules&#X201D; sections, and between <CODE>(*</CODE> and
<CODE>*)</CODE> (as in Caml) in the &#X201C;header&#X201D; and &#X201C;trailer&#X201D; sections.</P><!--TOC subsection Header and trailer-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc150">12.4.1</A>  Header and trailer</H3><!--SEC END --><P>The header and the trailer sections are Caml code that is copied
as is into file <I>grammar</I><TT>.ml</TT>. Both sections are optional. The header
goes at the beginning of the output file; it usually contains
<TT>open</TT> directives and auxiliary functions required by the semantic
actions of the rules. The trailer goes at the end of the output file.</P><!--TOC subsection Declarations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc151">12.4.2</A>  Declarations</H3><!--SEC END --><P>Declarations are given one per line. They all start with a <CODE>%</CODE> sign.</P><DL CLASS="description"><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%token</TT></FONT> <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026;  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I></B></DT><DD CLASS="dd-description">
Declare the given symbols <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026;  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I>
as tokens (terminal symbols). These symbols
are added as constant constructors for the <TT>token</TT> concrete type.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%token</TT> <TT>&lt;</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>&gt;</TT></FONT>  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026;  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I></B></DT><DD CLASS="dd-description">
Declare the given symbols <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> &#X2026;  <I><A HREF="#constr"><FONT COLOR=maroon>constr</FONT></A></I> as tokens with an
attached attribute of the
given type. These symbols are added as constructors with arguments of
the given type for the <TT>token</TT> concrete type. The <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> part is
an arbitrary Caml type expression, except that all type
constructor names must be fully qualified (e.g. <TT>Modname.typename</TT>)
for all types except standard built-in types, even if the proper
<CODE>open</CODE> directives (e.g. <CODE>open Modname</CODE>) were given in the
header section. That&#X2019;s because the header is copied only to the <TT>.ml</TT>
output file, but not to the <TT>.mli</TT> output file, while the <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> part
of a <CODE>%token</CODE> declaration is copied to both.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%start</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026;  <FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
Declare the given symbols as entry points for the grammar. For each
entry point, a parsing function with the same name is defined in the
output module. Non-terminals that are not declared as entry points
have no such parsing function. Start symbols must be given a type with
the <CODE>%type</CODE> directive below.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%type</TT> <TT>&lt;</TT></FONT> <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> <FONT COLOR=blue><TT>&gt;</TT></FONT>  <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026;  <FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
Specify the type of the semantic attributes for the given symbols.
This is mandatory for start symbols only. Other nonterminal symbols
need not be given types by hand: these types will be inferred when
running the output files through the OCaml compiler (unless the
<CODE>-s</CODE> option is in effect). The <I><A HREF="#typexpr"><FONT COLOR=maroon>typexpr</FONT></A></I> part is an arbitrary Caml
type expression, except that all type constructor names must be
fully qualified, as explained above for <TT>%token</TT>.</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%left</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026;  <FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%right</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026;  <FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><FONT COLOR=blue><TT>%nonassoc</TT></FONT> <FONT COLOR=maroon><I>symbol</I></FONT> &#X2026;  <FONT COLOR=maroon><I>symbol</I></FONT></B></DT><DD CLASS="dd-description"><P>Associate precedences and associativities to the given symbols. All
symbols on the same line are given the same precedence. They have
higher precedence than symbols declared before in a <CODE>%left</CODE>,
<CODE>%right</CODE> or <CODE>%nonassoc</CODE> line. They have lower precedence
than symbols declared after in a <CODE>%left</CODE>, <CODE>%right</CODE> or
<CODE>%nonassoc</CODE> line. The symbols are declared to associate to the
left (<CODE>%left</CODE>), to the right (<CODE>%right</CODE>), or to be
non-associative (<CODE>%nonassoc</CODE>). The symbols are usually tokens.
They can also be dummy nonterminals, for use with the <CODE>%prec</CODE>
directive inside the rules.</P><P>The precedence declarations are used in the following way to
resolve reduce/reduce and shift/reduce conflicts:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Tokens and rules have precedences. By default, the precedence
of a rule is the precedence of its rightmost terminal. You
can override this default by using the <FONT COLOR=blue><TT>%prec</TT></FONT> directive in the rule.
</LI><LI CLASS="li-itemize">A reduce/reduce conflict
is resolved in favor of the first rule (in the order given by the
source file), and <TT>ocamlyacc</TT> outputs a warning.
</LI><LI CLASS="li-itemize">A shift/reduce conflict
is resolved by comparing the precedence of the rule to be
reduced with the precedence of the token to be shifted. If the
precedence of the rule is higher, then the rule will be reduced;
if the precedence of the token is higher, then the token will
be shifted.
</LI><LI CLASS="li-itemize">A shift/reduce conflict between a rule and a token with the
same precedence will be resolved using the associativity: if the
token is left-associative, then the parser will reduce; if the
token is right-associative, then the parser will shift. If the
token is non-associative, then the parser will declare a syntax
error.
</LI><LI CLASS="li-itemize">When a shift/reduce conflict cannot be resolved using the above
method, then <TT>ocamlyacc</TT> will output a warning and the parser will
always shift.
</LI></UL></DD></DL><!--TOC subsection Rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc152">12.4.3</A>  Rules</H3><!--SEC END --><P>The syntax for rules is as usual:
</P><PRE>
<I>nonterminal</I> :
    <I>symbol</I> &#X2026; <I>symbol</I> { <I>semantic-action</I> }
  | &#X2026;
  | <I>symbol</I> &#X2026; <I>symbol</I> { <I>semantic-action</I> }
;
</PRE><P>
Rules can also contain the <CODE>%prec </CODE><I>symbol</I> directive in the
right-hand side part, to override the default precedence and
associativity of the rule with the precedence and associativity of the
given symbol.</P><P>Semantic actions are arbitrary Caml expressions, that
are evaluated to produce the semantic attribute attached to
the defined nonterminal. The semantic actions can access the
semantic attributes of the symbols in the right-hand side of
the rule with the <CODE>$</CODE> notation: <CODE>$1</CODE> is the attribute for the
first (leftmost) symbol, <CODE>$2</CODE> is the attribute for the second
symbol, etc.</P><P>The rules may contain the special symbol <TT>error</TT> to indicate
resynchronization points, as in <TT>yacc</TT>.</P><P>Actions occurring in the middle of rules are not supported.</P><P>Nonterminal symbols are like regular Caml symbols, except that they
cannot end with <TT>&#X2019;</TT> (single quote).</P><!--TOC subsection Error handling-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">12.4.4</A>  Error handling</H3><!--SEC END --><P>Error recovery is supported as follows: when the parser reaches an
error state (no grammar rules can apply), it calls a function named
<TT>parse_error</TT> with the string <TT>"syntax error"</TT> as argument. The default
<TT>parse_error</TT> function does nothing and returns, thus initiating error
recovery (see below). The user can define a customized <TT>parse_error</TT>
function in the header section of the grammar file.</P><P>The parser also enters error recovery mode if one of the grammar
actions raises the <TT>Parsing.Parse_error</TT> exception.</P><P>In error recovery mode, the parser discards states from the
stack until it reaches a place where the error token can be shifted.
It then discards tokens from the input until it finds three successive
tokens that can be accepted, and starts processing with the first of
these. If no state can be uncovered where the error token can be
shifted, then the parser aborts by raising the <TT>Parsing.Parse_error</TT>
exception.</P><P>Refer to documentation on <TT>yacc</TT> for more details and guidance in how
to use error recovery.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc154">12.5</A>  Options</H2><!--SEC END --><P>The <TT>ocamlyacc</TT> command recognizes the following options:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-b</TT><I>prefix</I></B></DT><DD CLASS="dd-description">
Name the output files <I>prefix</I><TT>.ml</TT>, <I>prefix</I><TT>.mli</TT>,
<I>prefix</I><TT>.output</TT>, instead of the default naming convention.</DD><DT CLASS="dt-description"><TT><B>-q</B></TT></DT><DD CLASS="dd-description">
This option has no effect.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Generate a description of the parsing tables and a report on conflicts
resulting from ambiguities in the grammar. The description is put in
file <I>grammar</I><TT>.output</TT>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><TT><B>-</B></TT></DT><DD CLASS="dd-description">
Read the grammar specification from standard input. The default
output file names are <TT>stdin.ml</TT> and <TT>stdin.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>--</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Process <I>file</I> as the grammar specification, even if its name
starts with a dash (-) character. This option must be the last on the
command line.</DD></DL><P>At run-time, the <TT>ocamlyacc</TT>-generated parser can be debugged by
setting the <TT>p</TT> option in the <TT>OCAMLRUNPARAM</TT> environment variable
(see section <A HREF="#ocamlrun-options">10.2</A>). This causes the pushdown
automaton executing the parser to print a trace of its action (tokens
shifted, rules reduced, etc). The trace mentions rule numbers and
state numbers that can be interpreted by looking at the file
<I>grammar</I><TT>.output</TT> generated by <TT>ocamlyacc -v</TT>.</P><!--TOC section A complete example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc155">12.6</A>  A complete example</H2><!--SEC END --><P>The all-time favorite: a desk calculator. This program reads
arithmetic expressions on standard input, one per line, and prints
their values. Here is the grammar definition:
</P><PRE CLASS="verbatim">        /* File parser.mly */
        %token &lt;int&gt; INT
        %token PLUS MINUS TIMES DIV
        %token LPAREN RPAREN
        %token EOL
        %left PLUS MINUS        /* lowest precedence */
        %left TIMES DIV         /* medium precedence */
        %nonassoc UMINUS        /* highest precedence */
        %start main             /* the entry point */
        %type &lt;int&gt; main
        %%
        main:
            expr EOL                { $1 }
        ;
        expr:
            INT                     { $1 }
          | LPAREN expr RPAREN      { $2 }
          | expr PLUS expr          { $1 + $3 }
          | expr MINUS expr         { $1 - $3 }
          | expr TIMES expr         { $1 * $3 }
          | expr DIV expr           { $1 / $3 }
          | MINUS expr %prec UMINUS { - $2 }
        ;
</PRE><P>Here is the definition for the corresponding lexer:
</P><PRE CLASS="verbatim">        (* File lexer.mll *)
        {
        open Parser        (* The type token is defined in parser.mli *)
        exception Eof
        }
        rule token = parse
            [' ' '\t']     { token lexbuf }     (* skip blanks *)
          | ['\n' ]        { EOL }
          | ['0'-'9']+ as lxm { INT(int_of_string lxm) }
          | '+'            { PLUS }
          | '-'            { MINUS }
          | '*'            { TIMES }
          | '/'            { DIV }
          | '('            { LPAREN }
          | ')'            { RPAREN }
          | eof            { raise Eof }
</PRE><P>Here is the main program, that combines the parser with the lexer:
</P><PRE CLASS="verbatim">        (* File calc.ml *)
        let _ =
          try
            let lexbuf = Lexing.from_channel stdin in
            while true do
              let result = Parser.main Lexer.token lexbuf in
                print_int result; print_newline(); flush stdout
            done
          with Lexer.Eof -&gt;
            exit 0
</PRE><P>To compile everything, execute:
</P><PRE CLASS="verbatim">        ocamllex lexer.mll       # generates lexer.ml
        ocamlyacc parser.mly     # generates parser.ml and parser.mli
        ocamlc -c parser.mli
        ocamlc -c lexer.ml
        ocamlc -c parser.ml
        ocamlc -c calc.ml
        ocamlc -o calc lexer.cmo parser.cmo calc.cmo
</PRE><!--TOC section Common errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc156">12.7</A>  Common errors</H2><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>ocamllex: transition table overflow, automaton is too big</B></DT><DD CLASS="dd-description"><P>The deterministic automata generated by <TT>ocamllex</TT> are limited to at
most 32767 transitions. The message above indicates that your lexer
definition is too complex and overflows this limit. This is commonly
caused by lexer definitions that have separate rules for each of the
alphabetic keywords of the language, as in the following example.
</P><PRE CLASS="verbatim">rule token = parse
  "keyword1"   { KWD1 }
| "keyword2"   { KWD2 }
| ...
| "keyword100" { KWD100 }
| ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { IDENT id}
</PRE><P>To keep the generated automata small, rewrite those definitions with
only one general &#X201C;identifier&#X201D; rule, followed by a hashtable lookup
to separate keywords from identifiers:
</P><PRE CLASS="verbatim">{ let keyword_table = Hashtbl.create 53
  let _ =
    List.iter (fun (kwd, tok) -&gt; Hashtbl.add keyword_table kwd tok)
              [ "keyword1", KWD1;
                "keyword2", KWD2; ...
                "keyword100", KWD100 ]
}
rule token = parse
  ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_'] * as id
               { try
                   Hashtbl.find keyword_table id
                 with Not_found -&gt;
                   IDENT id }
</PRE></DD><DT CLASS="dt-description"><B>ocamllex: Position memory overflow, too many bindings</B></DT><DD CLASS="dd-description">
The deterministic automata generated by <TT>ocamllex</TT> maintains a table of
positions inside the scanned lexer buffer. The size of this table is
limited to at most 255 cells. This error should not show up in normal
situations.</DD></DL><!--TOC chapter Dependency generator (ocamldep)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc157">Chapter 13</A>  Dependency generator (ocamldep)</H1><!--SEC END --><P> <A NAME="c:camldep"></A>
</P><P>The <TT>ocamldep</TT> command scans a set of OCaml source files
(<TT>.ml</TT> and <TT>.mli</TT> files) for references to external compilation units,
and outputs dependency lines in a format suitable for the <TT>make</TT>
utility. This ensures that <TT>make</TT> will compile the source files in the
correct order, and recompile those files that need to when a source
file is modified.</P><P>The typical usage is:
</P><PRE>
        ocamldep <I>options</I> *.mli *.ml &gt; .depend
</PRE><P>
where <TT>*.mli *.ml</TT> expands to all source files in the current
directory and <TT>.depend</TT> is the file that should contain the
dependencies. (See below for a typical <TT>Makefile</TT>.)</P><P>Dependencies are generated both for compiling with the bytecode
compiler <TT>ocamlc</TT> and with the native-code compiler <TT>ocamlopt</TT>.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc158">13.1</A>  Options</H2><!--SEC END --><P>The following command-line options are recognized by <TT>ocamldep</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source files. If a source file <TT>foo.ml</TT> mentions an external
compilation unit <TT>Bar</TT>, a dependency on that unit&#X2019;s interface
<TT>bar.cmi</TT> is generated only if the source for <TT>bar</TT> is found in the
current directory or in one of the directories specified with <TT>-I</TT>.
Otherwise, <TT>Bar</TT> is assumed to be a module from the standard library,
and no dependencies are generated. For programs that span multiple
directories, it is recommended to pass <TT>ocamldep</TT> the same <TT>-I</TT> options
that are passed to the compiler.</DD><DT CLASS="dt-description"><B><TT>-ml-synonym</TT> <I>.ext</I></B></DT><DD CLASS="dd-description">
Consider the given extension (with leading dot) to be a synonym for .ml.</DD><DT CLASS="dt-description"><B><TT>-mli-synonym</TT> <I>.ext</I></B></DT><DD CLASS="dd-description">
Consider the given extension (with leading dot) to be a synonym for .mli.</DD><DT CLASS="dt-description"><TT><B>-modules</B></TT></DT><DD CLASS="dd-description">
Output raw dependencies of the form
<PRE CLASS="verbatim">      filename: Module1 Module2 ... ModuleN
</PRE>where <TT>Module1</TT>, &#X2026;, <TT>ModuleN</TT> are the names of the compilation
units referenced within the file <TT>filename</TT>, but these names are not
resolved to source file names. Such raw dependencies cannot be used
by <TT>make</TT>, but can be post-processed by other tools such as <TT>Omake</TT>.</DD><DT CLASS="dt-description"><TT><B>-native</B></TT></DT><DD CLASS="dd-description">
Generate dependencies for a pure native-code program (no bytecode
version). When an implementation file (<TT>.ml</TT> file) has no explicit
interface file (<TT>.mli</TT> file), <TT>ocamldep</TT> generates dependencies on the
bytecode compiled file (<TT>.cmo</TT> file) to reflect interface changes.
This can cause unnecessary bytecode recompilations for programs that
are compiled to native-code only. The flag <TT>-native</TT> causes
dependencies on native compiled files (<TT>.cmx</TT>) to be generated instead
of on <TT>.cmo</TT> files. (This flag makes no difference if all source files
have explicit <TT>.mli</TT> interface files.)</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Cause <TT>ocamldep</TT> to call the given <I>command</I> as a preprocessor
for each source file.</DD><DT CLASS="dt-description"><TT><B>-slash</B></TT></DT><DD CLASS="dd-description">
Under Windows, use a forward slash (/) as the path separator instead
of the usual backward slash (\). Under Unix, this option does
nothing.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section A typical Makefile-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc159">13.2</A>  A typical Makefile</H2><!--SEC END --><P>Here is a template <TT>Makefile</TT> for a OCaml program.</P><PRE CLASS="verbatim">OCAMLC=ocamlc
OCAMLOPT=ocamlopt
OCAMLDEP=ocamldep
INCLUDES=                 # all relevant -I options here
OCAMLFLAGS=$(INCLUDES)    # add other options for ocamlc here
OCAMLOPTFLAGS=$(INCLUDES) # add other options for ocamlopt here

# prog1 should be compiled to bytecode, and is composed of three
# units: mod1, mod2 and mod3.

# The list of object files for prog1
PROG1_OBJS=mod1.cmo mod2.cmo mod3.cmo

prog1: $(PROG1_OBJS)
        $(OCAMLC) -o prog1 $(OCAMLFLAGS) $(PROG1_OBJS)

# prog2 should be compiled to native-code, and is composed of two
# units: mod4 and mod5.

# The list of object files for prog2
PROG2_OBJS=mod4.cmx mod5.cmx

prog2: $(PROG2_OBJS)
        $(OCAMLOPT) -o prog2 $(OCAMLFLAGS) $(PROG2_OBJS)

# Common rules
.SUFFIXES: .ml .mli .cmo .cmi .cmx

.ml.cmo:
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

.mli.cmi:
        $(OCAMLC) $(OCAMLFLAGS) -c $&lt;

.ml.cmx:
        $(OCAMLOPT) $(OCAMLOPTFLAGS) -c $&lt;

# Clean up
clean:
        rm -f prog1 prog2
        rm -f *.cm[iox]

# Dependencies
depend:
        $(OCAMLDEP) $(INCLUDES) *.mli *.ml &gt; .depend

include .depend
</PRE><!--TOC chapter The browser/editor (ocamlbrowser)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc160">Chapter 14</A>  The browser/editor (ocamlbrowser)</H1><!--SEC END --><P> <A NAME="c:browser"></A>
</P><P>This chapter describes OCamlBrowser, a source and compiled interface
browser, written using LablTk. This is a useful companion to the
programmer.</P><P>Its functions are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
navigation through OCaml&#X2019;s modules (using compiled interfaces).
</LI><LI CLASS="li-itemize">source editing, type-checking, and browsing.
</LI><LI CLASS="li-itemize">integrated OCaml shell, running as a subprocess.
</LI></UL><!--TOC section Invocation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc161">14.1</A>  Invocation</H2><!--SEC END --><P> <A NAME="s:browser-options"></A></P><P>The browser is started by the command <TT>ocamlbrowser</TT>, as follows:
</P><PRE>
        ocamlbrowser <I>options</I>
</PRE><P>The following command-line options are recognized by <TT>ocamlbrowser</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the list of directories searched for
source and compiled files. By default, only the standard library
directory is searched. The standard library can also be changed by
setting the <TT>OCAMLLIB</TT> environment variable.</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types. Labels cannot be used in
applications, and parameter order becomes strict.</DD><DT CLASS="dt-description"><TT><B>-oldui</B></TT></DT><DD CLASS="dd-description">
Old multi-window interface. The default is now more like Smalltalk&#X2019;s
class browser.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types during type-checking. By default,
only recursive types where the recursion goes through an object type
are supported.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-w</TT> <I>warning-list</I></B></DT><DD CLASS="dd-description">
Enable or disable warnings according to the argument <I>warning-list</I>.</DD></DL><P>Most options can also be modified inside the application by the <B>Modules - Path editor</B> and <B>Compiler - Preferences</B> commands.
They are inherited when you start a toplevel shell.</P><!--TOC section Viewer-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc162">14.2</A>  Viewer</H2><!--SEC END --><P>
This is the first window you get when you start OCamlBrowser.
It displays a search window, and the list of modules in the load path.
At the top a row of menus.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>File - Open</B> and <B>File - Editor</B> give access to the
editor.</LI><LI CLASS="li-itemize"><B>File - Shell</B> creates an OCaml subprocess in a shell.</LI><LI CLASS="li-itemize"><B>View - Show all defs</B> displays the signature of the currently
selected module.</LI><LI CLASS="li-itemize"><B>View - Search entry</B> shows/hides the search entry just
below the menu bar.</LI><LI CLASS="li-itemize"><B>Modules - Path editor</B> changes the load path. <B>Modules
- Reset cache</B> rescans the load path and resets the module cache.
Do it if you recompile some interface, or get confused about what is 
in the cache.</LI><LI CLASS="li-itemize"><B>Modules - Search symbol</B> allows to search a symbol either
by its name, like the bottom line of the viewer, or, more
interestingly, by its type. <B>Exact type</B> searches for a type
with exactly the same information as the pattern (variables match
only variables). <B>Included type</B> allows to give only partial
information: the actual type may take more arguments and return more
results, and variables in the pattern match anything. In both cases,
argument and tuple order is irrelevant<SUP><A NAME="text2" HREF="#note2">1</A></SUP>,
and unlabeled arguments in the pattern match any label.</LI><LI CLASS="li-itemize">The <B>Search entry</B> just below the menu bar allows one to
search for an identifier in all modules (wildcards &#X201C;?&#X201D; and &#X201C;*&#X201D;
allowed). If you choose the <TT>type</TT> option, the search is done by type
inclusion (<EM>cf.</EM> Search Symbol - Included type).</LI><LI CLASS="li-itemize">The <B>Close all</B> button is there to dismiss the windows
created by the Detach button.
By double-clicking on it you will quit the browser.</LI></UL><!--TOC section Module browsing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc163">14.3</A>  Module browsing</H2><!--SEC END --><P>You select a module in the leftmost box by either cliking on it or
pressing return when it is selected. Fast access is available in all
boxes pressing the first few letter of the desired name.
Double-clicking / double-return displays the whole signature for the
module.</P><P>Defined identifiers inside the module are displayed in a box to the
right of the previous one. If you click on one, this will either
display its contents in another box (if this is a sub-module) or
display the signature for this identifier below.</P><P>Signatures are clickable. Double clicking with the left mouse
button on an identifier in a signature brings you to its signature.
A single click on the right button pops up a menu displaying the
type declaration for the selected identifier. Its title, when
selectable, also brings you to its signature.</P><P>At the bottom, a series of buttons, depending on the context.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Detach</B> copies the currently displayed signature in a new window,
to keep it.
</LI><LI CLASS="li-itemize"><B>Impl</B> and <B>Intf</B> bring you to the implementation or
interface of the currently displayed signature, if it is available.
</LI></UL><P>Control-S lets you search a string in the signature.</P><!--TOC section File editor-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc164">14.4</A>  File editor</H2><!--SEC END --><P>
You can edit files with it, if you&#X2019;re not yet used to emacs. Otherwise
you can use it as a browser, making occasional corrections.</P><P>The <B>Edit</B> menu contains commands for jump (C-g), search (C-s),
and sending the current phrase (or selection if some text is selected)
to a sub-shell (M-x). For this last option, you may choose the shell
via a dialog.</P><P>Essential functions are in the <B>Compiler</B> menu.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Preferences</B> opens a dialog to set internals of the editor
and type-checker.</LI><LI CLASS="li-itemize"><B>Lex</B> adds colors according to lexical categories.</LI><LI CLASS="li-itemize"><B>Typecheck</B> verifies typing, and memorizes to let one see an
expression&#X2019;s type by double-clicking on it. This is also valid for
interfaces. If an error occurs, the part of the interface preceding
the error is computed.<P>After typechecking, pressing the right button pops up a menu giving
the type of the pointed expression, and eventually allowing to
follow some links.</P></LI><LI CLASS="li-itemize"><B>Clear errors</B> dismisses type-checker error messages and warnings.</LI><LI CLASS="li-itemize"><B>Signature</B> shows the signature of the current file
(after type checking).
</LI></UL><!--TOC section Shell-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc165">14.5</A>  Shell</H2><!--SEC END --><P>
When you create a shell, a dialog is presented to you, letting you
choose which command you want to run, and the title of the shell (to
choose it in the Editor).</P><P>The executed subshell is given the current load path.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>File</B> use a source file or load a bytecode file. You may
also import the browser&#X2019;s path into the subprocess.
</LI><LI CLASS="li-itemize"><B>History</B> M-p and M-n browse up and down.
</LI><LI CLASS="li-itemize"><B>Signal</B> C-c interrupts, and you can also kill the subprocess.
</LI></UL><!--BEGIN NOTES chapter-->
<HR CLASS="ffootnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note2" HREF="#text2">1</A></DT><DD CLASS="dd-thefootnotes">To avoid
combinatorial explosion of the search space, optional arguments in
the actual type are ignored in the actual if (1) there are too many
of them, and (2) they do not appear explicitly in the pattern.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter The documentation generator (ocamldoc)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc166">Chapter 15</A>  The documentation generator (ocamldoc)</H1><!--SEC END --><P> <A NAME="c:ocamldoc"></A>
</P><P>This chapter describes OCamldoc, a tool that generates documentation from
special comments embedded in source files. The comments used by OCamldoc
are of the form <TT>(**</TT>&#X2026;<TT>*)</TT> and follow the format described
in section <A HREF="#s:ocamldoc-comments">15.2</A>.</P><P>OCamldoc can produce documentation in various formats: HTML, L<sup>A</sup>T<sub>E</sub>X,
TeXinfo, Unix man pages, and <TT>dot</TT> dependency graphs. Moreover,
users can add their own custom generators, as explained in
section <A HREF="#s:ocamldoc-custom-generators">15.3</A>.</P><P>In this chapter, we use the word <EM>element</EM> to refer to any of the
following parts of an OCaml source file: a type declaration, a value,
a module, an exception, a module type, a type constructor, a record
field, a class, a class type, a class method, a class value or a class
inheritance clause.</P><!--TOC section Usage-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc167">15.1</A>  Usage</H2><!--SEC END --><P> <A NAME="s:ocamldoc-usage"></A></P><!--TOC subsection Invocation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc168">15.1.1</A>  Invocation</H3><!--SEC END --><P>OCamldoc is invoked via the command <TT>ocamldoc</TT>, as follows:
</P><PRE>
        ocamldoc <I>options sourcefiles</I>
</PRE><!--TOC subsubsection Options for choosing the output format-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for choosing the output format</H4><!--SEC END --><P>The following options determine the format for the generated
documentation.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-html</B></TT></DT><DD CLASS="dd-description">
Generate documentation in HTML default format. The generated HTML pages
are stored in the current directory, or in the directory specified
with the <TT><B>-d</B></TT> option. You can customize the style of the
generated pages by editing the generated <TT>style.css</TT> file, or by providing
your own style sheet using option <TT>-css-style</TT>.
The file <TT>style.css</TT> is not generated if it already exists.</DD><DT CLASS="dt-description"><TT><B>-latex</B></TT></DT><DD CLASS="dd-description">
Generate documentation in L<sup>A</sup>T<sub>E</sub>X default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <TT>ocamldoc.out</TT>, or in the file
specified with the <TT><B>-o</B></TT> option. The document uses the style file
<TT>ocamldoc.sty</TT>. This file is generated when using the <TT>-latex</TT> option,
if it does not already exist.
You can change this file to customize the style of your L<sup>A</sup>T<sub>E</sub>X documentation.</DD><DT CLASS="dt-description"><TT><B>-texi</B></TT></DT><DD CLASS="dd-description">
Generate documentation in TeXinfo default format. The generated
L<sup>A</sup>T<sub>E</sub>X document is saved in file <TT>ocamldoc.out</TT>, or in the file
specified with the <TT><B>-o</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-man</B></TT></DT><DD CLASS="dd-description">
Generate documentation as a set of Unix <TT>man</TT> pages. The generated pages
are stored in the current directory, or in the directory specified
with the <TT><B>-d</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-dot</B></TT></DT><DD CLASS="dd-description">
Generate a dependency graph for the toplevel modules, in a format suitable
for displaying and processing by <TT>dot</TT>. The <TT>dot</TT> tool is available from
<TT><A HREF="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</A></TT>.
The textual representation of the graph is written to the file
<TT>ocamldoc.out</TT>, or to the file specified with the <TT><B>-o</B></TT> option.
Use <TT>dot ocamldoc.out</TT> to display it.</DD><DT CLASS="dt-description"><B><TT>-g</TT> <I>file.cm[o,a]</I></B></DT><DD CLASS="dd-description">
Dynamically load the given file, which defines a custom documentation
generator. See section <A HREF="#s:ocamldoc-compilation-and-usage">15.4.1</A>. This
option is supported by the <TT>ocamldoc</TT> command, but not by its
native-code version <TT>ocamldoc.opt</TT>.
If the given file is a simple one and does not exist in
the current directory, then ocamldoc looks for it in the custom
generators default directory, and in the directories specified with
optional <TT>-i</TT> options.</DD><DT CLASS="dt-description"><TT><B>-customdir</B></TT></DT><DD CLASS="dd-description">
Display the custom generators default directory.</DD><DT CLASS="dt-description"><B><TT>-i</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add the given directory to the path where to look for custom generators.</DD></DL><!--TOC subsubsection General options-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->General options</H4><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-d</TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Generate files in directory <I>dir</I>, rather than the current directory.</DD><DT CLASS="dt-description"><B><TT>-dump</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Dump collected information into <I>file</I>. This information can be
read with the <TT>-load</TT> option in a subsequent invocation of <TT>ocamldoc</TT>.</DD><DT CLASS="dt-description"><B><TT>-hide</TT> <I>modules</I></B></DT><DD CLASS="dd-description">
Hide the given complete module names in the generated documentation.
<I>modules</I> is a list of complete module names are separated
by &#X2019;<TT>,</TT>&#X2019;, without blanks. For instance: <TT>Pervasives,M2.M3</TT>.</DD><DT CLASS="dt-description"><TT><B>-inv-merge-ml-mli</B></TT></DT><DD CLASS="dd-description">
Reverse the precedence of implementations and interfaces when merging.
All elements
in implementation files are kept, and the <TT><B>-m</B></TT> option
indicates which parts of the comments in interface files are merged
with the comments in implementation files.</DD><DT CLASS="dt-description"><TT><B>-keep-code</B></TT></DT><DD CLASS="dd-description">
Always keep the source code for values, methods and instance variables,
when available.
The source code is always kept when a <TT>.ml</TT>
file is given, but is by default discarded when a <TT>.mli</TT> is given.
This option allows to always keep the source code.</DD><DT CLASS="dt-description"><B><TT>-load</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Load information from <I>file</I>, which has been produced by
<TT>ocamldoc -dump</TT>. Several <TT>-load</TT> options can be given.</DD><DT CLASS="dt-description"><B><TT>-m</TT> <I>flags</I></B></DT><DD CLASS="dd-description">
Specify merge options between interfaces and implementations.
(see section <A HREF="#s:ocamldoc-merge">15.1.2</A> for details).
<I>flags</I> can be one or several of the following characters:
<DL CLASS="description"><DT CLASS="dt-description">
<TT><B>d</B></TT></DT><DD CLASS="dd-description"> merge description
</DD><DT CLASS="dt-description"><TT><B>a</B></TT></DT><DD CLASS="dd-description"> merge @author
</DD><DT CLASS="dt-description"><TT><B>v</B></TT></DT><DD CLASS="dd-description"> merge @version
</DD><DT CLASS="dt-description"><TT><B>l</B></TT></DT><DD CLASS="dd-description"> merge @see
</DD><DT CLASS="dt-description"><TT><B>s</B></TT></DT><DD CLASS="dd-description"> merge @since
</DD><DT CLASS="dt-description"><TT><B>b</B></TT></DT><DD CLASS="dd-description"> merge @before
</DD><DT CLASS="dt-description"><TT><B>o</B></TT></DT><DD CLASS="dd-description"> merge @deprecated
</DD><DT CLASS="dt-description"><TT><B>p</B></TT></DT><DD CLASS="dd-description"> merge @param
</DD><DT CLASS="dt-description"><TT><B>e</B></TT></DT><DD CLASS="dd-description"> merge @raise
</DD><DT CLASS="dt-description"><TT><B>r</B></TT></DT><DD CLASS="dd-description"> merge @return
</DD><DT CLASS="dt-description"><TT><B>A</B></TT></DT><DD CLASS="dd-description"> merge everything
</DD></DL></DD><DT CLASS="dt-description"><TT><B>-no-custom-tags</B></TT></DT><DD CLASS="dd-description">
Do not allow custom @-tags (see section <A HREF="#s:ocamldoc-tags">15.2.5</A>).</DD><DT CLASS="dt-description"><TT><B>-no-stop</B></TT></DT><DD CLASS="dd-description">
Keep elements placed after/between the <TT>(**/**)</TT> special comment(s)
(see section <A HREF="#s:ocamldoc-comments">15.2</A>).</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Output the generated documentation to <I>file</I> instead of <TT>ocamldoc.out</TT>.
This option is meaningful only in conjunction with the
<TT><B>-latex</B></TT>, <TT><B>-texi</B></TT>, or <TT><B>-dot</B></TT> options.</DD><DT CLASS="dt-description"><B><TT>-pp</TT> <I>command</I></B></DT><DD CLASS="dd-description">
Pipe sources through preprocessor <I>command</I>.</DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><B><TT>-text</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as a text file, even if its
extension is not <TT>.txt</TT>.</DD><DT CLASS="dt-description"><TT><B>-sort</B></TT></DT><DD CLASS="dd-description">
Sort the list of top-level modules before generating the documentation.</DD><DT CLASS="dt-description"><TT><B>-stars</B></TT></DT><DD CLASS="dd-description">
Remove blank characters until the first asterisk (&#X2019;<TT>*</TT>&#X2019;) in each
line of comments.</DD><DT CLASS="dt-description"><B><TT>-t</TT> <I>title</I></B></DT><DD CLASS="dd-description">
Use <I>title</I> as the title for the generated documentation.</DD><DT CLASS="dt-description"><B><TT>-intro</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Use content of <I>file</I> as ocamldoc text to use as introduction (HTML, L<sup>A</sup>T<sub>E</sub>Xand TeXinfo only).
For HTML, the file is used to create the whole <TT>index.html</TT> file.</DD><DT CLASS="dt-description"><TT><B>-v</B></TT></DT><DD CLASS="dd-description">
Verbose mode. Display progress information.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><TT><B>-warn-error</B></TT></DT><DD CLASS="dd-description">
Treat Ocamldoc warnings as errors.</DD><DT CLASS="dt-description"><TT><B>-hide-warnings</B></TT></DT><DD CLASS="dd-description">
Do not print OCamldoc warnings.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC subsubsection Type-checking options-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Type-checking options</H4><!--SEC END --><P>OCamldoc calls the OCaml type-checker to obtain type
information. The following options impact the type-checking phase.
They have the same meaning as for the <TT>ocamlc</TT> and <TT>ocamlopt</TT> commands.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-I</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Add <I>directory</I> to the list of directories search for compiled
interface files (<TT>.cmi</TT> files).</DD><DT CLASS="dt-description"><TT><B>-nolabels</B></TT></DT><DD CLASS="dd-description">
Ignore non-optional labels in types.</DD><DT CLASS="dt-description"><TT><B>-rectypes</B></TT></DT><DD CLASS="dd-description">
Allow arbitrary recursive types. (See the <TT>-rectypes</TT> option to <TT>ocamlc</TT>.)</DD></DL><!--TOC subsubsection Options for generating HTML pages-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating HTML pages</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-html</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-all-params</B></TT></DT><DD CLASS="dd-description">
Display the complete list of parameters for functions and methods.</DD><DT CLASS="dt-description"><B><TT>-css-style</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Use <I>filename</I> as the Cascading Style Sheet file.</DD><DT CLASS="dt-description"><TT><B>-colorize-code</B></TT></DT><DD CLASS="dd-description">
Colorize the OCaml code enclosed in <TT>[ ]</TT> and <TT>\{[ ]\}</TT>, using colors
to emphasize keywords, etc. If the code fragments are not
syntactically correct, no color is added.</DD><DT CLASS="dt-description"><TT><B>-index-only</B></TT></DT><DD CLASS="dd-description">
Generate only index files.</DD><DT CLASS="dt-description"><TT><B>-short-functors</B></TT></DT><DD CLASS="dd-description">
Use a short form to display functors:
<TT>module M : functor (A:Module) -&gt; functor (B:Module2) -&gt; sig .. end</TT>
is displayed as <TT>module M (A:Module) (B:Module2) : sig .. end</TT>.</DD></DL><!--TOC subsubsection Options for generating L<sup>A</sup>T<sub>E</sub>X files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating L<sup>A</sup>T<sub>E</sub>X files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-latex</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-latex-value-prefix</TT> <I>prefix</I></B></DT><DD CLASS="dd-description">
Give a prefix to use for the labels of the values in the generated
L<sup>A</sup>T<sub>E</sub>X document.
The default prefix is the empty string. You can also use the options
<TT>-latex-type-prefix</TT>, <TT>-latex-exception-prefix</TT>,
<TT>-latex-module-prefix</TT>,
<TT>-latex-module-type-prefix</TT>, <TT>-latex-class-prefix</TT>,
<TT>-latex-class-type-prefix</TT>,
<TT>-latex-attribute-prefix</TT> and <TT>-latex-method-prefix</TT>.<P>These options are useful when you have, for example, a type and a value with
the same name. If you do not specify prefixes, L<sup>A</sup>T<sub>E</sub>X will complain about
multiply defined labels.</P></DD><DT CLASS="dt-description"><B><TT>-latextitle</TT> <I>n,style</I></B></DT><DD CLASS="dd-description">
Associate style number <I>n</I> to the given L<sup>A</sup>T<sub>E</sub>X sectioning command
<I>style</I>, e.g. <TT>section</TT> or <TT>subsection</TT>. (L<sup>A</sup>T<sub>E</sub>X only.) This is
useful when including the generated document in another L<sup>A</sup>T<sub>E</sub>X document,
at a given sectioning level. The default association is 1 for <TT>section</TT>,
2 for <TT>subsection</TT>, 3 for <TT>subsubsection</TT>, 4 for <TT>paragraph</TT> and 5 for
<TT>subparagraph</TT>.</DD><DT CLASS="dt-description"><TT><B>-noheader</B></TT></DT><DD CLASS="dd-description">
Suppress header in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-notoc</B></TT></DT><DD CLASS="dd-description">
Do not generate a table of contents.</DD><DT CLASS="dt-description"><TT><B>-notrailer</B></TT></DT><DD CLASS="dd-description">
Suppress trailer in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-sepfiles</B></TT></DT><DD CLASS="dd-description">
Generate one <TT>.tex</TT> file per toplevel module, instead of the global
<TT>ocamldoc.out</TT> file.
</DD></DL><!--TOC subsubsection Options for generating TeXinfo files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating TeXinfo files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-texi</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-esc8</B></TT></DT><DD CLASS="dd-description">
Escape accented characters in Info files.</DD><DT CLASS="dt-description"><TT><B>-info-entry</B></TT></DT><DD CLASS="dd-description">
Specify Info directory entry.</DD><DT CLASS="dt-description"><TT><B>-info-section</B></TT></DT><DD CLASS="dd-description">
Specify section of Info directory.</DD><DT CLASS="dt-description"><TT><B>-noheader</B></TT></DT><DD CLASS="dd-description">
Suppress header in generated documentation.</DD><DT CLASS="dt-description"><TT><B>-noindex</B></TT></DT><DD CLASS="dd-description">
Do not build index for Info files.</DD><DT CLASS="dt-description"><TT><B>-notrailer</B></TT></DT><DD CLASS="dd-description">
Suppress trailer in generated documentation.
</DD></DL><!--TOC subsubsection Options for generating <TT>dot</TT> graphs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating <TT>dot</TT> graphs</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-dot</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-dot-colors</TT> <I>colors</I></B></DT><DD CLASS="dd-description">
Specify the colors to use in the generated <TT>dot</TT> code.
When generating module dependencies, <TT>ocamldoc</TT> uses different colors
for modules, depending on the directories in which they reside.
When generating types dependencies, <TT>ocamldoc</TT> uses different colors
for types, depending on the modules in which they are defined.
<I>colors</I> is a list of color names separated by &#X2019;<TT>,</TT>&#X2019;, as
in <TT>Red,Blue,Green</TT>. The available colors are the ones supported by
the <TT>dot</TT> tool.</DD><DT CLASS="dt-description"><TT><B>-dot-include-all</B></TT></DT><DD CLASS="dd-description">
Include all modules in the <TT>dot</TT> output, not only modules given
on the command line or loaded with the <TT><B>-load</B></TT> option.</DD><DT CLASS="dt-description"><TT><B>-dot-reduce</B></TT></DT><DD CLASS="dd-description">
Perform a transitive reduction of the dependency graph before
outputting the <TT>dot</TT> code. This can be useful if there are
a lot of transitive dependencies that clutter the graph.</DD><DT CLASS="dt-description"><TT><B>-dot-types</B></TT></DT><DD CLASS="dd-description">
Output <TT>dot</TT> code describing the type dependency graph instead of
the module dependency graph.
</DD></DL><!--TOC subsubsection Options for generating man files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Options for generating man files</H4><!--SEC END --><P>The following options apply in conjunction with the <TT>-man</TT> option:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>-man-mini</B></TT></DT><DD CLASS="dd-description">
Generate man pages only for modules, module types, clases and class
types, instead of pages for all elements.</DD><DT CLASS="dt-description"><B><TT>-man-suffix</TT> <I>suffix</I></B></DT><DD CLASS="dd-description">
Set the suffix used for generated man filenames. Default is &#X2019;<TT>3o</TT>&#X2019;,
as in <TT>List.3o</TT>.</DD><DT CLASS="dt-description"><B><TT>-man-section</TT> <I>section</I></B></DT><DD CLASS="dd-description">
Set the section number used for generated man filenames. Default is &#X2019;<TT>3</TT>&#X2019;.</DD></DL><!--TOC subsection Merging of module information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc169">15.1.2</A>  Merging of module information</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-merge"></A></P><P>Information on a module can be extracted either from the <TT>.mli</TT> or <TT>.ml</TT>
file, or both, depending on the files given on the command line.
When both <TT>.mli</TT> and <TT>.ml</TT> files are given for the same module,
information extracted from these files is merged according to the
following rules:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Only elements (values, types, classes, ...) declared in the <TT>.mli</TT>
file are kept. In other terms, definitions from the <TT>.ml</TT> file that are
not exported in the <TT>.mli</TT> file are not documented.
</LI><LI CLASS="li-itemize">Descriptions of elements and descriptions in @-tags are handled
as follows. If a description for the same element or in the same
@-tag of the same element is present in both files, then the
description of the <TT>.ml</TT> file is concatenated to the one in the <TT>.mli</TT> file,
if the corresponding <TT>-m</TT> flag is given on the command line.
If a description is present in the <TT>.ml</TT> file and not in the
<TT>.mli</TT> file, the <TT>.ml</TT> description is kept.
In either case, all the information given in the <TT>.mli</TT> file is kept.
</LI></UL><!--TOC subsection Coding rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc170">15.1.3</A>  Coding rules</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-rules"></A>
The following rules must be respected in order to avoid name clashes
resulting in cross-reference errors:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
In a module, there must not be two modules, two module types or
a module and a module type with the same name.
In the default HTML generator, modules <TT>ab</TT> and <TT>AB</TT> will be printed
to the same file on case insensitive file systems.
</LI><LI CLASS="li-itemize">In a module, there must not be two classes, two class types or
a class and a class type with the same name.
</LI><LI CLASS="li-itemize">In a module, there must not be two values, two types, or two
exceptions with the same name.
</LI><LI CLASS="li-itemize">Values defined in tuple, as in <TT>let (x,y,z) = (1,2,3)</TT>
are not kept by OCamldoc.
</LI><LI CLASS="li-itemize">Avoid the following construction:
<PRE CLASS="verbatim">open Foo (* which has a module Bar with a value x *)
module Foo =
  struct
    module Bar =
      struct
        let x = 1
      end
  end
  let dummy = Bar.x
</PRE>In this case, OCamldoc will associate <TT>Bar.x</TT> to the <TT>x</TT> of module
<TT>Foo</TT> defined just above, instead of to the <TT>Bar.x</TT> defined in the
opened module <TT>Foo</TT>.
</LI></UL><!--TOC section Syntax of documentation comments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc171">15.2</A>  Syntax of documentation comments</H2><!--SEC END --><P>
<A NAME="s:ocamldoc-comments"></A></P><P>Comments containing documentation material are called <EM>special
comments</EM> and are written between <TT>(**</TT> and <TT>*)</TT>. Special comments
must start exactly with <TT>(**</TT>. Comments beginning with <TT>(</TT> and more
than two <TT>*</TT> are ignored.</P><!--TOC subsection Placement of documentation comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc172">15.2.1</A>  Placement of documentation comments</H3><!--SEC END --><P>
OCamldoc can associate comments to some elements of the language
encountered in the source files. The association is made according to
the locations of comments with respect to the language elements. The
locations of comments in <TT>.mli</TT> and <TT>.ml</TT> files are different.</P><!--TOC subsubsection Comments in <TT>.mli</TT> files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments in <TT>.mli</TT> files</H4><!--SEC END --><P>
A special comment is associated to an element if it is placed before or
after the element.<BR>
A special comment before an element is associated to this element if :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
There is no blank line or another special comment between the special
comment and the element. However, a regular comment can occur between
the special comment and the element.
</LI><LI CLASS="li-itemize">The special comment is not already associated to the previous element.
</LI><LI CLASS="li-itemize">The special comment is not the first one of a toplevel module.
</LI></UL><P>A special comment after an element is associated to this element if
there is no blank line or comment between the special comment and the
element.</P><P>There are two exceptions: for type constructors and record fields in
type definitions, the associated comment can only be placed after the
constructor or field definition, without blank lines or other comments
between them. The special comment for a type constructor
with another type constructor following must be placed before the &#X2019;|&#X2019;
character separating the two constructors.</P><P>The following sample interface file <TT>foo.mli</TT> illustrates the
placement rules for comments in <TT>.mli</TT> files.</P><PRE CLASS="verbatim">(** The first special comment of the file is the comment associated
    with the whole module.*)


(** Special comments can be placed between elements and are kept
    by the OCamldoc tool, but are not associated to any element.
    @-tags in these comments are ignored.*)

(*******************************************************************)
(** Comments like the one above, with more than two asterisks,
    are ignored. *)

(** The comment for function f. *)
val f : int -&gt; int -&gt; int
(** The continuation of the comment for function f. *)

(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)
(* Hello, I'm a simple comment :-) *)
exception My_exception of (int -&gt; int) * int

(** Comment for type weather  *)
type weather =
| Rain of int (** The comment for construtor Rain *)
| Sun (** The comment for constructor Sun *)

(** Comment for type weather2  *)
type weather2 =
| Rain of int (** The comment for construtor Rain *)
| Sun (** The comment for constructor Sun *)
(** I can continue the comment for type weather2 here
  because there is already a comment associated to the last constructor.*)

(** The comment for type my_record *)
type my_record = {
    val foo : int ;    (** Comment for field foo *)
    val bar : string ; (** Comment for field bar *)
  }
  (** Continuation of comment for type my_record *)

(** Comment for foo *)
val foo : string
(** This comment is associated to foo and not to bar. *)
val bar : string
(** This comment is assciated to bar. *)

(** The comment for class my_class *)
class my_class :
  object
    (** A comment to describe inheritance from cl *)
    inherit cl

    (** The comment for attribute tutu *)
    val mutable tutu : string

    (** The comment for attribute toto. *)
    val toto : int

    (** This comment is not attached to titi since
        there is a blank line before titi, but is kept
        as a comment in the class. *)

    val titi : string

    (** Comment for method toto *)
    method toto : string

    (** Comment for method m *)
    method m : float -&gt; int
  end

(** The comment for the class type my_class_type *)
class type my_class_type =
  object
    (** The comment for variable x. *)
    val mutable x : int

    (** The commend for method m. *)
    method m : int -&gt; int
end

(** The comment for module Foo *)
module Foo =
  struct
    (** The comment for x *)
    val x : int

    (** A special comment that is kept but not associated to any element *)
  end

(** The comment for module type my_module_type. *)
module type my_module_type =
  sig
    (** The comment for value x. *)
    val x : int

    (** The comment for module M. *)
    module M =
      struct
        (** The comment for value y. *)
        val y : int

        (* ... *)
      end

  end

</PRE><!--TOC subsubsection Comments in <TT>.ml</TT> files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Comments in <TT>.ml</TT> files</H4><!--SEC END --><P>A special comment is associated to an element if it is placed before
the element and there is no blank line between the comment and the
element. Meanwhile, there can be a simple comment between the special
comment and the element. There are two exceptions, for type
constructors and record fields in type definitions, whose associated
comment must be placed after the constructor or field definition,
without blank line between them. The special comment for a type constructor
with another type constructor following must be placed before the &#X2019;|&#X2019;
character separating the two constructors.</P><P>The following example of file <TT>toto.ml</TT> shows where to place comments
in a <TT>.ml</TT> file.</P><PRE CLASS="verbatim">(** The first special comment of the file is the comment associated
    to the whole module.*)

(** The comment for function f *)
let f x y = x + y

(** This comment is not attached to any element since there is another
    special comment just before the next element. *)

(** Comment for exception My_exception, even with a simple comment
    between the special comment and the exception.*)
(* A simple comment. *)
exception My_exception of (int -&gt; int) * int

(** Comment for type weather  *)
type weather =
| Rain of int (** The comment for constructor Rain *)
| Sun (** The comment for constructor Sun *)

(** The comment for type my_record *)
type my_record = {
    val foo : int ;    (** Comment for field foo *)
    val bar : string ; (** Comment for field bar *)
  }

(** The comment for class my_class *)
class my_class =
    object
      (** A comment to describe inheritance from cl *)
      inherit cl

      (** The comment for the instance variable tutu *)
      val mutable tutu = "tutu"
      (** The comment for toto *)
      val toto = 1
      val titi = "titi"
      (** Comment for method toto *)
      method toto = tutu ^ "!"
      (** Comment for method m *)
      method m (f : float) = 1
    end

(** The comment for class type my_class_type *)
class type my_class_type =
  object
    (** The comment for the instance variable x. *)
    val mutable x : int
    (** The commend for method m. *)
    method m : int -&gt; int
  end

(** The comment for module Foo *)
module Foo =
  struct
    (** The comment for x *)
    val x : int
    (** A special comment in the class, but not associated to any element. *)
  end

(** The comment for module type my_module_type. *)
module type my_module_type =
  sig
    (* Comment for value x. *)
    val x : int
    (* ... *)
  end
</PRE><!--TOC subsection The Stop special comment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc173">15.2.2</A>  The Stop special comment</H3><!--SEC END --><P>
The special comment <TT>(**/**)</TT> tells OCamldoc to discard
elements placed after this comment, up to the end of the current
class, class type, module or module type, or up to the next stop comment.
For instance:
</P><PRE CLASS="verbatim">class type foo =
  object
    (** comment for method m *)
    method m : string

    (**/**)

    (** This method won't appear in the documentation *)
    method bar : int
  end

(** This value appears in the documentation, since the Stop special comment
    in the class does not affect the parent module of the class.*)
val foo : string

(**/**)
(** The value bar does not appear in the documentation.*)
val bar : string
(**/**)

(** The type t appears since in the documentation since the previous stop comment
toggled off the "no documentation mode". *)
type t = string
</PRE><P>The <TT><B>-no-stop</B></TT> option to <TT>ocamldoc</TT> causes the Stop special
comments to be ignored.</P><!--TOC subsection Syntax of documentation comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc174">15.2.3</A>  Syntax of documentation comments</H3><!--SEC END --><P>The inside of documentation comments <TT>(**</TT>&#X2026;<TT>*)</TT> consists of
free-form text with optional formatting annotations, followed by
optional <EM>tags</EM> giving more specific information about parameters,
version, authors, &#X2026; The tags are distinguished by a leading @
character. Thus, a documentation comment has the following shape:
</P><PRE CLASS="verbatim">(** The comment begins with a description, which is text formatted
   according to the rules described in the next section.
   The description continues until the first non-escaped '@' character.
   @author Mr Smith
   @param x description for parameter x
*)
</PRE><P>Some elements support only a subset of all @-tags. Tags that are not
relevant to the documented element are simply ignored. For instance,
all tags are ignored when documenting type constructors, record
fields, and class inheritance clauses. Similarly, a <TT>@param</TT> tag on a
class instance variable is ignored.</P><P>At last, <TT>(**)</TT> is the empty documentation comment.</P><!--TOC subsection Text formatting-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc175">15.2.4</A>  Text formatting</H3><!--SEC END --><P>Here is the BNF grammar for the simple markup language used to format
text descriptions.</P><P><I>text</I> ::= (<I>text_element</I>)<TT>+</TT><BR>

<I>text_element</I> ::=<BR>
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {[0-9]+ <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>format <I>text</I> as a section header;
the integer following <TT>{</TT> indicates the sectioning level.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {[0-9]+:<I>label text</I>}</TT></TD><TD VALIGN=top ALIGN=left> same, but also associate the name <I>label</I> to the current point.
This point can be referenced by its fully-qualified label in a
<TT>{!</TT> command, just like any other element.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {b <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>set <I>text</I> in bold.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {i <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>set <I>text</I> in italic.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {e <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>emphasize <I>text</I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {C <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>center <I>text</I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {L <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>left align <I>text</I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {R <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>right align <I>text</I>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {ul <I>list</I>}</TT></TD><TD VALIGN=top ALIGN=left>build a list.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {ol <I>list</I>}</TT></TD><TD VALIGN=top ALIGN=left>build an enumerated list.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {{:<I>string</I>}<I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>put a link to the given address
(given as a string) on the given text.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| [<I>string</I>]</TT></TD><TD VALIGN=top ALIGN=left>set the given <I>string</I> in source code style.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {[<I>string</I>]}</TT></TD><TD VALIGN=top ALIGN=left>set the given <I>string</I> in preformatted
				source code style.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {v <I>string</I> v}</TT></TD><TD VALIGN=top ALIGN=left>set the given <I>string</I> in verbatim style.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {% <I>string</I> %}</TT></TD><TD VALIGN=top ALIGN=left>take the given <I>string</I>
as raw L<sup>A</sup>T<sub>E</sub>X code.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {!<I>string</I>}</TT></TD><TD VALIGN=top ALIGN=left>insert a reference to the element named
<I>string</I>. <I>string</I> must be a fully qualified element name,
for example <TT>Foo.Bar.t</TT>. The kind of the referenced element can be forced
(useful when various elements have the same qualified name) with the following
syntax: <TT>{!<I>kind</I>: Foo.Bar.t}</TT> where <I><TT>kind</TT></I> can be
<TT>module</TT>, <TT>modtype</TT>, <TT>class</TT>, <TT>classtype</TT>, <TT>val</TT>,
<TT>type</TT>, <TT>exception</TT>, <TT>attribute</TT>, <TT>method</TT> or <TT>section</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {!modules: <I>string string</I> ...}</TT></TD><TD VALIGN=top ALIGN=left>insert an index table
for the given module names. Used in HTML only.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {!indexlist}</TT></TD><TD VALIGN=top ALIGN=left>insert a table of links to the various indexes
(types, values, modules, ...). Used in HTML only.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {^ <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>set text in superscript.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| {_ <I>text</I>}</TT></TD><TD VALIGN=top ALIGN=left>set text in subscript.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| <I>escaped_string</I></TT></TD><TD VALIGN=top ALIGN=left>typeset the given string as is;
special characters (&#X2019;<TT>{</TT>&#X2019;, &#X2019;<TT>}</TT>&#X2019;, &#X2019;<TT>[</TT>&#X2019;, &#X2019;<TT>]</TT>&#X2019; and &#X2019;<TT>@</TT>&#X2019;)
must be	escaped by a &#X2019;<TT>\</TT>&#X2019;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>| <I>blank_line</I> </TT></TD><TD VALIGN=top ALIGN=left>force a new line.</TD></TR>
</TABLE><P><BR>

<I>list</I> ::=<BR>
  <TT>| ({- <I>text</I>})+</TT><BR>
  <TT>| ({li <I>text</I>})+</TT><BR>

A shortcut syntax exists for lists and enumerated lists:
</P><PRE CLASS="verbatim">(** Here is a {b list}
- item 1
- item 2
- item 3

The list is ended by the blank line.*)
</PRE><P>is equivalent to:
</P><PRE CLASS="verbatim">(** Here is a {b list}
{ul {- item 1}
{- item 2}
{- item 3}}
The list is ended by the blank line.*)
</PRE><P>The same shortcut is available for enumerated lists, using &#X2019;<TT>+</TT>&#X2019;
instead of &#X2019;<TT>-</TT>&#X2019;.
Note that only one list can be defined by this shortcut in nested lists.</P><P>In the description of a value, type, exception, module, module type, class
or class type, the <EM>first sentence</EM> is sometimes used in indexes, or
when just a part of the description is needed. The first sentence
is composed of the first characters of the description, until
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the first dot followed by a blank, or
</LI><LI CLASS="li-itemize">the first blank line
</LI></UL><P>
outside of the following text formatting :
<TT>{ul <EM>list</EM>}</TT>,
<TT>{ol <EM>list</EM>}</TT>,
<TT>[<EM>string</EM>]</TT>,
<TT>{[<EM>string</EM>]}</TT>,
<TT>{v <EM>string</EM> v}</TT>,
<TT>{% <EM>string</EM>%}</TT>,
<TT>{!<EM>string</EM>}</TT>,
<TT>{^ <EM>text</EM>}</TT>,
<TT>{_ <EM>text</EM>}</TT>.</P><!--TOC subsection Documentation tags (@-tags)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc176">15.2.5</A>  Documentation tags (@-tags)</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-tags"></A></P><!--TOC subsubsection Predefined tags-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Predefined tags</H4><!--SEC END --><P>
The folowing table gives the list of predefined @-tags, with their
syntax and meaning.<BR>

</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><TT>@author </TT><EM>string</EM></TD><TD VALIGN=top ALIGN=left>The author of the element. One author by <TT>@author</TT> tag.
There may be several <TT>@author</TT> tags for the same element.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@deprecated </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>The <EM>text</EM> should describe when the element was
deprecated, what to use as a replacement, and possibly the reason
for deprecation.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@param </TT><EM>id text</EM></TD><TD VALIGN=top ALIGN=left>Associate the given description (<EM>text</EM>) to the
given parameter name <EM>id</EM>. This tag is used for functions,
methods, classes and functors.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@raise Exc </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>Explain that the element may raise
the exception <TT>Exc</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@return </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>Describe the return value and
its possible values. This tag is used for functions
and methods.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@see &lt;url&gt; </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>Add a reference to the URL between &#X2019;<TT>&lt;</TT>&#X2019; and &#X2019;<TT>&gt;</TT>&#X2019;
with the given text as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@see &#X2019;filename&#X2019; </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>Add a reference to the given file name
(written between single quotes), with the given text as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@see "document name" </TT><EM>text</EM></TD><TD VALIGN=top ALIGN=left>Add a reference to the given
document name (written between double quotes), with the given text
as comment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@since </TT><EM>string</EM></TD><TD VALIGN=top ALIGN=left>Indicate when the element was introduced.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@before </TT><EM>v text</EM></TD><TD VALIGN=top ALIGN=left>Associate the given description (<EM>text</EM>) to the
given version <EM>v</EM> in order to document compatibility issues.</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>@version </TT><EM>string</EM></TD><TD VALIGN=top ALIGN=left>The version number for the element.</TD></TR>
</TABLE><!--TOC subsubsection Custom tags-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Custom tags</H4><!--SEC END --><P>
<A NAME="s:ocamldoc-custom-tags"></A>
You can use custom tags in the documentation comments, but they will
have no effect if the generator used does not handle them. To use a
custom tag, for example <TT>foo</TT>, just put <TT>@foo</TT> with some text in your
comment, as in:
</P><PRE CLASS="verbatim">(** My comment to show you a custom tag.
@foo this is the text argument to the [foo] custom tag.
*)
</PRE><P>To handle custom tags, you need to define a custom generator,
as explained in section <A HREF="#s:ocamldoc-handling-custom-tags">15.3.2</A>.</P><!--TOC section Custom generators-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc177">15.3</A>  Custom generators</H2><!--SEC END --><P>
<A NAME="s:ocamldoc-custom-generators"></A></P><P>OCamldoc operates in two steps:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
analysis of the source files;
</LI><LI CLASS="li-enumerate">generation of documentation, through a documentation generator,
	which is an object of class <TT>Odoc_args.class_generator</TT>.
</LI></OL><P>
Users can provide their own documentation generator to be used during
step 2 instead of the default generators.
All the information retrieved during the analysis step is available through
the <TT>Odoc_info</TT> module, which gives access to all the types and functions
representing the elements found in the given modules, with their associated
description.</P><P>The files you can used to define custom generators are installed in the
<TT>ocamldoc</TT> sub-directory of the OCaml standard library.</P><!--TOC subsection The generator class-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc178">15.3.1</A>  The generator class</H3><!--SEC END --><P>
A generator class is a class of type <TT>Odoc_args.doc_generator</TT>.
It has only one method<BR>
<TT>generator : Odoc_info.Module.t_module list -&gt; unit</TT><BR>
This method will be called with the list of analysed and possibly
merged <TT>Odoc_info.t_module</TT> structures.
Of course the class can have other methods, but the object of this
class must be coerced to <TT>Odoc_args.doc_generator</TT> before being
passed to the function<BR>
<TT>Odoc_args.set_doc_generator : Odoc_args.doc_generator -&gt; unit</TT><BR>
which installs the new documentation generator.</P><P>The following example shows how to define and install a new documentation generator.
See the <TT>odoc_fhtml</TT> generator (in the Ocamldoc Hump) for a complete example.
</P><PRE CLASS="verbatim">class my_doc_gen =
  object
    (* ... *)

    method generate module_list =
      (* ... *)
      ()

    (* ... *)
  end

let my_generator = new my_doc_gen
let _ = Odoc_args.set_doc_generator (my_generator :&gt; Odoc_args.doc_generator)
</PRE><P>Note: The new class can inherit from <TT>Odoc_html.html</TT>, <TT>Odoc_latex.latex</TT>,
<TT>Odoc_man.man</TT>, <TT>Odoc_texi.texi</TT> or <TT>Odoc_dot.dot</TT>, and
redefine only some methods to benefit from the existing methods.</P><!--TOC subsection Handling custom tags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc179">15.3.2</A>  Handling custom tags</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-handling-custom-tags"></A></P><P>Making a custom generator handle custom tags (see
<A HREF="#s:ocamldoc-custom-tags">15.2.5</A>) is very simple.</P><!--TOC subsubsection For HTML-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->For HTML</H4><!--SEC END --><P>
Here is how to develop a HTML generator handling your custom tags.</P><P>The class <TT>Odoc_html.html</TT> inherits
from the class <TT>Odoc_html.info</TT>, containing a field <TT>tag_functions</TT> which is a
list pairs composed of a custom tag (e.g. &#X2019;foo&#X2019;) and a function taking a <TT>text</TT>
and returning HTML code (of type <TT>string</TT>).
To handle a new tag <TT>bar</TT>, create a HTML generator class from the existing one
and complete the <TT>tag_functions</TT> field:
</P><PRE CLASS="verbatim">class my_gen =
  object(self)
    inherit Odoc_html.html

    (** Return HTML code for the given text of a bar tag. *)
    method html_of_bar t = (* your code here *)

    initializer
      tag_functions &lt;- ("bar", self#html_of_bar) :: tag_functions
  end
</PRE><P>Another method of the class <TT>Odoc_html.info</TT> will look for the
function associated to a custom tag and apply it to the text given to
the tag. If no function is associated to a custom tag, then the method
prints a warning message on <TT>stderr</TT>.</P><!--TOC subsubsection For other generators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->For other generators</H4><!--SEC END --><P>
As for the HTML custom generator, you can define a new L<sup>A</sup>T<sub>E</sub>X(resp. <TT>man</TT>) generator by inheriting from the class
<TT>Odoc_latex.latex</TT> (resp. <TT>Odoc_man.man</TT>) and
adding your own tag handler to the field <TT>tag_functions</TT>.</P><!--TOC section Adding command line options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc180">15.4</A>  Adding command line options</H2><!--SEC END --><P>
The command line analysis is performed after loading the module containing the
documentation generator, thus allowing command line options to be added to the
list of existing ones. Adding an option can be done with the function<BR>
<TT>Odoc_args.add_option : string * Arg.spec * string -&gt; unit</TT><BR>
Note: Existing command line options can be redefined using this function.</P><!--TOC subsection Compilation and usage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc181">15.4.1</A>  Compilation and usage</H3><!--SEC END --><P>
<A NAME="s:ocamldoc-compilation-and-usage"></A></P><!--TOC subsubsection Defining a custom generator class in one file-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Defining a custom generator class in one file</H4><!--SEC END --><P>
Let <TT>custom.ml</TT> be the file defining a new generator class.
Compilation of <TT>custom.ml</TT> can be performed by the following command :<BR>
<TT>ocamlc -I +ocamldoc -c custom.ml</TT><BR>
The file <TT>custom.cmo</TT> is created and can be used this way :<BR>
<TT>ocamldoc -g custom.cmo <EM>other-options source-files</EM></TT><BR>
It is important not to give the <TT><B>-html</B></TT> or any other option selecting a
built in generator to <TT>ocamldoc</TT>,
which would result in using this generator instead of the one you just loaded.</P><!--TOC subsubsection Defining a custom generator class in several files-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Defining a custom generator class in several files</H4><!--SEC END --><P>
It is possible to define a generator class in several modules, which
are defined in several files <TT>file1.ml[i]</TT>, <TT>file2.ml[i]</TT>, ...,
<TT>fileN.ml[i]</TT>. A <TT>.cma</TT> library file must
be created, including all these files.<BR>
The following commands create the <TT>custom.cma</TT> file from files <TT>file1.ml[i]</TT>, ...,
<TT>fileN.ml[i]</TT> :<BR>
<TT>ocamlc -I +ocamldoc -c file1.ml[i]<BR>
ocamlc -I +ocamldoc -c file2.ml[i]<BR>
...<BR>
ocamlc -I +ocamldoc -c fileN.ml[i]<BR>
ocamlc -o custom.cma -a file1.cmo file2.cmo ... fileN.cmo</TT><BR>
Then, the following command uses <TT>custom.cma</TT> as custom generator:<BR>
<TT>ocamldoc -g custom.cma <EM>other-options source-files</EM></TT><BR>
Again, it is important not to give the <TT><B>-html</B></TT> or any other option selecting a
built in generator to <TT>ocamldoc</TT>,
which would result in using this generator instead of the one you just loaded.

</P><!--TOC chapter The debugger (ocamldebug)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc182">Chapter 16</A>  The debugger (ocamldebug)</H1><!--SEC END --><P> <A NAME="c:debugger"></A>
</P><P>This chapter describes the OCaml source-level replay debugger
<TT>ocamldebug</TT>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>   The debugger is available on Unix systems that provide
BSD sockets.
</BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>   The debugger is available under the Cygwin port of
OCaml, but not under the native Win32 ports.
</BLOCKQUOTE><!--TOC section Compiling for debugging-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc183">16.1</A>  Compiling for debugging</H2><!--SEC END --><P>Before the debugger can be used, the program must be compiled and
linked with the <TT>-g</TT> option: all <TT>.cmo</TT> and <TT>.cma</TT> files that are part
of the program should have been created with <TT>ocamlc -g</TT>, and they
must be linked together with <TT>ocamlc -g</TT>.</P><P>Compiling with <TT>-g</TT> entails no penalty on the running time of
programs: object files and bytecode executable files are bigger and
take longer to produce, but the executable files run at
exactly the same speed as if they had been compiled without <TT>-g</TT>.</P><!--TOC section Invocation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc184">16.2</A>  Invocation</H2><!--SEC END --><!--TOC subsection Starting the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc185">16.2.1</A>  Starting the debugger</H3><!--SEC END --><P>The OCaml debugger is invoked by running the program
<TT>ocamldebug</TT> with the name of the bytecode executable file as first
argument:
</P><PRE>
        ocamldebug [<I>options</I>] <I>program</I> [<I>arguments</I>]
</PRE><P>
The arguments following <I>program</I> are optional, and are passed as
command-line arguments to the program being debugged. (See also the
<TT>set arguments</TT> command.)</P><P>The following command-line options are recognized:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-c </TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the maximum number of simultaneously live checkpoints to <I>count</I>.</DD><DT CLASS="dt-description"><B><TT>-cd </TT> <I>dir</I></B></DT><DD CLASS="dd-description">
Run the debugger program from the working directory <I>dir</I>,
instead of the current directory. (See also the <TT>cd</TT> command.)</DD><DT CLASS="dt-description"><TT><B>-emacs</B></TT></DT><DD CLASS="dd-description">
Tell the debugger it is executed under Emacs. (See
section <A HREF="#s:inf-debugger">16.10</A> for information on how to run the
debugger under Emacs.)</DD><DT CLASS="dt-description"><B><TT>-I </TT><I>directory</I></B></DT><DD CLASS="dd-description">
Add <I>directory</I> to the list of directories searched for source
files and compiled files. (See also the <TT>directory</TT> command.)</DD><DT CLASS="dt-description"><B><TT>-s </TT><I>socket</I></B></DT><DD CLASS="dd-description">
Use <I>socket</I> for communicating with the debugged program. See the
description of the command <TT>set socket</TT> (section <A HREF="#s:communication">16.8.6</A>)
for the format of <I>socket</I>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC subsection Exiting the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc186">16.2.2</A>  Exiting the debugger</H3><!--SEC END --><P>The command <TT>quit</TT> exits the debugger. You can also exit the debugger
by typing an end-of-file character (usually <TT>ctrl-D</TT>).</P><P>Typing an interrupt character (usually <TT>ctrl-C</TT>) will not exit the
debugger, but will terminate the action of any debugger command that is in
progress and return to the debugger command level. </P><!--TOC section Commands-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc187">16.3</A>  Commands</H2><!--SEC END --><P> <A NAME="s:debugger-commands"></A></P><P>A debugger command is a single line of input. It starts with a command
name, which is followed by arguments depending on this name. Examples:
</P><PRE CLASS="verbatim">        run
        goto 1000
        set arguments arg1 arg2
</PRE><P>A command name can be truncated as long as there is no ambiguity. For
instance, <TT>go 1000</TT> is understood as <TT>goto 1000</TT>, since there are no
other commands whose name starts with <TT>go</TT>. For the most frequently
used commands, ambiguous abbreviations are allowed. For instance, <TT>r</TT>
stands for <TT>run</TT> even though there are others commands starting with
<TT>r</TT>. You can test the validity of an abbreviation using the <TT>help</TT> command.</P><P>If the previous command has been successful, a blank line (typing just
<TT>RET</TT>) will repeat it.</P><!--TOC subsection Getting help-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc188">16.3.1</A>  Getting help</H3><!--SEC END --><P>The OCaml debugger has a simple on-line help system, which gives
a brief description of each command and variable.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>help</B></TT></DT><DD CLASS="dd-description">
Print the list of commands.</DD><DT CLASS="dt-description"><B><TT>help </TT><I>command</I></B></DT><DD CLASS="dd-description">
Give help about the command <I>command</I>.</DD><DT CLASS="dt-description"><B><TT>help set </TT><I>variable</I>, <TT>help show </TT><I>variable</I></B></DT><DD CLASS="dd-description">
Give help about the variable <I>variable</I>. The list of all debugger
variables can be obtained with <TT>help set</TT>.</DD><DT CLASS="dt-description"><B><TT>help info </TT><I>topic</I></B></DT><DD CLASS="dd-description">
Give help about <I>topic</I>. Use <TT>help info</TT> to get a list of known topics.
</DD></DL><!--TOC subsection Accessing the debugger state-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc189">16.3.2</A>  Accessing the debugger state</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set </TT><I>variable value</I></B></DT><DD CLASS="dd-description">
Set the debugger variable <I>variable</I> to the value <I>value</I>.</DD><DT CLASS="dt-description"><B><TT>show </TT><I>variable</I></B></DT><DD CLASS="dd-description">
Print the value of the debugger variable <I>variable</I>.</DD><DT CLASS="dt-description"><B><TT>info </TT><I>subject</I></B></DT><DD CLASS="dd-description">
Give information about the given subject.
For instance, <TT>info breakpoints</TT> will print the list of all breakpoints.
</DD></DL><!--TOC section Executing a program-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc190">16.4</A>  Executing a program</H2><!--SEC END --><!--TOC subsection Events-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc191">16.4.1</A>  Events</H3><!--SEC END --><P>Events are &#X201C;interesting&#X201D; locations in the source code, corresponding
to the beginning or end of evaluation of &#X201C;interesting&#X201D;
sub-expressions. Events are the unit of single-stepping (stepping goes
to the next or previous event encountered in the program execution).
Also, breakpoints can only be set at events. Thus, events play the
role of line numbers in debuggers for conventional languages.</P><P>During program execution, a counter is incremented at each event
encountered. The value of this counter is referred as the <EM>current
time</EM>. Thanks to reverse execution, it is possible to jump back and
forth to any time of the execution.</P><P>Here is where the debugger events (written §§) are located in
the source code:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Following a function application:
<PRE>
(f arg)§§
</PRE>
</LI><LI CLASS="li-itemize">On entrance to a function:
<PRE>
fun x y z -&gt; §§ ...
</PRE>
</LI><LI CLASS="li-itemize">On each case of a pattern-matching definition (function,
<TT>match</TT>&#X2026;<TT>with</TT> construct, <TT>try</TT>&#X2026;<TT>with</TT> construct):
<PRE>
function pat1 -&gt; §§ expr1
       | ...
       | patN -&gt; §§ exprN
</PRE>
</LI><LI CLASS="li-itemize">Between subexpressions of a sequence:
<PRE>
expr1; §§ expr2; §§ ...; §§ exprN
</PRE>
</LI><LI CLASS="li-itemize">In the two branches of a conditional expression:
<PRE>
if cond then §§ expr1 else §§ expr2
</PRE>
</LI><LI CLASS="li-itemize">At the beginning of each iteration of a loop:
<PRE>
while cond do §§ body done
for i = a to b do §§ body done
</PRE>
</LI></UL><P>
Exceptions: A function application followed by a function return is replaced
by the compiler by a jump (tail-call optimization). In this case, no
event is put after the function application.
</P><!--TOC subsection Starting the debugged program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc192">16.4.2</A>  Starting the debugged program</H3><!--SEC END --><P>The debugger starts executing the debugged program only when needed.
This allows setting breapoints or assigning debugger variables before
execution starts. There are several ways to start execution:
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>run</B></TT></DT><DD CLASS="dd-description"> Run the program until a breakpoint is hit, or the program
terminates.
</DD><DT CLASS="dt-description"><TT><B>step 0</B></TT></DT><DD CLASS="dd-description"> Load the program and stop on the first event.
</DD><DT CLASS="dt-description"><B><TT>goto </TT><I>time</I></B></DT><DD CLASS="dd-description"> Load the program and execute it until the
given time. Useful when you already know approximately at what time
the problem appears. Also useful to set breakpoints on function values
that have not been computed at time 0 (see section <A HREF="#s:breakpoints">16.5</A>).
</DD></DL><P>The execution of a program is affected by certain information it
receives when the debugger starts it, such as the command-line
arguments to the program and its working directory. The debugger
provides commands to specify this information (<TT>set arguments</TT> and <TT>cd</TT>).
These commands must be used before program execution starts. If you try
to change the arguments or the working directory after starting your
program, the debugger will kill the program (after asking for confirmation).</P><!--TOC subsection Running the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc193">16.4.3</A>  Running the program</H3><!--SEC END --><P>The following commands execute the program forward or backward,
starting at the current time. The execution will stop either when
specified by the command or when a breakpoint is encountered.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>run</B></TT></DT><DD CLASS="dd-description"> Execute the program forward from current time. Stops at
next breakpoint or when the program terminates.
</DD><DT CLASS="dt-description"><TT><B>reverse</B></TT></DT><DD CLASS="dd-description"> Execute the program backward from current time.
Mostly useful to go to the last breakpoint encountered before the
current time.
</DD><DT CLASS="dt-description"><B><TT>step </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program and stop at the next event. With
an argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>backstep </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program backward and stop at
the previous event. With an argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>next </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program and stop at the next
event, skipping over function calls. With an argument, do it
<I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>previous </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description"> Run the program backward and stop at
the previous event, skipping over function calls. With an argument, do
it <I>count</I> times.
</DD><DT CLASS="dt-description"><TT><B>finish</B></TT></DT><DD CLASS="dd-description"> Run the program until the current function returns.
</DD><DT CLASS="dt-description"><TT><B>start</B></TT></DT><DD CLASS="dd-description"> Run the program backward and stop at the first event
before the current function invocation.
</DD></DL><!--TOC subsection Time travel-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc194">16.4.4</A>  Time travel</H3><!--SEC END --><P>You can jump directly to a given time, without stopping on
breakpoints, using the <TT>goto</TT> command.</P><P>As you move through the program, the debugger maintains an history of
the successive times you stop at. The <TT>last</TT> command can be used to
revisit these times: each <TT>last</TT> command moves one step back through
the history. That is useful mainly to undo commands such as <TT>step</TT>
and <TT>next</TT>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>goto </TT><I>time</I></B></DT><DD CLASS="dd-description">
Jump to the given time.
</DD><DT CLASS="dt-description"><B><TT>last </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Go back to the latest time recorded in the execution history. With an
argument, do it <I>count</I> times.
</DD><DT CLASS="dt-description"><B><TT>set history </TT><I>size</I></B></DT><DD CLASS="dd-description">
Set the size of the execution history.
</DD></DL><!--TOC subsection Killing the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc195">16.4.5</A>  Killing the program</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>kill</B></TT></DT><DD CLASS="dd-description"> Kill the program being executed. This command is mainly
useful if you wish to recompile the program without leaving the debugger.
</DD></DL><!--TOC section Breakpoints-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc196">16.5</A>  Breakpoints</H2><!--SEC END --><P> <A NAME="s:breakpoints"></A></P><P>A breakpoint causes the program to stop whenever a certain point in
the program is reached. It can be set in several ways using the
<TT>break</TT> command. Breakpoints are assigned numbers when set, for
further reference. The most comfortable way to set breakpoints is
through the Emacs interface (see section <A HREF="#s:inf-debugger">16.10</A>).</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>break</B></TT></DT><DD CLASS="dd-description">
Set a breakpoint at the current position in the program execution. The
current position must be on an event (i.e., neither at the beginning,
nor at the end of the program).</DD><DT CLASS="dt-description"><B><TT>break </TT><I>function</I></B></DT><DD CLASS="dd-description">
Set a breakpoint at the beginning of <I>function</I>. This works only
when the functional value of the identifier <I>function</I> has been
computed and assigned to the identifier. Hence this command cannot be
used at the very beginning of the program execution, when all
identifiers are still undefined; use <TT>goto</TT> <I>time</I> to advance
execution until the functional value is available.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <I>line</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> (or in the current module if
<I>module</I> is not given), at the first event of line <I>line</I>.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <I>line column</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> (or in the current module if
<I>module</I> is not given), at the event closest to line <I>line</I>,
column <I>column</I>.</DD><DT CLASS="dt-description"><B><TT>break @</TT> [<I>module</I>] <TT>#</TT> <I>character</I></B></DT><DD CLASS="dd-description">
Set a breakpoint in module <I>module</I> at the event closest to
character number <I>character</I>.</DD><DT CLASS="dt-description"><B><TT>break </TT><I>address</I></B></DT><DD CLASS="dd-description">
Set a breakpoint at the code address <I>address</I>.</DD><DT CLASS="dt-description"><B><TT>delete </TT>[<I>breakpoint-numbers</I>]</B></DT><DD CLASS="dd-description">
Delete the specified breakpoints. Without argument, all breakpoints
are deleted (after asking for confirmation).</DD><DT CLASS="dt-description"><TT><B>info breakpoints</B></TT></DT><DD CLASS="dd-description"> Print the list of all breakpoints.
</DD></DL><!--TOC section The call stack-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc197">16.6</A>  The call stack</H2><!--SEC END --><P>Each time the program performs a function application, it saves the
location of the application (the return address) in a block of data
called a stack frame. The frame also contains the local variables of
the caller function. All the frames are allocated in a region of
memory called the call stack. The command <TT>backtrace</TT> (or <TT>bt</TT>)
displays parts of the call stack.</P><P>At any time, one of the stack frames is &#X201C;selected&#X201D; by the debugger; several
debugger commands refer implicitly to the selected frame. In particular,
whenever you ask the debugger for the value of a local variable, the
value is found in the selected frame. The commands <TT>frame</TT>, <TT>up</TT> and <TT>down</TT>
select whichever frame you are interested in.</P><P>When the program stops, the debugger automatically selects the
currently executing frame and describes it briefly as the <TT>frame</TT>
command does.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>frame</B></TT></DT><DD CLASS="dd-description">
Describe the currently selected stack frame.</DD><DT CLASS="dt-description"><B><TT>frame</TT> <I>frame-number</I></B></DT><DD CLASS="dd-description">
Select a stack frame by number and describe it. The frame currently
executing when the program stopped has number 0; its caller has number
1; and so on up the call stack.</DD><DT CLASS="dt-description"><B><TT>backtrace </TT>[<I>count</I>], <TT>bt </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Print the call stack. This is useful to see which sequence of function
calls led to the currently executing frame. With a positive argument,
print only the innermost <I>count</I> frames.
With a negative argument, print only the outermost -<I>count</I> frames.</DD><DT CLASS="dt-description"><B><TT>up</TT> [<I>count</I>]</B></DT><DD CLASS="dd-description">
Select and display the stack frame just &#X201C;above&#X201D; the selected frame,
that is, the frame that called the selected frame. An argument says how
many frames to go up.</DD><DT CLASS="dt-description"><B><TT>down </TT>[<I>count</I>]</B></DT><DD CLASS="dd-description">
Select and display the stack frame just &#X201C;below&#X201D; the selected frame,
that is, the frame that was called by the selected frame. An argument
says how many frames to go down.
</DD></DL><!--TOC section Examining variable values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc198">16.7</A>  Examining variable values</H2><!--SEC END --><P>The debugger can print the current value of simple expressions. The
expressions can involve program variables: all the identifiers that
are in scope at the selected program point can be accessed.</P><P>Expressions that can be printed are a subset of OCaml
expressions, as described by the following grammar:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>
<I><A NAME="simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP>
<FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> { <FONT COLOR=maroon><I>capitalized-ident</I></FONT> <FONT COLOR=blue><TT>.</TT></FONT> }  <FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>*</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>$</TT></FONT> <FONT COLOR=maroon><I>integer</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I> <FONT COLOR=blue><TT>.</TT></FONT>  <FONT COLOR=maroon><I>lowercase-ident</I></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I> <FONT COLOR=blue><TT>.(</TT></FONT>  <FONT COLOR=maroon><I>integer</I></FONT> <FONT COLOR=blue><TT>)</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <I><A HREF="#simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I> <FONT COLOR=blue><TT>.[</TT></FONT>  <FONT COLOR=maroon><I>integer</I></FONT> <FONT COLOR=blue><TT>]</TT></FONT>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>!</TT></FONT> <I><A HREF="#simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I>
 </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X2223;</TD><TD ALIGN=left NOWRAP> <FONT COLOR=blue><TT>(</TT></FONT> <I><A HREF="#simple-expr"><FONT COLOR=maroon>simple-expr</FONT></A></I> <FONT COLOR=blue><TT>)</TT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
The first two cases refer to a value identifier, either unqualified or
qualified by the path to the structure that define it.
<TT>*</TT> refers to the result just computed (typically, the value of a
function application), and is valid only if the selected event is an
&#X201C;after&#X201D; event (typically, a function application).
<FONT COLOR=blue><TT>$</TT></FONT> <FONT COLOR=maroon><I>integer</I></FONT> refer to a previously printed value. The remaining four
forms select part of an expression: respectively, a record field, an
array element, a string element, and the current contents of a
reference.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>print </TT><I>variables</I></B></DT><DD CLASS="dd-description">
Print the values of the given variables. <TT>print</TT> can be abbreviated as
<TT>p</TT>.
</DD><DT CLASS="dt-description"><B><TT>display </TT><I>variables</I></B></DT><DD CLASS="dd-description">
Same as <TT>print</TT>, but limit the depth of printing to 1. Useful to
browse large data structures without printing them in full.
<TT>display</TT> can be abbreviated as <TT>d</TT>.
</DD></DL><P>When printing a complex expression, a name of the form <TT>$</TT><I>integer</I>
is automatically assigned to its value. Such names are also assigned
to parts of the value that cannot be printed because the maximal
printing depth is exceeded. Named values can be printed later on
with the commands <TT>p $</TT><I>integer</I> or <TT>d $</TT><I>integer</I>.
Named values are valid only as long as the program is stopped. They
are forgotten as soon as the program resumes execution.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set print_depth</TT> <I>d</I></B></DT><DD CLASS="dd-description">
Limit the printing of values to a maximal depth of <I>d</I>. 
</DD><DT CLASS="dt-description"><B><TT>set print_length</TT> <I>l</I></B></DT><DD CLASS="dd-description">
Limit the printing of values to at most <I>l</I> nodes printed.
</DD></DL><!--TOC section Controlling the debugger-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc199">16.8</A>  Controlling the debugger</H2><!--SEC END --><!--TOC subsection Setting the program name and arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc200">16.8.1</A>  Setting the program name and arguments</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set program</TT> <I>file</I></B></DT><DD CLASS="dd-description">
Set the program name to <I>file</I>.
</DD><DT CLASS="dt-description"><B><TT>set arguments</TT> <I>arguments</I></B></DT><DD CLASS="dd-description">
Give <I>arguments</I> as command-line arguments for the program.
</DD></DL><P>A shell is used to pass the arguments to the debugged program. You can
therefore use wildcards, shell variables, and file redirections inside
the arguments. To debug programs that read from standard input, it is
recommended to redirect their input from a file (using
<TT>set arguments &lt; input-file</TT>), otherwise input to the program and
input to the debugger are not properly separated, and inputs are not
properly replayed when running the program backwards.</P><!--TOC subsection How programs are loaded-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc201">16.8.2</A>  How programs are loaded</H3><!--SEC END --><P>The <TT>loadingmode</TT> variable controls how the program is executed.</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>set loadingmode direct</B></TT></DT><DD CLASS="dd-description">
The program is run directly by the debugger. This is the default mode.
</DD><DT CLASS="dt-description"><TT><B>set loadingmode runtime</B></TT></DT><DD CLASS="dd-description">
The debugger execute the OCaml runtime <TT>ocamlrun</TT> on the program.
Rarely useful; moreover it prevents the debugging of programs compiled
in &#X201C;custom runtime&#X201D; mode.
</DD><DT CLASS="dt-description"><TT><B>set loadingmode manual</B></TT></DT><DD CLASS="dd-description">
The user starts manually the program, when asked by the debugger.
Allows remote debugging (see section <A HREF="#s:communication">16.8.6</A>).
</DD></DL><!--TOC subsection Search path for files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc202">16.8.3</A>  Search path for files</H3><!--SEC END --><P>The debugger searches for source files and compiled interface files in
a list of directories, the search path. The search path initially
contains the current directory <TT>.</TT> and the standard library directory.
The <TT>directory</TT> command adds directories to the path.</P><P>Whenever the search path is modified, the debugger will clear any
information it may have cached about the files.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>directory</TT> <I>directorynames</I></B></DT><DD CLASS="dd-description">
Add the given directories to the search path. These directories are
added at the front, and will therefore be searched first.</DD><DT CLASS="dt-description"><B><TT>directory</TT> <I>directorynames</I> <TT>for</TT> <I>modulename</I></B></DT><DD CLASS="dd-description">
Same as <TT>directory</TT> <I>directorynames</I>, but the given directories will be
searched only when looking for the source file of a module that has 
been packed into <I>modulename</I>.</DD><DT CLASS="dt-description"><TT><B>directory</B></TT></DT><DD CLASS="dd-description">
Reset the search path. This requires confirmation.
</DD></DL><!--TOC subsection Working directory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc203">16.8.4</A>  Working directory</H3><!--SEC END --><P>Each time a program is started in the debugger, it inherits its working
directory from the current working directory of the debugger. This
working directory is initially whatever it inherited from its parent
process (typically the shell), but you can specify a new working
directory in the debugger with the <TT>cd</TT> command or the <TT>-cd</TT>
command-line option.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>cd</TT> <I>directory</I></B></DT><DD CLASS="dd-description">
Set the working directory for <TT>camldebug</TT> to <I>directory</I>.</DD><DT CLASS="dt-description"><TT><B>pwd</B></TT></DT><DD CLASS="dd-description">
Print the working directory for <TT>camldebug</TT>.
</DD></DL><!--TOC subsection Turning reverse execution on and off-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc204">16.8.5</A>  Turning reverse execution on and off</H3><!--SEC END --><P>In some cases, you may want to turn reverse execution off. This speeds
up the program execution, and is also sometimes useful for interactive
programs. </P><P>Normally, the debugger takes checkpoints of the program state from
time to time. That is, it makes a copy of the current state of the
program (using the Unix system call <TT>fork</TT>). If the variable
<I>checkpoints</I> is set to <TT>off</TT>, the debugger will not take any
checkpoints.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set checkpoints</TT> <I>on/off</I></B></DT><DD CLASS="dd-description">
Select whether the debugger makes checkpoints or not.
</DD></DL><!--TOC subsection Communication between the debugger and the program-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc205">16.8.6</A>  Communication between the debugger and the program</H3><!--SEC END --><P>
<A NAME="s:communication"></A></P><P>The debugger communicate with the program being debugged through a
Unix socket. You may need to change the socket name, for example if
you need to run the debugger on a machine and your program on another.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set socket</TT> <I>socket</I></B></DT><DD CLASS="dd-description">
Use <I>socket</I> for communication with the program. <I>socket</I> can be
either a file name, or an Internet port specification
<I>host</I>:<I>port</I>, where <I>host</I> is a host name or an Internet
address in dot notation, and <I>port</I> is a port number on the host.
</DD></DL><P>On the debugged program side, the socket name is passed through the
<TT>CAML_DEBUG_SOCKET</TT> environment variable.</P><!--TOC subsection Fine-tuning the debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc206">16.8.7</A>  Fine-tuning the debugger</H3><!--SEC END --><P> <A NAME="s:fine-tuning"></A></P><P>Several variables enables to fine-tune the debugger. Reasonable
defaults are provided, and you should normally not have to change them.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set processcount</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the maximum number of checkpoints to <I>count</I>. More checkpoints
facilitate going far back in time, but use more memory and create more
Unix processes.
</DD></DL><P>As checkpointing is quite expensive, it must not be done too often. On
the other hand, backward execution is faster when checkpoints are
taken more often. In particular, backward single-stepping is more
responsive when many checkpoints have been taken just before the
current time. To fine-tune the checkpointing strategy, the debugger
does not take checkpoints at the same frequency for long displacements
(e.g. <TT>run</TT>) and small ones (e.g. <TT>step</TT>). The two variables <TT>bigstep</TT>
and <TT>smallstep</TT> contain the number of events between two checkpoints
in each case.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>set bigstep</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the number of events between two checkpoints for long displacements.
</DD><DT CLASS="dt-description"><B><TT>set smallstep</TT> <I>count</I></B></DT><DD CLASS="dd-description">
Set the number of events between two checkpoints for small
displacements.
</DD></DL><P>The following commands display information on checkpoints and events:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>info checkpoints</B></TT></DT><DD CLASS="dd-description">
Print a list of checkpoints.
</DD><DT CLASS="dt-description"><B><TT>info events</TT> [<I>module</I>]</B></DT><DD CLASS="dd-description">
Print the list of events in the given module (the current module, by default).
</DD></DL><!--TOC subsection User-defined printers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc207">16.8.8</A>  User-defined printers</H3><!--SEC END --><P>Just as in the toplevel system (section <A HREF="#s:toplevel-directives">9.2</A>),
the user can register functions for printing values of certain types.
For technical reasons, the debugger cannot call printing functions
that reside in the program being debugged. The code for the printing
functions must therefore be loaded explicitly in the debugger.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>load_printer "</TT><I>file-name</I><TT>"</TT></B></DT><DD CLASS="dd-description">
Load in the debugger the indicated <TT>.cmo</TT> or <TT>.cma</TT> object file. The
file is loaded in an environment consisting only of the OCaml
standard library plus the definitions provided by object files
previously loaded using <TT>load_printer</TT>. If this file depends on other
object files not yet loaded, the debugger automatically loads them if
it is able to find them in the search path. The loaded file does not
have direct access to the modules of the program being debugged.</DD><DT CLASS="dt-description"><B><TT>install_printer </TT><I>printer-name</I></B></DT><DD CLASS="dd-description">
Register the function named <I>printer-name</I> (a
value path) as a printer for objects whose types match the argument
type of the function. That is, the debugger will call
<I>printer-name</I> when it has such an object to print.
The printing function <I>printer-name</I> must use the <TT>Format</TT> library
module to produce its output, otherwise its output will not be
correctly located in the values printed by the toplevel loop.<P>The value path <I>printer-name</I> must refer to one of the functions
defined by the object files loaded using <TT>load_printer</TT>. It cannot
reference the functions of the program being debugged.</P></DD><DT CLASS="dt-description"><B><TT>remove_printer </TT><I>printer-name</I></B></DT><DD CLASS="dd-description">
Remove the named function from the table of value printers.
</DD></DL><!--TOC section Miscellaneous commands-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc208">16.9</A>  Miscellaneous commands</H2><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>list</TT> [<I>module</I>] [<I>beginning</I>] [<I>end</I>]</B></DT><DD CLASS="dd-description">
List the source of module <I>module</I>, from line number
<I>beginning</I> to line number <I>end</I>. By default, 20 lines of the
current module are displayed, starting 10 lines before the current
position.
</DD><DT CLASS="dt-description"><B><TT>source</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Read debugger commands from the script <I>filename</I>.
</DD></DL><!--TOC section Running the debugger under Emacs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc209">16.10</A>  Running the debugger under Emacs</H2><!--SEC END --><P> <A NAME="s:inf-debugger"></A></P><P>The most user-friendly way to use the debugger is to run it under Emacs.
See the file <TT>emacs/README</TT> in the distribution for information on how
to load the Emacs Lisp files for Caml support.</P><P>The Caml debugger is started under Emacs by the command <TT>M-x camldebug</TT>, with argument the name of the executable file
<I>progname</I> to debug. Communication with the debugger takes place
in an Emacs buffer named <TT>*camldebug-</TT><I>progname</I><TT>*</TT>. The editing
and history facilities of Shell mode are available for interacting
with the debugger.</P><P>In addition, Emacs displays the source files containing the current
event (the current position in the program execution) and highlights
the location of the event. This display is updated synchronously with
the debugger action.</P><P>The following bindings for the most common debugger commands are
available in the <TT>*camldebug-</TT><I>progname</I><TT>*</TT> buffer:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>C-c C-s</B></TT></DT><DD CLASS="dd-description"> (command <TT>step</TT>): execute the program one step forward.
</DD><DT CLASS="dt-description"><TT><B>C-c C-k</B></TT></DT><DD CLASS="dd-description"> (command <TT>backstep</TT>): execute the program one step backward.
</DD><DT CLASS="dt-description"><TT><B>C-c C-n</B></TT></DT><DD CLASS="dd-description"> (command <TT>next</TT>): execute the program one step
forward, skipping over function calls.
</DD><DT CLASS="dt-description"><B>Middle mouse button</B></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display named value.
<TT>$</TT><I>n</I> under mouse cursor (support incremental browsing of large
data structures).
</DD><DT CLASS="dt-description"><TT><B>C-c C-p</B></TT></DT><DD CLASS="dd-description"> (command <TT>print</TT>): print value of identifier at point.
</DD><DT CLASS="dt-description"><TT><B>C-c C-d</B></TT></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display value of identifier at point.
</DD><DT CLASS="dt-description"><TT><B>C-c C-r</B></TT></DT><DD CLASS="dd-description"> (command <TT>run</TT>): execute the program forward to next
breakpoint.
</DD><DT CLASS="dt-description"><TT><B>C-c C-v</B></TT></DT><DD CLASS="dd-description"> (command <TT>reverse</TT>): execute the program backward to
latest breakpoint.
</DD><DT CLASS="dt-description"><TT><B>C-c C-l</B></TT></DT><DD CLASS="dd-description"> (command <TT>last</TT>): go back one step in the command history.
</DD><DT CLASS="dt-description"><TT><B>C-c C-t</B></TT></DT><DD CLASS="dd-description"> (command <TT>backtrace</TT>): display backtrace of function calls.
</DD><DT CLASS="dt-description"><TT><B>C-c C-f</B></TT></DT><DD CLASS="dd-description"> (command <TT>finish</TT>): run forward till the current
function returns.
</DD><DT CLASS="dt-description"><TT><B>C-c &lt;</B></TT></DT><DD CLASS="dd-description"> (command <TT>up</TT>): select the stack frame below the
current frame.
</DD><DT CLASS="dt-description"><TT><B>C-c &gt;</B></TT></DT><DD CLASS="dd-description"> (command <TT>down</TT>): select the stack frame above the
current frame.
</DD></DL><P>In all buffers in Caml editing mode, the following debugger commands
are also available:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>C-x C-a C-b</B></TT></DT><DD CLASS="dd-description"> (command <TT>break</TT>): set a breakpoint at event closest
to point
</DD><DT CLASS="dt-description"><TT><B>C-x C-a C-p</B></TT></DT><DD CLASS="dd-description"> (command <TT>print</TT>): print value of identifier at point
</DD><DT CLASS="dt-description"><TT><B>C-x C-a C-d</B></TT></DT><DD CLASS="dd-description"> (command <TT>display</TT>): display value of identifier at point
</DD></DL><!--TOC chapter Profiling (ocamlprof)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc210">Chapter 17</A>  Profiling (ocamlprof)</H1><!--SEC END --><P> <A NAME="c:profiler"></A>
</P><P>This chapter describes how the execution of OCaml
programs can be profiled, by recording how many times functions are
called, branches of conditionals are taken, &#X2026;</P><!--TOC section Compiling for profiling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc211">17.1</A>  Compiling for profiling</H2><!--SEC END --><P>Before profiling an execution, the program must be compiled in
profiling mode, using the <TT>ocamlcp</TT> front-end to the <TT>ocamlc</TT> compiler
(see chapter <A HREF="#c:camlc">8</A>). When compiling modules separately,
<TT>ocamlcp</TT> must be used when compiling the modules (production
of <TT>.cmo</TT> files), and can also be used (though this is not strictly
necessary) when linking them together.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> If a module (<TT>.ml</TT> file) doesn&#X2019;t have a corresponding
interface (<TT>.mli</TT> file), then compiling it with <TT>ocamlcp</TT> will produce
object files (<TT>.cmi</TT> and <TT>.cmo</TT>) that are not compatible with the ones
produced by <TT>ocamlc</TT>, which may lead to problems (if the <TT>.cmi</TT> or
<TT>.cmo</TT> is still around) when switching between profiling and
non-profiling compilations. To avoid this problem, you should always
have a <TT>.mli</TT> file for each <TT>.ml</TT> file.</P><!--TOC paragraph Note-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note</H5><!--SEC END --><P> To make sure your programs can be compiled in
profiling mode, avoid using any identifier that begins with
<TT>__ocaml_prof</TT>.</P><P>The amount of profiling information can be controlled through the <TT>-p</TT>
option to <TT>ocamlcp</TT>, followed by one or several letters indicating which
parts of the program should be profiled:</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>a</B></TT></DT><DD CLASS="dd-description"> all options
</DD><DT CLASS="dt-description"><TT><B>f</B></TT></DT><DD CLASS="dd-description"> function calls : a count point is set at the beginning of
each function body
</DD><DT CLASS="dt-description"><TT><B>i</B></TT></DT><DD CLASS="dd-description"> <B>if &#X2026;then &#X2026;else &#X2026;</B> : count points are set in
both <B>then</B> branch and <B>else</B> branch
</DD><DT CLASS="dt-description"><TT><B>l</B></TT></DT><DD CLASS="dd-description"> <B>while, for</B> loops: a count point is set at the beginning of
the loop body
</DD><DT CLASS="dt-description"><TT><B>m</B></TT></DT><DD CLASS="dd-description"> <B>match</B> branches: a count point is set at the beginning of the
body of each branch
</DD><DT CLASS="dt-description"><TT><B>t</B></TT></DT><DD CLASS="dd-description"> <B>try &#X2026;with &#X2026;</B> branches: a count point is set at the
beginning of the body of each branch
</DD></DL><P>For instance, compiling with <TT>ocamlcp -p film</TT> profiles function calls,
if&#X2026;then&#X2026;else&#X2026;, loops and pattern matching.</P><P>Calling <TT>ocamlcp</TT> without the <TT>-p</TT> option defaults to <TT>-p fm</TT>, meaning
that only function calls and pattern matching are profiled.</P><P><B>Note:</B> Due to the implementation of streams and stream patterns as
syntactic sugar, it is hard to predict what parts of stream expressions
and patterns will be profiled by a given flag. To profile a program with
streams, we recommend using <TT>ocamlcp -p a</TT>.</P><!--TOC section Profiling an execution-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc212">17.2</A>  Profiling an execution</H2><!--SEC END --><P>Running a bytecode executable file that has been compiled with <TT>ocamlcp</TT>
records the execution counts for the specified parts of the program
and saves them in a file called <TT>ocamlprof.dump</TT> in the current directory.</P><P>If the environment variable <TT>OCAMLPROF_DUMP</TT> is set when the program
exits, its value is used as the file name instead of <TT>ocamlprof.dump</TT>.</P><P>The dump file is written only if the program terminates
normally (by calling <TT>exit</TT> or by falling through). It is not written
if the program terminates with an <TT>uncaught exception</TT>.</P><P>If a compatible dump file already exists in the current directory, then the
profiling information is accumulated in this dump file. This allows, for
instance, the profiling of several executions of a program on
different inputs.</P><!--TOC section Printing profiling information-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc213">17.3</A>  Printing profiling information</H2><!--SEC END --><P>The <TT>ocamlprof</TT> command produces a source listing of the program modules
where execution counts have been inserted as comments. For instance,
</P><PRE CLASS="verbatim">        ocamlprof foo.ml
</PRE><P>prints the source code for the <TT>foo</TT> module, with comments indicating
how many times the functions in this module have been called. Naturally,
this information is accurate only if the source file has not been modified
since the profiling execution took place.</P><P>The following options are recognized by <TT>ocamlprof</TT>:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-f</TT> <I>dumpfile</I></B></DT><DD CLASS="dd-description"> 
Specifies an alternate dump file of profiling information to be read.</DD><DT CLASS="dt-description"><B><TT>-F</TT> <I>string</I></B></DT><DD CLASS="dd-description">
Specifies an additional string to be output with profiling information.
By default, <TT>ocamlprof</TT> will annotate programs with comments of the form
<TT>(* <I>n</I> *)</TT> where <I>n</I> is the counter value for a profiling
point. With option <TT>-F <I>s</I></TT>, the annotation will be
<TT>(* <I>sn</I> *)</TT>.</DD><DT CLASS="dt-description"><B><TT>-impl</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an implementation file, even if its
extension is not <TT>.ml</TT>.</DD><DT CLASS="dt-description"><B><TT>-intf</TT> <I>filename</I></B></DT><DD CLASS="dd-description">
Process the file <I>filename</I> as an interface file, even if its
extension is not <TT>.mli</TT>.</DD><DT CLASS="dt-description"><TT><B>-version</B></TT></DT><DD CLASS="dd-description">
Print version string and exit.</DD><DT CLASS="dt-description"><TT><B>-vnum</B></TT></DT><DD CLASS="dd-description">
Print short version number and exit.</DD><DT CLASS="dt-description"><B><TT>-help</TT> or <TT>--help</TT></B></DT><DD CLASS="dd-description">
Display a short usage summary and exit.
</DD></DL><!--TOC section Time profiling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc214">17.4</A>  Time profiling</H2><!--SEC END --><P>Profiling with <TT>ocamlprof</TT> only records execution counts, not the actual
time spent into each function. There is currently no way to perform
time profiling on bytecode programs generated by <TT>ocamlc</TT>.</P><P>Native-code programs generated by <TT>ocamlopt</TT> can be profiled for time
and execution counts using the <TT>-p</TT> option and the standard Unix
profiler <TT>gprof</TT>. Just add the <TT>-p</TT> option when compiling and linking
the program:
</P><PRE>
        ocamlopt -o myprog -p <I>other-options files</I>
        ./myprog
        gprof myprog
</PRE><P>
Caml function names in the output of <TT>gprof</TT> have the following format:
</P><PRE>
        <I>Module-name</I>_<I>function-name</I>_<I>unique-number</I>
</PRE><P>
Other functions shown are either parts of the Caml run-time system or
external C functions linked with the program.</P><P>The output of <TT>gprof</TT> is described in the Unix manual page for
<TT>gprof(1)</TT>. It generally consists of two parts: a &#X201C;flat&#X201D; profile
showing the time spent in each function and the number of invocation
of each function, and a &#X201C;hierarchical&#X201D; profile based on the call
graph. Currently, only the Intel x86/Linux and Alpha/Digital Unix
ports of <TT>ocamlopt</TT> support the two profiles. On other platforms,
<TT>gprof</TT> will report only the &#X201C;flat&#X201D; profile with just time
information. When reading the output of <TT>gprof</TT>, keep in mind that
the accumulated times computed by <TT>gprof</TT> are based on heuristics and
may not be exact.

</P><!--TOC chapter Interfacing C with OCaml-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc215">Chapter 18</A>  Interfacing<A NAME="c:intf-c"></A> C with OCaml</H1><!--SEC END --><P>This chapter describes how user-defined primitives, written in C, can
be linked with Caml code and called from Caml functions.</P><!--TOC section Overview and compilation information-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc216">18.1</A>  Overview and compilation information</H2><!--SEC END --><!--TOC subsection Declaring primitives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc217">18.1.1</A>  Declaring primitives</H3><!--SEC END --><P>
User primitives are declared in an implementation file or
<TT>struct</TT>&#X2026;<TT>end</TT> module expression using the <TT>external</TT> keyword:
</P><PRE>
        external <I>name</I> : <I>type</I> = <I>C-function-name</I>
</PRE><P>
This defines the value name <I>name</I> as a function with type
<I>type</I> that executes by calling the given C function.
For instance, here is how the <TT>input</TT> primitive is declared in the
standard library module <TT>Pervasives</TT>:
</P><PRE CLASS="verbatim">        external input : in_channel -&gt; string -&gt; int -&gt; int -&gt; int
                       = "input"
</PRE><P>Primitives with several arguments are always curried. The C function
does not necessarily have the same name as the ML function.</P><P>External functions thus defined can be specified in interface files or
<TT>sig</TT>&#X2026;<TT>end</TT> signatures either as regular values
</P><PRE>
        val <I>name</I> : <I>type</I>
</PRE><P>
thus hiding their implementation as a C function, or explicitly as
&#X201C;manifest&#X201D; external functions
</P><PRE>
        external <I>name</I> : <I>type</I> = <I>C-function-name</I>
</PRE><P>
The latter is slightly more efficient, as it allows clients of the
module to call directly the C function instead of going through the
corresponding Caml function. </P><P>The arity (number of arguments) of a primitive is automatically
determined from its Caml type in the <TT>external</TT> declaration, by
counting the number of function arrows in the type. For instance,
<TT>input</TT> above has arity 4, and the <TT>input</TT> C function is called with
four arguments. Similarly,
</P><PRE CLASS="verbatim">    external input2 : in_channel * string * int * int -&gt; int = "input2"
</PRE><P>has arity 1, and the <TT>input2</TT> C function receives one argument (which
is a quadruple of Caml values).</P><P>Type abbreviations are not expanded when determining the arity of a
primitive. For instance,
</P><PRE CLASS="verbatim">        type int_endo = int -&gt; int
        external f : int_endo -&gt; int_endo = "f"
        external g : (int -&gt; int) -&gt; (int -&gt; int) = "f"
</PRE><P><TT>f</TT> has arity 1, but <TT>g</TT> has arity 2. This allows a primitive to
return a functional value (as in the <TT>f</TT> example above): just remember
to name the functional return type in a type abbreviation.</P><!--TOC subsection Implementing primitives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc218">18.1.2</A>  Implementing primitives</H3><!--SEC END --><P>User primitives with arity <I>n</I> &#X2264; 5 are implemented by C functions
that take <I>n</I> arguments of type <TT>value</TT>, and return a result of type
<TT>value</TT>. The type <TT>value</TT> is the type of the representations for Caml
values. It encodes objects of several base types (integers,
floating-point numbers, strings, &#X2026;), as well as Caml data
structures. The type <TT>value</TT> and the associated conversion
functions and macros are described in details below. For instance,
here is the declaration for the C function implementing the <TT>input</TT>
primitive:
</P><PRE CLASS="verbatim">CAMLprim value input(value channel, value buffer, value offset, value length)
{
  ...
}
</PRE><P>When the primitive function is applied in a Caml program, the C
function is called with the values of the expressions to which the
primitive is applied as arguments. The value returned by the function is
passed back to the Caml program as the result of the function
application.</P><P>User primitives with arity greater than 5 should be implemented by two
C functions. The first function, to be used in conjunction with the
bytecode compiler <TT>ocamlc</TT>, receives two arguments: a pointer to an
array of Caml values (the values for the arguments), and an
integer which is the number of arguments provided. The other function,
to be used in conjunction with the native-code compiler <TT>ocamlopt</TT>,
takes its arguments directly. For instance, here are the two C
functions for the 7-argument primitive <TT>Nat.add_nat</TT>:
</P><PRE CLASS="verbatim">CAMLprim value add_nat_native(value nat1, value ofs1, value len1,
                              value nat2, value ofs2, value len2,
                              value carry_in)
{
  ...
}
CAMLprim value add_nat_bytecode(value * argv, int argn)
{
  return add_nat_native(argv[0], argv[1], argv[2], argv[3],
                        argv[4], argv[5], argv[6]);
}
</PRE><P>The names of the two C functions must be given in the primitive
declaration, as follows:
</P><PRE>
        external <I>name</I> : <I>type</I> =
                 <I>bytecode-C-function-name native-code-C-function-name</I>
</PRE><P>
For instance, in the case of <TT>add_nat</TT>, the declaration is:
</P><PRE CLASS="verbatim">        external add_nat: nat -&gt; int -&gt; int -&gt; nat -&gt; int -&gt; int -&gt; int -&gt; int
                        = "add_nat_bytecode" "add_nat_native"
</PRE><P>Implementing a user primitive is actually two separate tasks: on the
one hand, decoding the arguments to extract C values from the given
Caml values, and encoding the return value as a Caml 
value; on the other hand, actually computing the result from the arguments.
Except for very simple primitives, it is often preferable to have two
distinct C functions to implement these two tasks. The first function
actually implements the primitive, taking native C values as
arguments and returning a native C value. The second function,
often called the &#X201C;stub code&#X201D;, is a simple wrapper around the first
function that converts its arguments from Caml values to C values,
call the first function, and convert the returned C value to Caml
value. For instance, here is the stub code for the <TT>input</TT>
primitive:
</P><PRE CLASS="verbatim">CAMLprim value input(value channel, value buffer, value offset, value length)
{
  return Val_long(getblock((struct channel *) channel,
                           &amp;Byte(buffer, Long_val(offset)),
                           Long_val(length)));
}
</PRE><P>(Here, <TT>Val_long</TT>, <TT>Long_val</TT> and so on are conversion macros for the
type <TT>value</TT>, that will be described later. The <TT>CAMLprim</TT> macro
expands to the required compiler directives to ensure that the
function following it is exported and accessible from Caml.)
The hard work is performed by the function <TT>getblock</TT>, which is
declared as:
</P><PRE CLASS="verbatim">long getblock(struct channel * channel, char * p, long n)
{
  ...
}
</PRE><P>To write C code that operates on OCaml values, the following
include files are provided:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Include file</B></TD><TD ALIGN=center NOWRAP><B>Provides</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>caml/mlvalues.h</TT></TD><TD VALIGN=top ALIGN=left>definition of the <TT>value</TT> type, and conversion macros</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/alloc.h</TT></TD><TD VALIGN=top ALIGN=left>allocation functions (to create structured Caml
objects)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/memory.h</TT></TD><TD VALIGN=top ALIGN=left>miscellaneous memory-related functions
and macros (for GC interface, in-place modification of structures, etc).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/fail.h</TT></TD><TD VALIGN=top ALIGN=left>functions for raising exceptions
(see section <A HREF="#s:c-exceptions">18.4.5</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/callback.h</TT></TD><TD VALIGN=top ALIGN=left>callback from C to Caml (see
section <A HREF="#s:callback">18.7</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/custom.h</TT></TD><TD VALIGN=top ALIGN=left>operations on custom blocks (see
section <A HREF="#s:custom">18.9</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/intext.h</TT></TD><TD VALIGN=top ALIGN=left>operations for writing user-defined
serialization and deserialization functions for custom blocks
(see section <A HREF="#s:custom">18.9</A>).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml/threads.h</TT></TD><TD VALIGN=top ALIGN=left>operations for interfacing in the presence
of multiple threads (see section <A HREF="#s:C-multithreading">18.10</A>).</TD></TR>
</TABLE></DIV><P>
These files reside in the <TT>caml/</TT> subdirectory of the OCaml
standard library directory (usually <TT>/usr/local/lib/ocaml</TT>).</P><!--TOC subsection Statically linking C code with Caml code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc219">18.1.3</A>  Statically linking C code with Caml code</H3><!--SEC END --><P>
<A NAME="staticlink-c-code"></A></P><P>The OCaml runtime system comprises three main parts: the bytecode
interpreter, the memory manager, and a set of C functions that
implement the primitive operations. Some bytecode instructions are
provided to call these C functions, designated by their offset in a
table of functions (the table of primitives).</P><P>In the default mode, the Caml linker produces bytecode for the
standard runtime system, with a standard set of primitives. References
to primitives that are not in this standard set result in the
&#X201C;unavailable C primitive&#X201D; error. (Unless dynamic loading of C
libraries is supported &#X2013; see section <A HREF="#dynlink-c-code">18.1.4</A> below.)</P><P>In the &#X201C;custom runtime&#X201D; mode, the Caml linker scans the
object files and determines the set of required primitives. Then, it
builds a suitable runtime system, by calling the native code linker with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the table of the required primitives;
</LI><LI CLASS="li-itemize">a library that provides the bytecode interpreter, the
memory manager, and the standard primitives;
</LI><LI CLASS="li-itemize">libraries and object code files (<TT>.o</TT> files) mentioned on the
command line for the Caml linker, that provide implementations
for the user&#X2019;s primitives.
</LI></UL><P>
This builds a runtime system with the required primitives. The Caml
linker generates bytecode for this custom runtime system. The
bytecode is appended to the end of the custom runtime system, so that
it will be automatically executed when the output file (custom
runtime + bytecode) is launched.</P><P>To link in &#X201C;custom runtime&#X201D; mode, execute the <TT>ocamlc</TT> command with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the <TT>-custom</TT> option;
</LI><LI CLASS="li-itemize">the names of the desired Caml object files (<TT>.cmo</TT> and <TT>.cma</TT> files) ;
</LI><LI CLASS="li-itemize">the names of the C object files and libraries (<TT>.o</TT> and <TT>.a</TT>
files) that implement the required primitives. Under Unix and Windows,
a library named <TT>lib</TT><I>name</I><TT>.a</TT> (respectively, <TT>.lib</TT>) residing in one of the standard library directories can also be specified as <TT>-cclib -l</TT><I>name</I>.
</LI></UL><P>If you are using the native-code compiler <TT>ocamlopt</TT>, the <TT>-custom</TT>
flag is not needed, as the final linking phase of <TT>ocamlopt</TT> always
builds a standalone executable. To build a mixed Caml/C executable,
execute the <TT>ocamlopt</TT> command with:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the names of the desired Caml native object files (<TT>.cmx</TT> and
<TT>.cmxa</TT> files);
</LI><LI CLASS="li-itemize">the names of the C object files and libraries (<TT>.o</TT>, <TT>.a</TT>,
<TT>.so</TT> or <TT>.dll</TT> files) that implement the required primitives.
</LI></UL><P>Starting with Objective Caml 3.00, it is possible to record the
<TT>-custom</TT> option as well as the names of C libraries in a Caml
library file <TT>.cma</TT> or <TT>.cmxa</TT>. For instance, consider a Caml library
<TT>mylib.cma</TT>, built from the Caml object files <TT>a.cmo</TT> and <TT>b.cmo</TT>,
which reference C code in <TT>libmylib.a</TT>. If the library is
built as follows:
</P><PRE>
        ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib
</PRE><P>
users of the library can simply link with <TT>mylib.cma</TT>:
</P><PRE>
        ocamlc -o myprog mylib.cma ...
</PRE><P>
and the system will automatically add the <TT>-custom</TT> and <TT>-cclib -lmylib</TT> options, achieving the same effect as
</P><PRE>
        ocamlc -o myprog -custom a.cmo b.cmo ... -cclib -lmylib
</PRE><P>
The alternative, of course, is to build the library without extra
options:
</P><PRE>
        ocamlc -a -o mylib.cma a.cmo b.cmo
</PRE><P>
and then ask users to provide the <TT>-custom</TT> and <TT>-cclib -lmylib</TT>
options themselves at link-time:
</P><PRE>
        ocamlc -o myprog -custom mylib.cma ... -cclib -lmylib
</PRE><P>
The former alternative is more convenient for the final users of the
library, however.</P><!--TOC subsection Dynamically linking C code with Caml code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc220">18.1.4</A>  Dynamically linking C code with Caml code</H3><!--SEC END --><P>
<A NAME="dynlink-c-code"></A></P><P>Starting with Objective Caml 3.03, an alternative to static linking of C code
using the <TT>-custom</TT> code is provided. In this mode, the Caml linker
generates a pure bytecode executable (no embedded custom runtime
system) that simply records the names of dynamically-loaded libraries
containing the C code. The standard Caml runtime system <TT>ocamlrun</TT>
then loads dynamically these libraries, and resolves references to the
required primitives, before executing the bytecode.</P><P>This facility is currently supported and known to work well under
Linux, MacOS X, and Windows. It is supported, but not
fully tested yet, under FreeBSD, Tru64, Solaris and Irix. It is not
supported yet under other Unixes.</P><P>To dynamically link C code with Caml code, the C code must first be
compiled into a shared library (under Unix) or DLL (under Windows).
This involves 1- compiling the C files with appropriate C compiler
flags for producing position-independent code (when required by the
operating system), and 2- building a
shared library from the resulting object files. The resulting shared
library or DLL file must be installed in a place where <TT>ocamlrun</TT> can
find it later at program start-up time (see
section <A HREF="#s-ocamlrun-dllpath">10.3</A>).
Finally (step 3), execute the <TT>ocamlc</TT> command with
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the names of the desired Caml object files (<TT>.cmo</TT> and <TT>.cma</TT> files) ;
</LI><LI CLASS="li-itemize">the names of the C shared libraries (<TT>.so</TT> or <TT>.dll</TT> files) that
implement the required primitives. Under Unix and Windows, 
a library named <TT>dll</TT><I>name</I><TT>.so</TT> (respectively, <TT>.dll</TT>) residing
in one of the standard library directories can also be specified as
<TT>-dllib -l</TT><I>name</I>.
</LI></UL><P>
Do <EM>not</EM> set the <TT>-custom</TT> flag, otherwise you&#X2019;re back to static linking
as described in section <A HREF="#staticlink-c-code">18.1.3</A>.
The <TT>ocamlmklib</TT> tool (see section <A HREF="#s-ocamlmklib">18.11</A>)
automates steps 2 and 3.</P><P>As in the case of static linking, it is possible (and recommended) to
record the names of C libraries in a Caml <TT>.cma</TT> library archive. 
Consider again a Caml library
<TT>mylib.cma</TT>, built from the Caml object files <TT>a.cmo</TT> and <TT>b.cmo</TT>,
which reference C code in <TT>dllmylib.so</TT>. If the library is
built as follows:
</P><PRE>
        ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib
</PRE><P>
users of the library can simply link with <TT>mylib.cma</TT>:
</P><PRE>
        ocamlc -o myprog mylib.cma ...
</PRE><P>
and the system will automatically add the <TT>-dllib -lmylib</TT> option,
achieving the same effect as
</P><PRE>
        ocamlc -o myprog a.cmo b.cmo ... -dllib -lmylib
</PRE><P>
Using this mechanism, users of the library <TT>mylib.cma</TT> do not need to
known that it references C code, nor whether this C code must be
statically linked (using <TT>-custom</TT>) or dynamically linked.</P><!--TOC subsection Choosing between static linking and dynamic linking-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc221">18.1.5</A>  Choosing between static linking and dynamic linking</H3><!--SEC END --><P>After having described two different ways of linking C code with Caml
code, we now review the pros and cons of each, to help developers of
mixed Caml/C libraries decide.</P><P>The main advantage of dynamic linking is that it preserves the
platform-independence of bytecode executables. That is, the bytecode
executable contains no machine code, and can therefore be compiled on
platform <I>A</I> and executed on other platforms <I>B</I>, <I>C</I>, &#X2026;, as long
as the required shared libraries are available on all these
platforms. In contrast, executables generated by <TT>ocamlc -custom</TT> run
only on the platform on which they were created, because they embark a
custom-tailored runtime system specific to that platform. In
addition, dynamic linking results in smaller executables.</P><P>Another advantage of dynamic linking is that the final users of the
library do not need to have a C compiler, C linker, and C runtime
libraries installed on their machines. This is no big deal under 
Unix and Cygwin, but many Windows users are reluctant to install
Microsoft Visual C just to be able to do <TT>ocamlc -custom</TT>.</P><P>There are two drawbacks to dynamic linking. The first is that the
resulting executable is not stand-alone: it requires the shared
libraries, as well as <TT>ocamlrun</TT>, to be installed on the machine
executing the code. If you wish to distribute a stand-alone
executable, it is better to link it statically, using <TT>ocamlc -custom -ccopt -static</TT> or <TT>ocamlopt -ccopt -static</TT>. Dynamic linking also
raises the &#X201C;DLL hell&#X201D; problem: some care must be taken to ensure
that the right versions of the shared libraries are found at start-up
time.</P><P>The second drawback of dynamic linking is that it complicates the
construction of the library. The C compiler and linker flags to
compile to position-independent code and build a shared library vary
wildly between different Unix systems. Also, dynamic linking is not
supported on all Unix systems, requiring a fall-back case to static
linking in the Makefile for the library. The <TT>ocamlmklib</TT> command
(see section <A HREF="#s-ocamlmklib">18.11</A>) tries to hide some of these system
dependencies.</P><P>In conclusion: dynamic linking is highly recommended under the native
Windows port, because there are no portability problems and it is much
more convenient for the end users. Under Unix, dynamic linking should
be considered for mature, frequently used libraries because it
enhances platform-independence of bytecode executables. For new or
rarely-used libraries, static linking is much simpler to set up in a
portable way.</P><!--TOC subsection Building standalone custom runtime systems-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc222">18.1.6</A>  Building standalone custom runtime systems</H3><!--SEC END --><P>
<A NAME="s:custom-runtime"></A></P><P>It is sometimes inconvenient to build a custom runtime system each
time Caml code is linked with C libraries, like <TT>ocamlc -custom</TT> does.
For one thing, the building of the runtime system is slow on some
systems (that have bad linkers or slow remote file systems); for
another thing, the platform-independence of bytecode files is lost,
forcing to perform one <TT>ocamlc -custom</TT> link per platform of interest.</P><P>An alternative to <TT>ocamlc -custom</TT> is to build separately a custom
runtime system integrating the desired C libraries, then generate
&#X201C;pure&#X201D; bytecode executables (not containing their own runtime
system) that can run on this custom runtime. This is achieved by the
<TT>-make_runtime</TT> and <TT>-use_runtime</TT> flags to <TT>ocamlc</TT>. For example,
to build a custom runtime system integrating the C parts of the
&#X201C;Unix&#X201D; and &#X201C;Threads&#X201D; libraries, do:
</P><PRE CLASS="verbatim">        ocamlc -make-runtime -o /home/me/ocamlunixrun unix.cma threads.cma
</PRE><P>To generate a bytecode executable that runs on this runtime system,
do:
</P><PRE>
        ocamlc -use-runtime /home/me/ocamlunixrun -o myprog \
                unix.cma threads.cma <I>your .cmo and .cma files</I>
</PRE><P>
The bytecode executable <TT>myprog</TT> can then be launched as usual:
<TT>myprog</TT> <I>args</I> or <TT>/home/me/ocamlunixrun myprog</TT> <I>args</I>.</P><P>Notice that the bytecode libraries <TT>unix.cma</TT> and <TT>threads.cma</TT> must
be given twice: when building the runtime system (so that <TT>ocamlc</TT>
knows which C primitives are required) and also when building the
bytecode executable (so that the bytecode from <TT>unix.cma</TT> and
<TT>threads.cma</TT> is actually linked in).</P><!--TOC section The <TT>value</TT> type-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc223">18.2</A>  The <TT>value</TT> type</H2><!--SEC END --><P>All Caml objects are represented by the C type <TT>value</TT>,
defined in the include file <TT>caml/mlvalues.h</TT>, along with macros to
manipulate values of that type. An object of type <TT>value</TT> is either:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
an unboxed integer;
</LI><LI CLASS="li-itemize">a pointer to a block inside the heap (such as the blocks
allocated through one of the <CODE>caml_alloc_*</CODE> functions below);
</LI><LI CLASS="li-itemize">a pointer to an object outside the heap (e.g., a pointer to a block
allocated by <TT>malloc</TT>, or to a C variable).
</LI></UL><!--TOC subsection Integer values-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc224">18.2.1</A>  Integer values</H3><!--SEC END --><P>Integer values encode 31-bit signed integers (63-bit on 64-bit
architectures). They are unboxed (unallocated).</P><!--TOC subsection Blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc225">18.2.2</A>  Blocks</H3><!--SEC END --><P>Blocks in the heap are garbage-collected, and therefore have strict
structure constraints. Each block includes a header containing the
size of the block (in words), and the tag of the block.
The tag governs how the contents of the blocks are structured. A tag
lower than <TT>No_scan_tag</TT> indicates a structured block, containing
well-formed values, which is recursively traversed by the garbage
collector. A tag greater than or equal to <TT>No_scan_tag</TT> indicates a
raw block, whose contents are not scanned by the garbage collector.
For the benefits of ad-hoc polymorphic primitives such as equality and
structured input-output, structured and raw blocks are further
classified according to their tags as follows:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Tag</B></TD><TD ALIGN=center NOWRAP><B>Contents of the block</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
0 to <TT>No_scan_tag</TT>&#X2212;1</TD><TD VALIGN=top ALIGN=left>A structured block (an array of
Caml objects). Each field is a <TT>value</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Closure_tag</TT></TD><TD VALIGN=top ALIGN=left>A closure representing a functional value. The first
word is a pointer to a piece of code, the remaining words are
<TT>value</TT> containing the environment.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>String_tag</TT></TD><TD VALIGN=top ALIGN=left>A character string.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Double_tag</TT></TD><TD VALIGN=top ALIGN=left>A double-precision floating-point number.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Double_array_tag</TT></TD><TD VALIGN=top ALIGN=left>An array or record of double-precision
floating-point numbers.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Abstract_tag</TT></TD><TD VALIGN=top ALIGN=left>A block representing an abstract datatype.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Custom_tag</TT></TD><TD VALIGN=top ALIGN=left>A block representing an abstract datatype
with user-defined finalization, comparison, hashing,
serialization and deserialization functions atttached.</TD></TR>
</TABLE></DIV><!--TOC subsection Pointers outside the heap-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc226">18.2.3</A>  Pointers outside the heap</H3><!--SEC END --><P>Any word-aligned pointer to an address outside the heap can be safely
cast to and from the type <TT>value</TT>. This includes pointers returned by
<TT>malloc</TT>, and pointers to C variables (of size at least one word)
obtained with the <CODE>&amp;</CODE> operator.</P><P>Caution: if a pointer returned by <TT>malloc</TT> is cast to the type <TT>value</TT>
and returned to Caml, explicit deallocation of the pointer using
<TT>free</TT> is potentially dangerous, because the pointer may still be
accessible from the Caml world. Worse, the memory space deallocated
by <TT>free</TT> can later be reallocated as part of the Caml heap; the
pointer, formerly pointing outside the Caml heap, now points inside
the Caml heap, and this can confuse the garbage collector. To avoid
these problems, it is preferable to wrap the pointer in a Caml block
with tag <TT>Abstract_tag</TT> or <TT>Custom_tag</TT>.</P><!--TOC section Representation of Caml data types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc227">18.3</A>  Representation of Caml data types</H2><!--SEC END --><P>This section describes how Caml data types are encoded in the
<TT>value</TT> type.</P><!--TOC subsection Atomic types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc228">18.3.1</A>  Atomic types</H3><!--SEC END --><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Caml type</B></TD><TD ALIGN=center NOWRAP><B>Encoding</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>int</TT></TD><TD ALIGN=left NOWRAP>Unboxed integer values.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>char</TT></TD><TD ALIGN=left NOWRAP>Unboxed integer values (ASCII code).</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>float</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Double_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>string</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>String_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>int32</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>int64</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>nativeint</TT></TD><TD ALIGN=left NOWRAP>Blocks with tag <TT>Custom_tag</TT>.</TD></TR>
</TABLE></DIV><!--TOC subsection Tuples and records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc229">18.3.2</A>  Tuples and records</H3><!--SEC END --><P>Tuples are represented by pointers to blocks, with tag 0.</P><P>Records are also represented by zero-tagged blocks. The ordering of
labels in the record type declaration determines the layout of
the record fields: the value associated to the label
declared first is stored in field 0 of the block, the value associated
to the label declared next goes in field 1, and so on.</P><P>As an optimization, records whose fields all have static type <TT>float</TT>
are represented as arrays of floating-point numbers, with tag
<TT>Double_array_tag</TT>. (See the section below on arrays.)</P><!--TOC subsection Arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc230">18.3.3</A>  Arrays</H3><!--SEC END --><P>Arrays of integers and pointers are represented like tuples, 
that is, as pointers to blocks tagged 0. They are accessed with the
<TT>Field</TT> macro for reading and the <TT>caml_modify</TT> function for writing.</P><P>Arrays of floating-point numbers (type <TT>float array</TT>)
have a special, unboxed, more efficient representation.
These arrays are represented by pointers to blocks with tag
<TT>Double_array_tag</TT>. They should be accessed with the <TT>Double_field</TT>
and <TT>Store_double_field</TT> macros.</P><!--TOC subsection Concrete data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc231">18.3.4</A>  Concrete data types</H3><!--SEC END --><P>Constructed terms are represented either by unboxed integers (for
constant constructors) or by blocks whose tag encode the constructor
(for non-constant constructors). The constant constructors and the
non-constant constructors for a given concrete type are numbered
separately, starting from 0, in the order in which they appear in the
concrete type declaration. Constant constructors are represented by
unboxed integers equal to the constructor number. A non-constant
constructors declared with <I>n</I> arguments is represented by
a block of size <I>n</I>, tagged with the constructor number; the <I>n</I>
fields contain its arguments. Example:</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constructed term</B></TD><TD ALIGN=center NOWRAP><B>Representation</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>()</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>false</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>true</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(1)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>[]</TT></TD><TD VALIGN=top ALIGN=left><TT>Val_int(0)</TT>.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>h::t</TT></TD><TD VALIGN=top ALIGN=left>Block with size = 2 and tag = 0; first field
contains <TT>h</TT>, second field <TT>t</TT>.</TD></TR>
</TABLE></DIV><P>As a convenience, <TT>caml/mlvalues.h</TT> defines the macros <TT>Val_unit</TT>,
<TT>Val_false</TT> and <TT>Val_true</TT> to refer to <TT>()</TT>, <TT>false</TT> and <TT>true</TT>.</P><P>The following artificial example illustrates the assignment of
integers and block tags to constructors:
</P><PRE CLASS="verbatim">type t =
  | A             (* First constant constructor -&gt; integer "Val_int(0)" *)
  | B of string   (* First non-constant constructor -&gt; block with tag 0 *)
  | C             (* Second constant constructor -&gt; integer "Val_int(1)" *)
  | D of bool     (* Second non-constant constructor -&gt; block with tag 1 *)
  | E of t * t    (* Third non-constant constructor -&gt; block with tag 2 *)
</PRE><!--TOC subsection Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc232">18.3.5</A>  Objects</H3><!--SEC END --><P>Objects are represented as blocks with tag <TT>Object_tag</TT>. The first
field of the block refers to the object class and associated method
suite, in a format that cannot easily be exploited from C. The second
field contains a unique object ID, used for comparisons. The remaining
fields of the object contain the values of the instance variables of
the object. It is unsafe to access directly instance variables, as the
type system provides no guaranteee about the instance variables
contained by an object.
</P><P>One may extract a public method from an object using the C function
<TT>caml_get_public_method</TT> (declared in <TT>&lt;caml/mlvalues.h&gt;</TT>.)
Since public method tags are hashed in the same way as variant tags,
and methods are functions taking self as first argument, if you want
to do the method call <TT>foo#bar</TT> from the C side, you should call:
</P><PRE CLASS="verbatim">  callback(caml_get_public_method(foo, hash_variant("bar")), foo);
</PRE><!--TOC subsection Polymorphic variants-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc233">18.3.6</A>  Polymorphic variants</H3><!--SEC END --><P>Like constructed terms, polymorphic variant values are represented either
as integers (for polymorphic variants without arguments), or as blocks
(for polymorphic variants with an argument). Unlike constructed
terms, variant constructors are not numbered starting from 0, but
identified by a hash value (a Caml integer), as computed by the C function
<TT>hash_variant</TT> (declared in <TT>&lt;caml/mlvalues.h&gt;</TT>):
the hash value for a variant constructor named, say, <TT>VConstr</TT>
is <TT>hash_variant("VConstr")</TT>.</P><P>The variant value <TT>&#X2018;VConstr</TT> is represented by
<TT>hash_variant("VConstr")</TT>. The variant value <TT>&#X2018;VConstr(</TT><I>v</I><TT>)</TT> is
represented by a block of size 2 and tag 0, with field number 0
containing <TT>hash_variant("VConstr")</TT> and field number 1 containing
<I>v</I>.</P><P>Unlike constructed values, polymorphic variant values taking several
arguments are not flattened.
That is, <TT>&#X2018;VConstr(</TT><I>v</I><TT>, </TT><I>v&#X2019;</I><TT>)</TT> is represented by a block
of size 2, whose field number 1 contains the representation of the
pair <TT>(</TT><I>v</I><TT>, </TT><I>v&#X2019;</I><TT>)</TT>, rather than a block of size 3
containing <I>v</I> and <I>v&#X2019;</I> in fields 1 and 2.</P><!--TOC section Operations on values-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc234">18.4</A>  Operations on values</H2><!--SEC END --><!--TOC subsection Kind tests-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc235">18.4.1</A>  Kind tests</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Is_long(</TT><I>v</I><TT>)</TT> is true if value <I>v</I> is an immediate integer,
false otherwise
</LI><LI CLASS="li-itemize"><TT>Is_block(</TT><I>v</I><TT>)</TT> is true if value <I>v</I> is a pointer to a block,
and false if it is an immediate integer.
</LI></UL><!--TOC subsection Operations on integers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc236">18.4.2</A>  Operations on integers</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Val_long(</TT><I>l</I><TT>)</TT> returns the value encoding the <TT>long int</TT> <I>l</I>.
</LI><LI CLASS="li-itemize"><TT>Long_val(</TT><I>v</I><TT>)</TT> returns the <TT>long int</TT> encoded in value <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Val_int(</TT><I>i</I><TT>)</TT> returns the value encoding the <TT>int</TT> <I>i</I>.
</LI><LI CLASS="li-itemize"><TT>Int_val(</TT><I>v</I><TT>)</TT> returns the <TT>int</TT> encoded in value <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Val_bool(</TT><I>x</I><TT>)</TT> returns the Caml boolean representing the
truth value of the C integer <I>x</I>.
</LI><LI CLASS="li-itemize"><TT>Bool_val(</TT><I>v</I><TT>)</TT> returns 0 if <I>v</I> is the Caml boolean
<TT>false</TT>, 1 if <I>v</I> is <TT>true</TT>.
</LI><LI CLASS="li-itemize"><TT>Val_true</TT>, <TT>Val_false</TT> represent the Caml booleans <TT>true</TT> and <TT>false</TT>.
</LI></UL><!--TOC subsection Accessing blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc237">18.4.3</A>  Accessing blocks</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Wosize_val(</TT><I>v</I><TT>)</TT> returns the size of the block <I>v</I>, in words,
excluding the header.
</LI><LI CLASS="li-itemize"><TT>Tag_val(</TT><I>v</I><TT>)</TT> returns the tag of the block <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the value contained in the
<I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> field of the structured block <I>v</I>. Fields are numbered from 0 to
<TT>Wosize_val</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>Store_field(</TT><I>b</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT> stores the value
<I>v</I> in the field number <I>n</I> of value <I>b</I>, which must be a
structured block.
</LI><LI CLASS="li-itemize"><TT>Code_val(</TT><I>v</I><TT>)</TT> returns the code part of the closure <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>caml_string_length(</TT><I>v</I><TT>)</TT> returns the length (number of characters)
of the string <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Byte(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> character of the string
<I>v</I>, with type <TT>char</TT>. Characters are numbered from 0 to
<TT>string_length</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>Byte_u(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> character of the string
<I>v</I>, with type <TT>unsigned char</TT>. Characters are numbered from 0 to
<TT>string_length</TT>(<I>v</I>)&#X2212;1.
</LI><LI CLASS="li-itemize"><TT>String_val(</TT><I>v</I><TT>)</TT> returns a pointer to the first byte of the string
<I>v</I>, with type <TT>char *</TT>. This pointer is a valid C string: there is a
null character after the last character in the string. However, Caml
strings can contain embedded null characters, that will confuse
the usual C functions over strings. 
</LI><LI CLASS="li-itemize"><TT>Double_val(</TT><I>v</I><TT>)</TT> returns the floating-point number contained in
value <I>v</I>, with type <TT>double</TT>.
</LI><LI CLASS="li-itemize"><TT>Double_field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> returns
the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> element of the array of floating-point numbers <I>v</I> (a
block tagged <TT>Double_array_tag</TT>).
</LI><LI CLASS="li-itemize"><TT>Store_double_field(</TT><I>v</I><TT>, </TT><I>n</I><TT>, </TT><I>d</I><TT>)</TT> stores the double precision floating-point number <I>d</I>
in the <I>n</I><FONT SIZE=2><SUP>th</SUP></FONT> element of the array of floating-point numbers <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Data_custom_val(</TT><I>v</I><TT>)</TT> returns a pointer to the data part
of the custom block <I>v</I>. This pointer has type <TT>void *</TT> and must
be cast to the type of the data contained in the custom block.
</LI><LI CLASS="li-itemize"><TT>Int32_val(</TT><I>v</I><TT>)</TT> returns the 32-bit integer contained
in the <TT>int32</TT> <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Int64_val(</TT><I>v</I><TT>)</TT> returns the 64-bit integer contained
in the <TT>int64</TT> <I>v</I>.
</LI><LI CLASS="li-itemize"><TT>Nativeint_val(</TT><I>v</I><TT>)</TT> returns the long integer contained
in the <TT>nativeint</TT> <I>v</I>.
</LI></UL><P>
The expressions <TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT>,
<TT>Byte(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> and
<TT>Byte_u(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT>
are valid l-values. Hence, they can be assigned to, resulting in an
in-place modification of value <I>v</I>.
Assigning directly to <TT>Field(</TT><I>v</I><TT>, </TT><I>n</I><TT>)</TT> must
be done with care to avoid confusing the garbage collector (see
below).</P><!--TOC subsection Allocating blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc238">18.4.4</A>  Allocating blocks</H3><!--SEC END --><!--TOC subsubsection Simple interface-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Simple interface</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Atom(</TT><I>t</I><TT>)</TT> returns an &#X201C;atom&#X201D; (zero-sized block) with tag <I>t</I>.
Zero-sized blocks are preallocated outside of the heap. It is
incorrect to try and allocate a zero-sized block using the functions below.
For instance, <TT>Atom(0)</TT> represents the empty array.
</LI><LI CLASS="li-itemize"><TT>caml_alloc(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh block of size <I>n</I>
with tag <I>t</I>. If <I>t</I> is less than <TT>No_scan_tag</TT>, then the
fields of the block are initialized with a valid value in order to
satisfy the GC constraints.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_tuple(</TT><I>n</I><TT>)</TT> returns a fresh block of size
<I>n</I> words, with tag 0.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_string(</TT><I>n</I><TT>)</TT> returns a string value of length <I>n</I> characters.
The string initially contains garbage.
</LI><LI CLASS="li-itemize"><TT>caml_copy_string(</TT><I>s</I><TT>)</TT> returns a string value containing a copy of
the null-terminated C string <I>s</I> (a <TT>char *</TT>).
</LI><LI CLASS="li-itemize"><TT>caml_copy_double(</TT><I>d</I><TT>)</TT> returns a floating-point value initialized
with the <TT>double</TT> <I>d</I>.
</LI><LI CLASS="li-itemize"><TT>caml_copy_int32(</TT><I>i</I><TT>)</TT>, <TT>copy_int64(</TT><I>i</I><TT>)</TT> and
<TT>caml_copy_nativeint(</TT><I>i</I><TT>)</TT> return a value of Caml type <TT>int32</TT>,
<TT>int64</TT> and <TT>nativeint</TT>, respectively, initialized with the integer
<I>i</I>.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_array(</TT><I>f</I><TT>, </TT><I>a</I><TT>)</TT> allocates an array of values, calling
function <I>f</I> over each element of the input array <I>a</I> to transform it
into a value. The array <I>a</I> is an array of pointers terminated by the
null pointer. The function <I>f</I> receives each pointer as argument, and
returns a value. The zero-tagged block returned by
<TT>alloc_array(</TT><I>f</I><TT>, </TT><I>a</I><TT>)</TT> is filled with the values returned by the
successive calls to <I>f</I>. (This function must not be used to build
an array of floating-point numbers.)
</LI><LI CLASS="li-itemize"><TT>caml_copy_string_array(</TT><I>p</I><TT>)</TT> allocates an array of strings, copied from
the pointer to a string array <I>p</I> (a <CODE>char **</CODE>). <I>p</I> must
be NULL-terminated.
</LI></UL><!--TOC subsubsection Low-level interface-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Low-level interface</H4><!--SEC END --><P>The following functions are slightly more efficient than <TT>caml_alloc</TT>, but
also much more difficult to use.</P><P>From the standpoint of the allocation functions, blocks are divided
according to their size as zero-sized blocks, small blocks (with size
less than or equal to <CODE>Max_young_wosize</CODE>), and large blocks (with
size greater than <CODE>Max_young_wosize</CODE>). The constant
<CODE>Max_young_wosize</CODE> is declared in the include file <TT>mlvalues.h</TT>. It
is guaranteed to be at least 64 (words), so that any block with
constant size less than or equal to 64 can be assumed to be small. For
blocks whose size is computed at run-time, the size must be compared
against <CODE>Max_young_wosize</CODE> to determine the correct allocation procedure.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_alloc_small(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh small block of size
<I>n</I> &#X2264; <TT>Max_young_wosize</TT> words, with tag <I>t</I>. 
If this block is a structured block (i.e. if <I>t</I> &lt; <TT>No_scan_tag</TT>), then 
the fields of the block (initially containing garbage) must be initialized
with legal values (using direct assignment to the fields of the block)
before the next allocation.
</LI><LI CLASS="li-itemize"><TT>caml_alloc_shr(</TT><I>n</I><TT>, </TT><I>t</I><TT>)</TT> returns a fresh block of size
<I>n</I>, with tag <I>t</I>. 
The size of the block can be greater than <CODE>Max_young_wosize</CODE>. (It
can also be smaller, but in this case it is more efficient to call
<TT>caml_alloc_small</TT> instead of <TT>caml_alloc_shr</TT>.) 
If this block is a structured block (i.e. if <I>t</I> &lt; <TT>No_scan_tag</TT>), then 
the fields of the block (initially containing garbage) must be initialized
with legal values (using the <TT>caml_initialize</TT> function described below)
before the next allocation.
</LI></UL><!--TOC subsection Raising exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc239">18.4.5</A>  Raising exceptions</H3><!--SEC END --><P> <A NAME="s:c-exceptions"></A></P><P>Two functions are provided to raise two standard exceptions:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_failwith(</TT><I>s</I><TT>)</TT>, where <I>s</I> is a null-terminated C string (with
type <CODE>char *</CODE>), raises exception <TT>Failure</TT> with argument <I>s</I>.
</LI><LI CLASS="li-itemize"><TT>caml_invalid_argument(</TT><I>s</I><TT>)</TT>, where <I>s</I> is a null-terminated C
string (with type <CODE>char *</CODE>), raises exception <TT>Invalid_argument</TT>
with argument <I>s</I>.
</LI></UL><P>Raising arbitrary exceptions from C is more delicate: the
exception identifier is dynamically allocated by the Caml program, and
therefore must be communicated to the C function using the
registration facility described below in section <A HREF="#s:register-exn">18.7.3</A>.
Once the exception identifier is recovered in C, the following
functions actually raise the exception:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_raise_constant(</TT><I>id</I><TT>)</TT> raises the exception <I>id</I> with
no argument;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_arg(</TT><I>id</I><TT>, </TT><I>v</I><TT>)</TT> raises the exception
<I>id</I> with the Caml value <I>v</I> as argument;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_args(</TT><I>id</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT>
raises the exception <I>id</I> with the Caml values
<I>v</I><TT>[0]</TT>, &#X2026;, <I>v</I><TT>[</TT><I>n</I><TT>-1]</TT> as arguments;
</LI><LI CLASS="li-itemize"><TT>caml_raise_with_string(</TT><I>id</I><TT>, </TT><I>s</I><TT>)</TT>, where <I>s</I> is a
null-terminated C string, raises the exception <I>id</I> with a copy of
the C string <I>s</I> as argument.
</LI></UL><!--TOC section Living in harmony with the garbage collector-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc240">18.5</A>  Living in harmony with the garbage collector</H2><!--SEC END --><P>Unused blocks in the heap are automatically reclaimed by the garbage
collector. This requires some cooperation from C code that
manipulates heap-allocated blocks.</P><!--TOC subsection Simple interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc241">18.5.1</A>  Simple interface</H3><!--SEC END --><P>All the macros described in this section are declared in the
<TT>memory.h</TT> header file.</P><DIV CLASS="theorem"><B>Rule 1</B>  <EM>
A function that has parameters or local variables of type <TT>value</TT> must
begin with a call to one of the <TT>CAMLparam</TT> macros and return with
<TT>CAMLreturn</TT>, <TT>CAMLreturn0</TT>, or <TT>CAMLreturnT</TT>.
</EM></DIV><P>There are six <TT>CAMLparam</TT> macros: <TT>CAMLparam0</TT> to <TT>CAMLparam5</TT>, which
take zero to five arguments respectively. If your function has fewer
than 5 parameters of type <TT>value</TT>, use the corresponding macros
with these parameters as arguments. If your function has more than 5
parameters of type <TT>value</TT>, use <TT>CAMLparam5</TT> with five of these
parameters, and use one or more calls to the <TT>CAMLxparam</TT> macros for
the remaining parameters (<TT>CAMLxparam1</TT> to <TT>CAMLxparam5</TT>).</P><P>The macros <TT>CAMLreturn</TT>, <TT>CAMLreturn0</TT>, and <TT>CAMLreturnT</TT> are used to
replace the C
keyword <TT>return</TT>. Every occurence of <TT>return x</TT> must be replaced by
<TT>CAMLreturn (x)</TT> if <TT>x</TT> has type <TT>value</TT>, or <TT>CAMLreturnT (t, x)</TT>
(where <TT>t</TT> is the type of <TT>x</TT>); every occurence of <TT>return</TT> without
argument must be
replaced by <TT>CAMLreturn0</TT>. If your C function is a procedure (i.e. if
it returns void), you must insert <TT>CAMLreturn0</TT> at the end (to replace
C&#X2019;s implicit <TT>return</TT>).</P><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> some C compilers give bogus warnings about unused
variables <TT>caml__dummy_xxx</TT> at each use of <TT>CAMLparam</TT> and
<TT>CAMLlocal</TT>. You should ignore them.</P><P><BR>
</P><P>Example:
</P><PRE CLASS="verbatim">void foo (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  ...
  CAMLreturn0;
}
</PRE><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> if your function is a primitive with more than 5 arguments
for use with the byte-code runtime, its arguments are not <TT>value</TT>s and
must not be declared (they have types <TT>value *</TT> and <TT>int</TT>).</P><DIV CLASS="theorem"><B>Rule 2</B>  <EM>
Local variables of type <TT>value</TT> must be declared with one of the
<TT>CAMLlocal</TT> macros. Arrays of <TT>value</TT>s are declared with
<TT>CAMLlocalN</TT>. These macros must be used at the beginning of the
function, not in a nested block.
</EM></DIV><P>The macros <TT>CAMLlocal1</TT> to <TT>CAMLlocal5</TT> declare and initialize one to
five local variables of type <TT>value</TT>. The variable names are given as
arguments to the macros. <TT>CAMLlocalN(</TT><I>x</I><TT>, </TT><I>n</I><TT>)</TT> declares
and initializes a local variable of type <TT>value [</TT><I>n</I><TT>]</TT>. You can
use several calls to these macros if you have more than 5 local
variables.</P><P>Example:
</P><PRE CLASS="verbatim">value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  ...
  CAMLreturn (result);
}
</PRE><DIV CLASS="theorem"><B>Rule 3</B>  <EM>
Assignments to the fields of structured blocks must be done with the
<TT>Store_field</TT> macro (for normal blocks) or <TT>Store_double_field</TT> macro
(for arrays and records of floating-point numbers). Other assignments
must not use <TT>Store_field</TT> nor <TT>Store_double_field</TT>.
</EM></DIV><P><TT>Store_field (</TT><I>b</I><TT>, </TT><I>n</I><TT>, </TT><I>v</I><TT>)</TT> stores the value
<I>v</I> in the field number <I>n</I> of value <I>b</I>, which must be a
block (i.e. <TT>Is_block(</TT><I>b</I><TT>)</TT> must be true).</P><P>Example:
</P><PRE CLASS="verbatim">value bar (value v1, value v2, value v3)
{
  CAMLparam3 (v1, v2, v3);
  CAMLlocal1 (result);
  result = caml_alloc (3, 0);
  Store_field (result, 0, v1);
  Store_field (result, 1, v2);
  Store_field (result, 2, v3);
  CAMLreturn (result);
}
</PRE><!--TOC paragraph Warning:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Warning:</H5><!--SEC END --><P> The first argument of <TT>Store_field</TT> and
<TT>Store_double_field</TT> must be a variable declared by <TT>CAMLparam*</TT> or
a parameter declared by <TT>CAMLlocal*</TT> to ensure that a garbage
collection triggered by the evaluation of the other arguments will not
invalidate the first argument after it is computed.</P><DIV CLASS="theorem"><B>Rule 4</B>  <EM> Global variables containing values must be registered
with the garbage collector using the <TT>caml_register_global_root</TT> function.
</EM></DIV><P>Registration of a global variable <TT>v</TT> is achieved by calling
<TT>caml_register_global_root(&amp;v)</TT> just before or just after a valid
value is stored in <TT>v</TT> for the first time. You must not call any
of the OCaml runtime functions or macros between registering and
storing the value.</P><P>A registered global variable <TT>v</TT> can be un-registered by calling
<TT>caml_remove_global_root(&amp;v)</TT>.</P><P>If the contents of the global variable <TT>v</TT> are not modified after
registration, better performance can be achieved by calling
<TT>caml_register_generational_global_root(&amp;v)</TT> to register <TT>v</TT>,
and <TT>caml_remove_generational_global_root(&amp;v)</TT> to un-register it.
The garbage collector takes advantage of the guarantee that <TT>v</TT> is not
modified to scan it less often. This improves performance if many
global variables need to be registered.</P><!--TOC paragraph Note:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Note:</H5><!--SEC END --><P> The <TT>CAML</TT> macros use identifiers (local variables, type
identifiers, structure tags) that start with <TT>caml__</TT>. Do not use any
identifier starting with <TT>caml__</TT> in your programs.</P><!--TOC subsection Low-level interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc242">18.5.2</A>  Low-level interface</H3><!--SEC END --><P>We now give the GC rules corresponding to the low-level allocation
functions <TT>caml_alloc_small</TT> and <TT>caml_alloc_shr</TT>. You can ignore those rules
if you stick to the simplified allocation function <TT>caml_alloc</TT>.</P><DIV CLASS="theorem"><B>Rule 5</B>  <EM> After a structured block (a block with tag less than
<TT>No_scan_tag</TT>) is allocated with the low-level functions, all fields
of this block must be filled with well-formed values before the next
allocation operation. If the block has been allocated with
<TT>caml_alloc_small</TT>, filling is performed by direct assignment to the fields
of the block:
</EM><PRE><EM>
        Field(<I>v</I>, <I>n</I>) = <I>v<SUB>n</SUB></I>;
</EM></PRE><EM>
If the block has been allocated with <TT>caml_alloc_shr</TT>, filling is performed
through the <TT>caml_initialize</TT> function:
</EM><PRE><EM>
        caml_initialize(&amp;Field(<I>v</I>, <I>n</I>), <I>v<SUB>n</SUB></I>);
</EM></PRE>
</DIV><P>The next allocation can trigger a garbage collection. The garbage
collector assumes that all structured blocks contain well-formed
values. Newly created blocks contain random data, which generally do
not represent well-formed values.</P><P>If you really need to allocate before the fields can receive their
final value, first initialize with a constant value (e.g.
<TT>Val_unit</TT>), then allocate, then modify the fields with the correct
value (see rule 6).</P><DIV CLASS="theorem"><B>Rule 6</B>  <EM> Direct assignment to a field of a block, as in
</EM><PRE><EM>
        Field(<I>v</I>, <I>n</I>) = <I>w</I>;
</EM></PRE><EM>
is safe only if <I>v</I> is a block newly allocated by <TT>caml_alloc_small</TT>;
that is, if no allocation took place between the 
allocation of <I>v</I> and the assignment to the field. In all other cases,
never assign directly. If the block has just been allocated by <TT>caml_alloc_shr</TT>,
use <TT>caml_initialize</TT> to assign a value to a field for the first time:
</EM><PRE><EM>
        caml_initialize(&amp;Field(<I>v</I>, <I>n</I>), <I>w</I>);
</EM></PRE><EM>
Otherwise, you are updating a field that previously contained a
well-formed value; then, call the <TT>caml_modify</TT> function:
</EM><PRE><EM>
        caml_modify(&amp;Field(<I>v</I>, <I>n</I>), <I>w</I>);
</EM></PRE>
</DIV><P>To illustrate the rules above, here is a C function that builds and
returns a list containing the two integers given as parameters.
First, we write it using the simplified allocation functions:
</P><PRE CLASS="verbatim">value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc(2, 0);                   /* Allocate a cons cell */
  Store_field(r, 0, Val_int(i2));         /* car = the integer i2 */
  Store_field(r, 1, Val_int(0));          /* cdr = the empty list [] */
  result = caml_alloc(2, 0);              /* Allocate the other cons cell */
  Store_field(result, 0, Val_int(i1));    /* car = the integer i1 */
  Store_field(result, 1, r);              /* cdr = the first cons cell */
  CAMLreturn (result);
}
</PRE><P>Here, the registering of <TT>result</TT> is not strictly needed, because no
allocation takes place after it gets its value, but it&#X2019;s easier and
safer to simply register all the local variables that have type <TT>value</TT>.</P><P>Here is the same function written using the low-level allocation
functions. We notice that the cons cells are small blocks and can be
allocated with <TT>caml_alloc_small</TT>, and filled by direct assignments on
their fields.
</P><PRE CLASS="verbatim">value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (result, r);

  r = caml_alloc_small(2, 0);                  /* Allocate a cons cell */
  Field(r, 0) = Val_int(i2);              /* car = the integer i2 */
  Field(r, 1) = Val_int(0);               /* cdr = the empty list [] */
  result = caml_alloc_small(2, 0);        /* Allocate the other cons cell */
  Field(result, 0) = Val_int(i1);         /* car = the integer i1 */
  Field(result, 1) = r;                   /* cdr = the first cons cell */
  CAMLreturn (result);
}
</PRE><P>In the two examples above, the list is built bottom-up. Here is an
alternate way, that proceeds top-down. It is less efficient, but
illustrates the use of <TT>caml_modify</TT>.
</P><PRE CLASS="verbatim">value alloc_list_int(int i1, int i2)
{
  CAMLparam0 ();
  CAMLlocal2 (tail, r);

  r = caml_alloc_small(2, 0);             /* Allocate a cons cell */
  Field(r, 0) = Val_int(i1);              /* car = the integer i1 */
  Field(r, 1) = Val_int(0);               /* A dummy value
  tail = caml_alloc_small(2, 0);          /* Allocate the other cons cell */
  Field(tail, 0) = Val_int(i2);           /* car = the integer i2 */
  Field(tail, 1) = Val_int(0);            /* cdr = the empty list [] */
  caml_modify(&amp;Field(r, 1), tail);        /* cdr of the result = tail */
  CAMLreturn (r);
}
</PRE><P>It would be incorrect to perform
<TT>Field(r, 1) = tail</TT> directly, because the allocation of <TT>tail</TT>
has taken place since <TT>r</TT> was allocated.</P><!--TOC section A complete example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc243">18.6</A>  A complete example</H2><!--SEC END --><P>This section outlines how the functions from the Unix <TT>curses</TT> library
can be made available to OCaml programs. First of all, here is
the interface <TT>curses.mli</TT> that declares the <TT>curses</TT> primitives and
data types:
</P><PRE CLASS="verbatim">type window                   (* The type "window" remains abstract *)
external initscr: unit -&gt; window = "curses_initscr"
external endwin: unit -&gt; unit = "curses_endwin"
external refresh: unit -&gt; unit = "curses_refresh"
external wrefresh : window -&gt; unit = "curses_wrefresh"
external newwin: int -&gt; int -&gt; int -&gt; int -&gt; window = "curses_newwin"
external addch: char -&gt; unit = "curses_addch"
external mvwaddch: window -&gt; int -&gt; int -&gt; char -&gt; unit = "curses_mvwaddch"
external addstr: string -&gt; unit = "curses_addstr"
external mvwaddstr: window -&gt; int -&gt; int -&gt; string -&gt; unit = "curses_mvwaddstr"
(* lots more omitted *)
</PRE><P>To compile this interface:
</P><PRE CLASS="verbatim">        ocamlc -c curses.mli
</PRE><P>To implement these functions, we just have to provide the stub code;
the core functions are already implemented in the <TT>curses</TT> library.
The stub code file, <TT>curses_stubs.c</TT>, looks like this:
</P><PRE CLASS="verbatim">#include &lt;curses.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/custom.h&gt;

/* Encapsulation of opaque window handles (of type WINDOW *)
   as Caml custom blocks. */

static struct custom_operations curses_window_ops = {
  "fr.inria.caml.curses_windows",
  custom_finalize_default,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default
};

/* Accessing the WINDOW * part of a Caml custom block */
#define Window_val(v) (*((WINDOW **) Data_custom_val(v)))

/* Allocating a Caml custom block to hold the given WINDOW * */
static value alloc_window(WINDOW * w)
{
  value v = alloc_custom(&amp;curses_window_ops, sizeof(WINDOW *), 0, 1);
  Window_val(v) = w;
  return v;
}

value caml_curses_initscr(value unit)
{
  CAMLparam1 (unit);
  CAMLreturn (alloc_window(initscr()));
}

value caml_curses_endwin(value unit)
{
  CAMLparam1 (unit);
  endwin();
  CAMLreturn (Val_unit);
}

value caml_curses_refresh(value unit)
{
  CAMLparam1 (unit);
  refresh();
  CAMLreturn (Val_unit);
}

value caml_curses_wrefresh(value win)
{
  CAMLparam1 (win);
  wrefresh(Window_val(win));
  CAMLreturn (Val_unit);
}

value caml_curses_newwin(value nlines, value ncols, value x0, value y0)
{
  CAMLparam4 (nlines, ncols, x0, y0);
  CAMLreturn (alloc_window(newwin(Int_val(nlines), Int_val(ncols),
                                  Int_val(x0), Int_val(y0))));
}

value caml_curses_addch(value c)
{
  CAMLparam1 (c);
  addch(Int_val(c));            /* Characters are encoded like integers */
  CAMLreturn (Val_unit);
}

value caml_curses_mvwaddch(value win, value x, value y, value c)
{
  CAMLparam4 (win, x, y, c);
  mvwaddch(Window_val(win), Int_val(x), Int_val(y), Int_val(c));
  CAMLreturn (Val_unit);
}

value caml_curses_addstr(value s)
{
  CAMLparam1 (s);
  addstr(String_val(s));
  CAMLreturn (Val_unit);
}

value caml_curses_mvwaddstr(value win, value x, value y, value s)
{
  CAMLparam4 (win, x, y, s);
  mvwaddstr(Window_val(win), Int_val(x), Int_val(y), String_val(s));
  CAMLreturn (Val_unit);
}

/* This goes on for pages. */
</PRE><P>The file <TT>curses_stubs.c</TT> can be compiled with:
</P><PRE CLASS="verbatim">        cc -c -I`ocamlc -where` curses.c
</PRE><P>or, even simpler,
</P><PRE CLASS="verbatim">        ocamlc -c curses.c
</PRE><P>(When passed a <TT>.c</TT> file, the <TT>ocamlc</TT> command simply calls the C
compiler on that file, with the right <TT>-I</TT> option.)</P><P>Now, here is a sample Caml program <TT>test.ml</TT> that uses the <TT>curses</TT>
module:
</P><PRE CLASS="verbatim">open Curses
let main_window = initscr () in
let small_window = newwin 10 5 20 10 in
  mvwaddstr main_window 10 2 "Hello";
  mvwaddstr small_window 4 3 "world";
  refresh();
  Unix.sleep 5;
  endwin()
</PRE><P>To compile and link this program, run:
</P><PRE CLASS="verbatim">        ocamlc -custom -o test unix.cma test.ml curses_stubs.o -cclib -lcurses
</PRE><P>(On some machines, you may need to put <TT>-cclib -ltermcap</TT> or
<TT>-cclib -lcurses -cclib -ltermcap</TT> instead of <TT>-cclib -lcurses</TT>.)</P><!--TOC section Advanced topic: callbacks from C to Caml-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc244">18.7</A>  Advanced topic: callbacks from C to Caml</H2><!--SEC END --><P> <A NAME="s:callback"></A>
</P><P>So far, we have described how to call C functions from Caml. In this
section, we show how C functions can call Caml functions, either as
callbacks (Caml calls C which calls Caml), or because the main program
is written in C.</P><!--TOC subsection Applying Caml closures from C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc245">18.7.1</A>  Applying Caml closures from C</H3><!--SEC END --><P> <A NAME="s:callbacks"></A></P><P>C functions can apply Caml functional values (closures) to Caml values.
The following functions are provided to perform the applications:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_callback(</TT><I>f, a</I><TT>)</TT> applies the functional value <I>f</I> to
the value <I>a</I> and return the value returned by <I>f</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callback2(</TT><I>f, a, b</I><TT>)</TT> applies the functional value <I>f</I>
(which is assumed to be a curried Caml function with two arguments) to
<I>a</I> and <I>b</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callback3(</TT><I>f, a, b, c</I><TT>)</TT> applies the functional value <I>f</I>
(a curried Caml function with three arguments) to <I>a</I>, <I>b</I> and <I>c</I>.
</LI><LI CLASS="li-itemize"><TT>caml_callbackN(</TT><I>f, n, args</I><TT>)</TT> applies the functional value <I>f</I>
to the <I>n</I> arguments contained in the array of values <I>args</I>.
</LI></UL><P>
If the function <I>f</I> does not return, but raises an exception that
escapes the scope of the application, then this exception is
propagated to the next enclosing Caml code, skipping over the C
code. That is, if a Caml function <I>f</I> calls a C function <I>g</I> that
calls back a Caml function <I>h</I> that raises a stray exception, then the
execution of <I>g</I> is interrupted and the exception is propagated back
into <I>f</I>.</P><P>If the C code wishes to catch exceptions escaping the Caml function,
it can use the functions <TT>caml_callback_exn</TT>, <TT>caml_callback2_exn</TT>,
<TT>caml_callback3_exn</TT>, <TT>caml_callbackN_exn</TT>. These functions take the same
arguments as their non-<TT>_exn</TT> counterparts, but catch escaping
exceptions and return them to the C code. The return value <I>v</I> of the
<TT>caml_callback*_exn</TT> functions must be tested with the macro
<TT>Is_exception_result(</TT><I>v</I><TT>)</TT>. If the macro returns &#X201C;false&#X201D;, no
exception occured, and <I>v</I> is the value returned by the Caml
function. If <TT>Is_exception_result(</TT><I>v</I><TT>)</TT> returns &#X201C;true&#X201D;,
an exception escaped, and its value (the exception descriptor) can be
recovered using <TT>Extract_exception(</TT><I>v</I><TT>)</TT>.</P><!--TOC subsection Registering Caml closures for use in C functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc246">18.7.2</A>  Registering Caml closures for use in C functions</H3><!--SEC END --><P>The main difficulty with the <TT>callback</TT> functions described above is
obtaining a closure to the Caml function to be called. For this
purpose, OCaml provides a simple registration mechanism, by
which Caml code can register Caml functions under some global name,
and then C code can retrieve the corresponding closure by this global
name.</P><P>On the Caml side, registration is performed by evaluating
<TT>Callback.register</TT> <I>n v</I>. Here, <I>n</I> is the global name
(an arbitrary string) and <I>v</I> the Caml value. For instance:
</P><PRE CLASS="verbatim">    let f x = print_string "f is applied to "; print_int x; print_newline()
    let _ = Callback.register "test function" f
</PRE><P>On the C side, a pointer to the value registered under name <I>n</I> is
obtained by calling <TT>caml_named_value(</TT><I>n</I><TT>)</TT>. The returned
pointer must then be dereferenced to recover the actual Caml value.
If no value is registered under the name <I>n</I>, the null pointer is
returned. For example, here is a C wrapper that calls the Caml function <TT>f</TT>
above:
</P><PRE CLASS="verbatim">    void call_caml_f(int arg)
    {
        caml_callback(*caml_named_value("test function"), Val_int(arg));
    }
</PRE><P>The pointer returned by <TT>caml_named_value</TT> is constant and can safely
be cached in a C variable to avoid repeated name lookups. On the other
hand, the value pointed to can change during garbage collection and
must always be recomputed at the point of use. Here is a more
efficient variant of <TT>call_caml_f</TT> above that calls <TT>caml_named_value</TT>
only once:
</P><PRE CLASS="verbatim">    void call_caml_f(int arg)
    {
        static value * closure_f = NULL;
        if (closure_f == NULL) {
            /* First time around, look up by name */
            closure_f = caml_named_value("test function");
        }
        caml_callback(*closure_f, Val_int(arg));
    }
</PRE><!--TOC subsection Registering Caml exceptions for use in C functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc247">18.7.3</A>  Registering Caml exceptions for use in C functions</H3><!--SEC END --><P> <A NAME="s:register-exn"></A></P><P>The registration mechanism described above can also be used to
communicate exception identifiers from Caml to C. The Caml code
registers the exception by evaluating
<TT>Callback.register_exception</TT> <I>n exn</I>, where <I>n</I> is an
arbitrary name and <I>exn</I> is an exception value of the
exception to register. For example:
</P><PRE CLASS="verbatim">    exception Error of string
    let _ = Callback.register_exception "test exception" (Error "any string")
</PRE><P>The C code can then recover the exception identifier using
<TT>caml_named_value</TT> and pass it as first argument to the functions
<TT>raise_constant</TT>, <TT>raise_with_arg</TT>, and <TT>raise_with_string</TT> (described
in section <A HREF="#s:c-exceptions">18.4.5</A>) to actually raise the exception. For
example, here is a C function that raises the <TT>Error</TT> exception with
the given argument:
</P><PRE CLASS="verbatim">    void raise_error(char * msg)
    {
        caml_raise_with_string(*caml_named_value("test exception"), msg);
    }
</PRE><!--TOC subsection Main program in C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc248">18.7.4</A>  Main program in C</H3><!--SEC END --><P> <A NAME="s:main-c"></A></P><P>In normal operation, a mixed Caml/C program starts by executing the
Caml initialization code, which then may proceed to call C
functions. We say that the main program is the Caml code. In some
applications, it is desirable that the C code plays the role of the
main program, calling Caml functions when needed. This can be achieved as
follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The C part of the program must provide a <TT>main</TT> function,
which will override the default <TT>main</TT> function provided by the Caml
runtime system. Execution will start in the user-defined <TT>main</TT> function
just like for a regular C program.</LI><LI CLASS="li-itemize">At some point, the C code must call <TT>caml_main(argv)</TT> to
initialize the Caml code. The <TT>argv</TT> argument is a C array of strings
(type <TT>char **</TT>), terminated with a <TT>NULL</TT> pointer,
which represents the command-line arguments, as
passed as second argument to <TT>main</TT>. The Caml array <TT>Sys.argv</TT> will
be initialized from this parameter. For the bytecode compiler,
<TT>argv[0]</TT> and <TT>argv[1]</TT> are also consulted to find the file containing
the bytecode.</LI><LI CLASS="li-itemize">The call to <TT>caml_main</TT> initializes the Caml runtime system,
loads the bytecode (in the case of the bytecode compiler), and
executes the initialization code of the Caml program. Typically, this
initialization code registers callback functions using <TT>Callback.register</TT>.
Once the Caml initialization code is complete, control returns to the
C code that called <TT>caml_main</TT>.</LI><LI CLASS="li-itemize">The C code can then invoke Caml functions using the callback
mechanism (see section <A HREF="#s:callbacks">18.7.1</A>).
</LI></UL><!--TOC subsection Embedding the Caml code in the C code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc249">18.7.5</A>  Embedding the Caml code in the C code</H3><!--SEC END --><P> <A NAME="s:embedded-code"></A></P><P>The bytecode compiler in custom runtime mode (<TT>ocamlc -custom</TT>)
normally appends the bytecode to the executable file containing the
custom runtime. This has two consequences. First, the final linking
step must be performed by <TT>ocamlc</TT>. Second, the Caml runtime library
must be able to find the name of the executable file from the
command-line arguments. When using <TT>caml_main(argv)</TT> as in
section <A HREF="#s:main-c">18.7.4</A>, this means that <TT>argv[0]</TT> or <TT>argv[1]</TT> must
contain the executable file name.</P><P>An alternative is to embed the bytecode in the C code. The
<TT>-output-obj</TT> option to <TT>ocamlc</TT> is provided for this purpose. It
causes the <TT>ocamlc</TT> compiler to output a C object file (<TT>.o</TT> file,
<TT>.obj</TT> under Windows) containing the bytecode for the Caml part of the
program, as well as a <TT>caml_startup</TT> function. The C object file
produced by <TT>ocamlc -output-obj</TT> can then be linked with C code using
the standard C compiler, or stored in a C library.</P><P>The <TT>caml_startup</TT> function must be called from the main C program in
order to initialize the Caml runtime and execute the Caml
initialization code. Just like <TT>caml_main</TT>, it takes one <TT>argv</TT>
parameter containing the command-line parameters. Unlike <TT>caml_main</TT>,
this <TT>argv</TT> parameter is used only to initialize <TT>Sys.argv</TT>, but not
for finding the name of the executable file.</P><P>The <TT>-output-obj</TT> option can also be used to obtain the C source file.
More interestingly, the same option can also produce directly a shared
library (<TT>.so</TT> file, <TT>.dll</TT> under Windows) that contains the Caml
code, the Caml runtime system and any other static C code given to
<TT>ocamlc</TT> (<TT>.o</TT>, <TT>.a</TT>, respectively, <TT>.obj</TT>, <TT>.lib</TT>). This use of
<TT>-output-obj</TT> is very similar to a normal linking step, but instead of
producing a main program that automatically runs the Caml code, it
produces a shared library that can run the Caml code on demand. The
three possible behaviors of <TT>-output-obj</TT> are selected according
to the extension of the resulting file (given with <TT>-o</TT>).</P><P>The native-code compiler <TT>ocamlopt</TT> also supports the <TT>-output-obj</TT>
option, causing it to output a C object file or a shared library
containing the native code for all Caml modules on the command-line,
as well as the Caml startup code. Initialization is performed by
calling <TT>caml_startup</TT> as in the case of the bytecode compiler.</P><P>For the final linking phase, in addition to the object file produced
by <TT>-output-obj</TT>, you will have to provide the OCaml runtime
library (<TT>libcamlrun.a</TT> for bytecode, <TT>libasmrun.a</TT> for native-code),
as well as all C libraries that are required by the Caml libraries
used. For instance, assume the Caml part of your program uses the
Unix library. With <TT>ocamlc</TT>, you should do:
</P><PRE>
        ocamlc -output-obj -o camlcode.o unix.cma <I>other</I> .cmo <I>and</I> .cma <I>files</I>
        cc -o myprog <I>C objects and libraries</I> \
           camlcode.o -L/usr/local/lib/ocaml -lunix -lcamlrun
</PRE><P>
With <TT>ocamlopt</TT>, you should do:
</P><PRE>
        ocamlopt -output-obj -o camlcode.o unix.cmxa <I>other</I> .cmx <I>and</I> .cmxa <I>files</I>
        cc -o myprog <I>C objects and libraries</I> \
           camlcode.o -L/usr/local/lib/ocaml -lunix -lasmrun
</PRE><P>The shared libraries produced by <TT>ocamlc -output-obj</TT> or by <TT>ocamlopt -output-obj</TT> already contains the OCaml runtime library as
well as all the needed C libraries.</P><!--TOC paragraph Warning:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Warning:</H5><!--SEC END --><P> On some ports, special options are required on the final
linking phase that links together the object file produced by the
<TT>-output-obj</TT> option and the remainder of the program. Those options
are shown in the configuration file <TT>config/Makefile</TT> generated during
compilation of OCaml, as the variables <TT>BYTECCLINKOPTS</TT>
(for object files produced by <TT>ocamlc -output-obj</TT>) and
<TT>NATIVECCLINKOPTS</TT> (for object files produced by <TT>ocamlopt -output-obj</TT>). Currently, the only ports that require special
attention are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Alpha under Digital Unix / Tru64 Unix with <TT>gcc</TT>:
object files produced by <TT>ocamlc -output-obj</TT> must be linked with the
<TT>gcc</TT> options <TT>-Wl,-T,12000000 -Wl,-D,14000000</TT>.
This is not necessary for object files produced by <TT>ocamlopt -output-obj</TT>.
</LI><LI CLASS="li-itemize">Windows NT: the object file produced by OCaml have been
compiled with the <TT>/MD</TT> flag, and therefore all other object files
linked with it should also be compiled with <TT>/MD</TT>.
</LI></UL><!--TOC section Advanced example with callbacks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc250">18.8</A>  Advanced example with callbacks</H2><!--SEC END --><P>This section illustrates the callback facilities described in
section <A HREF="#s:callback">18.7</A>. We are going to package some Caml functions
in such a way that they can be linked with C code and called from C
just like any C functions. The Caml functions are defined in the
following <TT>mod.ml</TT> Caml source:</P><PRE CLASS="verbatim">(* File mod.ml -- some ``useful'' Caml functions *)

let rec fib n = if n &lt; 2 then 1 else fib(n-1) + fib(n-2)

let format_result n = Printf.sprintf "Result is: %d\n" n

(* Export those two functions to C *)

let _ = Callback.register "fib" fib
let _ = Callback.register "format_result" format_result
</PRE><P>Here is the C stub code for calling these functions from C:</P><PRE CLASS="verbatim">/* File modwrap.c -- wrappers around the Caml functions */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/callback.h&gt;

int fib(int n)
{
  static value * fib_closure = NULL;
  if (fib_closure == NULL) fib_closure = caml_named_value("fib");
  return Int_val(caml_callback(*fib_closure, Val_int(n)));
}

char * format_result(int n)
{
  static value * format_result_closure = NULL;
  if (format_result_closure == NULL)
    format_result_closure = caml_named_value("format_result");
  return strdup(String_val(caml_callback(*format_result_closure, Val_int(n))));
  /* We copy the C string returned by String_val to the C heap
     so that it remains valid after garbage collection. */
}
</PRE><P>We now compile the Caml code to a C object file and put it in a C
library along with the stub code in <TT>modwrap.c</TT> and the Caml runtime system:
</P><PRE CLASS="verbatim">        ocamlc -custom -output-obj -o modcaml.o mod.ml
        ocamlc -c modwrap.c
        cp /usr/local/lib/ocaml/libcamlrun.a mod.a
        ar r mod.a modcaml.o modwrap.o
</PRE><P>(One can also use <TT>ocamlopt -output-obj</TT> instead of <TT>ocamlc -custom -output-obj</TT>. In this case, replace <TT>libcamlrun.a</TT> (the bytecode
runtime library) by <TT>libasmrun.a</TT> (the native-code runtime library).)</P><P>Now, we can use the two functions <TT>fib</TT> and <TT>format_result</TT> in any C
program, just like regular C functions. Just remember to call
<TT>caml_startup</TT> once before.</P><PRE CLASS="verbatim">/* File main.c -- a sample client for the Caml functions */

#include &lt;stdio.h&gt;

int main(int argc, char ** argv)
{
  int result;

  /* Initialize Caml code */
  caml_startup(argv);
  /* Do some computation */
  result = fib(10);
  printf("fib(10) = %s\n", format_result(result));
  return 0;
}
</PRE><P>To build the whole program, just invoke the C compiler as follows:
</P><PRE CLASS="verbatim">        cc -o prog main.c mod.a -lcurses
</PRE><P>(On some machines, you may need to put <TT>-ltermcap</TT> or
<TT>-lcurses -ltermcap</TT> instead of <TT>-lcurses</TT>.)</P><!--TOC section Advanced topic: custom blocks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc251">18.9</A>  Advanced topic: custom blocks</H2><!--SEC END --><P> <A NAME="s:custom"></A>
</P><P>Blocks with tag <TT>Custom_tag</TT> contain both arbitrary user data and a
pointer to a C struct, with type <TT>struct custom_operations</TT>, that
associates user-provided finalization, comparison, hashing,
serialization and deserialization functions to this block.</P><!--TOC subsection The <TT>struct custom</TT><TT>_</TT><TT>operations</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc252">18.9.1</A>  The <TT>struct custom_operations</TT></H3><!--SEC END --><P>The <TT>struct custom_operations</TT> is defined in <TT>&lt;caml/custom.h&gt;</TT> and
contains the following fields:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>char *identifier</TT><BR>
A zero-terminated character string serving as an identifier for
serialization and deserialization operations.</LI><LI CLASS="li-itemize"><TT>void  (*finalize)(value v)</TT><BR>
The <TT>finalize</TT> field contains a pointer to a C function that is called
when the block becomes unreachable and is about to be reclaimed.
The block is passed as first argument to the function.
The <TT>finalize</TT> field can also be <TT>custom_finalize_default</TT> to indicate that no
finalization function is associated with the block.</LI><LI CLASS="li-itemize"><TT>int (*compare)(value v1, value v2)</TT><BR>
The <TT>compare</TT> field contains a pointer to a C function that is
called whenever two custom blocks are compared using Caml&#X2019;s generic
comparison operators (<TT>=</TT>, <TT>&lt;&gt;</TT>, <TT>&lt;=</TT>, <TT>&gt;=</TT>, <TT>&lt;</TT>, <TT>&gt;</TT> and
<TT>compare</TT>). The C function should return 0 if the data contained in
the two blocks are structurally equal, a negative integer if the data
from the first block is less than the data from the second block, and
a positive integer if the data from the first block is greater than
the data from the second block.<P>The <TT>compare</TT> field can be set to <TT>custom_compare_default</TT>; this
default comparison function simply raises <TT>Failure</TT>.</P></LI><LI CLASS="li-itemize"><TT>long (*hash)(value v)</TT><BR>
The <TT>hash</TT> field contains a pointer to a C function that is called
whenever Caml&#X2019;s generic hash operator (see module <TT>Hashtbl</TT>) is
applied to a custom block. The C function can return an arbitrary
long integer representing the hash value of the data contained in the
given custom block. The hash value must be compatible with the
<TT>compare</TT> function, in the sense that two structurally equal data
(that is, two custom blocks for which <TT>compare</TT> returns 0) must have
the same hash value.<P>The <TT>hash</TT> field can be set to <TT>custom_hash_default</TT>, in which case
the custom block is ignored during hash computation.</P></LI><LI CLASS="li-itemize"><TT>void (*serialize)(value v, unsigned long * wsize_32, unsigned long * wsize_64)</TT><BR>
The <TT>serialize</TT> field contains a pointer to a C function that is
called whenever the custom block needs to be serialized (marshaled)
using the Caml functions <TT>output_value</TT> or <TT>Marshal.to_...</TT>.
For a custom block, those functions first write the identifier of the
block (as given by the <TT>identifier</TT> field) to the output stream,
then call the user-provided <TT>serialize</TT> function. That function is
responsible for writing the data contained in the custom block, using
the <TT>serialize_...</TT> functions defined in <TT>&lt;caml/intext.h&gt;</TT> and listed
below. The user-provided <TT>serialize</TT> function must then store in its
<TT>wsize_32</TT> and <TT>wsize_64</TT> parameters the sizes in bytes of the data
part of the custom block on a 32-bit architecture and on a 64-bit
architecture, respectively.<P>The <TT>serialize</TT> field can be set to <TT>custom_serialize_default</TT>,
in which case the <TT>Failure</TT> exception is raised when attempting to
serialize the custom block.</P></LI><LI CLASS="li-itemize"><TT>unsigned long (*deserialize)(void * dst)</TT><BR>
The <TT>deserialize</TT> field contains a pointer to a C function that is
called whenever a custom block with identifier <TT>identifier</TT> needs to
be deserialized (un-marshaled) using the Caml functions <TT>input_value</TT>
or <TT>Marshal.from_...</TT>. This user-provided function is responsible for
reading back the data written by the <TT>serialize</TT> operation, using the
<TT>deserialize_...</TT> functions defined in <TT>&lt;caml/intext.h&gt;</TT> and listed
below. It must then rebuild the data part of the custom block
and store it at the pointer given as the <TT>dst</TT> argument. Finally, it
returns the size in bytes of the data part of the custom block.
This size must be identical to the <TT>wsize_32</TT> result of
the <TT>serialize</TT> operation if the architecture is 32 bits, or
<TT>wsize_64</TT> if the architecture is 64 bits.<P>The <TT>deserialize</TT> field can be set to <TT>custom_deserialize_default</TT>
to indicate that deserialization is not supported. In this case,
do not register the <TT>struct custom_operations</TT> with the deserializer
using <TT>register_custom_operations</TT> (see below).
</P></LI></UL><P>Note: the <TT>finalize</TT>, <TT>compare</TT>, <TT>hash</TT>, <TT>serialize</TT> and <TT>deserialize</TT>
functions attached to custom block descriptors must never trigger a
garbage collection. Within these functions, do not call any of the
Caml allocation functions, and do not perform a callback into Caml
code. Do not use <TT>CAMLparam</TT> to register the parameters to these
functions, and do not use <TT>CAMLreturn</TT> to return the result.</P><!--TOC subsection Allocating custom blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc253">18.9.2</A>  Allocating custom blocks</H3><!--SEC END --><P>Custom blocks must be allocated via the <TT>caml_alloc_custom</TT> function.
<TT>caml_alloc_custom(</TT><I>ops</I><TT>, </TT><I>size</I><TT>, </TT><I>used</I><TT>, </TT><I>max</I><TT>)</TT>
returns a fresh custom block, with room for <I>size</I> bytes of user
data, and whose associated operations are given by <I>ops</I> (a
pointer to a <TT>struct custom_operations</TT>, usually statically allocated
as a C global variable). </P><P>The two parameters <I>used</I> and <I>max</I> are used to control the
speed of garbage collection when the finalized object contains
pointers to out-of-heap resources. Generally speaking, the
Caml incremental major collector adjusts its speed relative to the
allocation rate of the program. The faster the program allocates, the
harder the GC works in order to reclaim quickly unreachable blocks
and avoid having large amount of &#X201C;floating garbage&#X201D; (unreferenced
objects that the GC has not yet collected).</P><P>Normally, the allocation rate is measured by counting the in-heap size
of allocated blocks. However, it often happens that finalized
objects contain pointers to out-of-heap memory blocks and other resources
(such as file descriptors, X Windows bitmaps, etc.). For those
blocks, the in-heap size of blocks is not a good measure of the
quantity of resources allocated by the program.</P><P>The two arguments <I>used</I> and <I>max</I> give the GC an idea of how
much out-of-heap resources are consumed by the finalized block
being allocated: you give the amount of resources allocated to this
object as parameter <I>used</I>, and the maximum amount that you want
to see in floating garbage as parameter <I>max</I>. The units are
arbitrary: the GC cares only about the ratio <I>used</I> / <I>max</I>.</P><P>For instance, if you are allocating a finalized block holding an X
Windows bitmap of <I>w</I> by <I>h</I> pixels, and you&#X2019;d rather not
have more than 1 mega-pixels of unreclaimed bitmaps, specify
<I>used</I> = <I>w</I> * <I>h</I> and <I>max</I> = 1000000.</P><P>Another way to describe the effect of the <I>used</I> and <I>max</I>
parameters is in terms of full GC cycles. If you allocate many custom
blocks with <I>used</I> / <I>max</I> = 1 / <I>N</I>, the GC will then do one
full cycle (examining every object in the heap and calling
finalization functions on those that are unreachable) every <I>N</I>
allocations. For instance, if <I>used</I> = 1 and <I>max</I> = 1000,
the GC will do one full cycle at least every 1000 allocations of
custom blocks.</P><P>If your finalized blocks contain no pointers to out-of-heap resources,
or if the previous discussion made little sense to you, just take
<I>used</I> = 0 and <I>max</I> = 1. But if you later find that the
finalization functions are not called &#X201C;often enough&#X201D;, consider
increasing the <I>used</I> / <I>max</I> ratio.</P><!--TOC subsection Accessing custom blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc254">18.9.3</A>  Accessing custom blocks</H3><!--SEC END --><P>The data part of a custom block <I>v</I> can be
accessed via the pointer <TT>Data_custom_val(</TT><I>v</I><TT>)</TT>. This pointer
has type <TT>void *</TT> and should be cast to the actual type of the data
stored in the custom block.</P><P>The contents of custom blocks are not scanned by the garbage
collector, and must therefore not contain any pointer inside the Caml
heap. In other terms, never store a Caml <TT>value</TT> in a custom block,
and do not use <TT>Field</TT>, <TT>Store_field</TT> nor <TT>caml_modify</TT> to access the data
part of a custom block. Conversely, any C data structure (not
containing heap pointers) can be stored in a custom block.</P><!--TOC subsection Writing custom serialization and deserialization functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc255">18.9.4</A>  Writing custom serialization and deserialization functions</H3><!--SEC END --><P>The following functions, defined in <TT>&lt;caml/intext.h&gt;</TT>, are provided to
write and read back the contents of custom blocks in a portable way.
Those functions handle endianness conversions when e.g. data is
written on a little-endian machine and read back on a big-endian machine.</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Function</B></TD><TD ALIGN=center NOWRAP><B>Action</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>caml_serialize_int_1</TT></TD><TD VALIGN=top ALIGN=left>Write a 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_2</TT></TD><TD VALIGN=top ALIGN=left>Write a 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_4</TT></TD><TD VALIGN=top ALIGN=left>Write a 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_int_8</TT></TD><TD VALIGN=top ALIGN=left>Write a 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_float_4</TT></TD><TD VALIGN=top ALIGN=left>Write a 4-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_float_8</TT></TD><TD VALIGN=top ALIGN=left>Write a 8-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_1</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 1-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_2</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 2-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_4</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 4-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_serialize_block_8</TT></TD><TD VALIGN=top ALIGN=left>Write an array of 8-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_1</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_1</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 1-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_2</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_2</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 2-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_4</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_4</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 4-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_uint_8</TT></TD><TD VALIGN=top ALIGN=left>Read an unsigned 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_sint_8</TT></TD><TD VALIGN=top ALIGN=left>Read a signed 8-byte integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_float_4</TT></TD><TD VALIGN=top ALIGN=left>Read a 4-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_float_8</TT></TD><TD VALIGN=top ALIGN=left>Read an 8-byte float</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_1</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 1-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_2</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 2-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_4</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 4-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_block_8</TT></TD><TD VALIGN=top ALIGN=left>Read an array of 8-byte quantities</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>caml_deserialize_error</TT></TD><TD VALIGN=top ALIGN=left>Signal an error during deserialization;
<TT>input_value</TT> or <TT>Marshal.from_...</TT> raise a <TT>Failure</TT> exception after
cleaning up their internal data structures</TD></TR>
</TABLE></DIV><P>Serialization functions are attached to the custom blocks to which
they apply. Obviously, deserialization functions cannot be attached
this way, since the custom block does not exist yet when
deserialization begins! Thus, the <TT>struct custom_operations</TT> that
contain deserialization functions must be registered with the
deserializer in advance, using the <TT>register_custom_operations</TT>
function declared in <TT>&lt;caml/custom.h&gt;</TT>. Deserialization proceeds by
reading the identifier off the input stream, allocating a custom block
of the size specified in the input stream, searching the registered
<TT>struct custom_operation</TT> blocks for one with the same identifier, and
calling its <TT>deserialize</TT> function to fill the data part of the custom block.</P><!--TOC subsection Choosing identifiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc256">18.9.5</A>  Choosing identifiers</H3><!--SEC END --><P>Identifiers in <TT>struct custom_operations</TT> must be chosen carefully,
since they must identify uniquely the data structure for serialization
and deserialization operations. In particular, consider including a
version number in the identifier; this way, the format of the data can
be changed later, yet backward-compatible deserialisation functions
can be provided.</P><P>Identifiers starting with <TT>_</TT> (an underscore character) are reserved
for the OCaml runtime system; do not use them for your custom
data. We recommend to use a URL
(<TT>http://mymachine.mydomain.com/mylibrary/version-number</TT>)
or a Java-style package name
(<TT>com.mydomain.mymachine.mylibrary.version-number</TT>)
as identifiers, to minimize the risk of identifier collision.</P><!--TOC subsection Finalized blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc257">18.9.6</A>  Finalized blocks</H3><!--SEC END --><P>Custom blocks generalize the finalized blocks that were present in
OCaml prior to version 3.00. For backward compatibility, the
format of custom blocks is compatible with that of finalized blocks,
and the <TT>alloc_final</TT> function is still available to allocate a custom
block with a given finalization function, but default comparison,
hashing and serialization functions. <TT>caml_alloc_final(</TT><I>n</I><TT>, </TT><I>f</I><TT>, </TT><I>used</I><TT>, </TT><I>max</I><TT>)</TT> returns a fresh custom block of
size <I>n</I> words, with finalization function <I>f</I>. The first
word is reserved for storing the custom operations; the other
<I>n</I>-1 words are available for your data. The two parameters
<I>used</I> and <I>max</I> are used to control the speed of garbage
collection, as described for <TT>caml_alloc_custom</TT>.</P><!--TOC section Advanced topic: multithreading-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc258">18.10</A>  Advanced topic: multithreading</H2><!--SEC END --><P>
<A NAME="s:C-multithreading"></A></P><P>Using multiple threads (shared-memory concurrency) in a mixed Caml/C
application requires special precautions, which are described in this
section.</P><!--TOC subsection Registering threads created from C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc259">18.10.1</A>  Registering threads created from C</H3><!--SEC END --><P>Callbacks from C to Caml are possible only if the calling thread is
known to the Caml run-time system. Threads created from Caml (through
the <TT>Thread.create</TT> function of the system threads library) are
automatically known to the run-time system. If the application
creates additional threads from C and wishes to callback into Caml
code from these threads, it must first register them with the run-time
system. The following functions are declared in the include file
<TT>&lt;caml/threads.h&gt;</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_c_thread_register()</TT> registers the calling thread with the Caml
run-time system. Returns 1 on success, 0 on error. Registering an
already-register thread does nothing and returns 0.
</LI><LI CLASS="li-itemize"><TT>caml_c_thread_unregister()</TT> must be called before the thread
terminates, to unregister it from the Caml run-time system.
Returns 1 on success, 0 on error. If the calling thread was not
previously registered, does nothing and returns 0.
</LI></UL><!--TOC subsection Parallel execution of long-running C code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc260">18.10.2</A>  Parallel execution of long-running C code</H3><!--SEC END --><P>The Caml run-time system is not reentrant: at any time, at most one
thread can be executing Caml code or C code that uses the Caml
run-time system. Technically, this is enforced by a &#X201C;master lock&#X201D;
that any thread must hold while executing such code.</P><P>When Caml calls the C code implementing a primitive, the master lock
is held, therefore the C code has full access to the facilities of the
run-time system. However, no other thread can execute Caml code
concurrently with the C code of the primitive.</P><P>If a C primitive runs for a long time or performs potentially blocking
input-output operations, it can explicitly release the master lock,
enabling other Caml threads to run concurrently with its operations.
The C code must re-acquire the master lock before returning to Caml.
This is achieved with the following functions, declared in 
the include file <TT>&lt;caml/threads.h&gt;</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_release_runtime_system()</TT>
The calling thread releases the master lock and other Caml resources,
enabling other threads to run Caml code in parallel with the execution
of the calling thread. 
</LI><LI CLASS="li-itemize"><TT>caml_acquire_runtime_system()</TT>
The calling thread re-acquires the master lock and other Caml
resources. It may block until no other thread uses the Caml run-time
system.
</LI></UL><P>After <TT>caml_release_runtime_system()</TT> was called and until
<TT>caml_acquire_runtime_system()</TT> is called, the C code must not access
any Caml data, nor call any function of the run-time system, nor call
back into Caml code. Consequently, arguments provided by Caml to the
C primitive must be copied into C data structures before calling
<TT>caml_release_runtime_system()</TT>, and results to be returned to Caml
must be encoded as Caml values after <TT>caml_acquire_runtime_system()</TT>
returns.</P><P>Example: the following C primitive invokes <TT>gethostbyname</TT> to find the
IP address of a host name. The <TT>gethostbyname</TT> function can block for
a long time, so we choose to release the Caml run-time system while it
is running.
</P><PRE CLASS="verbatim">CAMLprim stub_gethostbyname(value vname)
{
  CAMLparam1 (vname);
  CAMLlocal1 (vres);
  struct hostent * h;

  /* Copy the string argument to a C string, allocated outside the
     Caml heap. */
  name = stat_alloc(caml_string_length(vname) + 1);
  strcpy(name, String_val(vname));
  /* Release the Caml run-time system */
  caml_release_runtime_system();
  /* Resolve the name */
  h = gethostbyname(name);
  /* Re-acquire the Caml run-time system */
  caml_acquire_runtime_system();
  /* Encode the relevant fields of h as the Caml value vres */
  ... /* Omitted */
  /* Return to Caml */
  CAMLreturn (vres);
}
</PRE><P>Callbacks from C to Caml must be performed while holding the master
lock to the Caml run-time system. This is naturally the case if the
callback is performed by a C primitive that did not release the
run-time system. If the C primitive released the run-time system
previously, or the callback is performed from other C code that was
not invoked from Caml (e.g. an event loop in a GUI application), the
run-time system must be acquired before the callback and released
after:
</P><PRE CLASS="verbatim">  caml_acquire_runtime_system();
  /* Resolve Caml function vfun to be invoked */
  /* Build Caml argument varg to the callback */
  vres = callback(vfun, varg);
  /* Copy relevant parts of result vres to C data structures */
  caml_release_runtime_system();
</PRE><P>Note: the <TT>acquire</TT> and <TT>release</TT> functions described above were
introduced in OCaml 3.12. Older code uses the following historical
names, declared in <TT>&lt;caml/signals.h&gt;</TT>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>caml_enter_blocking_section</TT> as an alias for
<TT>caml_release_runtime_system</TT>
</LI><LI CLASS="li-itemize"><TT>caml_leave_blocking_section</TT> as an alias for
<TT>caml_acquire_runtime_system</TT>
</LI></UL><P>
Intuition: a &#X201C;blocking section&#X201D; is a piece of C code that does not
use the Caml run-time system, typically a blocking input/output operation.</P><!--TOC section Building mixed C/Caml libraries: <TT>ocamlmklib</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc261">18.11</A>  Building mixed C/Caml libraries: <TT>ocamlmklib</TT></H2><!--SEC END --><P> <A NAME="s-ocamlmklib"></A></P><P>The <TT>ocamlmklib</TT> command facilitates the construction of libraries
containing both Caml code and C code, and usable both in static
linking and dynamic linking modes. This command is available under
Windows since Objective Caml 3.11 and under other operating systems since
Objective Caml 3.03.</P><P>The <TT>ocamlmklib</TT> command takes three kinds of arguments:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Caml source files and object files (<TT>.cmo</TT>, <TT>.cmx</TT>, <TT>.ml</TT>)
comprising the Caml part of the library;
</LI><LI CLASS="li-itemize">C object files (<TT>.o</TT>, <TT>.a</TT>, respectively, <TT>.obj</TT>, <TT>.lib</TT>)
comprising the C part of the library;
</LI><LI CLASS="li-itemize">Support libraries for the C part (<TT>-l</TT><I>lib</I>).
</LI></UL><P>
It generates the following outputs:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A Caml bytecode library <TT>.cma</TT> incorporating the <TT>.cmo</TT> and
<TT>.ml</TT> Caml files given as arguments, and automatically referencing the
C library generated with the C object files.
</LI><LI CLASS="li-itemize">A Caml native-code library <TT>.cmxa</TT> incorporating the <TT>.cmx</TT> and
<TT>.ml</TT> Caml files given as arguments, and automatically referencing the
C library generated with the C object files.
</LI><LI CLASS="li-itemize">If dynamic linking is supported on the target platform, a
<TT>.so</TT> (respectively, <TT>.dll</TT>) shared library built from the C object files given as arguments,
and automatically referencing the support libraries.
</LI><LI CLASS="li-itemize">A C static library <TT>.a</TT>(respectively, <TT>.lib</TT>) built from the C object files.
</LI></UL><P>
In addition, the following options are recognized:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>-cclib</TT>, <TT>-ccopt</TT>, <TT>-I</TT>, <TT>-linkall</TT></B></DT><DD CLASS="dd-description">
These options are passed as is to <TT>ocamlc</TT> or <TT>ocamlopt</TT>.
See the documentation of these commands.
</DD><DT CLASS="dt-description"><B><TT>-rpath</TT>, <TT>-R</TT>, <TT>-Wl,-rpath</TT>, <TT>-Wl,-R</TT></B></DT><DD CLASS="dd-description">
These options are passed as is to the C compiler. Refer to the
documentation of the C compiler.
</DD><DT CLASS="dt-description"><TT><B>-custom</B></TT></DT><DD CLASS="dd-description"> Force the construction of a statically linked library
only, even if dynamic linking is supported.
</DD><DT CLASS="dt-description"><TT><B>-failsafe</B></TT></DT><DD CLASS="dd-description"> Fall back to building a statically linked library
if a problem occurs while building the shared library (e.g. some of
the support libraries are not available as shared libraries).
</DD><DT CLASS="dt-description"><B><TT>-L</TT><I>dir</I></B></DT><DD CLASS="dd-description"> Add <I>dir</I> to the search path for support
libraries (<TT>-l</TT><I>lib</I>).
</DD><DT CLASS="dt-description"><B><TT>-ocamlc</TT> <I>cmd</I></B></DT><DD CLASS="dd-description"> Use <I>cmd</I> instead of <TT>ocamlc</TT> to call
the bytecode compiler.
</DD><DT CLASS="dt-description"><B><TT>-ocamlopt</TT> <I>cmd</I></B></DT><DD CLASS="dd-description"> Use <I>cmd</I> instead of <TT>ocamlopt</TT> to call
the native-code compiler.
</DD><DT CLASS="dt-description"><B><TT>-o</TT> <I>output</I></B></DT><DD CLASS="dd-description"> Set the name of the generated Caml library.
<TT>ocamlmklib</TT> will generate <I>output</I><TT>.cma</TT> and/or <I>output</I><TT>.cmxa</TT>.
If not specified, defaults to <TT>a</TT>.
</DD><DT CLASS="dt-description"><B><TT>-oc</TT> <I>outputc</I></B></DT><DD CLASS="dd-description"> Set the name of the generated C library.
<TT>ocamlmklib</TT> will generate <TT>lib</TT><I>outputc</I><TT>.so</TT> (if shared
libraries are supported) and <TT>lib</TT><I>outputc</I><TT>.a</TT>.
If not specified, defaults to the output name given with <TT>-o</TT>.
</DD></DL><!--TOC paragraph Example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Example</H5><!--SEC END --><P> Consider a Caml interface to the standard <TT>libz</TT>
C library for reading and writing compressed files. Assume this
library resides in <TT>/usr/local/zlib</TT>. This interface is
composed of a Caml part <TT>zip.cmo</TT>/<TT>zip.cmx</TT> and a C part <TT>zipstubs.o</TT>
containing the stub code around the <TT>libz</TT> entry points. The
following command builds the Caml libraries <TT>zip.cma</TT> and <TT>zip.cmxa</TT>,
as well as the companion C libraries <TT>dllzip.so</TT> and <TT>libzip.a</TT>:
</P><PRE CLASS="verbatim">ocamlmklib -o zip zip.cmo zip.cmx zipstubs.o -lz -L/usr/local/zlib
</PRE><P>If shared libraries are supported, this performs the following
commands:
</P><PRE CLASS="verbatim">ocamlc -a -o zip.cma zip.cmo -dllib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -cclib -lzip \
        -cclib -lzip -cclib -lz -ccopt -L/usr/local/zlib
gcc -shared -o dllzip.so zipstubs.o -lz -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</PRE><P>If shared libraries are not supported, the following commands are
performed instead:
</P><PRE CLASS="verbatim">ocamlc -a -custom -o zip.cma zip.cmo -cclib -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ocamlopt -a -o zip.cmxa zip.cmx -lzip \
        -cclib -lz -ccopt -L/usr/local/zlib
ar rc libzip.a zipstubs.o
</PRE><P>Instead of building simultaneously the bytecode library, the
native-code library and the C libraries, <TT>ocamlmklib</TT> can be called
three times to build each separately. Thus,
</P><PRE CLASS="verbatim">ocamlmklib -o zip zip.cmo -lz -L/usr/local/zlib
</PRE><P>builds the bytecode library <TT>zip.cma</TT>, and
</P><PRE CLASS="verbatim">ocamlmklib -o zip zip.cmx -lz -L/usr/local/zlib
</PRE><P>builds the native-code library <TT>zip.cmxa</TT>, and
</P><PRE CLASS="verbatim">ocamlmklib -o zip zipstubs.o -lz -L/usr/local/zlib
</PRE><P>builds the C libraries <TT>dllzip.so</TT> and <TT>libzip.a</TT>. Notice that the
support libraries (<TT>-lz</TT>) and the corresponding options
(<TT>-L/usr/local/zlib</TT>) must be given on all three invocations of <TT>ocamlmklib</TT>,
because they are needed at different times depending on whether shared
libraries are supported.</P><!--TOC part The OCaml library-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc262">Part IV</A><BR>
The OCaml library</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:library"></A>
</P><!--TOC chapter The core library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc263">Chapter 19</A>  The core library</H1><!--SEC END --><P> <A NAME="c:corelib"></A>
</P><P>This chapter describes the OCaml core library, which is
composed of declarations for built-in types and exceptions, plus
the module <TT>Pervasives</TT> that provides basic operations on these
built-in types. The <TT>Pervasives</TT> module is special in two
ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
It is automatically linked with the user&#X2019;s object code files by
the <TT>ocamlc</TT> command (chapter <A HREF="#c:camlc">8</A>).</LI><LI CLASS="li-itemize">It is automatically &#X201C;opened&#X201D; when a compilation starts, or
when the toplevel system is launched. Hence, it is possible to use
unqualified identifiers to refer to the functions provided by the
<TT>Pervasives</TT> module, without adding a <TT>open Pervasives</TT> directive.
</LI></UL><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>The declarations of the built-in types and the components of module
<TT>Pervasives</TT> are printed one by one in typewriter font, followed by a
short comment. All library modules and the components they provide are
indexed at the end of this report.</P><!--TOC section Built-in types and predefined exceptions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc264">19.1</A>  Built-in types and predefined exceptions</H2><!--SEC END --><P>The following built-in types and predefined exceptions are always
defined in the
compilation environment, but are not part of any module. As a
consequence, they can only be referred by their short names.</P><!--TOC subsection Built-in types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Built-in types</H3><!--SEC END --><PRE>
 type int
</PRE><P>
<A NAME="@manual9"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of integer numbers.
</BLOCKQUOTE><PRE>
 type char
</PRE><P>
<A NAME="@manual10"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of characters.
</BLOCKQUOTE><PRE>
 type string
</PRE><P>
<A NAME="@manual11"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of character strings.
</BLOCKQUOTE><PRE>
 type float
</PRE><P>
<A NAME="@manual12"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of floating-point numbers.
</BLOCKQUOTE><PRE>
 type bool = false | true
</PRE><P>
<A NAME="@manual13"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of booleans (truth values).
</BLOCKQUOTE><PRE>
 type unit = ()
</PRE><P>
<A NAME="@manual14"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of the unit value.
</BLOCKQUOTE><PRE>
 type exn
</PRE><P>
<A NAME="@manual15"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of exception values.
</BLOCKQUOTE><PRE>
 type &#X2019;a array
</PRE><P>
<A NAME="@manual16"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of arrays whose elements have type <TT>&#X2019;a</TT>.
</BLOCKQUOTE><PRE>
 type &#X2019;a list = [] | :: of &#X2019;a * &#X2019;a list
</PRE><P>
<A NAME="@manual17"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of lists whose elements have type <TT>&#X2019;a</TT>.
</BLOCKQUOTE><PRE>
type &#X2019;a option = None | Some of &#X2019;a
</PRE><P>
<A NAME="@manual18"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of optional values of type <TT>&#X2019;a</TT>. 
</BLOCKQUOTE><PRE>
type int32
</PRE><P>
<A NAME="@manual19"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed 32-bit integers. 
See the <TT>Int32</TT>[<TT><A HREF="libref/Int32.html">Int32</A></TT>] module.
</BLOCKQUOTE><PRE>
type int64
</PRE><P>
<A NAME="@manual20"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed 64-bit integers. 
See the <TT>Int64</TT>[<TT><A HREF="libref/Int64.html">Int64</A></TT>] module.
</BLOCKQUOTE><PRE>
type nativeint
</PRE><P>
<A NAME="@manual21"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of signed, platform-native integers (32 bits on 32-bit
processors, 64 bits on 64-bit processors).
See the <TT>Nativeint</TT>[<TT><A HREF="libref/Nativeint.html">Nativeint</A></TT>] module.
</BLOCKQUOTE><PRE>
type (&#X2019;a, &#X2019;b, &#X2019;c, &#X2019;d) format4
</PRE><P>
<A NAME="@manual22"></A>
</P><BLOCKQUOTE CLASS="quote">
The type of format strings. <TT>&#X2019;a</TT> is the type of the parameters
of the format, <TT>&#X2019;d</TT> is the result type for the <TT>printf</TT>-style
function, <TT>&#X2019;b</TT> is the type of the first argument given to
<TT>\%a</TT> and <TT>\%t</TT> printing functions (see module <TT>Printf</TT>[<TT><A HREF="libref/Printf.html">Printf</A></TT>]),
and <TT>&#X2019;c</TT> is the result type of these functions.
</BLOCKQUOTE><PRE>
type &#X2019;a lazy_t
</PRE><P>
<A NAME="@manual23"></A>
</P><BLOCKQUOTE CLASS="quote">
This type is used to implement the <TT>Lazy</TT>[<TT><A HREF="libref/Lazy.html">Lazy</A></TT>] module.
It should not be used directly.
</BLOCKQUOTE><!--TOC subsection Predefined exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Predefined exceptions</H3><!--SEC END --><PRE>
exception Match_failure of (string * int * int)
</PRE><P>
<A NAME="@manual24"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when none of the cases of a pattern-matching
apply. The arguments are the location of the <TT>match</TT> keyword
in the source code (file name, line number, column number).
</BLOCKQUOTE><PRE>
exception Assert_failure of (string * int * int)
</PRE><P>
<A NAME="@manual25"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when an assertion fails. The arguments are
the location of the <TT>assert</TT> keyword in the source code
(file name, line number, column number).
</BLOCKQUOTE><PRE>
exception Invalid_argument of string
</PRE><P>
<A NAME="@manual26"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by library functions to signal that the given
arguments do not make sense.
</BLOCKQUOTE><PRE>
exception Failure of string
</PRE><P>
<A NAME="@manual27"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by library functions to signal that they are
undefined on the given arguments. 
</BLOCKQUOTE><PRE>
exception Not_found
</PRE><P>
<A NAME="@manual28"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by search functions when the desired object
could not be found.
</BLOCKQUOTE><PRE>
exception Out_of_memory
</PRE><P>
<A NAME="@manual29"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the garbage collector
when there is insufficient memory to complete the computation.
</BLOCKQUOTE><PRE>
exception Stack_overflow
</PRE><P>
<A NAME="@manual30"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the bytecode interpreter when the evaluation
stack reaches its maximal size. This often indicates infinite
or excessively deep recursion in the user&#X2019;s program.
(Not fully implemented by the native-code compiler;
see section <A HREF="#s:compat-native-bytecode">11.5</A>.)
</BLOCKQUOTE><PRE>
exception Sys_error of string
</PRE><P>
<A NAME="@manual31"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by the input/output functions to report
an operating system error.
</BLOCKQUOTE><PRE>
exception End_of_file
</PRE><P>
<A NAME="@manual32"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by input functions to signal that the
end of file has been reached.
</BLOCKQUOTE><PRE>
exception Division_by_zero
</PRE><P>
<A NAME="@manual33"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised by integer division and remainder operations
when their second argument is zero.
</BLOCKQUOTE><PRE>
exception Sys_blocked_io
</PRE><P>
<A NAME="@manual34"></A>
</P><BLOCKQUOTE CLASS="quote">
A special case of <TT>Sys_error</TT> raised when no I/O is possible
on a non-blocking I/O channel.
</BLOCKQUOTE><PRE>
exception Undefined_recursive_module of (string * int * int)
</PRE><P>
<A NAME="@manual35"></A>
</P><BLOCKQUOTE CLASS="quote">
Exception raised when an ill-founded recursive module definition
is evaluated. (See section <A HREF="#s-recursive-modules">7.8</A>.)
The arguments are the location of the definition in the source code
(file name, line number, column number).
</BLOCKQUOTE><!--TOC section Module <TT>Pervasives</TT>: the initially opened module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc265">19.2</A>  Module <TT>Pervasives</TT>: the initially opened module</H2><!--SEC END --><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Pervasives.html">Module <TT>Pervasives</TT>: the initially opened module</A>
</LI></UL><!--TOC chapter The standard library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc266">Chapter 20</A>  The standard library</H1><!--SEC END --><P> <A NAME="c:stdlib"></A>
</P><P>This chapter describes the functions provided by the OCaml
standard library. The modules from the standard library are
automatically linked with the user&#X2019;s object code files by the <TT>ocamlc</TT>
command. Hence, these modules can be used in standalone programs without
having to add any <TT>.cmo</TT> file on the command line for the linking
phase. Similarly, in interactive use, these globals can be used in
toplevel phrases without having to load any <TT>.cmo</TT> file in memory.</P><P>Unlike the <TT>Pervasives</TT> module from the core library, the modules from the
standard library are not automatically &#X201C;opened&#X201D; when a compilation
starts, or when the toplevel system is launched. Hence it is necessary
to use qualified identifiers to refer to the functions provided by these
modules, or to add <TT>open</TT> directives.</P><P><A NAME="stdlib:top"></A></P><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P>For easy reference, the modules are listed below in alphabetical order
of module names.
For each module, the declarations from its signature are printed
one by one in typewriter font, followed by a short comment.
All modules and the identifiers they export are indexed at the end of
this report.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Arg.html">Module <TT>Arg</TT>: parsing of command line arguments</A>
</LI><LI CLASS="li-links"><A HREF="libref/Array.html">Module <TT>Array</TT>: array operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/ArrayLabels.html">Module <TT>ArrayLabels</TT>: array operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Buffer.html">Module <TT>Buffer</TT>: extensible string buffers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Callback.html">Module <TT>Callback</TT>: registering Caml values with the C runtime</A>
</LI><LI CLASS="li-links"><A HREF="libref/Char.html">Module <TT>Char</TT>: character operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/Complex.html">Module <TT>Complex</TT>: Complex numbers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Digest.html">Module <TT>Digest</TT>: MD5 message digest</A>
</LI><LI CLASS="li-links"><A HREF="libref/Filename.html">Module <TT>Filename</TT>: operations on file names</A>
</LI><LI CLASS="li-links"><A HREF="libref/Format.html">Module <TT>Format</TT>: pretty printing</A>
</LI><LI CLASS="li-links"><A HREF="libref/Gc.html">Module <TT>Gc</TT>: memory management control and statistics; finalised values</A>
</LI><LI CLASS="li-links"><A HREF="libref/Genlex.html">Module <TT>Genlex</TT>: a generic lexical analyzer</A>
</LI><LI CLASS="li-links"><A HREF="libref/Hashtbl.html">Module <TT>Hashtbl</TT>: hash tables and hash functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Int32.html">Module <TT>Int32</TT>: 32-bit integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Int64.html">Module <TT>Int64</TT>: 64-bit integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Lazy.html">Module <TT>Lazy</TT>: deferred computations</A>
</LI><LI CLASS="li-links"><A HREF="libref/Lexing.html">Module <TT>Lexing</TT>: the run-time library for lexers generated by <TT>ocamllex</TT></A>
</LI><LI CLASS="li-links"><A HREF="libref/List.html">Module <TT>List</TT>: list operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/ListLabels.html">Module <TT>ListLabels</TT>: list operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Map.html">Module <TT>Map</TT>: association tables over ordered types</A>
</LI><LI CLASS="li-links"><A HREF="libref/Marshal.html">Module <TT>Marshal</TT>: marshaling of data structures</A>
</LI><LI CLASS="li-links"><A HREF="libref/MoreLabels.html">Module <TT>MoreLabels</TT>: Include modules <TT>Hashtbl</TT>, <TT>Map</TT> and <TT>Set</TT> with labels</A>
</LI><LI CLASS="li-links"><A HREF="libref/Nativeint.html">Module <TT>Nativeint</TT>: processor-native integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Oo.html">Module <TT>Oo</TT>: object-oriented extension</A>
</LI><LI CLASS="li-links"><A HREF="libref/Parsing.html">Module <TT>Parsing</TT>: the run-time library for parsers generated by <TT>ocamlyacc</TT></A>
</LI><LI CLASS="li-links"><A HREF="libref/Printexc.html">Module <TT>Printexc</TT>: facilities for printing exceptions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Printf.html">Module <TT>Printf</TT>: formatting printing functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Queue.html">Module <TT>Queue</TT>: first-in first-out queues</A>
</LI><LI CLASS="li-links"><A HREF="libref/Random.html">Module <TT>Random</TT>: pseudo-random number generator (PRNG)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Scanf.html">Module <TT>Scanf</TT>: formatted input functions</A>
</LI><LI CLASS="li-links"><A HREF="libref/Set.html">Module <TT>Set</TT>: sets over ordered types</A>
</LI><LI CLASS="li-links"><A HREF="libref/Sort.html">Module <TT>Sort</TT>: sorting and merging lists</A>
</LI><LI CLASS="li-links"><A HREF="libref/Stack.html">Module <TT>Stack</TT>: last-in first-out stacks</A>
</LI><LI CLASS="li-links"><A HREF="libref/StdLabels.html">Module <TT>StdLabels</TT>: Include modules <TT>Array</TT>, <TT>List</TT> and <TT>String</TT> with labels</A>
</LI><LI CLASS="li-links"><A HREF="libref/Stream.html">Module <TT>Stream</TT>: streams and parsers</A>
</LI><LI CLASS="li-links"><A HREF="libref/String.html">Module <TT>String</TT>: string operations</A>
</LI><LI CLASS="li-links"><A HREF="libref/StringLabels.html">Module <TT>StringLabels</TT>: string operations (with labels)</A>
</LI><LI CLASS="li-links"><A HREF="libref/Sys.html">Module <TT>Sys</TT>: system interface</A>
</LI><LI CLASS="li-links"><A HREF="libref/Weak.html">Module <TT>Weak</TT>: arrays of weak pointers</A>
</LI></UL><!--TOC chapter The unix library: Unix system calls-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc267">Chapter 21</A>  The unix library: Unix system calls</H1><!--SEC END --><P>The <TT>unix</TT> library makes many Unix
system calls and system-related library functions available to
OCaml programs. This chapter describes briefly the functions
provided. Refer to sections 2 and 3 of the Unix manual for more
details on the behavior of these functions.</P><P>Not all functions are provided by all Unix variants. If some functions
are not available, they will raise <TT>Invalid_arg</TT> when called.</P><P>Programs that use the <TT>unix</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> unix.cma <I>other files</I>
        ocamlopt <I>other options</I> unix.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>unix</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop unix.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "unix.cma";;</TT>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
A fairly complete emulation of the Unix system calls is provided in
the Windows version of OCaml. The end of this chapter gives
more information on the functions that are not supported under Windows.
</BLOCKQUOTE><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Unix.html">Module <TT>Unix</TT>: Unix system calls</A>
</LI><LI CLASS="li-links"><A HREF="libref/UnixLabels.html">Module <TT>UnixLabels</TT>: Labeled Unix system calls</A>
</LI></UL><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
The Cygwin port of OCaml fully implements all functions from
the Unix module. The native Win32 ports implement a subset of them.
Below is a list of the functions that are not implemented, or only
partially implemented, by the Win32 ports. Functions not mentioned are
fully implemented and behave as described previously in this chapter.<DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Functions</B></TD><TD ALIGN=center NOWRAP><B>Comment</B></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fork</TT></TD><TD VALIGN=top ALIGN=left>not implemented, use <TT>create_process</TT> or threads</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>wait</TT></TD><TD VALIGN=top ALIGN=left>not implemented, use <TT>waitpid</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>waitpid</TT></TD><TD VALIGN=top ALIGN=left>can only wait for a given PID, not any child process</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getppid</TT></TD><TD VALIGN=top ALIGN=left>not implemented (meaningless under Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>nice</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>truncate</TT>, <TT>ftruncate</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>link</TT>, <TT>symlink</TT>, <TT>readlink</TT></TD><TD VALIGN=top ALIGN=left>not implemented (no links under
Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>access</TT></TD><TD VALIGN=top ALIGN=left>execute permission <TT>X_OK</TT> cannot be tested,
it just tests for read permission instead</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>fchmod</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>chown</TT>, <TT>fchown</TT></TD><TD VALIGN=top ALIGN=left>not implemented (make no sense on a DOS
file system)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>umask</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>set_nonblock</TT>, <TT>clear_nonblock</TT></TD><TD VALIGN=top ALIGN=left>implemented as dummy
functions; use threads instead of non-blocking I/O</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>rewinddir</TT></TD><TD VALIGN=top ALIGN=left>not implemented; re-open the directory instead</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>mkfifo</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>kill</TT>, <TT>pause</TT></TD><TD VALIGN=top ALIGN=left>not implemented (no inter-process signals in Windows)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>alarm</TT>, <TT>times</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getitimer</TT>, <TT>setitimer</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getuid</TT>, <TT>getgid</TT></TD><TD VALIGN=top ALIGN=left>always return 1</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getgid</TT>, <TT>getegid</TT>, <TT>getgroups</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>setuid</TT>, <TT>setgid</TT></TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getpwnam</TT>, <TT>getpwuid</TT></TD><TD VALIGN=top ALIGN=left>always raise <TT>Not_found</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>getgrnam</TT>, <TT>getgrgid</TT></TD><TD VALIGN=top ALIGN=left>always raise <TT>Not_found</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>type <TT>socket_domain</TT></TD><TD VALIGN=top ALIGN=left>the domains <TT>PF_UNIX</TT> and <TT>PF_INET6</TT> 
are not supported; <TT>PF_INET</TT> is fully supported</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>establish_server</TT></TD><TD VALIGN=top ALIGN=left>not implemented; use threads</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>terminal functions (<TT>tc*</TT>)</TD><TD VALIGN=top ALIGN=left>not implemented</TD></TR>
</TABLE></DIV></BLOCKQUOTE><!--TOC chapter The num library: arbitrary-precision rational arithmetic-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc268">Chapter 22</A>  The num library: arbitrary-precision rational arithmetic</H1><!--SEC END --><P>The <TT>num</TT> library implements integer arithmetic and rational
arithmetic in arbitrary precision.</P><P>More documentation on the functions provided in this library can be found
in <EM>The CAML Numbers Reference Manual</EM> by 
Valérie Ménissier-Morain, technical report 141, INRIA, july 1992
(available electronically,
<TT>ftp://ftp.inria.fr/INRIA/publication/RT/RT-0141.ps.gz</TT>).</P><P>Programs that use the <TT>num</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> nums.cma <I>other files</I>
        ocamlopt <I>other options</I> nums.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>nums</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop nums.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "nums.cma";;</TT>.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Num.html">Module <TT>Num</TT>: operation on arbitrary-precision numbers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Big_int.html">Module <TT>Big_int</TT>: operations on arbitrary-precision integers</A>
</LI><LI CLASS="li-links"><A HREF="libref/Arith_status.html">Module <TT>Arith_status</TT>: flags that control rational arithmetic</A>
</LI></UL><!--TOC chapter The str library: regular expressions and string processing-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc269">Chapter 23</A>  The str library: regular expressions and string processing</H1><!--SEC END --><P>The <TT>str</TT> library provides high-level string processing functions,
some based on regular expressions. It is intended to support the kind
of file processing that is usually performed with scripting languages
such as <TT>awk</TT>, <TT>perl</TT> or <TT>sed</TT>.</P><P>Programs that use the <TT>str</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> str.cma <I>other files</I>
        ocamlopt <I>other options</I> str.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>str</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop str.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "str.cma";;</TT>.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Str.html">Module <TT>Str</TT>: regular expressions and string processing</A>
</LI></UL><!--TOC chapter The threads library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc270">Chapter 24</A>  The threads library</H1><!--SEC END --><P>
<A NAME="c:threads"></A>
</P><P>The <TT>threads</TT> library allows concurrent programming in OCaml.
It provides multiple threads of control (also called lightweight
processes) that execute concurrently in the same memory space. Threads
communicate by in-place modification of shared data structures, or by
sending and receiving data on communication channels.</P><P>The <TT>threads</TT> library is implemented by time-sharing on a single
processor. It will not take advantage of multi-processor machines.
Using this library will therefore never make programs run
faster. However, many programs are easier to write when structured as
several communicating processes.</P><P>Two implementations of the <TT>threads</TT> library are available, depending
on the capabilities of the operating system:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
System threads. This implementation builds on the OS-provided threads
facilities: POSIX 1003.1c threads for Unix, and Win32 threads for
Windows. When available, system threads support both bytecode and
native-code programs.
</LI><LI CLASS="li-itemize">VM-level threads. This implementation performs time-sharing and
context switching at the level of the OCaml virtual machine (bytecode
interpreter). It is available on Unix systems, and supports only
bytecode programs. It cannot be used with native-code programs.
</LI></UL><P>
Programs that use system threads must be linked as follows:
</P><PRE>
        ocamlc -thread <I>other options</I> unix.cma threads.cma <I>other files</I>
        ocamlopt -thread <I>other options</I> unix.cmxa threads.cmxa <I>other files</I>
</PRE><P>
Compilation units that use the <TT>threads</TT> library must also be compiled with
the <TT>-thread</TT> option (see chapter <A HREF="#c:camlc">8</A>).</P><P>Programs that use VM-level threads must be compiled with the <TT>-vmthread</TT>
option to <TT>ocamlc</TT> (see chapter <A HREF="#c:camlc">8</A>), and be linked as follows:
</P><PRE>
        ocamlc -vmthread <I>other options</I> threads.cma <I>other files</I>
</PRE><P>
Compilation units that use <TT>threads</TT> library must also be compiled with
the <TT>-vmthread</TT> option (see chapter <A HREF="#c:camlc">8</A>).</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Thread.html">Module <TT>Thread</TT>: lightweight threads</A>
</LI><LI CLASS="li-links"><A HREF="libref/Mutex.html">Module <TT>Mutex</TT>: locks for mutual exclusion</A>
</LI><LI CLASS="li-links"><A HREF="libref/Condition.html">Module <TT>Condition</TT>: condition variables to synchronize between threads</A>
</LI><LI CLASS="li-links"><A HREF="libref/Event.html">Module <TT>Event</TT>: first-class synchronous communication</A>
</LI><LI CLASS="li-links"><A HREF="libref/ThreadUnix.html">Module <TT>ThreadUnix</TT>: thread-compatible system calls</A>
</LI></UL><!--TOC chapter The graphics library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc271">Chapter 25</A>  The graphics library</H1><!--SEC END --><P>The <TT>graphics</TT> library provides a set of portable drawing primitives.
Drawing takes place
in a separate window that is created when <TT>Graphics.open_graph</TT> is called.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
This library is implemented under the X11 windows system. 
Programs that use the <TT>graphics</TT> library must be linked as follows:
<PRE>
        ocamlc <I>other options</I> graphics.cma <I>other files</I>
</PRE>
For interactive use of the <TT>graphics</TT> library, do:
<PRE>
        ocamlmktop -o mytop graphics.cma
        ./mytop
</PRE>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "graphics.cma";;</TT>.<P>Here are the graphics mode specifications supported by
<TT>Graphics.open_graph</TT> on
the X11 implementation of this library:
the argument to <TT>Graphics.open_graph</TT> has the format
<TT>"</TT><I>display-name geometry</I><TT>"</TT>,
where <I>display-name</I> is the name of the X-windows display to
connect to, and <I>geometry</I> is a standard X-windows geometry
specification. The two components are separated by a space. Either can
be omitted, or both. Examples:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>Graphics.open_graph "foo:0"</TT></B></DT><DD CLASS="dd-description">
connects to the display <TT>foo:0</TT> and creates a window with the default geometry
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph "foo:0 300x100+50-0"</TT></B></DT><DD CLASS="dd-description">
connects to the display <TT>foo:0</TT> and creates a window 300 pixels wide
by 100 pixels tall, at location (50,0)
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph " 300x100+50-0"</TT></B></DT><DD CLASS="dd-description">
connects to the default display and creates a window 300 pixels wide
by 100 pixels tall, at location (50,0)
</DD><DT CLASS="dt-description"><B><TT>Graphics.open_graph ""</TT></B></DT><DD CLASS="dd-description">
connects to the default display and creates a window with the default
geometry.
</DD></DL></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
This library is available both for standalone compiled programs and
under the toplevel application <TT>ocamlwin.exe</TT>. For the latter, this
library must be loaded in-core by typing
<PRE CLASS="verbatim">        #load "graphics.cma";;
</PRE></BLOCKQUOTE><P>The screen coordinates are interpreted as shown in the figure below.
Notice that the coordinate system used is the same as in mathematics:
<I>y</I> increases from the bottom of the screen to the top of the screen,
and angles are measured counterclockwise (in degrees).
Drawing is clipped to the screen.
</P><DIV CLASS="center">
<IMG SRC="libgraph.gif">
</DIV><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Graphics.html">Module <TT>Graphics</TT>: machine-independent graphics primitives</A>
</LI></UL><!--TOC chapter The dbm library: access to NDBM databases-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc272">Chapter 26</A>  The dbm library: access to NDBM databases</H1><!--SEC END --><P>The <TT>dbm</TT> library provides access to NDBM databases under Unix.
NDBM databases maintain key/data associations, where both the key and
the data are arbitrary strings. They support fairly large databases
(several gigabytes) and can retrieve a keyed item in one or two file
system accesses. Refer to the Unix manual pages for more information.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
Programs that use the <TT>dbm</TT> library must be linked as follows:
<PRE>
        ocamlc <I>other options</I> dbm.cma <I>other files</I>
        ocamlopt <I>other options</I> dbm.cmxa <I>other files</I>
</PRE>
For interactive use of the <TT>dbm</TT> library, do:
<PRE>
        ocamlmktop -o mytop dbm.cma
        ./mytop
</PRE>
</BLOCKQUOTE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "dbm.cma";;</TT>.</P><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
This library is not available.
</BLOCKQUOTE><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Dbm.html">Module <TT>Dbm</TT>: interface to the NDBM database</A>
</LI></UL><!--TOC chapter The dynlink library: dynamic loading and linking of object files-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc273">Chapter 27</A>  The dynlink library: dynamic loading and linking of object files</H1><!--SEC END --><P>The <TT>dynlink</TT> library supports type-safe dynamic loading and linking
of bytecode object files (<TT>.cmo</TT> and <TT>.cma</TT> files) in a running
bytecode program, or of native plugins (usually <TT>.cmxs</TT> files) in a
running native program. Type safety is ensured by limiting the set of
modules from the running program that the loaded object file can
access, and checking that the running program and the loaded object
file have been compiled against the same interfaces for these modules.
In native code, there are also some compatibility checks on the
implementations (to avoid errors with cross-module optimizations); it
might be useful to hide <TT>.cmx</TT> files when building native plugins so
that they remain independent of the implementation of modules in the
main program.</P><P>Programs that use the <TT>dynlink</TT> library simply need to link
<TT>dynlink.cma</TT> or <TT>dynlink.cmxa</TT> with their object files and other libraries. </P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Dynlink.html">Module <TT>Dynlink</TT>: dynamic loading of bytecode object files</A>
</LI></UL><!--TOC chapter The LablTk library: Tcl/Tk GUI interface-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc274">Chapter 28</A>  The LablTk library: Tcl/Tk GUI interface</H1><!--SEC END --><P>The <TT>labltk</TT> library provides access to the Tcl/Tk GUI from
OCaml programs. This interface is generated in an automated way, and
you should refer to Tcl/Tk books and man pages for detailed
information on the behavior of the numerous functions. We also suggest
to use <TT>ocamlbrowser</TT> to see the types of the various functions, that
are the best documentation for the library itself. </P><P><BR>
Programs that use the <TT>labltk</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> -I +labltk labltk.cma <I>other files</I>
        ocamlopt <I>other options</I> -I +labltk labltk.cmxa <I>other files</I>
</PRE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Unix:</FONT>  
The <TT>labltk</TT> library is available for any system with Tcl/Tk installed,
starting from Tcl 7.5/Tk 4.1 up to Tcl/Tk 8.4. Beware that some beta
versions may have compatibility problems.<P>If the library was not compiled correctly, try to run again the
<TT>configure</TT> script with the option <TT>-tkdefs</TT> <I>switches</I>,
where <I>switches</I> is a list of C-style inclusion paths leading to
the right <TT>tcl.h</TT> and <TT>tk.h</TT>, for instance
&#X2019;<TT>-I/usr/local/include/tcl8.4 -I/usr/local/include/tk8.4</TT>&#X2019;.</P><P>A script is installed, to make easier the use of the <TT>labltk</TT>
library as toplevel.
</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>labltk</B></TT></DT><DD CLASS="dd-description">
This is a toplevel including the <TT>labltk</TT> library, and the path is
already set as to allow the use of the various modules. It also
includes code for the Unix and Str libraries. You can use it
in place of <TT>ocaml</TT>.
</DD></DL></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT COLOR=purple>Windows:</FONT>  
The <TT>labltk</TT> library has been precompiled for use with Tcl/Tk 8.4.
You must first have it installed on your system.
It can be downloaded from<BR>
<TT>http://www.activestate.com/products/ActiveTcl/</TT>.
After installing it, you must put the dynamically loaded libraries
<TT>tcl84.dll</TT> and <TT>tk84.dll</TT> (from the <TT>bin</TT> directory of the Tcl
installation) in a directory included in you path.<P>No toplevel is available, but you can load the library from the
standard toplevel with the following commands.
</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim"># #directory "+labltk";;
# #load "labltk.cma";;
</PRE></BLOCKQUOTE><P>
You can also load it directly from the command line.
</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim">C:\ocaml\bin&gt; ocaml -I +labltk labltk.cma
</PRE></BLOCKQUOTE></BLOCKQUOTE><P>The <TT>labltk</TT> library is composed of a large number of modules.
</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim">Bell                Imagebitmap         Place
Button              Imagephoto          Radiobutton
Canvas              Label               Scale
Checkbutton         Listbox             Scrollbar
Clipboard           Menu                Selection
Dialog              Menubutton          Text
Entry               Message             Tk
Focus               Option              Tkwait
Frame               Optionmenu          Toplevel
Grab                Pack                Winfo
Grid                Palette             Wm
</PRE></BLOCKQUOTE><P>Giving a detailed account of each of these module would be impractical
here. We will just present some of the basic functions in the module
<TT>Tk</TT>. Note that for most other modules information can be found in the
Tcl <TT>man</TT> page of their name.</P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Tk.html">The <TT>Tk</TT> library: Basic functions and types for LablTk</A>
</LI></UL><!--TOC chapter The bigarray library-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc275">Chapter 29</A>  The bigarray library</H1><!--SEC END --><P>The <TT>bigarray</TT> library implements large, multi-dimensional, numerical
arrays. These arrays are called &#X201C;big arrays&#X201D; to distinguish them
from the standard Caml arrays described in 
<A HREF="libref/Array.html">Module <TT>Array</TT></A>.
The main differences between &#X201C;big arrays&#X201D; and standard Caml arrays
are as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Big arrays are not limited in size, unlike Caml arrays
(<TT>float array</TT> are limited to 2097151 elements on a 32-bit platform,
other <TT>array</TT> types to 4194303 elements).
</LI><LI CLASS="li-itemize">Big arrays are multi-dimensional. Any number of dimensions
between 1 and 16 is supported. In contrast, Caml arrays are
mono-dimensional and require encoding multi-dimensional arrays as
arrays of arrays.
</LI><LI CLASS="li-itemize">Big arrays can only contain integers and floating-point
numbers, while Caml arrays can contain arbitrary Caml data types.
However, big arrays provide more space-efficient storage of integer
and floating-point elements, in particular because they support
&#X201C;small&#X201D; types such as single-precision floats and 8 and 16-bit
integers, in addition to the standard Caml types of double-precision
floats and 32 and 64-bit integers.
</LI><LI CLASS="li-itemize">The memory layout of big arrays is entirely compatible with that
of arrays in C and Fortran, allowing large arrays to be passed back
and forth between Caml code and C / Fortran code with no data copying
at all.
</LI><LI CLASS="li-itemize">Big arrays support interesting high-level operations that normal
arrays do not provide efficiently, such as extracting sub-arrays and
&#X201C;slicing&#X201D; a multi-dimensional array along certain dimensions, all
without any copying.
</LI></UL><P>
Programs that use the <TT>bigarray</TT> library must be linked as follows:
</P><PRE>
        ocamlc <I>other options</I> bigarray.cma <I>other files</I>
        ocamlopt <I>other options</I> bigarray.cmxa <I>other files</I>
</PRE><P>
For interactive use of the <TT>bigarray</TT> library, do:
</P><PRE>
        ocamlmktop -o mytop bigarray.cma
        ./mytop
</PRE><P>
or (if dynamic linking of C libraries is supported on your platform),
start <TT>ocaml</TT> and type <TT>#load "bigarray.cma";;</TT>.</P><!--TOC section Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc276">29.1</A>  Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays</H2><!--SEC END --><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/Bigarray.html">Module <TT>Bigarray</TT></A>
</LI></UL><!--TOC section Big arrays in the Caml-C interface-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc277">29.2</A>  Big arrays in the Caml-C interface</H2><!--SEC END --><P>C stub code that interface C or Fortran code with Caml code, as
described in chapter <A HREF="#c:intf-c">18</A>, can exploit big arrays as
follows.</P><!--TOC subsection Include file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc278">29.2.1</A>  Include file</H3><!--SEC END --><P>The include file <TT>&lt;caml/bigarray.h&gt;</TT> must be included in the C stub
file. It declares the functions, constants and macros discussed
below.</P><!--TOC subsection Accessing a Caml bigarray from C or Fortran-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc279">29.2.2</A>  Accessing a Caml bigarray from C or Fortran</H3><!--SEC END --><P>If <I>v</I> is a Caml <TT>value</TT> representing a big array, the expression
<TT>Data_bigarray_val(</TT><I>v</I><TT>)</TT> returns a pointer to the data part of the array.
This pointer is of type <TT>void *</TT> and can be cast to the appropriate C
type for the array (e.g. <TT>double []</TT>, <TT>char [][10]</TT>, etc).</P><P>Various characteristics of the Caml big array can be consulted from C
as follows:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>C expression</B></TD><TD ALIGN=center NOWRAP><B>Returns</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;num_dims</TT></TD><TD ALIGN=left NOWRAP>number of dimensions</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;dim[</TT><I>i</I><TT>]</TT></TD><TD ALIGN=left NOWRAP><I>i</I>-th dimension</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Bigarray_val(</TT><I>v</I><TT>)-&gt;flags &amp; BIGARRAY_KIND_MASK</TT></TD><TD ALIGN=left NOWRAP>kind of array elements</TD></TR>
</TABLE></DIV><P>
The kind of array elements is one of the following constants:
</P><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1 WIDTH="80%"><TR><TD ALIGN=center NOWRAP><B>Constant</B></TD><TD ALIGN=center NOWRAP><B>Element kind</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>BIGARRAY_FLOAT32</TT></TD><TD ALIGN=left NOWRAP>32-bit single-precision floats</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_FLOAT64</TT></TD><TD ALIGN=left NOWRAP>64-bit double-precision floats</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_SINT8</TT></TD><TD ALIGN=left NOWRAP>8-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_UINT8</TT></TD><TD ALIGN=left NOWRAP>8-bit unsigned integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_SINT16</TT></TD><TD ALIGN=left NOWRAP>16-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_UINT16</TT></TD><TD ALIGN=left NOWRAP>16-bit unsigned integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_INT32</TT></TD><TD ALIGN=left NOWRAP>32-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_INT64</TT></TD><TD ALIGN=left NOWRAP>64-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_CAML_INT</TT></TD><TD ALIGN=left NOWRAP>31- or 63-bit signed integers</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>BIGARRAY_NATIVE_INT</TT></TD><TD ALIGN=left NOWRAP>32- or 64-bit (platform-native) integers</TD></TR>
</TABLE></DIV><P>
The following example shows the passing of a two-dimensional big array
to a C function and a Fortran function.
</P><PRE CLASS="verbatim">    extern void my_c_function(double * data, int dimx, int dimy);
    extern void my_fortran_function_(double * data, int * dimx, int * dimy);

    value caml_stub(value bigarray)
    {
      int dimx = Bigarray_val(bigarray)-&gt;dim[0];
      int dimy = Bigarray_val(bigarray)-&gt;dim[1];
      /* C passes scalar parameters by value */
      my_c_function(Data_bigarray_val(bigarray), dimx, dimy);
      /* Fortran passes all parameters by reference */
      my_fortran_function_(Data_bigarray_val(bigarray), &amp;dimx, &amp;dimy);
      return Val_unit;
    }
</PRE><!--TOC subsection Wrapping a C or Fortran array as a Caml big array-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc280">29.2.3</A>  Wrapping a C or Fortran array as a Caml big array</H3><!--SEC END --><P>A pointer <I>p</I> to an already-allocated C or Fortran array can be
wrapped and returned to Caml as a big array using the <TT>alloc_bigarray</TT>
or <TT>alloc_bigarray_dims</TT> functions.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>alloc_bigarray(</TT><I>kind</I> <TT>|</TT> <I>layout</I>, <I>numdims</I>, <I>p</I>, <I>dims</I><TT>)</TT><P>Return a Caml big array wrapping the data pointed to by <I>p</I>.
<I>kind</I> is the kind of array elements (one of the <TT>BIGARRAY_</TT>
kind constants above). <I>layout</I> is <TT>BIGARRAY_C_LAYOUT</TT> for an
array with C layout and <TT>BIGARRAY_FORTRAN_LAYOUT</TT> for an array with
Fortran layout. <I>numdims</I> is the number of dimensions in the
array. <I>dims</I> is an array of <I>numdims</I> long integers, giving
the sizes of the array in each dimension.</P></LI><LI CLASS="li-itemize"><TT>alloc_bigarray_dims(</TT><I>kind</I> <TT>|</TT> <I>layout</I>, <I>numdims</I>,
<I>p</I>, <TT>(long) </TT><I>dim</I><SUB>1</SUB>, <TT>(long) </TT><I>dim</I><SUB>2</SUB>, &#X2026;, <TT>(long) </TT><I>dim<SUB>numdims</SUB></I><TT>)</TT><P>Same as <TT>alloc_bigarray</TT>, but the sizes of the array in each dimension
are listed as extra arguments in the function call, rather than being
passed as an array.
</P></LI></UL><P>
The following example illustrates how statically-allocated C and
Fortran arrays can be made available to Caml.
</P><PRE CLASS="verbatim">    extern long my_c_array[100][200];
    extern float my_fortran_array_[300][400];

    value caml_get_c_array(value unit)
    {
      long dims[2];
      dims[0] = 100; dims[1] = 200;
      return alloc_bigarray(BIGARRAY_NATIVE_INT | BIGARRAY_C_LAYOUT,
                            2, my_c_array, dims);
    }

    value caml_get_fortran_array(value unit)
    {
      return alloc_bigarray_dims(BIGARRAY_FLOAT32 | BIGARRAY_FORTRAN_LAYOUT,
                                 2, my_fortran_array_, 300L, 400L);
    }
</PRE><!--TOC part Appendix-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc281">Part V</A><BR>
Appendix</H1></TD></TR>
</TABLE><!--SEC END --><P>
<A NAME="p:appendix"></A></P><UL CLASS="ftoc2"><LI CLASS="li-links">
<A HREF="libref/index_modules.html">Index of modules</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_module_types.html">Index of module types</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_types.html">Index of types</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_exceptions.html">Index of exceptions</A>
</LI><LI CLASS="li-links"><A HREF="libref/index_values.html">Index of values</A>
</LI></UL><!--TOC chapter Index of keywords-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index of keywords</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
<TT>and</TT>, see <I><TT>let</TT>, <TT>type</TT>, <TT>class</TT></I>, <A HREF="#@manual.kwd84">6.9.2</A>, <A HREF="#@manual.kwd109">6.9.3</A>, <A HREF="#@manual.kwd113">6.9.4</A>, <A HREF="#@manual.kwd117">6.9.5</A>
</LI><LI CLASS="li-indexenv"><TT>as</TT>, <A HREF="#@manual.kwd2">6.4</A>, <A HREF="#@manual.kwd3">6.4</A>, <A HREF="#@manual.kwd4">6.4</A>, <A HREF="#@manual.kwd5">6.6</A>, <A HREF="#@manual.kwd6">6.6</A>, <A HREF="#@manual.kwd7">6.6</A>, <A HREF="#@manual.kwd86">6.9.2</A>, <A HREF="#@manual.kwd95">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>assert</TT>, <A HREF="#@manual.kwd173">7.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>begin</TT>, <A HREF="#@manual.kwd27">6.7</A>, <A HREF="#@manual.kwd39">6.7.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>class</TT>, <A HREF="#@manual.kwd108">6.9.3</A>, <A HREF="#@manual.kwd112">6.9.4</A>, <A HREF="#@manual.kwd115">6.9.5</A>, <A HREF="#@manual.kwd127">6.10</A>, <A HREF="#@manual.kwd137">6.10.2</A>, <A HREF="#@manual.kwd138">6.10.2</A>, <A HREF="#@manual.kwd154">6.11</A>, <A HREF="#@manual.kwd164">6.11.2</A>, <A HREF="#@manual.kwd165">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>constraint</TT>, <A HREF="#@manual.kwd55">6.8.1</A>, <A HREF="#@manual.kwd57">6.8.1</A>, <A HREF="#@manual.kwd67">6.9.1</A>, <A HREF="#@manual.kwd77">6.9.1</A>, <A HREF="#@manual.kwd92">6.9.2</A>, <A HREF="#@manual.kwd106">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>do</TT>, see <I><TT>while</TT>, <TT>for</TT></I>
</LI><LI CLASS="li-indexenv"><TT>done</TT>, see <I><TT>while</TT>, <TT>for</TT></I>
</LI><LI CLASS="li-indexenv"><TT>downto</TT>, see <TT><I>for</I></TT>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>else</TT>, see <TT><I>if</I></TT>
</LI><LI CLASS="li-indexenv"><TT>end</TT>, <A HREF="#@manual.kwd28">6.7</A>, <A HREF="#@manual.kwd40">6.7.1</A>, <A HREF="#@manual.kwd60">6.9.1</A>, <A HREF="#@manual.kwd79">6.9.2</A>, <A HREF="#@manual.kwd120">6.10</A>, <A HREF="#@manual.kwd132">6.10.2</A>, <A HREF="#@manual.kwd148">6.11</A>, <A HREF="#@manual.kwd159">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>exception</TT>, <A HREF="#@manual.kwd58">6.8.2</A>, <A HREF="#@manual.kwd126">6.10</A>, <A HREF="#@manual.kwd136">6.10.2</A>, <A HREF="#@manual.kwd153">6.11</A>, <A HREF="#@manual.kwd163">6.11.2</A>
</LI><LI CLASS="li-indexenv"><TT>external</TT>, <A HREF="#@manual.kwd124">6.10</A>, <A HREF="#@manual.kwd134">6.10.2</A>, <A HREF="#@manual.kwd151">6.11</A>, <A HREF="#@manual.kwd161">6.11.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>false</TT>, <A HREF="#@manual.kwd0">6.3</A>
</LI><LI CLASS="li-indexenv"><TT>for</TT>, <A HREF="#@manual.kwd20">6.7</A>, <A HREF="#@manual.kwd49">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>fun</TT>, <A HREF="#@manual.kwd14">6.7</A>, <A HREF="#@manual.kwd34">6.7</A>, <A HREF="#@manual.kwd42">6.7.1</A>, <A HREF="#@manual.kwd80">6.9.2</A>, <A HREF="#@manual.kwd185">7.13</A>
</LI><LI CLASS="li-indexenv"><TT>function</TT>, <A HREF="#@manual.kwd13">6.7</A>, <A HREF="#@manual.kwd35">6.7</A>, <A HREF="#@manual.kwd41">6.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>functor</TT>, <A HREF="#@manual.kwd121">6.10</A>, <A HREF="#@manual.kwd145">6.10.3</A>, <A HREF="#@manual.kwd149">6.11</A>, <A HREF="#@manual.kwd172">6.11.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>if</TT>, <A HREF="#@manual.kwd23">6.7</A>, <A HREF="#@manual.kwd33">6.7</A>, <A HREF="#@manual.kwd45">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>in</TT>, see <TT><I>let</I></TT>, <A HREF="#@manual.kwd83">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>include</TT>, <A HREF="#@manual.kwd130">6.10</A>, <A HREF="#@manual.kwd144">6.10.2</A>, <A HREF="#@manual.kwd157">6.11</A>, <A HREF="#@manual.kwd171">6.11.2</A>, <A HREF="#@manual.kwd191">7.15</A>
</LI><LI CLASS="li-indexenv"><TT>inherit</TT>, <A HREF="#@manual.kwd61">6.9.1</A>, <A HREF="#@manual.kwd68">6.9.1</A>, <A HREF="#@manual.kwd85">6.9.2</A>, <A HREF="#@manual.kwd94">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>initializer</TT>, <A HREF="#@manual.kwd93">6.9.2</A>, <A HREF="#@manual.kwd107">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>lazy</TT>, <A HREF="#@manual.kwd174">7.6</A>
</LI><LI CLASS="li-indexenv"><TT>let</TT>, <A HREF="#@manual.kwd11">6.7</A>, <A HREF="#@manual.kwd38">6.7</A>, <A HREF="#@manual.kwd44">6.7.1</A>, <A HREF="#@manual.kwd81">6.9.2</A>, <A HREF="#@manual.kwd150">6.11</A>, <A HREF="#@manual.kwd160">6.11.2</A>, <A HREF="#@manual.kwd175">7.7</A>, <A HREF="#@manual.kwd181">7.10</A>, <A HREF="#@manual.kwd183">7.12</A>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv"><TT>match</TT>, <A HREF="#@manual.kwd26">6.7</A>, <A HREF="#@manual.kwd36">6.7</A>, <A HREF="#@manual.kwd46">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>method</TT>, <A HREF="#@manual.kwd64">6.9.1</A>, <A HREF="#@manual.kwd72">6.9.1</A>, <A HREF="#@manual.kwd75">6.9.1</A>, <A HREF="#@manual.kwd89">6.9.2</A>, <A HREF="#@manual.kwd101">6.9.2</A>, <A HREF="#@manual.kwd104">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>module</TT>, <A HREF="#@manual.kwd128">6.10</A>, <A HREF="#@manual.kwd140">6.10.2</A>, <A HREF="#@manual.kwd142">6.10.2</A>, <A HREF="#@manual.kwd155">6.11</A>, <A HREF="#@manual.kwd167">6.11.2</A>, <A HREF="#@manual.kwd169">6.11.2</A>, <A HREF="#@manual.kwd176">7.7</A>, <A HREF="#@manual.kwd177">7.8</A>, <A HREF="#@manual.kwd186">7.14</A>, <A HREF="#@manual.kwd189">7.15</A>, <A HREF="#@manual.kwd193">7.16</A>
</LI><LI CLASS="li-indexenv"><TT>mutable</TT>, <A HREF="#@manual.kwd54">6.8.1</A>, <A HREF="#@manual.kwd56">6.8.1</A>, <A HREF="#@manual.kwd63">6.9.1</A>, <A HREF="#@manual.kwd70">6.9.1</A>, <A HREF="#@manual.kwd88">6.9.2</A>, <A HREF="#@manual.kwd97">6.9.2</A>, <A HREF="#@manual.kwd100">6.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>new</TT>, <A HREF="#@manual.kwd30">6.7</A>, <A HREF="#@manual.kwd51">6.7.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>object</TT>, <A HREF="#@manual.kwd31">6.7</A>, <A HREF="#@manual.kwd52">6.7.5</A>, <A HREF="#@manual.kwd59">6.9.1</A>, <A HREF="#@manual.kwd78">6.9.2</A>
</LI><LI CLASS="li-indexenv"><TT>of</TT>, see <I><TT>type</TT>, <TT>exception</TT></I>
</LI><LI CLASS="li-indexenv"><TT>open</TT>, <A HREF="#@manual.kwd129">6.10</A>, <A HREF="#@manual.kwd143">6.10.2</A>, <A HREF="#@manual.kwd156">6.11</A>, <A HREF="#@manual.kwd170">6.11.2</A>, <A HREF="#@manual.kwd182">7.10</A>
</LI><LI CLASS="li-indexenv"><TT>or</TT>, <A HREF="#@manual.kwd25">6.7</A>, <A HREF="#@manual.kwd32">6.7</A>, <A HREF="#@manual.kwd47">6.7.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>private</TT>, <A HREF="#@manual.kwd65">6.9.1</A>, <A HREF="#@manual.kwd73">6.9.1</A>, <A HREF="#@manual.kwd76">6.9.1</A>, <A HREF="#@manual.kwd90">6.9.2</A>, <A HREF="#@manual.kwd102">6.9.2</A>, <A HREF="#@manual.kwd105">6.9.2</A>, <A HREF="#@manual.kwd179">7.9</A>, <A HREF="#@manual.kwd180">7.9.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>rec</TT>, see <TT><I>let</I></TT>, <A HREF="#@manual.kwd82">6.9.2</A>, <A HREF="#@manual.kwd178">7.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>sig</TT>, <A HREF="#@manual.kwd119">6.10</A>, <A HREF="#@manual.kwd131">6.10.2</A>
</LI><LI CLASS="li-indexenv"><TT>struct</TT>, <A HREF="#@manual.kwd147">6.11</A>, <A HREF="#@manual.kwd158">6.11.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>then</TT>, see <TT><I>if</I></TT>
</LI><LI CLASS="li-indexenv"><TT>to</TT>, see <TT><I>for</I></TT>
</LI><LI CLASS="li-indexenv"><TT>true</TT>, <A HREF="#@manual.kwd1">6.3</A>
</LI><LI CLASS="li-indexenv"><TT>try</TT>, <A HREF="#@manual.kwd12">6.7</A>, <A HREF="#@manual.kwd37">6.7</A>, <A HREF="#@manual.kwd50">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>type</TT>, <A HREF="#@manual.kwd53">6.8.1</A>, <A HREF="#@manual.kwd116">6.9.5</A>, <A HREF="#@manual.kwd125">6.10</A>, <A HREF="#@manual.kwd135">6.10.2</A>, <A HREF="#@manual.kwd139">6.10.2</A>, <A HREF="#@manual.kwd141">6.10.2</A>, <A HREF="#@manual.kwd152">6.11</A>, <A HREF="#@manual.kwd162">6.11.2</A>, <A HREF="#@manual.kwd166">6.11.2</A>, <A HREF="#@manual.kwd168">6.11.2</A>, <A HREF="#@manual.kwd184">7.13</A>, <A HREF="#@manual.kwd190">7.15</A>, <A HREF="#@manual.kwd194">7.16</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>val</TT>, <A HREF="#@manual.kwd62">6.9.1</A>, <A HREF="#@manual.kwd69">6.9.1</A>, <A HREF="#@manual.kwd87">6.9.2</A>, <A HREF="#@manual.kwd96">6.9.2</A>, <A HREF="#@manual.kwd99">6.9.2</A>, <A HREF="#@manual.kwd123">6.10</A>, <A HREF="#@manual.kwd133">6.10.2</A>, <A HREF="#@manual.kwd187">7.14</A>
</LI><LI CLASS="li-indexenv"><TT>virtual</TT>, <A HREF="#@manual.kwd66">6.9.1</A>, <A HREF="#@manual.kwd71">6.9.1</A>, <A HREF="#@manual.kwd74">6.9.1</A>, <A HREF="#@manual.kwd91">6.9.2</A>, <A HREF="#@manual.kwd98">6.9.2</A>, <A HREF="#@manual.kwd103">6.9.2</A>, <A HREF="#@manual.kwd110">6.9.3</A>, <A HREF="#@manual.kwd111">6.9.3</A>, <A HREF="#@manual.kwd114">6.9.4</A>, <A HREF="#@manual.kwd118">6.9.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>when</TT>, <A HREF="#@manual.kwd29">6.7</A>, <A HREF="#@manual.kwd43">6.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>while</TT>, <A HREF="#@manual.kwd48">6.7.2</A>
</LI><LI CLASS="li-indexenv"><TT>with</TT>, see <I><TT>match</TT>, <TT>try</TT></I>, <A HREF="#@manual.kwd122">6.10</A>, <A HREF="#@manual.kwd146">6.10.4</A>, <A HREF="#@manual.kwd188">7.14</A>, <A HREF="#@manual.kwd192">7.16</A>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://hevea.inria.fr/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="manual.css">
<TITLE>Contents</TITLE>
</HEAD>
<BODY >
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="manual002.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter">Contents</H1><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="index.html#htoc1">Part I  An introduction to OCaml</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="manual003.html#htoc2">Chapter 1  The core language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual003.html#htoc3">1.1  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc4">1.2  Data types</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc5">1.3  Functions as values</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc6">1.4  Records and variants</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc7">1.5  Imperative features</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc8">1.6  Exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc9">1.7  Symbolic processing of expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc10">1.8  Pretty-printing and parsing</A>
</LI><LI CLASS="li-toc"><A HREF="manual003.html#htoc11">1.9  Standalone Caml programs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual004.html#htoc12">Chapter 2  The module system</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual004.html#htoc13">2.1  Structures</A>
</LI><LI CLASS="li-toc"><A HREF="manual004.html#htoc14">2.2  Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="manual004.html#htoc15">2.3  Functors</A>
</LI><LI CLASS="li-toc"><A HREF="manual004.html#htoc16">2.4  Functors and type abstraction</A>
</LI><LI CLASS="li-toc"><A HREF="manual004.html#htoc17">2.5  Modules and separate compilation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc18">Chapter 3  Objects in Caml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual005.html#htoc19">3.1  Classes and objects</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc20">3.2  Immediate objects</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc21">3.3  Reference to self</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc22">3.4  Initializers</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc23">3.5  Virtual methods</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc24">3.6  Private methods</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc25">3.7  Class interfaces</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc26">3.8  Inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc27">3.9  Multiple inheritance</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc28">3.10  Parameterized classes</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc29">3.11  Polymorphic methods</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc30">3.12  Using coercions</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc31">3.13  Functional objects</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc32">3.14  Cloning objects</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc33">3.15  Recursive classes</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc34">3.16  Binary methods</A>
</LI><LI CLASS="li-toc"><A HREF="manual005.html#htoc35">3.17  Friends</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual006.html#htoc36">Chapter 4  Labels and variants</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual006.html#htoc37">4.1  Labels</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual006.html#htoc38">4.1.1  Optional arguments</A>
</LI><LI CLASS="li-toc"><A HREF="manual006.html#htoc39">4.1.2  Labels and type inference</A>
</LI><LI CLASS="li-toc"><A HREF="manual006.html#htoc40">4.1.3  Suggestions for labeling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual006.html#htoc41">4.2  Polymorphic variants</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual006.html#htoc42">4.2.1  Weaknesses of polymorphic variants</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual007.html#htoc43">Chapter 5  Advanced examples with classes and modules</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual007.html#htoc44">5.1  Extended example: bank accounts</A>
</LI><LI CLASS="li-toc"><A HREF="manual007.html#htoc45">5.2  Simple modules as classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual007.html#htoc46">5.2.1  Strings</A>
</LI><LI CLASS="li-toc"><A HREF="manual007.html#htoc47">5.2.2  Hashtbl</A>
</LI><LI CLASS="li-toc"><A HREF="manual007.html#htoc48">5.2.3  Sets</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual007.html#htoc49">5.3  The subject/observer pattern</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="index.html#htoc50">Part II  The OCaml language</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="language.html#htoc51">Chapter 6  The OCaml language</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="lex.html#htoc52">6.1  Lexical conventions</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc53">6.2  Values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual010.html#htoc54">6.2.1  Base values</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc55">6.2.2  Tuples</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc56">6.2.3  Records</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc57">6.2.4  Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc58">6.2.5  Variant values</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc59">6.2.6  Polymorphic variants</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc60">6.2.7  Functions</A>
</LI><LI CLASS="li-toc"><A HREF="manual010.html#htoc61">6.2.8  Objects</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual011.html#htoc62">6.3  Names</A>
</LI><LI CLASS="li-toc"><A HREF="types.html#htoc63">6.4  Type expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual013.html#htoc64">6.5  Constants</A>
</LI><LI CLASS="li-toc"><A HREF="patterns.html#htoc65">6.6  Patterns</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc66">6.7  Expressions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="expr.html#htoc67">6.7.1  Basic expressions</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc68">6.7.2  Control structures</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc69">6.7.3  Operations on data structures</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc70">6.7.4  Operators</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc71">6.7.5  Objects</A>
</LI><LI CLASS="li-toc"><A HREF="expr.html#htoc72">6.7.6  Coercions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual016.html#htoc73">6.8  Type and exception definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual016.html#htoc74">6.8.1  Type definitions</A>
</LI><LI CLASS="li-toc"><A HREF="manual016.html#htoc75">6.8.2  Exception definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual017.html#htoc76">6.9  Classes</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual017.html#htoc77">6.9.1  Class types</A>
</LI><LI CLASS="li-toc"><A HREF="manual017.html#htoc78">6.9.2  Class expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual017.html#htoc79">6.9.3  Class definitions</A>
</LI><LI CLASS="li-toc"><A HREF="manual017.html#htoc80">6.9.4  Class specification</A>
</LI><LI CLASS="li-toc"><A HREF="manual017.html#htoc81">6.9.5  Class type definitions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual018.html#htoc82">6.10  Module types (module specifications)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual018.html#htoc83">6.10.1  Simple module types</A>
</LI><LI CLASS="li-toc"><A HREF="manual018.html#htoc84">6.10.2  Signatures</A>
</LI><LI CLASS="li-toc"><A HREF="manual018.html#htoc85">6.10.3  Functor types</A>
</LI><LI CLASS="li-toc"><A HREF="manual018.html#htoc86">6.10.4  The <TT>with</TT> operator</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual019.html#htoc87">6.11  Module expressions (module implementations)</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual019.html#htoc88">6.11.1  Simple module expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual019.html#htoc89">6.11.2  Structures</A>
</LI><LI CLASS="li-toc"><A HREF="manual019.html#htoc90">6.11.3  Functors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual020.html#htoc91">6.12  Compilation units</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc92">Chapter 7  Language extensions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual021.html#htoc93">7.1  Integer literals for types <TT>int32</TT>, <TT>int64</TT> and <TT>nativeint</TT></A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc94">7.2  Streams and stream parsers</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc95">7.3  Recursive definitions of values</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc96">7.4  Range patterns</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc97">7.5  Assertion checking</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc98">7.6  Lazy evaluation</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc99">7.7  Local modules</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc100">7.8  Recursive modules</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc101">7.9  Private types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual021.html#htoc102">7.9.1  Private variant and record types</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc103">7.9.2  Private type abbreviations</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc104">7.9.3  Private row types</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc105">7.10  Local opens</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc106">7.11  Record notations</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc107">7.12  Explicit polymorphic type annotations</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc108">7.13  Explicit naming of type variables</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc109">7.14  First-class modules</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc110">7.15  Recovering the type of a module</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc111">7.16  Substituting inside a signature</A>
</LI><LI CLASS="li-toc"><A HREF="manual021.html#htoc112">7.17  Explicit overriding in class definitions</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="index.html#htoc113">Part III  The OCaml tools</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="manual022.html#htoc114">Chapter 8  Batch compilation (ocamlc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual022.html#htoc115">8.1  Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="manual022.html#htoc116">8.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual022.html#htoc117">8.3  Modules and the file system</A>
</LI><LI CLASS="li-toc"><A HREF="manual022.html#htoc118">8.4  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc119">Chapter 9  The toplevel system (ocaml)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual023.html#htoc120">9.1  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc121">9.2  Toplevel directives</A>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc122">9.3  The toplevel and the module system</A>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc123">9.4  Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc124">9.5  Building custom toplevel systems: <TT>ocamlmktop</TT></A>
</LI><LI CLASS="li-toc"><A HREF="manual023.html#htoc125">9.6  Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual024.html#htoc126">Chapter 10  The runtime system (ocamlrun)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual024.html#htoc127">10.1  Overview</A>
</LI><LI CLASS="li-toc"><A HREF="manual024.html#htoc128">10.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual024.html#htoc129">10.3  Dynamic loading of shared libraries</A>
</LI><LI CLASS="li-toc"><A HREF="manual024.html#htoc130">10.4  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual025.html#htoc131">Chapter 11  Native-code compilation (ocamlopt)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual025.html#htoc132">11.1  Overview of the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="manual025.html#htoc133">11.2  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual025.html#htoc134">11.3  Common errors</A>
</LI><LI CLASS="li-toc"><A HREF="manual025.html#htoc135">11.4  Running executables produced by ocamlopt</A>
</LI><LI CLASS="li-toc"><A HREF="manual025.html#htoc136">11.5  Compatibility with the bytecode compiler</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc137">Chapter 12  Lexer and parser generators (ocamllex, ocamlyacc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual026.html#htoc138">12.1  Overview of <TT>ocamllex</TT></A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual026.html#htoc139">12.1.1  Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc140">12.2  Syntax of lexer definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual026.html#htoc141">12.2.1  Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc142">12.2.2  Naming regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc143">12.2.3  Entry points</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc144">12.2.4  Regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc145">12.2.5  Actions</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc146">12.2.6  Variables in regular expressions</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc147">12.2.7  Reserved identifiers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc148">12.3  Overview of <TT>ocamlyacc</TT></A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc149">12.4  Syntax of grammar definitions</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual026.html#htoc150">12.4.1  Header and trailer</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc151">12.4.2  Declarations</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc152">12.4.3  Rules</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc153">12.4.4  Error handling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc154">12.5  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc155">12.6  A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="manual026.html#htoc156">12.7  Common errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual027.html#htoc157">Chapter 13  Dependency generator (ocamldep)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual027.html#htoc158">13.1  Options</A>
</LI><LI CLASS="li-toc"><A HREF="manual027.html#htoc159">13.2  A typical Makefile</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual028.html#htoc160">Chapter 14  The browser/editor (ocamlbrowser)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual028.html#htoc161">14.1  Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="manual028.html#htoc162">14.2  Viewer</A>
</LI><LI CLASS="li-toc"><A HREF="manual028.html#htoc163">14.3  Module browsing</A>
</LI><LI CLASS="li-toc"><A HREF="manual028.html#htoc164">14.4  File editor</A>
</LI><LI CLASS="li-toc"><A HREF="manual028.html#htoc165">14.5  Shell</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc166">Chapter 15  The documentation generator (ocamldoc)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual029.html#htoc167">15.1  Usage</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual029.html#htoc168">15.1.1  Invocation</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc169">15.1.2  Merging of module information</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc170">15.1.3  Coding rules</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc171">15.2  Syntax of documentation comments</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual029.html#htoc172">15.2.1  Placement of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc173">15.2.2  The Stop special comment</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc174">15.2.3  Syntax of documentation comments</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc175">15.2.4  Text formatting</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc176">15.2.5  Documentation tags (@-tags)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc177">15.3  Custom generators</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual029.html#htoc178">15.3.1  The generator class</A>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc179">15.3.2  Handling custom tags</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual029.html#htoc180">15.4  Adding command line options</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual029.html#htoc181">15.4.1  Compilation and usage</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc182">Chapter 16  The debugger (ocamldebug)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual030.html#htoc183">16.1  Compiling for debugging</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc184">16.2  Invocation</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual030.html#htoc185">16.2.1  Starting the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc186">16.2.2  Exiting the debugger</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc187">16.3  Commands</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual030.html#htoc188">16.3.1  Getting help</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc189">16.3.2  Accessing the debugger state</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc190">16.4  Executing a program</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual030.html#htoc191">16.4.1  Events</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc192">16.4.2  Starting the debugged program</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc193">16.4.3  Running the program</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc194">16.4.4  Time travel</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc195">16.4.5  Killing the program</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc196">16.5  Breakpoints</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc197">16.6  The call stack</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc198">16.7  Examining variable values</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc199">16.8  Controlling the debugger</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual030.html#htoc200">16.8.1  Setting the program name and arguments</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc201">16.8.2  How programs are loaded</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc202">16.8.3  Search path for files</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc203">16.8.4  Working directory</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc204">16.8.5  Turning reverse execution on and off</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc205">16.8.6  Communication between the debugger and the program</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc206">16.8.7  Fine-tuning the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc207">16.8.8  User-defined printers</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc208">16.9  Miscellaneous commands</A>
</LI><LI CLASS="li-toc"><A HREF="manual030.html#htoc209">16.10  Running the debugger under Emacs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual031.html#htoc210">Chapter 17  Profiling (ocamlprof)</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual031.html#htoc211">17.1  Compiling for profiling</A>
</LI><LI CLASS="li-toc"><A HREF="manual031.html#htoc212">17.2  Profiling an execution</A>
</LI><LI CLASS="li-toc"><A HREF="manual031.html#htoc213">17.3  Printing profiling information</A>
</LI><LI CLASS="li-toc"><A HREF="manual031.html#htoc214">17.4  Time profiling</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc215">Chapter 18  Interfacing C with OCaml</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc216">18.1  Overview and compilation information</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc217">18.1.1  Declaring primitives</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc218">18.1.2  Implementing primitives</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc219">18.1.3  Statically linking C code with Caml code</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc220">18.1.4  Dynamically linking C code with Caml code</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc221">18.1.5  Choosing between static linking and dynamic linking</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc222">18.1.6  Building standalone custom runtime systems</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc223">18.2  The <TT>value</TT> type</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc224">18.2.1  Integer values</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc225">18.2.2  Blocks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc226">18.2.3  Pointers outside the heap</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc227">18.3  Representation of Caml data types</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc228">18.3.1  Atomic types</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc229">18.3.2  Tuples and records</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc230">18.3.3  Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc231">18.3.4  Concrete data types</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc232">18.3.5  Objects</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc233">18.3.6  Polymorphic variants</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc234">18.4  Operations on values</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc235">18.4.1  Kind tests</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc236">18.4.2  Operations on integers</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc237">18.4.3  Accessing blocks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc238">18.4.4  Allocating blocks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc239">18.4.5  Raising exceptions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc240">18.5  Living in harmony with the garbage collector</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc241">18.5.1  Simple interface</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc242">18.5.2  Low-level interface</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc243">18.6  A complete example</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc244">18.7  Advanced topic: callbacks from C to Caml</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc245">18.7.1  Applying Caml closures from C</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc246">18.7.2  Registering Caml closures for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc247">18.7.3  Registering Caml exceptions for use in C functions</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc248">18.7.4  Main program in C</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc249">18.7.5  Embedding the Caml code in the C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc250">18.8  Advanced example with callbacks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc251">18.9  Advanced topic: custom blocks</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc252">18.9.1  The <TT>struct custom_operations</TT></A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc253">18.9.2  Allocating custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc254">18.9.3  Accessing custom blocks</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc255">18.9.4  Writing custom serialization and deserialization functions</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc256">18.9.5  Choosing identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc257">18.9.6  Finalized blocks</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc258">18.10  Advanced topic: multithreading</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual032.html#htoc259">18.10.1  Registering threads created from C</A>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc260">18.10.2  Parallel execution of long-running C code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual032.html#htoc261">18.11  Building mixed C/Caml libraries: <TT>ocamlmklib</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="index.html#htoc262">Part IV  The OCaml library</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="manual033.html#htoc263">Chapter 19  The core library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual033.html#htoc264">19.1  Built-in types and predefined exceptions</A>
</LI><LI CLASS="li-toc"><A HREF="manual033.html#htoc265">19.2  Module <TT>Pervasives</TT>: the initially opened module</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="manual034.html#htoc266">Chapter 20  The standard library</A>
</LI><LI CLASS="li-toc"><A HREF="manual035.html#htoc267">Chapter 21  The unix library: Unix system calls</A>
</LI><LI CLASS="li-toc"><A HREF="manual036.html#htoc268">Chapter 22  The num library: arbitrary-precision rational arithmetic</A>
</LI><LI CLASS="li-toc"><A HREF="manual037.html#htoc269">Chapter 23  The str library: regular expressions and string processing</A>
</LI><LI CLASS="li-toc"><A HREF="manual038.html#htoc270">Chapter 24  The threads library</A>
</LI><LI CLASS="li-toc"><A HREF="manual039.html#htoc271">Chapter 25  The graphics library</A>
</LI><LI CLASS="li-toc"><A HREF="manual040.html#htoc272">Chapter 26  The dbm library: access to NDBM databases</A>
</LI><LI CLASS="li-toc"><A HREF="manual041.html#htoc273">Chapter 27  The dynlink library: dynamic loading and linking of object files</A>
</LI><LI CLASS="li-toc"><A HREF="manual042.html#htoc274">Chapter 28  The LablTk library: Tcl/Tk GUI interface</A>
</LI><LI CLASS="li-toc"><A HREF="manual043.html#htoc275">Chapter 29  The bigarray library</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="manual043.html#htoc276">29.1  Module <TT>Bigarray</TT>: large, multi-dimensional, numerical arrays</A>
</LI><LI CLASS="li-toc"><A HREF="manual043.html#htoc277">29.2  Big arrays in the Caml-C interface</A>
<UL CLASS="ftoc4"><LI CLASS="li-toc">
<A HREF="manual043.html#htoc278">29.2.1  Include file</A>
</LI><LI CLASS="li-toc"><A HREF="manual043.html#htoc279">29.2.2  Accessing a Caml bigarray from C or Fortran</A>
</LI><LI CLASS="li-toc"><A HREF="manual043.html#htoc280">29.2.3  Wrapping a C or Fortran array as a Caml big array</A>
</LI></UL>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="index.html#htoc281">Part V  Appendix</A>
</LI></UL><HR>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="manual002.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>

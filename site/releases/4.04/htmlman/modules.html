<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.18">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>Module expressions (module implementations)</title>
</head>
<body>
<a href="modtypes.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="language.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="compunit.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<h2 class="section" id="s:module-expr">6.11&#XA0;&#XA0;Module expressions (module implementations)</h2>
<ul>
<li><a href="modules.html#sec200">Simple module expressions</a>
</li><li><a href="modules.html#sec201">Structures</a>
</li><li><a href="modules.html#sec211">Functors</a>
</li></ul>
<p>Module expressions are the module-level equivalent of value
expressions: they evaluate to modules, thus providing implementations
for the specifications expressed in module types.</p><p><a id="hevea_manual.kwd175"></a>
<a id="hevea_manual.kwd176"></a>
<a id="hevea_manual.kwd177"></a>
<a id="hevea_manual.kwd178"></a>
<a id="hevea_manual.kwd179"></a>
<a id="hevea_manual.kwd180"></a>
<a id="hevea_manual.kwd181"></a>
<a id="hevea_manual.kwd182"></a>
<a id="hevea_manual.kwd183"></a>
<a id="hevea_manual.kwd184"></a>
<a id="hevea_manual.kwd185"></a>
<a id="hevea_manual.kwd186"></a></p><table class="display dcenter"><tr class="c022"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c021">
<a class="syntax" id="module-expr"><span class="c013">module-expr</span></a></td><td class="c018">::=</td><td class="c020">
<a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">struct</span>&#XA0;[&#XA0;<a class="syntax" href="#module-items"><span class="c013">module-items</span></a>&#XA0;]&#XA0;<span class="c007">end</span>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">functor</span>&#XA0;<span class="c007">(</span>&#XA0;<a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a>&#XA0;<span class="c007">:</span>&#XA0;&#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>&#XA0;<span class="c007">)</span>&#XA0;<span class="c007">-&gt;</span>&#XA0;&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>&#XA0;<span class="c007">(</span>&#XA0;&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>&#XA0;<span class="c007">)</span>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">(</span>&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>&#XA0;<span class="c007">)</span>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">(</span>&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>&#XA0;<span class="c007">:</span>&#XA0;&#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>&#XA0;<span class="c007">)</span>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td></tr>
<tr><td class="c021">
<a class="syntax" id="module-items"><span class="c013">module-items</span></a></td><td class="c018">::=</td><td class="c020">
{<span class="c007">;;</span>}&#XA0;(&#XA0;<a class="syntax" href="#definition"><span class="c013">definition</span></a>&#XA0;&#X2223;&#XA0;&#XA0;<a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a>&#XA0;)&#XA0;&#XA0;{&#XA0;{<span class="c007">;;</span>}&#XA0;(&#XA0;<a class="syntax" href="#definition"><span class="c013">definition</span></a>&#XA0;&#X2223;&#XA0;&#XA0;<span class="c007">;;</span>&#XA0;<a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a>)&#XA0;}&#XA0;&#XA0;{<span class="c007">;;</span>}
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td></tr>
<tr><td class="c021">
<a class="syntax" id="definition"><span class="c013">definition</span></a></td><td class="c018">::=</td><td class="c020">
<span class="c007">let</span>&#XA0;[<span class="c007">rec</span>]&#XA0;<a class="syntax" href="expr.html#let-binding"><span class="c013">let-binding</span></a>&#XA0;&#XA0;{&#XA0;<span class="c007">and</span>&#XA0;<a class="syntax" href="expr.html#let-binding"><span class="c013">let-binding</span></a>&#XA0;}
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">external</span>&#XA0;<a class="syntax" href="names.html#value-name"><span class="c013">value-name</span></a>&#XA0;<span class="c007">:</span>&#XA0;&#XA0;<a class="syntax" href="types.html#typexpr"><span class="c013">typexpr</span></a>&#XA0;<span class="c007">=</span>&#XA0;&#XA0;<a class="syntax" href="intfc.html#external-declaration"><span class="c013">external-declaration</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<a class="syntax" href="typedecl.html#type-definition"><span class="c013">type-definition</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<a class="syntax" href="typedecl.html#exception-definition"><span class="c013">exception-definition</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<a class="syntax" href="classes.html#class-definition"><span class="c013">class-definition</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<a class="syntax" href="classes.html#classtype-definition"><span class="c013">classtype-definition</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">module</span>&#XA0;<a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a>&#XA0;&#XA0;{&#XA0;<span class="c007">(</span>&#XA0;<a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a>&#XA0;<span class="c007">:</span>&#XA0;&#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>&#XA0;<span class="c007">)</span>&#XA0;}
&#XA0;[&#XA0;<span class="c007">:</span>&#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>&#XA0;]&#XA0;&#XA0;<span class="c007">=</span>&#XA0;&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">module</span>&#XA0;<span class="c007">type</span>&#XA0;<a class="syntax" href="names.html#modtype-name"><span class="c013">modtype-name</span></a>&#XA0;<span class="c007">=</span>&#XA0;&#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">open</span>&#XA0;<a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a>
&#XA0;</td></tr>
<tr><td class="c021">&nbsp;</td><td class="c018">&#X2223;</td><td class="c020">&#XA0;<span class="c007">include</span>&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
</td></tr>
</table></td></tr>
</table>
<h3 class="subsection" id="sec200">6.11.1&#XA0;&#XA0;Simple module expressions</h3>
<p>The expression <a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a> evaluates to the module bound to the name
<a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a>.</p><p>The expression <span class="c007">(</span> <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> <span class="c007">)</span> evaluates to the same module as
<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>.</p><p>The expression <span class="c007">(</span> <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> <span class="c007">)</span> checks that the
type of <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> is a subtype of <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>, that is, that all
components specified in <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> are implemented in
<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>, and their implementation meets the requirements given
in <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>. In other terms, it checks that the implementation
<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> meets the type specification <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>. The whole
expression evaluates to the same module as <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>, except that
all components not specified in <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> are hidden and can no
longer be accessed.</p>
<h3 class="subsection" id="sec201">6.11.2&#XA0;&#XA0;Structures</h3>
<p><a id="hevea_manual.kwd187"></a>
<a id="hevea_manual.kwd188"></a></p><p>Structures <span class="c007">struct</span> &#X2026; <span class="c007">end</span> are collections of definitions for
value names, type names, exceptions, module names and module type
names. The definitions are evaluated in the order in which they appear
in the structure. The scopes of the bindings performed by the
definitions extend to the end of the structure. As a consequence, a
definition may refer to names bound by earlier definitions in the same
structure.</p><p>For compatibility with toplevel phrases (chapter&#XA0;<a href="toplevel.html#c%3Acamllight">9</a>),
optional <span class="c007">;;</span> are allowed after and before each definition in a structure. These
<span class="c007">;;</span> have no semantic meanings. Similarly, an <a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a> preceded by <span class="c006">;;</span> is allowed as
a component of a structure. It is equivalent to <span class="c004"><span class="c006">let</span> <span class="c006">_</span> <span class="c006">=</span></span> <a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a>, i.e. <a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a> is
evaluated for its side-effects but is not bound to any identifier. If <a class="syntax" href="expr.html#expr"><span class="c013">expr</span></a> is
the first component of a structure, the preceding <span class="c006">;;</span> can be omitted.</p><h4 class="subsubsection" id="sec202">Value definitions</h4>
<p><a id="hevea_manual.kwd189"></a></p><p>A value definition <span class="c007">let</span> [<span class="c007">rec</span>] <a class="syntax" href="expr.html#let-binding"><span class="c013">let-binding</span></a> &#XA0;{ <span class="c007">and</span> <a class="syntax" href="expr.html#let-binding"><span class="c013">let-binding</span></a> }
bind value names in the same way as a <span class="c007">let</span> &#X2026; <span class="c007">in</span> &#X2026; expression
(see section&#XA0;<a href="expr.html#s%3Alocaldef">6.7.1</a>). The value names appearing in the
left-hand sides of the bindings are bound to the corresponding values
in the right-hand sides.</p><p><a id="hevea_manual.kwd190"></a></p><p>A value definition <span class="c007">external</span> <a class="syntax" href="names.html#value-name"><span class="c013">value-name</span></a> <span class="c007">:</span> &#XA0;<a class="syntax" href="types.html#typexpr"><span class="c013">typexpr</span></a> <span class="c007">=</span> &#XA0;<a class="syntax" href="intfc.html#external-declaration"><span class="c013">external-declaration</span></a>
implements <a class="syntax" href="names.html#value-name"><span class="c013">value-name</span></a> as the external function specified in
<a class="syntax" href="intfc.html#external-declaration"><span class="c013">external-declaration</span></a> (see chapter&#XA0;<a href="intfc.html#c%3Aintf-c">19</a>).</p><h4 class="subsubsection" id="sec203">Type definitions</h4>
<p><a id="hevea_manual.kwd191"></a></p><p>A definition of one or several type components is written
<span class="c007">type</span> <a class="syntax" href="typedecl.html#typedef"><span class="c013">typedef</span></a> &#XA0;{ <span class="c007">and</span> <a class="syntax" href="typedecl.html#typedef"><span class="c013">typedef</span></a> } and consists of a sequence
of mutually recursive definitions of type names.</p><h4 class="subsubsection" id="sec204">Exception definitions</h4>
<p><a id="hevea_manual.kwd192"></a></p><p>Exceptions are defined with the syntax <span class="c007">exception</span> <a class="syntax" href="typedecl.html#constr-decl"><span class="c013">constr-decl</span></a>
or <span class="c007">exception</span> <a class="syntax" href="names.html#constr-name"><span class="c013">constr-name</span></a> <span class="c007">=</span> &#XA0;<a class="syntax" href="names.html#constr"><span class="c013">constr</span></a>.</p><h4 class="subsubsection" id="sec205">Class definitions</h4>
<p><a id="hevea_manual.kwd193"></a></p><p>A definition of one or several classes is written <span class="c007">class</span>
<a class="syntax" href="classes.html#class-binding"><span class="c013">class-binding</span></a> &#XA0;{ <span class="c007">and</span> <a class="syntax" href="classes.html#class-binding"><span class="c013">class-binding</span></a> } and consists of a sequence of
mutually recursive definitions of class names. Class definitions are
described more precisely in section&#XA0;<a href="classes.html#s%3Aclassdef">6.9.3</a>.</p><h4 class="subsubsection" id="sec206">Class type definitions</h4>
<p><a id="hevea_manual.kwd194"></a>
<a id="hevea_manual.kwd195"></a></p><p>A definition of one or several classes is written
<span class="c004"><span class="c006">class</span> <span class="c006">type</span></span> <a class="syntax" href="classes.html#classtype-def"><span class="c013">classtype-def</span></a> &#XA0;{ <span class="c007">and</span> <a class="syntax" href="classes.html#classtype-def"><span class="c013">classtype-def</span></a> } and consists of
a sequence of mutually recursive definitions of class type names.
Class type definitions are described more precisely in
section&#XA0;<a href="classes.html#s%3Aclasstype">6.9.5</a>.</p><h4 class="subsubsection" id="sec207">Module definitions</h4>
<p><a id="hevea_manual.kwd196"></a></p><p>The basic form for defining a module component is
<span class="c007">module</span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c007">=</span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>, which evaluates <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> and binds
the result to the name <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a>.</p><p>One can write
</p><div class="center">
<span class="c007">module</span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> <span class="c007">=</span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
</div><p>
instead of
</p><div class="center">
<span class="c007">module</span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c004"><span class="c006">=</span> <span class="c006">(</span></span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> <span class="c007">)</span>.
</div><p>
Another derived form is
</p><div class="center">
<span class="c007">module</span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c007">(</span> &#XA0;<span class="c013">name</span><sub>1</sub> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a><sub>1</sub> <span class="c007">)</span> &#X2026;
<span class="c007">(</span> &#XA0;<span class="c013">name</span><sub><span class="c012">n</span></sub> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a><sub><span class="c012">n</span></sub> <span class="c004"><span class="c006">)</span> <span class="c006">=</span></span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
</div><p>
which is equivalent to
</p><div class="center">
<span class="c007">module</span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c004"><span class="c006">=</span>
<span class="c006">functor</span> <span class="c006">(</span></span> &#XA0;<span class="c013">name</span><sub>1</sub> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a><sub>1</sub> <span class="c004"><span class="c006">)</span> <span class="c006">-&gt;</span></span> &#X2026;
<span class="c007">-&gt;</span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>
</div><h4 class="subsubsection" id="sec208">Module type definitions</h4>
<p><a id="hevea_manual.kwd197"></a>
<a id="hevea_manual.kwd198"></a></p><p>A definition for a module type is written
<span class="c004"><span class="c006">module</span> <span class="c006">type</span></span> <a class="syntax" href="names.html#modtype-name"><span class="c013">modtype-name</span></a> <span class="c007">=</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>.
It binds the name <a class="syntax" href="names.html#modtype-name"><span class="c013">modtype-name</span></a> to the module type denoted by the
expression <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a>.</p><h4 class="subsubsection" id="sec209">Opening a module path</h4>
<p><a id="hevea_manual.kwd199"></a></p><p>The expression <span class="c007">open</span> <a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a> in a structure does not define any
components nor perform any bindings. It simply affects the parsing of
the following items of the structure, allowing components of the
module denoted by <a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a> to be referred to by their simple names
<span class="c013">name</span> instead of path accesses <a class="syntax" href="names.html#module-path"><span class="c013">module-path</span></a> <span class="c007">.</span> &#XA0;<span class="c013">name</span>. The scope of
the <span class="c007">open</span> stops at the end of the structure expression.</p><h4 class="subsubsection" id="sec210">Including the components of another structure</h4>
<p><a id="hevea_manual.kwd200"></a></p><p>The expression <span class="c007">include</span> <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> in a structure re-exports in
the current structure all definitions of the structure denoted by
<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a>. For instance, if the identifier <span class="c006">S</span> is bound to the
module
</p><pre>        struct type t = int  let x = 2 end
</pre><p>the module expression
</p><pre>        struct include S  let y = (x + 1 : t) end
</pre><p>is equivalent to the module expression
</p><pre>        struct type t = S.t  let x = S.x  let y = (x + 1 : t) end
</pre><p>The difference between <span class="c007">open</span> and <span class="c007">include</span> is that <span class="c007">open</span>
simply provides short names for the components of the opened
structure, without defining any components of the current structure,
while <span class="c007">include</span> also adds definitions for the components of the
included structure.</p>
<h3 class="subsection" id="sec211">6.11.3&#XA0;&#XA0;Functors</h3>
<h4 class="subsubsection" id="sec212">Functor definition</h4>
<p><a id="hevea_manual.kwd201"></a></p><p>The expression <span class="c004"><span class="c006">functor</span> <span class="c006">(</span></span> <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> <span class="c007">:</span> &#XA0;<a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a> <span class="c004"><span class="c006">)</span> <span class="c006">-&gt;</span></span>
&#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> evaluates to a functor that takes as argument modules of
the type <a class="syntax" href="modtypes.html#module-type"><span class="c013">module-type</span></a><sub>1</sub>, binds <a class="syntax" href="names.html#module-name"><span class="c013">module-name</span></a> to these modules,
evaluates <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a> in the extended environment, and returns the
resulting modules as results. No restrictions are placed on the type of the
functor argument; in particular, a functor may take another functor as
argument (&#X201C;higher-order&#X201D; functor).</p><h4 class="subsubsection" id="sec213">Functor application</h4>
<p>The expression <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>1</sub> <span class="c007">(</span> &#XA0;<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>2</sub> <span class="c007">)</span> evaluates
<a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>1</sub> to a functor and <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>2</sub> to a module, and
applies the former to the latter. The type of <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>2</sub> must
match the type expected for the arguments of the functor <a class="syntax" href="#module-expr"><span class="c013">module-expr</span></a><sub>1</sub>.</p>
<hr>
<a href="modtypes.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="language.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="compunit.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>

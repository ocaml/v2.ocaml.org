<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Une histoire d'OCaml</title>
    <link href="ocaml.css" media="all" type="text/css" rel="stylesheet" />
  </head>
  <body>
    <h1>Une histoire d'OCaml</h1>

    <p>« Caml » était à l'origine un acronyme pour <em>Categorical
    Abstract Machine Language</em>. C'était un jeu de mots sur CAM, la
    Machine Abstraite Catégorique, et ML, la famille de langages de
    programmation à laquelle Caml appartient. Le nom Caml est resté à
    travers l'évolution du langage, bien que l'implantation actuelle
    n'ait rien à voir avec la CAM.</p>

    <p>Caml fut d'abord conçu et implanté par l'équipe <em>Formel</em>
    de l'<a href="http://www.inria.fr/index.fr.html"
    >Inria</a>, dirigée par
      <a href="http://cristal.inria.fr/~huet/" >Gérard Huet</a>. Son
      développement a continué dans l'équipe
	  <a href="http://cristal.inria.fr/">Cristal</a>,
	  et aujourd'hui dans son successeur, 
	  <a href="http://gallium.inria.fr/">Gallium</a>.
	</p>

    <h2>L'origine</h2>

    <p>L'équipe Formel commença à s'intéresser au langage ML en
      1980–81. ML était le <em>métalangage</em> de la version
      d'Édimbourg de l'assistant de preuve LCF, tous deux conçus
      par <a href="http://www.cl.cam.ac.uk/~rm135/" >Robin
	Milner</a>. Il était implanté par une sorte d'interprète écrit en
      Lisp par <a href="http://www.cl.cam.ac.uk/users/mjcg/" >Mike
	Gordon</a>, <a href="http://www.cl.cam.ac.uk/~rm135/" >Robin
	Milner</a> et Christopher Wadsworth.  LCF lui-même était écrit
      partiellement en ML et partiellement en Lisp. Pour pouvoir
      utiliser l'assistant de preuve LCF sur les divers systèmes alors
      exploités chez Formel (Multics, Berkeley Unix sur Vax, Symbolics),
      <a href="http://cristal.inria.fr/~huet/" >Gérard Huet</a> décida
      de rendre l'implantation de ML compatible avec les différents
      compilateurs Lisp (MacLisp, FranzLisp, LeLisp,
      ZetaLisp). <a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
      Cousineau</a> et
      <a href="http://www.cl.cam.ac.uk/users/lcp/" >Larry Paulson</a>
      participèrent à ce travail. Les performances de cette
      implantation de ML furent améliorés par l'ajout d'un
      compilateur. <a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
      Cousineau</a> ajouta également les types de données algébriques
      et le filtrage, d'après des idées de Milner, que lui-même avait
      empruntées à Hope, un langage de programmation conçu par
      <a href="http://www.dcs.ed.ac.uk/home/rb/" >Rod Burstall</a>
      et <a href="http://people.cs.uchicago.edu/~dbm/" >Dave
      McQueen</a>. À un certain moment, cette implantation fut nommée
      Le_ML, appellation qui ne survécut pas. Elle fut utilisée
      par <a href="http://www.cl.cam.ac.uk/users/lcp/" >Larry
      Paulson</a> pour développer Cambridge LCF et
      par <a href="http://www.cl.cam.ac.uk/users/mjcg/" >Mike
      Gordon</a> pour la première version de HOL, comme le rappelle
      la <a href="http://www.cl.cam.ac.uk/users/mjcg/papers/HolHistory.html"
      >courte histoire de HOL</a> de Gordon.
    </p>

    <p>Vers 1984, trois événements nous encouragèrent à prendre une
    part plus grande dans le développement de ML:
    </p>
    <ul>
      <li>À Édimbourg, <a href="http://lucacardelli.name/" >Luca
      Cardelli</a> développa une implantation beaucoup plus rapide de
      ML à l'aide de sa <em>Functional Abstract Machine (FAM)</em>.
      Il conçut également sa propre version du langage, connue à
      l'époque sous le nom de <em>Cardelli's ML</em>.
      </li>
      <li>
	<a href="http://www.cl.cam.ac.uk/~rm135/" >Robin Milner</a>
	pensait que le moment était venu de proposer une nouvelle
	définition de ML, de façon à éviter la divergence entre les
	diverses implantations. Il définit le noyau du langage
	Standard ML, qui fut ensuite complété par un système de
	modules conçu
	par <a href="http://people.cs.uchicago.edu/~dbm/" >Dave
	McQueen</a>.
      </li>
      <li>
	Au même
	moment, <a href="http://www.pps.jussieu.fr/~curien/"
	>Pierre-Louis Curien</a> développa un calcul de combinateurs
	catégoriques, ainsi qu'une correspondance entre lambda-calcul
	et combinateurs catégoriques, qui, comme le
	remarqua <a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
	Cousineau</a>, pouvait être vue comme une technique de
	compilation pour ML. En effet, elle était assez proche de la
	technique d'implantation originelle du ML d'Édimbourg, mais
	pouvait être décrite, vérifiée, et optimisée de façon
	simple. Ceci mena à la définition de la Machine Abstraite
	Catégorique (CAM).
      </li>
    </ul>

    <p>Ceci poussa <a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
    Cousineau</a> à développer une nouvelle implantation de ML, basée
    sur la CAM. Cependant, le langage que nous implantâmes finalement
    ne fut pas Standard ML, mais... Caml. Pourquoi? Notre principale
    raison pour développer Caml était de l'utiliser pour développer le
    système <a href="http://pauillac.inria.fr/coq/index.fr.html"
    >Coq</a>, qui, suite à la thèse
    de <a href="http://www.cs.chalmers.se/~coquand/" >Thierry
    Coquand</a> en 1985, devint le principal objectif de
    l'équipe. Nous n'étions pas pressés d'adopter un standard qui
    risquait ensuite de nous empêcher d'adapter le langage à nos
    besoins en tant que programmeurs. En particulier, Philippe Le
    Chenadec et <a href="http://michel.mauny.net/index.fr.php" >Michel
    Mauny</a> développèrent des outils de manipulation syntaxique, qui
    furent jugés utiles et incorporés dans Caml. Devoir nous
    synchroniser avec l'équipe Standard ML avant de pouvoir adopter
    les modifications du langage qui nous semblaient utiles aurait
    retardé notre travail de façon trop importante. De plus, notre
    philosophie entrait en conflit avec celle d'un langage
    « standard », qui n'est pas censé évoluer trop rapidement.
    Néanmoins, nous incorporâmes effectivement dans Caml la plupart
    des améliorations apportées par Standard ML vis-à-vis du ML
    d'Édimbourg.
    </p>

    <h2>La première implantation</h2>

    <p>La première implantation de Caml fut publiée en 1987, et
    développée jusqu'en 1992. Elle était principalement l'&#339;uvre
    d'Ascander Suarez. Après le départ d'Ascander en
    1988, <a href="http://cristal.inria.fr/~weis/" >Pierre Weis</a>
    et <a href="http://michel.mauny.net/index.fr.php" >Michel Mauny</a>
    continuèrent le développement et la maintenance du système. Cette
    implantation compilait Caml vers LLM3, la machine virtuelle du
    système Le_Lisp.</p>

    <p><a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
    Cousineau</a> se souvient modestement: « Je dois admettre que
    lorsque le développement de Caml commença, mon expérience de
    l'implémentation des langages de programmation était très
    limitée.  S'appuyer sur la machine abstraite LLM3 et sur le système
    d'allocation et de gestion de mémoire de Le_Lisp nous évitait un
    gros travail, mais ne permettait pas d'atteindre une grande
    efficacité.  Le modèle CAM permettait la construction rapide des
    clôtures et un bon partage des environnements mais pénalisait
    l'accès à l'environnement et rendait les optimisations
    difficiles.  De plus, il introduisait potentiellement des fuites de
    mémoire, puisque des valeurs inutiles étaient conservées à
    l'intérieur des clôtures. Par ailleurs, je n'avais pas réalisé
    qu'il était plus important d'offrir de bonnes performances aux
    programmes non fonctionnels qu'aux programmes très
    fonctionnels.  Par-dessus tout, j'avais négligé l'importance de la
    portabilité et de l'ouverture.  Malgré ces inadéquations, dont je
    suis initialement responsable, Ascander, Pierre et Michel ont fait
    du beau travail. »
    </p>

    <h2>Caml Light</h2>

    <p>En 1990 et
    1991, <a href="http://cristal.inria.fr/~xleroy/" >Xavier Leroy</a>
    mit au point une implantation totalement nouvelle de Caml, basée
    sur un interprète de code-octets écrit
    en C.  <a href="http://cristal.inria.fr/~doligez/" >Damien
    Doligez</a> fournit un excellent système de gestion de la
    mémoire.  Cette nouvelle implantation, connue sous le nom de Caml
    Light, était hautement portable et fonctionnait aisément sur de
    petites machines de bureau comme les Macs et PCs.  Elle remplaça
    l'ancienne implantation de Caml et aida beaucoup à répandre
    l'emploi de Caml dans l'enseignement et la recherche.  Sa notion de
    flux de données et ses facilités pour l'analyse syntaxique, dues
    à <a href="http://michel.mauny.net/index.fr.php" >Michel Mauny</a>,
    faisaient suite à un effort de longue haleine de l'équipe Formel
    pour promouvoir les outils de manipulation syntaxique.
    </p>

    <h2>Caml Special Light</h2>

    <p>En 1995, <a href="http://cristal.inria.fr/~xleroy/" >Xavier
    Leroy</a> publia Caml Special Light, qui surpassait Caml Light de
    plusieurs façons. En premier lieu, un compilateur optimisant
    produisant du code natif est venu complémenter le compilateur
    code-octets.  Ce compilateur natif égalait ou surpassait les
    performances des meilleurs compilateurs existants pour les
    langages fonctionnels, et a permis à Caml d'être davantage
    compétitif, en termes de performances, vis-à-vis des langages de
    programmation impératifs classiques tels que C++.  Par ailleurs,
    Caml Special Light proposait un système de modules de haut niveau,
    conçu par <a href="http://cristal.inria.fr/~xleroy/" >Xavier
    Leroy</a> et inspiré par les modules de Standard ML.  Ce système
    de modules fournit de puissants mécanismes d'abstraction et de
    paramétrisation, essentiels pour la programmation à grande
    échelle.
    </p>

    <h2>Objective Caml</h2>

    <p>Les systèmes de types et l'inférence de types pour la
    programmation par objets sont un domaine actif de recherche depuis
    le début des années
    1990.  <a href="http://cristal.inria.fr/~remy/" >Didier Rémy</a>
    et ensuite <a href="http://www.pps.jussieu.fr/~vouillon/" >Jérôme
    Vouillon</a> ont conçu un système de types élégant et très
    expressif pour les objets et les classes.  Ce design fut intégré à
    et implémenté dans Caml Special Light, donnant naissance au
    langage Objective Caml et à son implémentation, publiée pour la
    première fois en 1996 et renommée en OCaml en 2011.  Objective
    Caml fut le premier langage de programmation a combiner toute la
    puissance de la programmation par objets avec un typage statique
    avec inférence dans le style de ML.  Il est capable de reconnaître
    statiquement comme bien typés de nombreux idiomes difficiles de la
    programmation par objets (classes paramétrées par des types,
    méthodes binaires, spécialisation du type de l'objet), idiomes qui
    sont traités de manière non sûre ou à l'aide de vérifications
    dynamiques de types dans d'autres langages à objets comme C++ et
    Java.
    </p>

    <p>En
    2000, <a href="http://www.math.nagoya-u.ac.jp/~garrigue/home-f.html"
    >Jacques Garrigue</a> ajouta à Objective Caml plusieurs nouveaux
    traits, qu'il avait expérimentés pendant quelques années dans le
    dialecte Objective Label. Parmi ceux-ci se trouvaient les méthodes
    polymorphes, les arguments de fonctions étiquetés et optionnels,
    et les variantes polymorphes.
    </p>

    <h2>La montée en puissance d'OCaml</h2>

    <p>Depuis la fin des années 1990, OCaml a régulièrement gagné en
    popularité et a attiré une communauté significative
    d'utilisateurs.  En plus de programmes complets de haute
    technicité écrits en OCaml, cette communauté d'utilisateur a
    également contribué un bon nombre de bibliothèques,
    d'infrastructures et d'outils de haute qualité, allant des
    interfaces utilisateur graphiques et des interfaces avec des SGBD,
    à la programmation du Web et des réseaux, l'interopérabilité avec
    d'autres langages, et l'analyse statique de programmes.  En
    parallèle, l'équipe initiale de développement d'OCaml travaille
    toujours activement sur le système de base, améliorant sans cesse
    la qualité de l'implémentation et l'adaptant aux architectures et
    systèmes les plus récents.
    </p>

    <h2>Quelques parents proches</h2>

    <p>En plus de ces versions officielles de Caml, il faut mentionner
    de nombreux compilateurs
    voisins. <a href="http://michel.mauny.net/index.fr.php" >Michel
    Mauny</a> et <a href="http://cristal.inria.fr/~ddr/" >Daniel de
    Rauglaudre</a> ont conçu Chamau, qui offre des possibilités de
    manipulation syntaxique uniques que l'on retrouve maintenant sous
    forme de pré-processeur dans le système Camlp4.
      <a href="http://www-sop.inria.fr/members/Manuel.Serrano/"
      >Manuel Serrano</a>
      et <a href="http://cristal.inria.fr/~weis/" >Pierre Weis</a> ont
      créé BIGLOO. Régis Cridlig a produit Camlot. Jean
      Goubault-Larrecq a écrit HimML, qui est doté de « hash-consing »
      implicite et d'opérations efficaces sur les ensembles et cartes
      associatives. <a href="http://www.pps.jussieu.fr/~emmanuel/"
      >Emmanuel Chailloux</a> a publié CeML. Dans l'équipe
      <em>Para</em>, Francis Dupont a implanté Caml pour des machines
      parallèles, tandis
      que <a href="http://cristal.inria.fr/~maranget/" >Luc
      Maranget</a> a construit Gaml, un compilateur pour un langage de
      programmation fonctionnel paresseux.
    </p>

    <h2>Citation finale</h2>

    <p>En 1996, <a href="http://www.pps.jussieu.fr/~cousinea/" >Guy
    Cousineau</a> écrivait: « L'histoire de Caml aurait certainement
    pu être plus linéaire. Néanmoins, à travers une série de
    tâtonnements, une capacité à produire des implantations de haute
    performance, portables et flexibles, pour les langages de
    programmation fonctionnels a émergé en France. »
    </p>

  </body>
</html>
